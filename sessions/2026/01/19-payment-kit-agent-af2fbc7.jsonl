{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":"检查dynamic pricing功能是否正确集成到现有payment流程中：\n\n**背景**：\n- `generateQuotesForInvoiceItems` 是新增的函数（在之前的会话中添加）\n- Dynamic pricing是新功能\n- 可能原有的payment流程没有考虑dynamic pricing\n\n**调查重点**：\n\n1. **CheckoutSession创建时**：\n   - 创建checkout session时，line_items的price信息是如何设置的？\n   - 对于dynamic pricing的items，price字段是什么值？\n   - 是否有逻辑会覆盖dynamic pricing的price？\n\n2. **Submit接口中quote的使用**：\n   - `attachQuotesToLineItems` 函数返回的 `lineItemsWithQuotes` 是什么结构？\n   - 这些enriched line items是否被保存回CheckoutSession？\n   - 还是只是临时变量？\n\n3. **Invoice创建的所有路径**：\n   - 除了 `ensureInvoiceForCheckout`，还有哪些地方会创建invoice？\n   - 每个路径是否都考虑了dynamic pricing？\n   - 特别检查payment模式的所有invoice创建场景\n\n4. **Price模型和Currency的关系**：\n   - Dynamic pricing的price模型中，amount字段是什么值？\n   - Invoice item创建时，如果直接使用price.amount，会得到什么？\n   - 应该使用price.amount还是quote.quoted_amount？\n\n重点找出：**新增的dynamic pricing代码与现有payment流程的集成断点在哪里**。"},"uuid":"043fead7-d616-4861-b885-654cdb2ac583","timestamp":"2026-01-06T15:03:34.059Z"}
{"parentUuid":"043fead7-d616-4861-b885-654cdb2ac583","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VoF9KLFce4tuQxB3oZ62cb","type":"message","role":"assistant","content":[{"type":"text","text":"我来全面调查dynamic pricing功能与现有payment流程的集成情况。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14745,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14745,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWrL1BTanPHB9SKpcVqmD","type":"assistant","uuid":"5e49a586-8df2-4a71-bb9a-97332d6ceb97","timestamp":"2026-01-06T15:03:38.528Z"}
{"parentUuid":"5e49a586-8df2-4a71-bb9a-97332d6ceb97","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VoF9KLFce4tuQxB3oZ62cb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01V8P59ZBf1uAznwG3wpq2zn","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14745,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14745,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWrL1BTanPHB9SKpcVqmD","type":"assistant","uuid":"d9148285-5ba0-4284-a258-7be505f63c7a","timestamp":"2026-01-06T15:03:39.134Z"}
{"parentUuid":"d9148285-5ba0-4284-a258-7be505f63c7a","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VoF9KLFce4tuQxB3oZ62cb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01W4mDgbWP51dzEM5spcgq7R","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice-quote.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14745,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14745,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWrL1BTanPHB9SKpcVqmD","type":"assistant","uuid":"4fc1a71b-17d2-48fd-b09a-e916525506a9","timestamp":"2026-01-06T15:03:39.763Z"}
{"parentUuid":"4fc1a71b-17d2-48fd-b09a-e916525506a9","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VoF9KLFce4tuQxB3oZ62cb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01E2Bndy8uXYAqHnKXzzom85","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14745,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14745,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWrL1BTanPHB9SKpcVqmD","type":"assistant","uuid":"8d4fd14c-dcf3-4aab-a799-e2d2c6dc81d7","timestamp":"2026-01-06T15:03:40.318Z"}
{"parentUuid":"8d4fd14c-dcf3-4aab-a799-e2d2c6dc81d7","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VoF9KLFce4tuQxB3oZ62cb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014XXkvMaa6Tzmbz93h9pBdo","name":"Grep","input":{"pattern":"createInvoice|ensureInvoice","output_mode":"files_with_matches","path":"~/Arcblock/payment-kit-master/blocklets/core/api/src"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14745,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14745,"ephemeral_1h_input_tokens":0},"output_tokens":359,"service_tier":"standard"}},"requestId":"req_011CWrL1BTanPHB9SKpcVqmD","type":"assistant","uuid":"76560adb-d29a-4fd4-ac18-a7579aefdde8","timestamp":"2026-01-06T15:03:41.484Z"}
{"parentUuid":"76560adb-d29a-4fd4-ac18-a7579aefdde8","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01W4mDgbWP51dzEM5spcgq7R","type":"tool_result","content":"     1→import { Price, PaymentCurrency } from '../store/models';\n     2→import { getQuoteService, type RateResult } from './quote-service';\n     3→import { getExchangeRateService } from './exchange-rate';\n     4→import logger from './logger';\n     5→\n     6→export interface InvoiceItemInput {\n     7→  price_id: string;\n     8→  quantity: number;\n     9→  amount: string;\n    10→  subscription_item_id?: string;\n    11→  description: string;\n    12→  period?: { start: number; end: number };\n    13→  metadata?: Record<string, any>;\n    14→  discountable?: boolean;\n    15→  discount_amounts?: any[];\n    16→}\n    17→\n    18→export interface InvoiceItemWithQuote extends InvoiceItemInput {\n    19→  quote_id?: string;\n    20→}\n    21→\n    22→/**\n    23→ * Generate quotes for dynamic pricing invoice items\n    24→ * This function checks each invoice item's price and generates a quote if it uses dynamic pricing\n    25→ */\n    26→export async function generateQuotesForInvoiceItems(params: {\n    27→  invoiceId: string;\n    28→  items: InvoiceItemInput[];\n    29→  currencyId: string;\n    30→}): Promise<InvoiceItemWithQuote[]> {\n    31→  const { invoiceId, items, currencyId } = params;\n    32→\n    33→  if (!items || items.length === 0) {\n    34→    return [];\n    35→  }\n    36→\n    37→  // Load currency with payment method\n    38→  const currency = await PaymentCurrency.findByPk(currencyId, {\n    39→    include: [{ association: 'payment_method' }],\n    40→  });\n    41→  if (!currency) {\n    42→    throw new Error(`Currency ${currencyId} not found`);\n    43→  }\n    44→\n    45→  // Get exchange rate once for all dynamic prices (for efficiency)\n    46→  // For ArcBlock payment method, always use ABT for exchange rate\n    47→  const exchangeRateService = getExchangeRateService();\n    48→  const rateSymbol = (currency as any).payment_method?.type === 'arcblock' ? 'ABT' : currency.symbol;\n    49→  let rateResult: RateResult | null = null;\n    50→\n    51→  const quoteService = getQuoteService();\n    52→  const enrichedItems: InvoiceItemWithQuote[] = [];\n    53→\n    54→  // Note: Sequential processing is intentional here\n    55→  // 1. Prices may not exist (early continue)\n    56→  // 2. Exchange rate is fetched once and reused (rateResult)\n    57→  // 3. Quote failures must be handled immediately (P0 critical)\n    58→  // eslint-disable-next-line no-restricted-syntax\n    59→  for (const item of items) {\n    60→    // eslint-disable-next-line no-await-in-loop\n    61→    const price = await Price.findByPk(item.price_id);\n    62→    if (!price) {\n    63→      logger.warn('Price not found for invoice item', { priceId: item.price_id, invoiceId });\n    64→      enrichedItems.push(item);\n    65→      // eslint-disable-next-line no-continue\n    66→      continue;\n    67→    }\n    68→\n    69→    // Check if price uses dynamic pricing\n    70→    if (price.pricing_type !== 'dynamic') {\n    71→      // Fixed pricing - use item amount as-is\n    72→      enrichedItems.push(item);\n    73→      // eslint-disable-next-line no-continue\n    74→      continue;\n    75→    }\n    76→\n    77→    // Dynamic pricing - generate quote\n    78→    try {\n    79→      // Get exchange rate if not already fetched\n    80→      if (!rateResult) {\n    81→        // eslint-disable-next-line no-await-in-loop\n    82→        rateResult = await exchangeRateService.getRate(rateSymbol);\n    83→      }\n    84→\n    85→      // Create quote for this invoice item\n    86→      // eslint-disable-next-line no-await-in-loop\n    87→      const { quote } = await quoteService.createQuoteWithRate({\n    88→        price_id: item.price_id,\n    89→        invoice_id: invoiceId,\n    90→        target_currency_id: currencyId,\n    91→        quantity: item.quantity,\n    92→        rateResult,\n    93→      });\n    94→\n    95→      logger.info('Generated quote for invoice item', {\n    96→        invoiceId,\n    97→        priceId: item.price_id,\n    98→        quoteId: quote.id,\n    99→        quotedAmount: quote.quoted_amount,\n   100→      });\n   101→\n   102→      // Update item with quote info\n   103→      enrichedItems.push({\n   104→        ...item,\n   105→        amount: quote.quoted_amount,\n   106→        quote_id: quote.id,\n   107→        metadata: {\n   108→          ...item.metadata,\n   109→          quote: {\n   110→            id: quote.id,\n   111→            // Reference price (USD)\n   112→            base_currency: quote.base_currency,\n   113→            base_amount: quote.base_amount, // Total USD amount\n   114→            // Actual payment price\n   115→            quoted_amount: quote.quoted_amount, // Total token amount\n   116→            target_currency_id: quote.target_currency_id,\n   117→            rate_currency_symbol: quote.rate_currency_symbol,\n   118→            // Exchange rate info\n   119→            exchange_rate: quote.exchange_rate, // 1 token = X USD\n   120→            rate_provider_name: quote.rate_provider_name,\n   121→            rate_provider_id: quote.rate_provider_id,\n   122→            rate_timestamp_ms: quote.rate_timestamp_ms,\n   123→            // Pricing context\n   124→            quantity: item.quantity,\n   125→            expires_at: quote.expires_at,\n   126→            status: quote.status,\n   127→          },\n   128→        },\n   129→      });\n   130→    } catch (error: any) {\n   131→      logger.error('Failed to generate quote for invoice item', {\n   132→        invoiceId,\n   133→        priceId: item.price_id,\n   134→        error: error.message,\n   135→      });\n   136→\n   137→      // P0 CRITICAL: Do not allow fallback for dynamic pricing\n   138→      // Quote is the only source of truth for dynamic pricing amounts\n   139→      // If quote generation fails, the invoice creation must fail\n   140→      throw new Error(`Failed to generate quote for dynamic price ${item.price_id}: ${error.message}`);\n   141→    }\n   142→  }\n   143→\n   144→  return enrichedItems;\n   145→}\n   146→\n   147→/**\n   148→ * Check if any invoice items use dynamic pricing\n   149→ */\n   150→export async function hasDynamicPricingItems(items: InvoiceItemInput[]): Promise<boolean> {\n   151→  if (!items || items.length === 0) {\n   152→    return false;\n   153→  }\n   154→\n   155→  const priceIds = items.map((item) => item.price_id).filter(Boolean);\n   156→  if (priceIds.length === 0) {\n   157→    return false;\n   158→  }\n   159→\n   160→  const prices = await Price.findAll({\n   161→    where: { id: priceIds },\n   162→    attributes: ['id', 'pricing_type'],\n   163→  });\n   164→\n   165→  return prices.some((price) => price.pricing_type === 'dynamic');\n   166→}\n   167→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"e434d639-f649-4e11-87e2-24f08ec41c60","timestamp":"2026-01-06T15:03:41.613Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice-quote.ts","content":"import { Price, PaymentCurrency } from '../store/models';\nimport { getQuoteService, type RateResult } from './quote-service';\nimport { getExchangeRateService } from './exchange-rate';\nimport logger from './logger';\n\nexport interface InvoiceItemInput {\n  price_id: string;\n  quantity: number;\n  amount: string;\n  subscription_item_id?: string;\n  description: string;\n  period?: { start: number; end: number };\n  metadata?: Record<string, any>;\n  discountable?: boolean;\n  discount_amounts?: any[];\n}\n\nexport interface InvoiceItemWithQuote extends InvoiceItemInput {\n  quote_id?: string;\n}\n\n/**\n * Generate quotes for dynamic pricing invoice items\n * This function checks each invoice item's price and generates a quote if it uses dynamic pricing\n */\nexport async function generateQuotesForInvoiceItems(params: {\n  invoiceId: string;\n  items: InvoiceItemInput[];\n  currencyId: string;\n}): Promise<InvoiceItemWithQuote[]> {\n  const { invoiceId, items, currencyId } = params;\n\n  if (!items || items.length === 0) {\n    return [];\n  }\n\n  // Load currency with payment method\n  const currency = await PaymentCurrency.findByPk(currencyId, {\n    include: [{ association: 'payment_method' }],\n  });\n  if (!currency) {\n    throw new Error(`Currency ${currencyId} not found`);\n  }\n\n  // Get exchange rate once for all dynamic prices (for efficiency)\n  // For ArcBlock payment method, always use ABT for exchange rate\n  const exchangeRateService = getExchangeRateService();\n  const rateSymbol = (currency as any).payment_method?.type === 'arcblock' ? 'ABT' : currency.symbol;\n  let rateResult: RateResult | null = null;\n\n  const quoteService = getQuoteService();\n  const enrichedItems: InvoiceItemWithQuote[] = [];\n\n  // Note: Sequential processing is intentional here\n  // 1. Prices may not exist (early continue)\n  // 2. Exchange rate is fetched once and reused (rateResult)\n  // 3. Quote failures must be handled immediately (P0 critical)\n  // eslint-disable-next-line no-restricted-syntax\n  for (const item of items) {\n    // eslint-disable-next-line no-await-in-loop\n    const price = await Price.findByPk(item.price_id);\n    if (!price) {\n      logger.warn('Price not found for invoice item', { priceId: item.price_id, invoiceId });\n      enrichedItems.push(item);\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    // Check if price uses dynamic pricing\n    if (price.pricing_type !== 'dynamic') {\n      // Fixed pricing - use item amount as-is\n      enrichedItems.push(item);\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    // Dynamic pricing - generate quote\n    try {\n      // Get exchange rate if not already fetched\n      if (!rateResult) {\n        // eslint-disable-next-line no-await-in-loop\n        rateResult = await exchangeRateService.getRate(rateSymbol);\n      }\n\n      // Create quote for this invoice item\n      // eslint-disable-next-line no-await-in-loop\n      const { quote } = await quoteService.createQuoteWithRate({\n        price_id: item.price_id,\n        invoice_id: invoiceId,\n        target_currency_id: currencyId,\n        quantity: item.quantity,\n        rateResult,\n      });\n\n      logger.info('Generated quote for invoice item', {\n        invoiceId,\n        priceId: item.price_id,\n        quoteId: quote.id,\n        quotedAmount: quote.quoted_amount,\n      });\n\n      // Update item with quote info\n      enrichedItems.push({\n        ...item,\n        amount: quote.quoted_amount,\n        quote_id: quote.id,\n        metadata: {\n          ...item.metadata,\n          quote: {\n            id: quote.id,\n            // Reference price (USD)\n            base_currency: quote.base_currency,\n            base_amount: quote.base_amount, // Total USD amount\n            // Actual payment price\n            quoted_amount: quote.quoted_amount, // Total token amount\n            target_currency_id: quote.target_currency_id,\n            rate_currency_symbol: quote.rate_currency_symbol,\n            // Exchange rate info\n            exchange_rate: quote.exchange_rate, // 1 token = X USD\n            rate_provider_name: quote.rate_provider_name,\n            rate_provider_id: quote.rate_provider_id,\n            rate_timestamp_ms: quote.rate_timestamp_ms,\n            // Pricing context\n            quantity: item.quantity,\n            expires_at: quote.expires_at,\n            status: quote.status,\n          },\n        },\n      });\n    } catch (error: any) {\n      logger.error('Failed to generate quote for invoice item', {\n        invoiceId,\n        priceId: item.price_id,\n        error: error.message,\n      });\n\n      // P0 CRITICAL: Do not allow fallback for dynamic pricing\n      // Quote is the only source of truth for dynamic pricing amounts\n      // If quote generation fails, the invoice creation must fail\n      throw new Error(`Failed to generate quote for dynamic price ${item.price_id}: ${error.message}`);\n    }\n  }\n\n  return enrichedItems;\n}\n\n/**\n * Check if any invoice items use dynamic pricing\n */\nexport async function hasDynamicPricingItems(items: InvoiceItemInput[]): Promise<boolean> {\n  if (!items || items.length === 0) {\n    return false;\n  }\n\n  const priceIds = items.map((item) => item.price_id).filter(Boolean);\n  if (priceIds.length === 0) {\n    return false;\n  }\n\n  const prices = await Price.findAll({\n    where: { id: priceIds },\n    attributes: ['id', 'pricing_type'],\n  });\n\n  return prices.some((price) => price.pricing_type === 'dynamic');\n}\n","numLines":167,"startLine":1,"totalLines":167}}}
{"parentUuid":"e434d639-f649-4e11-87e2-24f08ec41c60","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014XXkvMaa6Tzmbz93h9pBdo","type":"tool_result","content":"Found 10 files\napi/src/routes/checkout-sessions.ts\napi/src/routes/connect/shared.ts\napi/src/queues/subscription.ts\napi/src/routes/connect/pay.ts\napi/src/routes/connect/collect.ts\napi/src/libs/invoice.ts\napi/src/routes/subscriptions.ts\napi/src/routes/connect/subscribe.ts\napi/src/queues/checkout-session.ts\napi/src/queues/auto-recharge.ts"}]},"uuid":"2978637f-b014-44f9-95b0-27d532b6e066","timestamp":"2026-01-06T15:03:41.628Z","toolUseResult":{"mode":"files_with_matches","filenames":["api/src/routes/checkout-sessions.ts","api/src/routes/connect/shared.ts","api/src/queues/subscription.ts","api/src/routes/connect/pay.ts","api/src/routes/connect/collect.ts","api/src/libs/invoice.ts","api/src/routes/subscriptions.ts","api/src/routes/connect/subscribe.ts","api/src/queues/checkout-session.ts","api/src/queues/auto-recharge.ts"],"numFiles":10}}
{"parentUuid":"2978637f-b014-44f9-95b0-27d532b6e066","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (37773 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01V8P59ZBf1uAznwG3wpq2zn"}]},"uuid":"30e8e850-bd50-4455-b148-78c21284c65d","timestamp":"2026-01-06T15:03:42.478Z","toolUseResult":"Error: File content (37773 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"parentUuid":"30e8e850-bd50-4455-b148-78c21284c65d","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01E2Bndy8uXYAqHnKXzzom85","type":"tool_result","content":"     1→import { component } from '@blocklet/sdk';\n     2→import type { LiteralUnion } from 'type-fest';\n     3→import { withQuery } from 'ufo';\n     4→\n     5→import { BN, fromUnitToToken } from '@ocap/util';\n     6→import { Op, type WhereOptions } from 'sequelize';\n     7→import { cloneDeep, pick } from 'lodash';\n     8→import {\n     9→  Customer,\n    10→  Invoice,\n    11→  InvoiceItem,\n    12→  PaymentCurrency,\n    13→  PaymentIntent,\n    14→  PaymentMethod,\n    15→  PaymentSettings,\n    16→  Price,\n    17→  Product,\n    18→  Refund,\n    19→  SetupIntent,\n    20→  SimpleCustomField,\n    21→  Subscription,\n    22→  SubscriptionItem,\n    23→  TaxRate,\n    24→  TInvoice,\n    25→  TLineItemExpanded,\n    26→  UsageRecord,\n    27→  Lock,\n    28→  DiscountAmount,\n    29→} from '../store/models';\n    30→import { getConnectQueryParam } from './util';\n    31→import { expandLineItems } from './session';\n    32→import dayjs from './dayjs';\n    33→import {\n    34→  getSubscriptionCycleAmount,\n    35→  getSubscriptionCycleSetup,\n    36→  getSubscriptionItemPrice,\n    37→  getSubscriptionStakeAmountSetup,\n    38→  isSubscriptionOverdraftProtectionEnabled,\n    39→} from './subscription';\n    40→import logger from './logger';\n    41→import { ensureOverdraftProtectionPrice } from './overdraft-protection';\n    42→import { CHARGE_SUPPORTED_CHAIN_TYPES } from './constants';\n    43→import { emitAsync } from './event';\n    44→import { getPriceUintAmountByCurrency } from './price';\n    45→import { generateQuotesForInvoiceItems } from './invoice-quote';\n    46→\n    47→export function getCustomerInvoicePageUrl({\n    48→  invoiceId,\n    49→  userDid,\n    50→  locale = 'en',\n    51→  action = '',\n    52→}: {\n    53→  userDid: string;\n    54→  invoiceId: string;\n    55→  locale: LiteralUnion<'en' | 'zh', string>;\n    56→  action?: LiteralUnion<'pay', string>;\n    57→}) {\n    58→  return component.getUrl(\n    59→    withQuery(`customer/invoice/${invoiceId}`, {\n    60→      locale,\n    61→      action,\n    62→      ...getConnectQueryParam({ userDid }),\n    63→    })\n    64→  );\n    65→}\n    66→\n    67→export async function getOneTimeProductInfo(invoiceId: string, paymentCurrency: PaymentCurrency) {\n    68→  try {\n    69→    const doc = await Invoice.findOne({\n    70→      where: { id: invoiceId },\n    71→      include: [{ model: InvoiceItem, as: 'lines' }],\n    72→    });\n    73→    if (!doc) {\n    74→      throw new Error(`Invoice not found: ${invoiceId}`);\n    75→    }\n    76→    const json = doc.toJSON();\n    77→    const products = (await Product.findAll()).map((x) => x.toJSON());\n    78→    const prices = (await Price.findAll()).map((x) => x.toJSON());\n    79→    // @ts-ignore\n    80→    expandLineItems(json.lines, products, prices);\n    81→    const oneTimePaymentInfo: Array<{\n    82→      productName: string;\n    83→      paymentInfo: string;\n    84→      quantity: number;\n    85→    }> = [];\n    86→    // @ts-ignore\n    87→    (json.lines || []).forEach((x) => {\n    88→      const { recurring, product } = x.price;\n    89→      if (!recurring) {\n    90→        // it's one-time product\n    91→        oneTimePaymentInfo.push({\n    92→          productName: product?.name,\n    93→          paymentInfo: `${fromUnitToToken(x.amount, paymentCurrency.decimal)} ${paymentCurrency.symbol}`,\n    94→          quantity: x.quantity,\n    95→        });\n    96→      }\n    97→    });\n    98→    return oneTimePaymentInfo;\n    99→  } catch (err) {\n   100→    console.error(`Error in getOneTimeProductInfo for invoice ${invoiceId}:`, err);\n   101→    return [];\n   102→  }\n   103→}\n   104→\n   105→export async function getInvoiceShouldPayTotal(invoice: Invoice) {\n   106→  try {\n   107→    const subscription = await Subscription.findByPk(invoice.subscription_id);\n   108→    if (!subscription) {\n   109→      throw new Error(`Subscription not found: ${invoice.subscription_id}`);\n   110→    }\n   111→\n   112→    const paymentCurrency = await PaymentCurrency.findByPk(invoice.currency_id);\n   113→    if (!paymentCurrency) {\n   114→      throw new Error(`Payment currency not found: ${invoice.currency_id}`);\n   115→    }\n   116→\n   117→    const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n   118→    if (!paymentMethod) {\n   119→      throw new Error(`Payment method not found: ${paymentCurrency.payment_method_id}`);\n   120→    }\n   121→\n   122→    const subscriptionItems = await SubscriptionItem.findAll({\n   123→      where: { subscription_id: subscription.id },\n   124→    });\n   125→\n   126→    let expandedItems = await Price.expand(\n   127→      subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n   128→      { product: true }\n   129→    );\n   130→\n   131→    const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, invoice.period_start);\n   132→    let offset = 0;\n   133→    let filterFunc = (item: any) => item;\n   134→    if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type)) {\n   135→      switch (invoice.billing_reason) {\n   136→        case 'subscription_cancel':\n   137→          filterFunc = (item: any) => item.price?.recurring?.usage_type === 'metered';\n   138→          break;\n   139→        case 'subscription_cycle':\n   140→          filterFunc = (item: any) => item.price?.type === 'recurring';\n   141→          offset = setup.cycle / 1000;\n   142→          break;\n   143→        default:\n   144→          filterFunc = () => true;\n   145→      }\n   146→    }\n   147→    const previousPeriodStart = setup.period.start - offset;\n   148→    const previousPeriodEnd = setup.period.end - offset;\n   149→    expandedItems = await Promise.all(\n   150→      expandedItems.filter(filterFunc).map(async (item: any) => {\n   151→        const { price } = item;\n   152→        if (price?.recurring?.usage_type === 'metered') {\n   153→          const rawQuantity = await UsageRecord.getSummary({\n   154→            id: item.id,\n   155→            start: previousPeriodStart,\n   156→            end: previousPeriodEnd,\n   157→            method: price.recurring?.aggregate_usage,\n   158→            dryRun: true,\n   159→            searchBilled: false,\n   160→          });\n   161→          item.quantity = price.transformQuantity(rawQuantity);\n   162→        }\n   163→        return item;\n   164→      })\n   165→    );\n   166→\n   167→    const baseAmount = getSubscriptionCycleAmount(expandedItems, subscription.currency_id);\n   168→    let shouldPayTotal = baseAmount?.total || invoice.total;\n   169→\n   170→    // Apply discount if exists\n   171→    if (baseAmount?.total && invoice.total_discount_amounts && invoice.total_discount_amounts.length > 0) {\n   172→      const totalDiscountAmount = invoice.total_discount_amounts.reduce((sum, discount) => {\n   173→        return new BN(sum).add(new BN(discount.amount.toString())).toString();\n   174→      }, '0');\n   175→\n   176→      shouldPayTotal = new BN(shouldPayTotal).sub(new BN(totalDiscountAmount)).toString();\n   177→\n   178→      // Ensure the final amount doesn't go below zero\n   179→      if (new BN(shouldPayTotal).lt(new BN('0'))) {\n   180→        shouldPayTotal = '0';\n   181→      }\n   182→    }\n   183→\n   184→    return shouldPayTotal;\n   185→  } catch (err) {\n   186→    console.error(`Error in getInvoiceShouldPayTotal for invoice ${invoice.id}:`, err);\n   187→    return invoice.total;\n   188→  }\n   189→}\n   190→\n   191→export async function getReturnStakeInvoices(subscription: Subscription) {\n   192→  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n   193→  const returnStakeInvoice: Invoice[] = [];\n   194→  const refunds = await Refund.findAll({\n   195→    where: { subscription_id: subscription.id, status: 'succeeded', type: 'stake_return' },\n   196→    include: [\n   197→      { model: Invoice, as: 'invoice' },\n   198→      { model: Customer, as: 'customer' },\n   199→      { model: PaymentCurrency, as: 'paymentCurrency' },\n   200→    ],\n   201→  });\n   202→\n   203→  await Promise.all(\n   204→    refunds.map(async (r: any) => {\n   205→      const invoice =\n   206→        r.invoice ||\n   207→        (await Invoice.findOne({\n   208→          where: {\n   209→            subscription_id: subscription.id,\n   210→            currency_id: r.currency_id,\n   211→          },\n   212→          order: [['created_at', 'ASC']],\n   213→        }));\n   214→      returnStakeInvoice.push({\n   215→        id: r.id,\n   216→        status: 'paid',\n   217→        billing_reason: 'return_stake',\n   218→        description: 'Return Subscription staking',\n   219→        total: r.amount,\n   220→        amount_due: '0',\n   221→        amount_paid: r.amount,\n   222→        amount_remaining: '0',\n   223→        subscription_id: subscription.id,\n   224→        paid: true,\n   225→        ...pick(invoice, ['number', 'auto_advance', 'period_start', 'period_end']),\n   226→        ...pick(r, ['created_at', 'updated_at', 'currency_id', 'customer_id']),\n   227→        // @ts-ignore\n   228→        paymentCurrency: r.paymentCurrency,\n   229→        paymentMethod: method,\n   230→        customer: r.customer,\n   231→        metadata: {\n   232→          payment_details: {\n   233→            arcblock: {\n   234→              tx_hash: r?.payment_details?.arcblock?.tx_hash,\n   235→              payer: r?.payment_details?.arcblock?.payer,\n   236→            },\n   237→          },\n   238→        },\n   239→      });\n   240→    })\n   241→  );\n   242→  return returnStakeInvoice;\n   243→}\n   244→\n   245→export async function getSetupInvoice(\n   246→  subscription: Subscription,\n   247→  paymentMethod: PaymentMethod,\n   248→  currencyId: string,\n   249→  stakingProps: { tx_hash: string; payer: string; address: string }\n   250→) {\n   251→  const currency = await PaymentCurrency.findByPk(currencyId);\n   252→  if (!currency) {\n   253→    return null;\n   254→  }\n   255→  if (!stakingProps?.tx_hash) {\n   256→    return null;\n   257→  }\n   258→  if (paymentMethod?.type !== 'arcblock') {\n   259→    return null;\n   260→  }\n   261→  const firstInvoice = await Invoice.findOne({\n   262→    where: { subscription_id: subscription.id, currency_id: currency.id },\n   263→    order: [['created_at', 'ASC']],\n   264→    include: [{ model: Customer, as: 'customer' }],\n   265→  });\n   266→  if (!firstInvoice) {\n   267→    return null;\n   268→  }\n   269→  const stakeAmountResult = await getSubscriptionStakeAmountSetup(subscription, paymentMethod, stakingProps.tx_hash);\n   270→  // @ts-ignore\n   271→  const stakeAmount = stakeAmountResult?.[currency?.contract] || '0';\n   272→  return {\n   273→    id: stakingProps.address as string,\n   274→    status: 'paid',\n   275→    description: 'Subscription staking',\n   276→    billing_reason: 'stake',\n   277→    total: stakeAmount,\n   278→    amount_due: '0',\n   279→    amount_paid: stakeAmount,\n   280→    amount_remaining: '0',\n   281→    ...pick(firstInvoice, [\n   282→      'number',\n   283→      'paid',\n   284→      'auto_advance',\n   285→      'currency_id',\n   286→      'customer_id',\n   287→      'subscription_id',\n   288→      'period_start',\n   289→      'period_end',\n   290→      'created_at',\n   291→      'updated_at',\n   292→    ]),\n   293→    // @ts-ignore\n   294→    paymentCurrency: currency,\n   295→    paymentMethod,\n   296→    // @ts-ignore\n   297→    customer: firstInvoice?.customer,\n   298→    metadata: {\n   299→      payment_details: {\n   300→        arcblock: {\n   301→          tx_hash: stakingProps?.tx_hash,\n   302→          payer: stakingProps?.payer,\n   303→        },\n   304→      },\n   305→    },\n   306→  };\n   307→}\n   308→\n   309→export async function getStakingInvoices(subscription: Subscription): Promise<Invoice[]> {\n   310→  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n   311→  if (!method) {\n   312→    return [];\n   313→  }\n   314→  const stakeInvoices = await Invoice.findAll({\n   315→    where: { subscription_id: subscription.id, billing_reason: 'stake', status: 'paid' },\n   316→    include: [\n   317→      { model: Customer, as: 'customer' },\n   318→      { model: PaymentCurrency, as: 'paymentCurrency' },\n   319→      { model: PaymentMethod, as: 'paymentMethod' },\n   320→    ],\n   321→  });\n   322→  const invoices = cloneDeep(stakeInvoices);\n   323→  const setups = await SetupIntent.findAll({\n   324→    where: {\n   325→      customer_id: subscription.customer_id,\n   326→      payment_method_id: method?.id,\n   327→      status: 'succeeded',\n   328→      [Op.and]: [\n   329→        { metadata: { [Op.not]: null } },\n   330→        { 'metadata.subscription_id': subscription.id },\n   331→        { setup_details: { [Op.not]: null } },\n   332→        { 'setup_details.arcblock': { [Op.not]: null } },\n   333→        { 'setup_details.arcblock.staking': { [Op.not]: null } },\n   334→      ] as any,\n   335→    },\n   336→  });\n   337→  if (setups.length === 0) {\n   338→    // No payment change, use the first invoice\n   339→    if (stakeInvoices.length > 0) {\n   340→      return stakeInvoices;\n   341→    }\n   342→    const newInvoice = await getSetupInvoice(subscription, method, subscription.currency_id, {\n   343→      tx_hash: subscription.payment_details?.arcblock?.staking?.tx_hash!,\n   344→      payer: subscription.payment_details?.arcblock?.payer!,\n   345→      address: subscription.payment_details?.arcblock?.staking?.address!,\n   346→    });\n   347→    // @ts-ignore\n   348→    return [newInvoice].filter(Boolean);\n   349→  }\n   350→\n   351→  await Promise.all(\n   352→    setups.map(async (setup: SetupIntent, index: number) => {\n   353→      if (\n   354→        index === 0 &&\n   355→        setup.metadata?.from_currency &&\n   356→        !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.from_currency)\n   357→      ) {\n   358→        const paymentDetails =\n   359→          setup?.metadata?.from_payment_details?.arcblock || subscription.payment_details?.arcblock;\n   360→        const fromMethod = await PaymentMethod.findByPk(setup?.metadata?.from_payment_method_id);\n   361→        const newInvoice = await getSetupInvoice(subscription, fromMethod!, setup.metadata?.from_currency, {\n   362→          tx_hash: paymentDetails?.staking?.tx_hash!,\n   363→          payer: paymentDetails?.payer!,\n   364→          address: paymentDetails?.staking?.address!,\n   365→        });\n   366→        if (newInvoice) {\n   367→          // @ts-ignore\n   368→          invoices.push(newInvoice);\n   369→        }\n   370→      }\n   371→      if (setup.metadata?.to_currency && !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.to_currency)) {\n   372→        const newInvoice = await getSetupInvoice(subscription, method, setup.metadata?.to_currency, {\n   373→          tx_hash: setup.setup_details?.arcblock?.staking?.tx_hash!,\n   374→          payer: setup.setup_details?.arcblock?.payer!,\n   375→          address: setup.setup_details?.arcblock?.staking?.address!,\n   376→        });\n   377→        if (newInvoice) {\n   378→          // @ts-ignore\n   379→          invoices.push(newInvoice);\n   380→        }\n   381→      }\n   382→    })\n   383→  );\n   384→  return invoices;\n   385→}\n   386→\n   387→type BaseInvoiceProps = {\n   388→  customer: Customer;\n   389→  subscription?: Subscription | null;\n   390→  currency_id: string;\n   391→  livemode: boolean;\n   392→  period_start: number;\n   393→  period_end: number;\n   394→  status?: string;\n   395→  billing_reason: string;\n   396→  description: string;\n   397→  statement_descriptor?: string;\n   398→  total: string;\n   399→  subtotal?: string;\n   400→  amount_due?: string;\n   401→  amount_paid?: string;\n   402→  amount_remaining?: string;\n   403→  default_payment_method_id: string;\n   404→  payment_intent_id?: string;\n   405→  checkout_session_id?: string;\n   406→  metadata?: Record<string, any>;\n   407→  // Discount fields\n   408→  discounts?: string[];\n   409→  total_discount_amounts?: DiscountAmount[];\n   410→  items?: Array<{\n   411→    price_id: string;\n   412→    amount: string;\n   413→    quantity: number;\n   414→    description: string;\n   415→    period?: {\n   416→      start: number;\n   417→      end: number;\n   418→    };\n   419→    metadata?: Record<string, any>;\n   420→    subscription_item_id?: string;\n   421→    // Discount fields for InvoiceItem\n   422→    discountable?: boolean;\n   423→    discount_amounts?: DiscountAmount[];\n   424→  }>;\n   425→  auto_advance?: boolean;\n   426→  paid?: boolean;\n   427→  paid_out_of_band?: boolean;\n   428→  payment_settings?: PaymentSettings;\n   429→  footer?: string;\n   430→  custom_fields?: SimpleCustomField[];\n   431→  starting_token_balance?: Record<string, string>;\n   432→  ending_token_balance?: Record<string, string>;\n   433→  subtotal_excluding_tax?: string;\n   434→  collection_method?: 'charge_automatically' | 'send_invoice';\n   435→  id?: string;\n   436→  quote_id?: string;\n   437→};\n   438→\n   439→async function createInvoiceWithItems(props: BaseInvoiceProps): Promise<{\n   440→  invoice: Invoice;\n   441→  items: InvoiceItem[];\n   442→}> {\n   443→  const {\n   444→    customer,\n   445→    subscription,\n   446→    currency_id: currencyId,\n   447→    livemode,\n   448→    period_start: periodStart,\n   449→    period_end: periodEnd,\n   450→    status = 'open',\n   451→    billing_reason: billingReason,\n   452→    description,\n   453→    statement_descriptor: statementDescriptor = '',\n   454→    total,\n   455→    amount_due: amountDue = total,\n   456→    amount_paid: amountPaid = '0',\n   457→    amount_remaining: amountRemaining = total,\n   458→    default_payment_method_id: paymentMethodId,\n   459→    payment_intent_id: paymentIntentId = '',\n   460→    checkout_session_id: checkoutSessionId = '',\n   461→    items: itemsData,\n   462→    metadata = {},\n   463→    paid = false,\n   464→    auto_advance: autoAdvance = true,\n   465→    paid_out_of_band: paidOutOfBand = false,\n   466→    payment_settings: paymentSettings,\n   467→    ...extraProps\n   468→  } = props;\n   469→\n   470→  const invoiceNumber = await customer.getInvoiceNumber();\n   471→  // create invoice\n   472→  const invoice = await Invoice.create({\n   473→    amount_shipping: '0',\n   474→    starting_balance: '0',\n   475→    ending_balance: '0',\n   476→    subtotal_excluding_tax: '0',\n   477→    starting_token_balance: {},\n   478→    ending_token_balance: {},\n   479→    attempt_count: 0,\n   480→    attempted: false,\n   481→    tax: '0',\n   482→    discounts: props.discounts || [],\n   483→    total_discount_amounts: props.total_discount_amounts || [],\n   484→    collection_method: 'charge_automatically',\n   485→    ...extraProps,\n   486→    livemode,\n   487→    number: invoiceNumber,\n   488→    description,\n   489→    statement_descriptor: statementDescriptor,\n   490→    period_start: periodStart,\n   491→    period_end: periodEnd,\n   492→    auto_advance: autoAdvance,\n   493→    paid,\n   494→    paid_out_of_band: paidOutOfBand,\n   495→    status,\n   496→    billing_reason: billingReason,\n   497→    currency_id: currencyId,\n   498→    customer_id: customer.id,\n   499→    default_payment_method_id: paymentMethodId,\n   500→    payment_intent_id: paymentIntentId,\n   501→    subscription_id: subscription?.id,\n   502→    checkout_session_id: checkoutSessionId,\n   503→    total,\n   504→    subtotal: props.subtotal || total,\n   505→    amount_due: amountDue,\n   506→    amount_paid: amountPaid,\n   507→    amount_remaining: amountRemaining,\n   508→\n   509→    customer_address: customer.address,\n   510→    customer_email: customer.email,\n   511→    customer_name: customer.name,\n   512→    customer_phone: customer.phone,\n   513→\n   514→    effective_at: dayjs().unix(),\n   515→    status_transitions: {\n   516→      finalized_at: dayjs().unix(),\n   517→    },\n   518→    payment_settings: paymentSettings || subscription?.payment_settings,\n   519→    metadata,\n   520→  });\n   521→\n   522→  if (!itemsData) {\n   523→    return { invoice, items: [] };\n   524→  }\n   525→\n   526→  // Generate quotes for dynamic pricing items (subscription invoices)\n   527→  const enrichedItemsData = subscription\n   528→    ? await generateQuotesForInvoiceItems({\n   529→        invoiceId: invoice.id,\n   530→        items: itemsData,\n   531→        currencyId,\n   532→      })\n   533→    : itemsData;\n   534→\n   535→  // create invoice items\n   536→  const items = await Promise.all(\n   537→    enrichedItemsData.map(async (item) => {\n   538→      // Match tax rate for this specific item\n   539→      let taxRateId: string | undefined;\n   540→      if (customer.address?.country && item.price_id) {\n   541→        try {\n   542→          const price = await Price.findByPk(item.price_id);\n   543→          if (price?.product_id) {\n   544→            const product = await Product.findByPk(price.product_id);\n   545→            if (product) {\n   546→              const taxRate = await TaxRate.findMatchingRate({\n   547→                country: customer.address.country,\n   548→                state: customer.address.state,\n   549→                postalCode: customer.address.postal_code,\n   550→                taxCode: product.tax_code,\n   551→                livemode,\n   552→              });\n   553→              taxRateId = taxRate?.id;\n   554→            }\n   555→          }\n   556→        } catch (error) {\n   557→          logger.error('Failed to match tax rate for invoice item:', error);\n   558→        }\n   559→      }\n   560→\n   561→      return InvoiceItem.create({\n   562→        livemode,\n   563→        amount: item.amount,\n   564→        quantity: item.quantity,\n   565→        description: item.description,\n   566→        period: item.period,\n   567→        currency_id: currencyId,\n   568→        customer_id: customer.id,\n   569→        price_id: item.price_id,\n   570→        invoice_id: invoice.id,\n   571→        subscription_id: subscription?.id,\n   572→        subscription_item_id: item.subscription_item_id,\n   573→        tax_rate_id: taxRateId,\n   574→        discountable: item.discountable || false,\n   575→        discounts: [], // Keep as empty for now - this is legacy field\n   576→        discount_amounts:\n   577→          item.discount_amounts?.map((d) => ({ amount: new BN(d.amount || '0').toString(), discount: d.discount })) ||\n   578→          [],\n   579→        proration: false,\n   580→        proration_details: {},\n   581→        metadata: {\n   582→          ...(item.metadata || {}),\n   583→          // Include quote_id in metadata if it exists (for dynamic pricing)\n   584→          ...((item as any).quote_id && { quote_id: (item as any).quote_id }),\n   585→        },\n   586→      });\n   587→    })\n   588→  );\n   589→\n   590→  return { invoice, items };\n   591→}\n   592→\n   593→export async function ensureInvoiceAndItems({\n   594→  customer,\n   595→  currency,\n   596→  subscription,\n   597→  subscriptions,\n   598→  props,\n   599→  lineItems,\n   600→  trialing,\n   601→  metered,\n   602→  applyCredit = true,\n   603→}: {\n   604→  customer: Customer;\n   605→  currency: PaymentCurrency;\n   606→  subscription?: Subscription;\n   607→  subscriptions?: Subscription[];\n   608→  props: TInvoice;\n   609→  lineItems: TLineItemExpanded[];\n   610→  trialing: boolean; // do we have trialing\n   611→  metered: boolean; // is the quantity metered\n   612→  applyCredit?: boolean; // should we apply customer credit?\n   613→}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n   614→  // apply possible balance to invoice\n   615→  let remaining = props.total;\n   616→  let result = { starting: {}, ending: {} };\n   617→  if (applyCredit && props.total > '0' && !props.amount_remaining) {\n   618→    const balance = customer.getBalanceToApply(currency.id, props.total);\n   619→    result = await customer.decreaseTokenBalance(currency.id, balance);\n   620→    remaining = new BN(props.total).sub(new BN(balance)).toString();\n   621→    logger.info('Invoice will use customer credit', { result, remaining, total: props.total });\n   622→  }\n   623→\n   624→  // get subscription items\n   625→  let subscriptionItems: SubscriptionItem[] = [];\n   626→  if (subscriptions && subscriptions.length > 0) {\n   627→    subscriptionItems = await SubscriptionItem.findAll({\n   628→      where: { subscription_id: { [Op.in]: subscriptions.map((s) => s.id) } },\n   629→    });\n   630→  } else if (subscription) {\n   631→    subscriptionItems = await SubscriptionItem.findAll({\n   632→      where: { subscription_id: subscription?.id },\n   633→    });\n   634→  }\n   635→\n   636→  function getLineSetup(x: TLineItemExpanded) {\n   637→    const price = getSubscriptionItemPrice(x);\n   638→    if (price.type === 'recurring' && trialing) {\n   639→      return {\n   640→        price,\n   641→        amount: '0',\n   642→        // @ts-ignore\n   643→        description: trialing ? `${price.product.name} (trialing)` : price.product.name,\n   644→        period: {\n   645→          start: props.period_start,\n   646→          end: props.period_end,\n   647→        },\n   648→      };\n   649→    }\n   650→\n   651→    return {\n   652→      price,\n   653→      amount:\n   654→        x.custom_amount ||\n   655→        new BN(getPriceUintAmountByCurrency(price, props.currency_id)).mul(new BN(x.quantity)).toString(),\n   656→      description: price.product.name,\n   657→      period: undefined,\n   658→    };\n   659→  }\n   660→  // process line items\n   661→  const processedItems = lineItems.map((x: TLineItemExpanded) => {\n   662→    const setup = getLineSetup(x);\n   663→    const { price } = setup;\n   664→    let { quantity } = x;\n   665→    if (price.type === 'recurring') {\n   666→      if (price.recurring?.usage_type === 'metered' && !metered) {\n   667→        quantity = 0;\n   668→      }\n   669→      if (trialing) {\n   670→        quantity = 0;\n   671→      }\n   672→    }\n   673→\n   674→    return {\n   675→      price_id: price.id,\n   676→      amount: quantity > 0 ? setup.amount : '0',\n   677→      quantity,\n   678→      description: setup.description,\n   679→      period: setup.period,\n   680→      metadata: x.metadata || {},\n   681→      subscription_item_id: subscriptionItems.find((si) => si.price_id === price.id)?.id,\n   682→      // Discount fields from pre-calculated line items\n   683→      discountable: x.discountable || false,\n   684→      discount_amounts: x.discount_amounts || [],\n   685→    };\n   686→  });\n   687→\n   688→  return createInvoiceWithItems({\n   689→    customer,\n   690→    subscription,\n   691→    items: processedItems,\n   692→    livemode: props.livemode,\n   693→    status: props.status || 'open',\n   694→    billing_reason: props.billing_reason,\n   695→    description: props.description || '',\n   696→    statement_descriptor: props.statement_descriptor,\n   697→\n   698→    currency_id: props.currency_id,\n   699→    payment_intent_id: props.payment_intent_id,\n   700→    checkout_session_id: props.checkout_session_id,\n   701→    default_payment_method_id: props.default_payment_method_id,\n   702→\n   703→    period_start: props.period_start,\n   704→    period_end: props.period_end,\n   705→    auto_advance: props.auto_advance,\n   706→\n   707→    total: props.total,\n   708→    subtotal: props.subtotal || props.total,\n   709→    amount_remaining: props.amount_remaining || remaining,\n   710→    amount_paid: props.amount_paid,\n   711→    amount_due: props.amount_due || remaining,\n   712→    subtotal_excluding_tax: props.subtotal || props.total || '0',\n   713→    starting_token_balance: result.starting,\n   714→    ending_token_balance: result.ending,\n   715→\n   716→    footer: props.footer,\n   717→    custom_fields: props.custom_fields,\n   718→    payment_settings: props.payment_settings || subscription?.payment_settings,\n   719→    discounts: props.discounts,\n   720→    total_discount_amounts: props.total_discount_amounts || [],\n   721→    metadata: {\n   722→      ...props.metadata,\n   723→      starting_token_balance: result.starting,\n   724→      ending_token_balance: result.ending,\n   725→    },\n   726→  });\n   727→}\n   728→\n   729→export async function cleanupInvoiceAndItems(invoiceId: string) {\n   730→  const invoice = await Invoice.findByPk(invoiceId);\n   731→  if (!invoice) {\n   732→    return;\n   733→  }\n   734→  if (invoice.isImmutable()) {\n   735→    return;\n   736→  }\n   737→\n   738→  const removedItem = await InvoiceItem.destroy({ where: { invoice_id: invoiceId } });\n   739→  const removedInvoice = await Invoice.destroy({ where: { id: invoiceId } });\n   740→  logger.info('cleanup invoice and items', { invoiceId, removedItem, removedInvoice });\n   741→}\n   742→\n   743→export async function ensureRechargeInvoice(\n   744→  invoiceProps: {\n   745→    total: string;\n   746→    description?: string;\n   747→    checkout_session_id?: string;\n   748→    currency_id: string;\n   749→    metadata?: any;\n   750→    payment_settings?: any;\n   751→    livemode?: boolean;\n   752→  },\n   753→  subscription: Subscription | null,\n   754→  paymentMethod: PaymentMethod,\n   755→  customer: Customer\n   756→) {\n   757→  try {\n   758→    const { livemode = true } = invoiceProps;\n   759→    const { invoice } = await createInvoiceWithItems({\n   760→      customer,\n   761→      subscription,\n   762→      currency_id: invoiceProps.currency_id,\n   763→      livemode: subscription?.livemode ?? livemode,\n   764→      period_start: dayjs().unix(),\n   765→      period_end: dayjs().unix(),\n   766→      status: 'paid',\n   767→      billing_reason: 'recharge',\n   768→      description: invoiceProps?.description || 'Add funds for subscription',\n   769→      total: invoiceProps.total || '0',\n   770→      amount_due: '0',\n   771→      amount_paid: invoiceProps.total || '0',\n   772→      amount_remaining: '0',\n   773→      default_payment_method_id: paymentMethod.id,\n   774→      checkout_session_id: invoiceProps?.checkout_session_id || '',\n   775→      metadata: invoiceProps.metadata || {},\n   776→      auto_advance: false,\n   777→      paid: true,\n   778→      paid_out_of_band: false,\n   779→      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n   780→    });\n   781→\n   782→    logger.info('create recharge invoice success', {\n   783→      invoice,\n   784→      subscriptionId: subscription?.id,\n   785→      paymentMethod: paymentMethod.id,\n   786→    });\n   787→  } catch (error) {\n   788→    logger.error('ensureRechargeInvoice: create invoice failed', {\n   789→      error,\n   790→      subscriptionId: subscription?.id,\n   791→      paymentMethod: paymentMethod.id,\n   792→    });\n   793→    throw error;\n   794→  }\n   795→}\n   796→\n   797→export async function ensureOverdraftProtectionInvoiceAndItems({\n   798→  customer,\n   799→  subscription,\n   800→  paymentIntent,\n   801→  props,\n   802→}: {\n   803→  customer: Customer;\n   804→  subscription: Subscription;\n   805→  paymentIntent: PaymentIntent;\n   806→  props: Partial<TInvoice> & { period_start: number; period_end: number };\n   807→}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n   808→  const { price, product } = await ensureOverdraftProtectionPrice(subscription.livemode);\n   809→  const invoicePrice = price?.currency_options?.find((x: any) => x.currency_id === paymentIntent?.currency_id);\n   810→\n   811→  if (!subscription.overdraft_protection?.enabled) {\n   812→    throw new Error('Overdraft protection invoice creation skipped: overdraft protection is not enabled');\n   813→  }\n   814→\n   815→  if (!invoicePrice) {\n   816→    throw new Error('Overdraft protection invoice price not found');\n   817→  }\n   818→  const currency = await PaymentCurrency.findByPk(invoicePrice.currency_id);\n   819→  if (!currency) {\n   820→    throw new Error('Overdraft protection invoice currency not found');\n   821→  }\n   822→  const paymentMethod = await PaymentMethod.findByPk(currency?.payment_method_id);\n   823→  if (!paymentMethod) {\n   824→    throw new Error('Overdraft protection invoice payment method not found');\n   825→  }\n   826→\n   827→  if (paymentMethod.type !== 'arcblock') {\n   828→    throw new Error(`Payment method ${paymentMethod.type} not supported for overdraft protection`);\n   829→  }\n   830→\n   831→  const { unused } = await isSubscriptionOverdraftProtectionEnabled(subscription, paymentIntent?.currency_id);\n   832→  if (new BN(unused).lt(new BN(invoicePrice.unit_amount))) {\n   833→    throw new Error('Overdraft protection invoice creation skipped: insufficient overdraft protection funds');\n   834→  }\n   835→\n   836→  const result = await createInvoiceWithItems({\n   837→    customer,\n   838→    subscription,\n   839→    currency_id: invoicePrice.currency_id,\n   840→    livemode: subscription.livemode,\n   841→    period_start: props.period_start || 0,\n   842→    period_end: props.period_end || 0,\n   843→    status: props.status,\n   844→    billing_reason: 'overdraft_protection',\n   845→    description: 'Overdraft protection',\n   846→    collection_method: 'send_invoice',\n   847→    default_payment_method_id: paymentMethod.id,\n   848→    total: invoicePrice.unit_amount || '0',\n   849→    items: [\n   850→      {\n   851→        price_id: price?.id || '',\n   852→        amount: invoicePrice.unit_amount || '0',\n   853→        quantity: 1,\n   854→        description: product?.name || '',\n   855→        period: {\n   856→          start: props.period_start || 0,\n   857→          end: props.period_end || 0,\n   858→        },\n   859→      },\n   860→    ],\n   861→    metadata: {\n   862→      ...(props.metadata || {}),\n   863→      payment_intent_id: paymentIntent.id,\n   864→    },\n   865→  });\n   866→\n   867→  await Price.increment({ quantity_sold: 1 }, { where: { id: price?.id } });\n   868→  return result;\n   869→}\n   870→\n   871→export async function ensureStakeInvoice(\n   872→  invoiceProps: {\n   873→    total: string;\n   874→    description?: string;\n   875→    checkout_session_id?: string;\n   876→    currency_id: string;\n   877→    billing_reason?: string;\n   878→    metadata?: any;\n   879→    payment_settings?: any;\n   880→  },\n   881→  subscription: Subscription,\n   882→  paymentMethod: PaymentMethod,\n   883→  customer: Customer,\n   884→  allSubscriptions?: Subscription[]\n   885→) {\n   886→  if (paymentMethod.type !== 'arcblock') {\n   887→    return;\n   888→  }\n   889→\n   890→  try {\n   891→    const isMultiSubscription = allSubscriptions && allSubscriptions.length > 1;\n   892→    const metadata = {\n   893→      ...(invoiceProps.metadata || {}),\n   894→    };\n   895→\n   896→    if (isMultiSubscription) {\n   897→      metadata.all_subscription_ids = allSubscriptions.map((s) => s.id);\n   898→      metadata.is_shared_stake = true;\n   899→      metadata.primary_subscription_id = subscription.id;\n   900→    }\n   901→\n   902→    const { invoice } = await createInvoiceWithItems({\n   903→      customer,\n   904→      subscription,\n   905→      currency_id: invoiceProps.currency_id,\n   906→      livemode: subscription.livemode,\n   907→      period_start: dayjs().unix(),\n   908→      period_end: subscription.current_period_end,\n   909→      status: 'paid',\n   910→      billing_reason: invoiceProps?.billing_reason || 'stake',\n   911→      description: invoiceProps?.description || 'Stake for subscription',\n   912→      total: invoiceProps.total || '0',\n   913→      amount_due: '0',\n   914→      amount_paid: invoiceProps.total || '0',\n   915→      amount_remaining: '0',\n   916→      default_payment_method_id: paymentMethod.id,\n   917→      checkout_session_id: invoiceProps?.checkout_session_id || '',\n   918→      metadata,\n   919→      auto_advance: false,\n   920→      paid: true,\n   921→      paid_out_of_band: false,\n   922→      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n   923→    });\n   924→\n   925→    logger.info('create staking invoice success', {\n   926→      invoice,\n   927→      subscriptionId: subscription?.id,\n   928→      paymentMethod: paymentMethod.id,\n   929→    });\n   930→  } catch (error) {\n   931→    logger.error('ensureStake: create invoice failed', {\n   932→      error,\n   933→      subscriptionId: subscription?.id,\n   934→      paymentMethod: paymentMethod.id,\n   935→    });\n   936→    throw error;\n   937→  }\n   938→}\n   939→\n   940→export async function getStakeInvoiceForSubscription(subscriptionId: string, currencyId: string) {\n   941→  const where: WhereOptions = {\n   942→    [Op.or]: [\n   943→      { subscription_id: subscriptionId },\n   944→      { 'metadata.all_subscription_ids': { [Op.contains]: [subscriptionId] } },\n   945→    ],\n   946→    billing_reason: 'stake',\n   947→    status: 'paid',\n   948→  };\n   949→\n   950→  if (currencyId) {\n   951→    where.currency_id = currencyId;\n   952→  }\n   953→  try {\n   954→    const invoice = await Invoice.findOne({ where });\n   955→    return invoice;\n   956→  } catch (error) {\n   957→    logger.error('getStakeInvoiceForSubscription: find invoice failed', {\n   958→      error,\n   959→      subscriptionId,\n   960→      currencyId,\n   961→    });\n   962→    return null;\n   963→  }\n   964→}\n   965→\n   966→// mark overdraft protection invoice as void after payment\n   967→export async function handleOverdraftProtectionInvoiceAfterPayment(invoice: Invoice) {\n   968→  try {\n   969→    if (['stake', 'overdraft_protection', 'stake_overdraft_protection'].includes(invoice.billing_reason)) {\n   970→      return;\n   971→    }\n   972→    const subscription = await Subscription.findByPk(invoice.subscription_id);\n   973→    if (!subscription) {\n   974→      logger.info('handle overdraft protection invoice skipped due to subscription not found', {\n   975→        invoiceId: invoice.id,\n   976→      });\n   977→      return;\n   978→    }\n   979→    if (!subscription.overdraft_protection?.enabled) {\n   980→      logger.info('handle overdraft protection invoice skipped due to overdraft protection not enabled', {\n   981→        subscriptionId: subscription.id,\n   982→      });\n   983→      return;\n   984→    }\n   985→    const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n   986→    if (!paymentMethod || paymentMethod?.type !== 'arcblock') {\n   987→      logger.info('handle overdraft protection invoice skipped due to payment method not supported', {\n   988→        invoiceId: invoice.id,\n   989→        paymentMethodId: paymentMethod?.id,\n   990→      });\n   991→      return;\n   992→    }\n   993→    const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n   994→    if (!paymentIntent) {\n   995→      logger.info('handle overdraft protection invoice skipped due to payment intent not found', {\n   996→        invoiceId: invoice.id,\n   997→      });\n   998→      return;\n   999→    }\n  1000→    if (paymentIntent.status !== 'succeeded') {\n  1001→      logger.info('handle overdraft protection invoice skipped due to payment intent not succeeded', {\n  1002→        invoiceId: invoice.id,\n  1003→      });\n  1004→      return;\n  1005→    }\n  1006→    if (paymentIntent.payment_details?.arcblock?.type !== 'transfer') {\n  1007→      logger.info('handle overdraft protection invoice skipped due to payment type not transfer', {\n  1008→        invoiceId: invoice.id,\n  1009→        paymentIntentId: paymentIntent.id,\n  1010→      });\n  1011→      return;\n  1012→    }\n  1013→    const overdraftProtectionInvoice = await Invoice.findOne({\n  1014→      where: {\n  1015→        subscription_id: subscription.id,\n  1016→        billing_reason: 'overdraft_protection',\n  1017→        'metadata.invoice_id': invoice.id,\n  1018→        status: {\n  1019→          [Op.notIn]: ['paid', 'void'],\n  1020→        },\n  1021→      },\n  1022→    });\n  1023→    if (!overdraftProtectionInvoice) {\n  1024→      logger.info('handle overdraft protection invoice skipped due to overdraft protection invoice not found', {\n  1025→        invoiceId: invoice.id,\n  1026→      });\n  1027→      return;\n  1028→    }\n  1029→\n  1030→    if (overdraftProtectionInvoice.payment_intent_id) {\n  1031→      const overdraftProtectionPaymentIntent = await PaymentIntent.findOne({\n  1032→        where: {\n  1033→          id: overdraftProtectionInvoice.payment_intent_id,\n  1034→        },\n  1035→      });\n  1036→      if (overdraftProtectionPaymentIntent) {\n  1037→        await overdraftProtectionPaymentIntent.update({\n  1038→          status: 'canceled',\n  1039→          canceled_at: dayjs().unix(),\n  1040→          cancellation_reason: 'void_invoice',\n  1041→        });\n  1042→      }\n  1043→    }\n  1044→\n  1045→    await overdraftProtectionInvoice.update({\n  1046→      status: 'void',\n  1047→      status_transitions: {\n  1048→        ...(overdraftProtectionInvoice.status_transitions || {}),\n  1049→        voided_at: dayjs().unix(),\n  1050→      },\n  1051→    });\n  1052→  } catch (error) {\n  1053→    logger.error('handle overdraft protection invoice failed', {\n  1054→      error,\n  1055→      invoiceId: invoice.id,\n  1056→    });\n  1057→  }\n  1058→}\n  1059→\n  1060→/**\n  1061→ * retry uncollectible invoices\n  1062→ * @param options\n  1063→ */\n  1064→export async function retryUncollectibleInvoices(options: {\n  1065→  customerId?: string;\n  1066→  subscriptionId?: string;\n  1067→  invoiceId?: string;\n  1068→  invoiceIds?: string[];\n  1069→  currencyId?: string;\n  1070→}) {\n  1071→  const lockKey = `retry-uncollectible-${JSON.stringify(options)}`;\n  1072→\n  1073→  const isLocked = await Lock.isLocked(lockKey);\n  1074→  if (isLocked) {\n  1075→    logger.warn('Retry uncollectible invoices already in progress', {\n  1076→      lockKey,\n  1077→      options,\n  1078→    });\n  1079→    throw new Error('Retry already in progress');\n  1080→  }\n  1081→\n  1082→  try {\n  1083→    await Lock.acquire(lockKey, dayjs().add(5, 'minutes').unix());\n  1084→\n  1085→    const { customerId, subscriptionId, invoiceId, invoiceIds, currencyId } = options;\n  1086→\n  1087→    const where: WhereOptions = {\n  1088→      status: { [Op.in]: ['uncollectible'] },\n  1089→      payment_intent_id: { [Op.ne]: null },\n  1090→    };\n  1091→\n  1092→    if (customerId) {\n  1093→      where.customer_id = customerId;\n  1094→    }\n  1095→\n  1096→    if (subscriptionId) {\n  1097→      where.subscription_id = subscriptionId;\n  1098→    }\n  1099→\n  1100→    if (invoiceId) {\n  1101→      where.id = invoiceId;\n  1102→    }\n  1103→\n  1104→    if (invoiceIds && invoiceIds.length > 0) {\n  1105→      where.id = { [Op.in]: invoiceIds };\n  1106→    }\n  1107→\n  1108→    if (currencyId) {\n  1109→      where.currency_id = currencyId;\n  1110→    }\n  1111→\n  1112→    const overdueInvoices = (await Invoice.findAll({\n  1113→      where,\n  1114→      include: [{ model: PaymentIntent, as: 'paymentIntent' }],\n  1115→      attributes: ['id', 'payment_intent_id', 'subscription_id', 'customer_id', 'created_at', 'status', 'currency_id'],\n  1116→      order: [['created_at', 'ASC']],\n  1117→    })) as (Invoice & { paymentIntent?: PaymentIntent })[];\n  1118→\n  1119→    const startTime = Date.now();\n  1120→    logger.info('Found uncollectible invoices to retry', {\n  1121→      count: overdueInvoices.length,\n  1122→      criteria: options,\n  1123→      invoiceIds: overdueInvoices.map((inv) => inv.id),\n  1124→    });\n  1125→\n  1126→    const results = {\n  1127→      processed: overdueInvoices.length,\n  1128→      successful: [] as string[],\n  1129→      failed: [] as Array<{ id: string; reason: string }>,\n  1130→    };\n  1131→\n  1132→    const settledResults = await Promise.allSettled(\n  1133→      overdueInvoices.map(async (invoice, index) => {\n  1134→        const { paymentIntent } = invoice;\n  1135→        const delay = index * 2;\n  1136→        if (!paymentIntent) {\n  1137→          throw new Error('No payment intent found');\n  1138→        }\n  1139→\n  1140→        await paymentIntent.update({ status: 'requires_capture' });\n  1141→        await emitAsync(\n  1142→          'payment.queued',\n  1143→          paymentIntent.id,\n  1144→          { paymentIntentId: paymentIntent.id, retryOnError: true, ignoreMaxRetryCheck: true },\n  1145→          { sync: false, delay }\n  1146→        );\n  1147→\n  1148→        return invoice;\n  1149→      })\n  1150→    );\n  1151→\n  1152→    settledResults.forEach((result, index) => {\n  1153→      const invoice = overdueInvoices[index];\n  1154→      if (!invoice) {\n  1155→        return;\n  1156→      }\n  1157→      if (result.status === 'fulfilled') {\n  1158→        results.successful.push(invoice.id);\n  1159→        logger.info('Successfully queued uncollectible invoice retry', {\n  1160→          invoiceId: invoice.id,\n  1161→          customerId: invoice.customer_id,\n  1162→          paymentIntentId: invoice.payment_intent_id,\n  1163→        });\n  1164→      } else {\n  1165→        const error = result.reason;\n  1166→        const errorType = error.name || 'Unknown';\n  1167→        const errorCode = error.code || 'UNKNOWN_ERROR';\n  1168→\n  1169→        results.failed.push({\n  1170→          id: invoice.id,\n  1171→          reason: error.message || 'Unknown error',\n  1172→        });\n  1173→\n  1174→        logger.error('Failed to queue uncollectible invoice retry', {\n  1175→          invoiceId: invoice.id,\n  1176→          customerId: invoice.customer_id,\n  1177→          subscriptionId: invoice.subscription_id,\n  1178→          paymentIntentId: invoice.payment_intent_id,\n  1179→          errorType,\n  1180→          errorCode,\n  1181→          error,\n  1182→        });\n  1183→      }\n  1184→    });\n  1185→\n  1186→    const processingTime = Date.now() - startTime;\n  1187→    logger.info('Completed retrying uncollectible invoices', {\n  1188→      totalProcessed: results.processed,\n  1189→      successful: results.successful.length,\n  1190→      failed: results.failed.length,\n  1191→      processingTimeMs: processingTime,\n  1192→    });\n  1193→\n  1194→    return results;\n  1195→  } finally {\n  1196→    await Lock.release(lockKey);\n  1197→    logger.info('Released retry uncollectible lock', { lockKey });\n  1198→  }\n  1199→}\n  1200→\n  1201→/**\n  1202→ * Migrate billing when a subscription's payment method changes.\n  1203→ * Steps:\n  1204→ * 1. Check if all subscription items are prepaid (licensed recurring).\n  1205→ * 2. If so, check if there is an unpaid invoice for the current period with the old payment method.\n  1206→ * 3. If such an invoice exists, void the old invoice and cancel its payment intent if present.\n  1207→ * 4. Create a new invoice for the current period with the new payment method.\n  1208→ * 5. If any step fails, throw an error and log details.\n  1209→ *\n  1210→ * @param subscription Subscription instance\n  1211→ * @param oldCurrencyId Old payment currency ID\n  1212→ * @param newCurrencyId New payment currency ID\n  1213→ * @returns Migration result: { migrated, oldInvoice, newInvoice }\n  1214→ */\n  1215→export const migrateSubscriptionPaymentMethodInvoice = async (\n  1216→  subscription: Subscription,\n  1217→  oldCurrencyId: string,\n  1218→  newCurrencyId: string\n  1219→) => {\n  1220→  // 1. Check if all subscription items are prepaid (licensed recurring)\n  1221→  const subscriptionItems = await SubscriptionItem.findAll({\n  1222→    where: { subscription_id: subscription.id },\n  1223→    include: [{ model: Price, as: 'price' }],\n  1224→  });\n  1225→\n  1226→  const subscriptionItemsExpanded = await Price.expand(subscriptionItems.map((x) => x.toJSON()));\n  1227→  const isPrepaid = subscriptionItemsExpanded.every((item: TLineItemExpanded) => {\n  1228→    const price = getSubscriptionItemPrice(item);\n  1229→    return price.type === 'recurring' && price.recurring?.usage_type === 'licensed';\n  1230→  });\n  1231→\n  1232→  if (!isPrepaid) {\n  1233→    logger.info('Skip billing migration for non-prepaid items', {\n  1234→      subscriptionId: subscription.id,\n  1235→    });\n  1236→    return { migrated: false, reason: 'has_non_prepaid_items' };\n  1237→  }\n  1238→\n  1239→  // 2. Find unpaid invoice for the current period with the old payment method\n  1240→  const currentPeriodInvoice = await Invoice.findOne({\n  1241→    where: {\n  1242→      subscription_id: subscription.id,\n  1243→      billing_reason: 'subscription_cycle',\n  1244→      status: ['open', 'uncollectible'],\n  1245→      currency_id: oldCurrencyId,\n  1246→      period_start: {\n  1247→        [Op.gte]: subscription.current_period_start,\n  1248→        [Op.lt]: subscription.current_period_end,\n  1249→      },\n  1250→    },\n  1251→    order: [['created_at', 'DESC']],\n  1252→  });\n  1253→\n  1254→  let voidedInvoice: Invoice | null = null;\n  1255→\n  1256→  if (!currentPeriodInvoice) {\n  1257→    voidedInvoice = await Invoice.findOne({\n  1258→      where: {\n  1259→        subscription_id: subscription.id,\n  1260→        billing_reason: 'subscription_cycle',\n  1261→        status: 'void',\n  1262→        currency_id: oldCurrencyId,\n  1263→        period_start: {\n  1264→          [Op.gte]: subscription.current_period_start,\n  1265→          [Op.lt]: subscription.current_period_end,\n  1266→        },\n  1267→      },\n  1268→      order: [['created_at', 'DESC']],\n  1269→    });\n  1270→    if (!voidedInvoice) {\n  1271→      logger.info('Skip billing migration for no unpaid invoice', {\n  1272→        subscriptionId: subscription.id,\n  1273→        periodStart: subscription.current_period_start,\n  1274→        periodEnd: subscription.current_period_end,\n  1275→        oldCurrencyId,\n  1276→      });\n  1277→      return { migrated: false, reason: 'no_unpaid_invoice' };\n  1278→    }\n  1279→  }\n  1280→\n  1281→  // 3. Get old and new payment method/currency\n  1282→  const oldPaymentCurrency = await PaymentCurrency.findByPk(oldCurrencyId);\n  1283→  if (!oldPaymentCurrency) {\n  1284→    throw new Error(`Payment currency ${oldCurrencyId} not found`);\n  1285→  }\n  1286→  const oldPaymentMethod = await PaymentMethod.findByPk(oldPaymentCurrency.payment_method_id);\n  1287→  if (!oldPaymentMethod) {\n  1288→    throw new Error(`Payment method for currency ${oldCurrencyId} not found`);\n  1289→  }\n  1290→\n  1291→  const newPaymentCurrency = await PaymentCurrency.findByPk(newCurrencyId);\n  1292→  if (!newPaymentCurrency) {\n  1293→    throw new Error(`Payment currency ${newCurrencyId} not found`);\n  1294→  }\n  1295→  const newPaymentMethod = await PaymentMethod.findByPk(newPaymentCurrency.payment_method_id);\n  1296→  if (!newPaymentMethod) {\n  1297→    throw new Error(`Payment method for currency ${newCurrencyId} not found`);\n  1298→  }\n  1299→\n  1300→  // 4. Stripe payment method is not supported for migration\n  1301→  if (newPaymentMethod.type === 'stripe') {\n  1302→    logger.info('Skip billing migration for stripe payment method', {\n  1303→      subscriptionId: subscription.id,\n  1304→    });\n  1305→    return { migrated: false, reason: 'stripe_payment_method' };\n  1306→  }\n  1307→\n  1308→  try {\n  1309→    const customer = await Customer.findByPk(subscription.customer_id);\n  1310→    if (!customer) {\n  1311→      throw new Error(`Customer ${subscription.customer_id} not found`);\n  1312→    }\n  1313→\n  1314→    const cancelOldInvoice = async (invoice: Invoice) => {\n  1315→      try {\n  1316→        if (invoice.payment_intent_id) {\n  1317→          const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n  1318→          if (paymentIntent && paymentIntent.status !== 'canceled') {\n  1319→            await paymentIntent.update({\n  1320→              status: 'canceled',\n  1321→              canceled_at: dayjs().unix(),\n  1322→              cancellation_reason: 'void_invoice',\n  1323→            });\n  1324→          }\n  1325→        }\n  1326→\n  1327→        if (oldPaymentMethod.type === 'stripe' && invoice.metadata?.stripe_id) {\n  1328→          const client = oldPaymentMethod.getStripeClient();\n  1329→          await client.invoices.voidInvoice(invoice.metadata.stripe_id);\n  1330→        }\n  1331→\n  1332→        await invoice.update({\n  1333→          status: 'void',\n  1334→          status_transitions: {\n  1335→            ...(invoice.status_transitions || {}),\n  1336→            voided_at: dayjs().unix(),\n  1337→          },\n  1338→        });\n  1339→\n  1340→        logger.info('Successfully voided old invoice for payment method change', {\n  1341→          subscriptionId: subscription.id,\n  1342→          oldInvoice: invoice.id,\n  1343→          oldCurrency: oldCurrencyId,\n  1344→          newCurrency: newCurrencyId,\n  1345→        });\n  1346→      } catch (error) {\n  1347→        logger.error('Failed to void old invoice', {\n  1348→          subscription: subscription.id,\n  1349→          invoiceId: invoice.id,\n  1350→          error: error.message,\n  1351→        });\n  1352→        throw error;\n  1353→      }\n  1354→    };\n  1355→\n  1356→    const createNewInvoice = async () => {\n  1357→      const preInvoice = currentPeriodInvoice || voidedInvoice;\n  1358→      if (!preInvoice) {\n  1359→        throw new Error('No unpaid invoice found');\n  1360→      }\n  1361→      const metadata: Record<string, any> = {\n  1362→        prev_invoice_id: preInvoice.id,\n  1363→      };\n  1364→      const amount = getSubscriptionCycleAmount(subscriptionItemsExpanded, newCurrencyId);\n  1365→\n  1366→      const { invoice } = await ensureInvoiceAndItems({\n  1367→        customer,\n  1368→        currency: newPaymentCurrency,\n  1369→        subscription,\n  1370→        trialing: subscription.status === 'trialing',\n  1371→        metered: false,\n  1372→        lineItems: subscriptionItemsExpanded,\n  1373→        applyCredit: false,\n  1374→        props: {\n  1375→          status: 'open',\n  1376→          total: amount.total,\n  1377→          livemode: subscription.livemode,\n  1378→          description: 'Subscription cycle',\n  1379→          statement_descriptor: preInvoice.statement_descriptor,\n  1380→          period_start: preInvoice.period_start,\n  1381→          period_end: preInvoice.period_end,\n  1382→          auto_advance: true,\n  1383→          billing_reason: 'subscription_cycle',\n  1384→          currency_id: newCurrencyId,\n  1385→          default_payment_method_id: newPaymentMethod.id,\n  1386→          custom_fields: preInvoice.custom_fields || [],\n  1387→          footer: preInvoice.footer || '',\n  1388→          payment_settings: subscription.payment_settings,\n  1389→          metadata,\n  1390→        } as Invoice,\n  1391→      });\n  1392→      return invoice;\n  1393→    };\n  1394→\n  1395→    // 5. Cancel old invoice, then create new invoice\n  1396→    if (currentPeriodInvoice) {\n  1397→      await cancelOldInvoice(currentPeriodInvoice);\n  1398→    }\n  1399→\n  1400→    const invoice = await createNewInvoice();\n  1401→    if (invoice) {\n  1402→      await emitAsync('invoice.queued', invoice.id, { invoiceId: invoice.id, retryOnError: true }, { sync: false });\n  1403→      logger.info('Successfully queued new invoice for payment method change', {\n  1404→        subscriptionId: subscription.id,\n  1405→        invoiceId: invoice.id,\n  1406→      });\n  1407→    }\n  1408→\n  1409→    logger.info('Successfully migrated invoice for payment method change', {\n  1410→      subscriptionId: subscription.id,\n  1411→      oldInvoiceId: currentPeriodInvoice?.id || voidedInvoice?.id,\n  1412→      oldCurrency: oldCurrencyId,\n  1413→      newCurrency: newCurrencyId,\n  1414→      newInvoiceId: invoice.id,\n  1415→    });\n  1416→    return {\n  1417→      migrated: true,\n  1418→      oldInvoice: currentPeriodInvoice,\n  1419→      newInvoice: invoice,\n  1420→    };\n  1421→  } catch (error) {\n  1422→    logger.error('Failed to migrate invoice for payment method change', {\n  1423→      subscriptionId: subscription.id,\n  1424→      oldCurrencyId,\n  1425→      newCurrencyId,\n  1426→      error: error.message,\n  1427→    });\n  1428→    throw error;\n  1429→  }\n  1430→};\n  1431→\n  1432→export async function destroyExistingInvoice(invoice: Invoice) {\n  1433→  const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n  1434→  try {\n  1435→    if (paymentMethod?.type === 'stripe' && invoice.metadata?.stripe_id) {\n  1436→      const client = paymentMethod.getStripeClient();\n  1437→      await client.invoices.del(invoice.metadata.stripe_id);\n  1438→    }\n  1439→  } catch (error) {\n  1440→    logger.error('Failed to destroy invoice on stripe', {\n  1441→      error: error.message,\n  1442→      invoiceId: invoice.id,\n  1443→    });\n  1444→  }\n  1445→  await InvoiceItem.destroy({ where: { invoice_id: invoice.id } });\n  1446→  await invoice.destroy();\n  1447→}\n  1448→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"fc7c8323-e4ce-448b-849b-b518c4a23e80","timestamp":"2026-01-06T15:03:43.645Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts","content":"import { component } from '@blocklet/sdk';\nimport type { LiteralUnion } from 'type-fest';\nimport { withQuery } from 'ufo';\n\nimport { BN, fromUnitToToken } from '@ocap/util';\nimport { Op, type WhereOptions } from 'sequelize';\nimport { cloneDeep, pick } from 'lodash';\nimport {\n  Customer,\n  Invoice,\n  InvoiceItem,\n  PaymentCurrency,\n  PaymentIntent,\n  PaymentMethod,\n  PaymentSettings,\n  Price,\n  Product,\n  Refund,\n  SetupIntent,\n  SimpleCustomField,\n  Subscription,\n  SubscriptionItem,\n  TaxRate,\n  TInvoice,\n  TLineItemExpanded,\n  UsageRecord,\n  Lock,\n  DiscountAmount,\n} from '../store/models';\nimport { getConnectQueryParam } from './util';\nimport { expandLineItems } from './session';\nimport dayjs from './dayjs';\nimport {\n  getSubscriptionCycleAmount,\n  getSubscriptionCycleSetup,\n  getSubscriptionItemPrice,\n  getSubscriptionStakeAmountSetup,\n  isSubscriptionOverdraftProtectionEnabled,\n} from './subscription';\nimport logger from './logger';\nimport { ensureOverdraftProtectionPrice } from './overdraft-protection';\nimport { CHARGE_SUPPORTED_CHAIN_TYPES } from './constants';\nimport { emitAsync } from './event';\nimport { getPriceUintAmountByCurrency } from './price';\nimport { generateQuotesForInvoiceItems } from './invoice-quote';\n\nexport function getCustomerInvoicePageUrl({\n  invoiceId,\n  userDid,\n  locale = 'en',\n  action = '',\n}: {\n  userDid: string;\n  invoiceId: string;\n  locale: LiteralUnion<'en' | 'zh', string>;\n  action?: LiteralUnion<'pay', string>;\n}) {\n  return component.getUrl(\n    withQuery(`customer/invoice/${invoiceId}`, {\n      locale,\n      action,\n      ...getConnectQueryParam({ userDid }),\n    })\n  );\n}\n\nexport async function getOneTimeProductInfo(invoiceId: string, paymentCurrency: PaymentCurrency) {\n  try {\n    const doc = await Invoice.findOne({\n      where: { id: invoiceId },\n      include: [{ model: InvoiceItem, as: 'lines' }],\n    });\n    if (!doc) {\n      throw new Error(`Invoice not found: ${invoiceId}`);\n    }\n    const json = doc.toJSON();\n    const products = (await Product.findAll()).map((x) => x.toJSON());\n    const prices = (await Price.findAll()).map((x) => x.toJSON());\n    // @ts-ignore\n    expandLineItems(json.lines, products, prices);\n    const oneTimePaymentInfo: Array<{\n      productName: string;\n      paymentInfo: string;\n      quantity: number;\n    }> = [];\n    // @ts-ignore\n    (json.lines || []).forEach((x) => {\n      const { recurring, product } = x.price;\n      if (!recurring) {\n        // it's one-time product\n        oneTimePaymentInfo.push({\n          productName: product?.name,\n          paymentInfo: `${fromUnitToToken(x.amount, paymentCurrency.decimal)} ${paymentCurrency.symbol}`,\n          quantity: x.quantity,\n        });\n      }\n    });\n    return oneTimePaymentInfo;\n  } catch (err) {\n    console.error(`Error in getOneTimeProductInfo for invoice ${invoiceId}:`, err);\n    return [];\n  }\n}\n\nexport async function getInvoiceShouldPayTotal(invoice: Invoice) {\n  try {\n    const subscription = await Subscription.findByPk(invoice.subscription_id);\n    if (!subscription) {\n      throw new Error(`Subscription not found: ${invoice.subscription_id}`);\n    }\n\n    const paymentCurrency = await PaymentCurrency.findByPk(invoice.currency_id);\n    if (!paymentCurrency) {\n      throw new Error(`Payment currency not found: ${invoice.currency_id}`);\n    }\n\n    const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n    if (!paymentMethod) {\n      throw new Error(`Payment method not found: ${paymentCurrency.payment_method_id}`);\n    }\n\n    const subscriptionItems = await SubscriptionItem.findAll({\n      where: { subscription_id: subscription.id },\n    });\n\n    let expandedItems = await Price.expand(\n      subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n      { product: true }\n    );\n\n    const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, invoice.period_start);\n    let offset = 0;\n    let filterFunc = (item: any) => item;\n    if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type)) {\n      switch (invoice.billing_reason) {\n        case 'subscription_cancel':\n          filterFunc = (item: any) => item.price?.recurring?.usage_type === 'metered';\n          break;\n        case 'subscription_cycle':\n          filterFunc = (item: any) => item.price?.type === 'recurring';\n          offset = setup.cycle / 1000;\n          break;\n        default:\n          filterFunc = () => true;\n      }\n    }\n    const previousPeriodStart = setup.period.start - offset;\n    const previousPeriodEnd = setup.period.end - offset;\n    expandedItems = await Promise.all(\n      expandedItems.filter(filterFunc).map(async (item: any) => {\n        const { price } = item;\n        if (price?.recurring?.usage_type === 'metered') {\n          const rawQuantity = await UsageRecord.getSummary({\n            id: item.id,\n            start: previousPeriodStart,\n            end: previousPeriodEnd,\n            method: price.recurring?.aggregate_usage,\n            dryRun: true,\n            searchBilled: false,\n          });\n          item.quantity = price.transformQuantity(rawQuantity);\n        }\n        return item;\n      })\n    );\n\n    const baseAmount = getSubscriptionCycleAmount(expandedItems, subscription.currency_id);\n    let shouldPayTotal = baseAmount?.total || invoice.total;\n\n    // Apply discount if exists\n    if (baseAmount?.total && invoice.total_discount_amounts && invoice.total_discount_amounts.length > 0) {\n      const totalDiscountAmount = invoice.total_discount_amounts.reduce((sum, discount) => {\n        return new BN(sum).add(new BN(discount.amount.toString())).toString();\n      }, '0');\n\n      shouldPayTotal = new BN(shouldPayTotal).sub(new BN(totalDiscountAmount)).toString();\n\n      // Ensure the final amount doesn't go below zero\n      if (new BN(shouldPayTotal).lt(new BN('0'))) {\n        shouldPayTotal = '0';\n      }\n    }\n\n    return shouldPayTotal;\n  } catch (err) {\n    console.error(`Error in getInvoiceShouldPayTotal for invoice ${invoice.id}:`, err);\n    return invoice.total;\n  }\n}\n\nexport async function getReturnStakeInvoices(subscription: Subscription) {\n  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n  const returnStakeInvoice: Invoice[] = [];\n  const refunds = await Refund.findAll({\n    where: { subscription_id: subscription.id, status: 'succeeded', type: 'stake_return' },\n    include: [\n      { model: Invoice, as: 'invoice' },\n      { model: Customer, as: 'customer' },\n      { model: PaymentCurrency, as: 'paymentCurrency' },\n    ],\n  });\n\n  await Promise.all(\n    refunds.map(async (r: any) => {\n      const invoice =\n        r.invoice ||\n        (await Invoice.findOne({\n          where: {\n            subscription_id: subscription.id,\n            currency_id: r.currency_id,\n          },\n          order: [['created_at', 'ASC']],\n        }));\n      returnStakeInvoice.push({\n        id: r.id,\n        status: 'paid',\n        billing_reason: 'return_stake',\n        description: 'Return Subscription staking',\n        total: r.amount,\n        amount_due: '0',\n        amount_paid: r.amount,\n        amount_remaining: '0',\n        subscription_id: subscription.id,\n        paid: true,\n        ...pick(invoice, ['number', 'auto_advance', 'period_start', 'period_end']),\n        ...pick(r, ['created_at', 'updated_at', 'currency_id', 'customer_id']),\n        // @ts-ignore\n        paymentCurrency: r.paymentCurrency,\n        paymentMethod: method,\n        customer: r.customer,\n        metadata: {\n          payment_details: {\n            arcblock: {\n              tx_hash: r?.payment_details?.arcblock?.tx_hash,\n              payer: r?.payment_details?.arcblock?.payer,\n            },\n          },\n        },\n      });\n    })\n  );\n  return returnStakeInvoice;\n}\n\nexport async function getSetupInvoice(\n  subscription: Subscription,\n  paymentMethod: PaymentMethod,\n  currencyId: string,\n  stakingProps: { tx_hash: string; payer: string; address: string }\n) {\n  const currency = await PaymentCurrency.findByPk(currencyId);\n  if (!currency) {\n    return null;\n  }\n  if (!stakingProps?.tx_hash) {\n    return null;\n  }\n  if (paymentMethod?.type !== 'arcblock') {\n    return null;\n  }\n  const firstInvoice = await Invoice.findOne({\n    where: { subscription_id: subscription.id, currency_id: currency.id },\n    order: [['created_at', 'ASC']],\n    include: [{ model: Customer, as: 'customer' }],\n  });\n  if (!firstInvoice) {\n    return null;\n  }\n  const stakeAmountResult = await getSubscriptionStakeAmountSetup(subscription, paymentMethod, stakingProps.tx_hash);\n  // @ts-ignore\n  const stakeAmount = stakeAmountResult?.[currency?.contract] || '0';\n  return {\n    id: stakingProps.address as string,\n    status: 'paid',\n    description: 'Subscription staking',\n    billing_reason: 'stake',\n    total: stakeAmount,\n    amount_due: '0',\n    amount_paid: stakeAmount,\n    amount_remaining: '0',\n    ...pick(firstInvoice, [\n      'number',\n      'paid',\n      'auto_advance',\n      'currency_id',\n      'customer_id',\n      'subscription_id',\n      'period_start',\n      'period_end',\n      'created_at',\n      'updated_at',\n    ]),\n    // @ts-ignore\n    paymentCurrency: currency,\n    paymentMethod,\n    // @ts-ignore\n    customer: firstInvoice?.customer,\n    metadata: {\n      payment_details: {\n        arcblock: {\n          tx_hash: stakingProps?.tx_hash,\n          payer: stakingProps?.payer,\n        },\n      },\n    },\n  };\n}\n\nexport async function getStakingInvoices(subscription: Subscription): Promise<Invoice[]> {\n  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n  if (!method) {\n    return [];\n  }\n  const stakeInvoices = await Invoice.findAll({\n    where: { subscription_id: subscription.id, billing_reason: 'stake', status: 'paid' },\n    include: [\n      { model: Customer, as: 'customer' },\n      { model: PaymentCurrency, as: 'paymentCurrency' },\n      { model: PaymentMethod, as: 'paymentMethod' },\n    ],\n  });\n  const invoices = cloneDeep(stakeInvoices);\n  const setups = await SetupIntent.findAll({\n    where: {\n      customer_id: subscription.customer_id,\n      payment_method_id: method?.id,\n      status: 'succeeded',\n      [Op.and]: [\n        { metadata: { [Op.not]: null } },\n        { 'metadata.subscription_id': subscription.id },\n        { setup_details: { [Op.not]: null } },\n        { 'setup_details.arcblock': { [Op.not]: null } },\n        { 'setup_details.arcblock.staking': { [Op.not]: null } },\n      ] as any,\n    },\n  });\n  if (setups.length === 0) {\n    // No payment change, use the first invoice\n    if (stakeInvoices.length > 0) {\n      return stakeInvoices;\n    }\n    const newInvoice = await getSetupInvoice(subscription, method, subscription.currency_id, {\n      tx_hash: subscription.payment_details?.arcblock?.staking?.tx_hash!,\n      payer: subscription.payment_details?.arcblock?.payer!,\n      address: subscription.payment_details?.arcblock?.staking?.address!,\n    });\n    // @ts-ignore\n    return [newInvoice].filter(Boolean);\n  }\n\n  await Promise.all(\n    setups.map(async (setup: SetupIntent, index: number) => {\n      if (\n        index === 0 &&\n        setup.metadata?.from_currency &&\n        !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.from_currency)\n      ) {\n        const paymentDetails =\n          setup?.metadata?.from_payment_details?.arcblock || subscription.payment_details?.arcblock;\n        const fromMethod = await PaymentMethod.findByPk(setup?.metadata?.from_payment_method_id);\n        const newInvoice = await getSetupInvoice(subscription, fromMethod!, setup.metadata?.from_currency, {\n          tx_hash: paymentDetails?.staking?.tx_hash!,\n          payer: paymentDetails?.payer!,\n          address: paymentDetails?.staking?.address!,\n        });\n        if (newInvoice) {\n          // @ts-ignore\n          invoices.push(newInvoice);\n        }\n      }\n      if (setup.metadata?.to_currency && !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.to_currency)) {\n        const newInvoice = await getSetupInvoice(subscription, method, setup.metadata?.to_currency, {\n          tx_hash: setup.setup_details?.arcblock?.staking?.tx_hash!,\n          payer: setup.setup_details?.arcblock?.payer!,\n          address: setup.setup_details?.arcblock?.staking?.address!,\n        });\n        if (newInvoice) {\n          // @ts-ignore\n          invoices.push(newInvoice);\n        }\n      }\n    })\n  );\n  return invoices;\n}\n\ntype BaseInvoiceProps = {\n  customer: Customer;\n  subscription?: Subscription | null;\n  currency_id: string;\n  livemode: boolean;\n  period_start: number;\n  period_end: number;\n  status?: string;\n  billing_reason: string;\n  description: string;\n  statement_descriptor?: string;\n  total: string;\n  subtotal?: string;\n  amount_due?: string;\n  amount_paid?: string;\n  amount_remaining?: string;\n  default_payment_method_id: string;\n  payment_intent_id?: string;\n  checkout_session_id?: string;\n  metadata?: Record<string, any>;\n  // Discount fields\n  discounts?: string[];\n  total_discount_amounts?: DiscountAmount[];\n  items?: Array<{\n    price_id: string;\n    amount: string;\n    quantity: number;\n    description: string;\n    period?: {\n      start: number;\n      end: number;\n    };\n    metadata?: Record<string, any>;\n    subscription_item_id?: string;\n    // Discount fields for InvoiceItem\n    discountable?: boolean;\n    discount_amounts?: DiscountAmount[];\n  }>;\n  auto_advance?: boolean;\n  paid?: boolean;\n  paid_out_of_band?: boolean;\n  payment_settings?: PaymentSettings;\n  footer?: string;\n  custom_fields?: SimpleCustomField[];\n  starting_token_balance?: Record<string, string>;\n  ending_token_balance?: Record<string, string>;\n  subtotal_excluding_tax?: string;\n  collection_method?: 'charge_automatically' | 'send_invoice';\n  id?: string;\n  quote_id?: string;\n};\n\nasync function createInvoiceWithItems(props: BaseInvoiceProps): Promise<{\n  invoice: Invoice;\n  items: InvoiceItem[];\n}> {\n  const {\n    customer,\n    subscription,\n    currency_id: currencyId,\n    livemode,\n    period_start: periodStart,\n    period_end: periodEnd,\n    status = 'open',\n    billing_reason: billingReason,\n    description,\n    statement_descriptor: statementDescriptor = '',\n    total,\n    amount_due: amountDue = total,\n    amount_paid: amountPaid = '0',\n    amount_remaining: amountRemaining = total,\n    default_payment_method_id: paymentMethodId,\n    payment_intent_id: paymentIntentId = '',\n    checkout_session_id: checkoutSessionId = '',\n    items: itemsData,\n    metadata = {},\n    paid = false,\n    auto_advance: autoAdvance = true,\n    paid_out_of_band: paidOutOfBand = false,\n    payment_settings: paymentSettings,\n    ...extraProps\n  } = props;\n\n  const invoiceNumber = await customer.getInvoiceNumber();\n  // create invoice\n  const invoice = await Invoice.create({\n    amount_shipping: '0',\n    starting_balance: '0',\n    ending_balance: '0',\n    subtotal_excluding_tax: '0',\n    starting_token_balance: {},\n    ending_token_balance: {},\n    attempt_count: 0,\n    attempted: false,\n    tax: '0',\n    discounts: props.discounts || [],\n    total_discount_amounts: props.total_discount_amounts || [],\n    collection_method: 'charge_automatically',\n    ...extraProps,\n    livemode,\n    number: invoiceNumber,\n    description,\n    statement_descriptor: statementDescriptor,\n    period_start: periodStart,\n    period_end: periodEnd,\n    auto_advance: autoAdvance,\n    paid,\n    paid_out_of_band: paidOutOfBand,\n    status,\n    billing_reason: billingReason,\n    currency_id: currencyId,\n    customer_id: customer.id,\n    default_payment_method_id: paymentMethodId,\n    payment_intent_id: paymentIntentId,\n    subscription_id: subscription?.id,\n    checkout_session_id: checkoutSessionId,\n    total,\n    subtotal: props.subtotal || total,\n    amount_due: amountDue,\n    amount_paid: amountPaid,\n    amount_remaining: amountRemaining,\n\n    customer_address: customer.address,\n    customer_email: customer.email,\n    customer_name: customer.name,\n    customer_phone: customer.phone,\n\n    effective_at: dayjs().unix(),\n    status_transitions: {\n      finalized_at: dayjs().unix(),\n    },\n    payment_settings: paymentSettings || subscription?.payment_settings,\n    metadata,\n  });\n\n  if (!itemsData) {\n    return { invoice, items: [] };\n  }\n\n  // Generate quotes for dynamic pricing items (subscription invoices)\n  const enrichedItemsData = subscription\n    ? await generateQuotesForInvoiceItems({\n        invoiceId: invoice.id,\n        items: itemsData,\n        currencyId,\n      })\n    : itemsData;\n\n  // create invoice items\n  const items = await Promise.all(\n    enrichedItemsData.map(async (item) => {\n      // Match tax rate for this specific item\n      let taxRateId: string | undefined;\n      if (customer.address?.country && item.price_id) {\n        try {\n          const price = await Price.findByPk(item.price_id);\n          if (price?.product_id) {\n            const product = await Product.findByPk(price.product_id);\n            if (product) {\n              const taxRate = await TaxRate.findMatchingRate({\n                country: customer.address.country,\n                state: customer.address.state,\n                postalCode: customer.address.postal_code,\n                taxCode: product.tax_code,\n                livemode,\n              });\n              taxRateId = taxRate?.id;\n            }\n          }\n        } catch (error) {\n          logger.error('Failed to match tax rate for invoice item:', error);\n        }\n      }\n\n      return InvoiceItem.create({\n        livemode,\n        amount: item.amount,\n        quantity: item.quantity,\n        description: item.description,\n        period: item.period,\n        currency_id: currencyId,\n        customer_id: customer.id,\n        price_id: item.price_id,\n        invoice_id: invoice.id,\n        subscription_id: subscription?.id,\n        subscription_item_id: item.subscription_item_id,\n        tax_rate_id: taxRateId,\n        discountable: item.discountable || false,\n        discounts: [], // Keep as empty for now - this is legacy field\n        discount_amounts:\n          item.discount_amounts?.map((d) => ({ amount: new BN(d.amount || '0').toString(), discount: d.discount })) ||\n          [],\n        proration: false,\n        proration_details: {},\n        metadata: {\n          ...(item.metadata || {}),\n          // Include quote_id in metadata if it exists (for dynamic pricing)\n          ...((item as any).quote_id && { quote_id: (item as any).quote_id }),\n        },\n      });\n    })\n  );\n\n  return { invoice, items };\n}\n\nexport async function ensureInvoiceAndItems({\n  customer,\n  currency,\n  subscription,\n  subscriptions,\n  props,\n  lineItems,\n  trialing,\n  metered,\n  applyCredit = true,\n}: {\n  customer: Customer;\n  currency: PaymentCurrency;\n  subscription?: Subscription;\n  subscriptions?: Subscription[];\n  props: TInvoice;\n  lineItems: TLineItemExpanded[];\n  trialing: boolean; // do we have trialing\n  metered: boolean; // is the quantity metered\n  applyCredit?: boolean; // should we apply customer credit?\n}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n  // apply possible balance to invoice\n  let remaining = props.total;\n  let result = { starting: {}, ending: {} };\n  if (applyCredit && props.total > '0' && !props.amount_remaining) {\n    const balance = customer.getBalanceToApply(currency.id, props.total);\n    result = await customer.decreaseTokenBalance(currency.id, balance);\n    remaining = new BN(props.total).sub(new BN(balance)).toString();\n    logger.info('Invoice will use customer credit', { result, remaining, total: props.total });\n  }\n\n  // get subscription items\n  let subscriptionItems: SubscriptionItem[] = [];\n  if (subscriptions && subscriptions.length > 0) {\n    subscriptionItems = await SubscriptionItem.findAll({\n      where: { subscription_id: { [Op.in]: subscriptions.map((s) => s.id) } },\n    });\n  } else if (subscription) {\n    subscriptionItems = await SubscriptionItem.findAll({\n      where: { subscription_id: subscription?.id },\n    });\n  }\n\n  function getLineSetup(x: TLineItemExpanded) {\n    const price = getSubscriptionItemPrice(x);\n    if (price.type === 'recurring' && trialing) {\n      return {\n        price,\n        amount: '0',\n        // @ts-ignore\n        description: trialing ? `${price.product.name} (trialing)` : price.product.name,\n        period: {\n          start: props.period_start,\n          end: props.period_end,\n        },\n      };\n    }\n\n    return {\n      price,\n      amount:\n        x.custom_amount ||\n        new BN(getPriceUintAmountByCurrency(price, props.currency_id)).mul(new BN(x.quantity)).toString(),\n      description: price.product.name,\n      period: undefined,\n    };\n  }\n  // process line items\n  const processedItems = lineItems.map((x: TLineItemExpanded) => {\n    const setup = getLineSetup(x);\n    const { price } = setup;\n    let { quantity } = x;\n    if (price.type === 'recurring') {\n      if (price.recurring?.usage_type === 'metered' && !metered) {\n        quantity = 0;\n      }\n      if (trialing) {\n        quantity = 0;\n      }\n    }\n\n    return {\n      price_id: price.id,\n      amount: quantity > 0 ? setup.amount : '0',\n      quantity,\n      description: setup.description,\n      period: setup.period,\n      metadata: x.metadata || {},\n      subscription_item_id: subscriptionItems.find((si) => si.price_id === price.id)?.id,\n      // Discount fields from pre-calculated line items\n      discountable: x.discountable || false,\n      discount_amounts: x.discount_amounts || [],\n    };\n  });\n\n  return createInvoiceWithItems({\n    customer,\n    subscription,\n    items: processedItems,\n    livemode: props.livemode,\n    status: props.status || 'open',\n    billing_reason: props.billing_reason,\n    description: props.description || '',\n    statement_descriptor: props.statement_descriptor,\n\n    currency_id: props.currency_id,\n    payment_intent_id: props.payment_intent_id,\n    checkout_session_id: props.checkout_session_id,\n    default_payment_method_id: props.default_payment_method_id,\n\n    period_start: props.period_start,\n    period_end: props.period_end,\n    auto_advance: props.auto_advance,\n\n    total: props.total,\n    subtotal: props.subtotal || props.total,\n    amount_remaining: props.amount_remaining || remaining,\n    amount_paid: props.amount_paid,\n    amount_due: props.amount_due || remaining,\n    subtotal_excluding_tax: props.subtotal || props.total || '0',\n    starting_token_balance: result.starting,\n    ending_token_balance: result.ending,\n\n    footer: props.footer,\n    custom_fields: props.custom_fields,\n    payment_settings: props.payment_settings || subscription?.payment_settings,\n    discounts: props.discounts,\n    total_discount_amounts: props.total_discount_amounts || [],\n    metadata: {\n      ...props.metadata,\n      starting_token_balance: result.starting,\n      ending_token_balance: result.ending,\n    },\n  });\n}\n\nexport async function cleanupInvoiceAndItems(invoiceId: string) {\n  const invoice = await Invoice.findByPk(invoiceId);\n  if (!invoice) {\n    return;\n  }\n  if (invoice.isImmutable()) {\n    return;\n  }\n\n  const removedItem = await InvoiceItem.destroy({ where: { invoice_id: invoiceId } });\n  const removedInvoice = await Invoice.destroy({ where: { id: invoiceId } });\n  logger.info('cleanup invoice and items', { invoiceId, removedItem, removedInvoice });\n}\n\nexport async function ensureRechargeInvoice(\n  invoiceProps: {\n    total: string;\n    description?: string;\n    checkout_session_id?: string;\n    currency_id: string;\n    metadata?: any;\n    payment_settings?: any;\n    livemode?: boolean;\n  },\n  subscription: Subscription | null,\n  paymentMethod: PaymentMethod,\n  customer: Customer\n) {\n  try {\n    const { livemode = true } = invoiceProps;\n    const { invoice } = await createInvoiceWithItems({\n      customer,\n      subscription,\n      currency_id: invoiceProps.currency_id,\n      livemode: subscription?.livemode ?? livemode,\n      period_start: dayjs().unix(),\n      period_end: dayjs().unix(),\n      status: 'paid',\n      billing_reason: 'recharge',\n      description: invoiceProps?.description || 'Add funds for subscription',\n      total: invoiceProps.total || '0',\n      amount_due: '0',\n      amount_paid: invoiceProps.total || '0',\n      amount_remaining: '0',\n      default_payment_method_id: paymentMethod.id,\n      checkout_session_id: invoiceProps?.checkout_session_id || '',\n      metadata: invoiceProps.metadata || {},\n      auto_advance: false,\n      paid: true,\n      paid_out_of_band: false,\n      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n    });\n\n    logger.info('create recharge invoice success', {\n      invoice,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n  } catch (error) {\n    logger.error('ensureRechargeInvoice: create invoice failed', {\n      error,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n    throw error;\n  }\n}\n\nexport async function ensureOverdraftProtectionInvoiceAndItems({\n  customer,\n  subscription,\n  paymentIntent,\n  props,\n}: {\n  customer: Customer;\n  subscription: Subscription;\n  paymentIntent: PaymentIntent;\n  props: Partial<TInvoice> & { period_start: number; period_end: number };\n}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n  const { price, product } = await ensureOverdraftProtectionPrice(subscription.livemode);\n  const invoicePrice = price?.currency_options?.find((x: any) => x.currency_id === paymentIntent?.currency_id);\n\n  if (!subscription.overdraft_protection?.enabled) {\n    throw new Error('Overdraft protection invoice creation skipped: overdraft protection is not enabled');\n  }\n\n  if (!invoicePrice) {\n    throw new Error('Overdraft protection invoice price not found');\n  }\n  const currency = await PaymentCurrency.findByPk(invoicePrice.currency_id);\n  if (!currency) {\n    throw new Error('Overdraft protection invoice currency not found');\n  }\n  const paymentMethod = await PaymentMethod.findByPk(currency?.payment_method_id);\n  if (!paymentMethod) {\n    throw new Error('Overdraft protection invoice payment method not found');\n  }\n\n  if (paymentMethod.type !== 'arcblock') {\n    throw new Error(`Payment method ${paymentMethod.type} not supported for overdraft protection`);\n  }\n\n  const { unused } = await isSubscriptionOverdraftProtectionEnabled(subscription, paymentIntent?.currency_id);\n  if (new BN(unused).lt(new BN(invoicePrice.unit_amount))) {\n    throw new Error('Overdraft protection invoice creation skipped: insufficient overdraft protection funds');\n  }\n\n  const result = await createInvoiceWithItems({\n    customer,\n    subscription,\n    currency_id: invoicePrice.currency_id,\n    livemode: subscription.livemode,\n    period_start: props.period_start || 0,\n    period_end: props.period_end || 0,\n    status: props.status,\n    billing_reason: 'overdraft_protection',\n    description: 'Overdraft protection',\n    collection_method: 'send_invoice',\n    default_payment_method_id: paymentMethod.id,\n    total: invoicePrice.unit_amount || '0',\n    items: [\n      {\n        price_id: price?.id || '',\n        amount: invoicePrice.unit_amount || '0',\n        quantity: 1,\n        description: product?.name || '',\n        period: {\n          start: props.period_start || 0,\n          end: props.period_end || 0,\n        },\n      },\n    ],\n    metadata: {\n      ...(props.metadata || {}),\n      payment_intent_id: paymentIntent.id,\n    },\n  });\n\n  await Price.increment({ quantity_sold: 1 }, { where: { id: price?.id } });\n  return result;\n}\n\nexport async function ensureStakeInvoice(\n  invoiceProps: {\n    total: string;\n    description?: string;\n    checkout_session_id?: string;\n    currency_id: string;\n    billing_reason?: string;\n    metadata?: any;\n    payment_settings?: any;\n  },\n  subscription: Subscription,\n  paymentMethod: PaymentMethod,\n  customer: Customer,\n  allSubscriptions?: Subscription[]\n) {\n  if (paymentMethod.type !== 'arcblock') {\n    return;\n  }\n\n  try {\n    const isMultiSubscription = allSubscriptions && allSubscriptions.length > 1;\n    const metadata = {\n      ...(invoiceProps.metadata || {}),\n    };\n\n    if (isMultiSubscription) {\n      metadata.all_subscription_ids = allSubscriptions.map((s) => s.id);\n      metadata.is_shared_stake = true;\n      metadata.primary_subscription_id = subscription.id;\n    }\n\n    const { invoice } = await createInvoiceWithItems({\n      customer,\n      subscription,\n      currency_id: invoiceProps.currency_id,\n      livemode: subscription.livemode,\n      period_start: dayjs().unix(),\n      period_end: subscription.current_period_end,\n      status: 'paid',\n      billing_reason: invoiceProps?.billing_reason || 'stake',\n      description: invoiceProps?.description || 'Stake for subscription',\n      total: invoiceProps.total || '0',\n      amount_due: '0',\n      amount_paid: invoiceProps.total || '0',\n      amount_remaining: '0',\n      default_payment_method_id: paymentMethod.id,\n      checkout_session_id: invoiceProps?.checkout_session_id || '',\n      metadata,\n      auto_advance: false,\n      paid: true,\n      paid_out_of_band: false,\n      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n    });\n\n    logger.info('create staking invoice success', {\n      invoice,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n  } catch (error) {\n    logger.error('ensureStake: create invoice failed', {\n      error,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n    throw error;\n  }\n}\n\nexport async function getStakeInvoiceForSubscription(subscriptionId: string, currencyId: string) {\n  const where: WhereOptions = {\n    [Op.or]: [\n      { subscription_id: subscriptionId },\n      { 'metadata.all_subscription_ids': { [Op.contains]: [subscriptionId] } },\n    ],\n    billing_reason: 'stake',\n    status: 'paid',\n  };\n\n  if (currencyId) {\n    where.currency_id = currencyId;\n  }\n  try {\n    const invoice = await Invoice.findOne({ where });\n    return invoice;\n  } catch (error) {\n    logger.error('getStakeInvoiceForSubscription: find invoice failed', {\n      error,\n      subscriptionId,\n      currencyId,\n    });\n    return null;\n  }\n}\n\n// mark overdraft protection invoice as void after payment\nexport async function handleOverdraftProtectionInvoiceAfterPayment(invoice: Invoice) {\n  try {\n    if (['stake', 'overdraft_protection', 'stake_overdraft_protection'].includes(invoice.billing_reason)) {\n      return;\n    }\n    const subscription = await Subscription.findByPk(invoice.subscription_id);\n    if (!subscription) {\n      logger.info('handle overdraft protection invoice skipped due to subscription not found', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n    if (!subscription.overdraft_protection?.enabled) {\n      logger.info('handle overdraft protection invoice skipped due to overdraft protection not enabled', {\n        subscriptionId: subscription.id,\n      });\n      return;\n    }\n    const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n    if (!paymentMethod || paymentMethod?.type !== 'arcblock') {\n      logger.info('handle overdraft protection invoice skipped due to payment method not supported', {\n        invoiceId: invoice.id,\n        paymentMethodId: paymentMethod?.id,\n      });\n      return;\n    }\n    const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n    if (!paymentIntent) {\n      logger.info('handle overdraft protection invoice skipped due to payment intent not found', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n    if (paymentIntent.status !== 'succeeded') {\n      logger.info('handle overdraft protection invoice skipped due to payment intent not succeeded', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n    if (paymentIntent.payment_details?.arcblock?.type !== 'transfer') {\n      logger.info('handle overdraft protection invoice skipped due to payment type not transfer', {\n        invoiceId: invoice.id,\n        paymentIntentId: paymentIntent.id,\n      });\n      return;\n    }\n    const overdraftProtectionInvoice = await Invoice.findOne({\n      where: {\n        subscription_id: subscription.id,\n        billing_reason: 'overdraft_protection',\n        'metadata.invoice_id': invoice.id,\n        status: {\n          [Op.notIn]: ['paid', 'void'],\n        },\n      },\n    });\n    if (!overdraftProtectionInvoice) {\n      logger.info('handle overdraft protection invoice skipped due to overdraft protection invoice not found', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n\n    if (overdraftProtectionInvoice.payment_intent_id) {\n      const overdraftProtectionPaymentIntent = await PaymentIntent.findOne({\n        where: {\n          id: overdraftProtectionInvoice.payment_intent_id,\n        },\n      });\n      if (overdraftProtectionPaymentIntent) {\n        await overdraftProtectionPaymentIntent.update({\n          status: 'canceled',\n          canceled_at: dayjs().unix(),\n          cancellation_reason: 'void_invoice',\n        });\n      }\n    }\n\n    await overdraftProtectionInvoice.update({\n      status: 'void',\n      status_transitions: {\n        ...(overdraftProtectionInvoice.status_transitions || {}),\n        voided_at: dayjs().unix(),\n      },\n    });\n  } catch (error) {\n    logger.error('handle overdraft protection invoice failed', {\n      error,\n      invoiceId: invoice.id,\n    });\n  }\n}\n\n/**\n * retry uncollectible invoices\n * @param options\n */\nexport async function retryUncollectibleInvoices(options: {\n  customerId?: string;\n  subscriptionId?: string;\n  invoiceId?: string;\n  invoiceIds?: string[];\n  currencyId?: string;\n}) {\n  const lockKey = `retry-uncollectible-${JSON.stringify(options)}`;\n\n  const isLocked = await Lock.isLocked(lockKey);\n  if (isLocked) {\n    logger.warn('Retry uncollectible invoices already in progress', {\n      lockKey,\n      options,\n    });\n    throw new Error('Retry already in progress');\n  }\n\n  try {\n    await Lock.acquire(lockKey, dayjs().add(5, 'minutes').unix());\n\n    const { customerId, subscriptionId, invoiceId, invoiceIds, currencyId } = options;\n\n    const where: WhereOptions = {\n      status: { [Op.in]: ['uncollectible'] },\n      payment_intent_id: { [Op.ne]: null },\n    };\n\n    if (customerId) {\n      where.customer_id = customerId;\n    }\n\n    if (subscriptionId) {\n      where.subscription_id = subscriptionId;\n    }\n\n    if (invoiceId) {\n      where.id = invoiceId;\n    }\n\n    if (invoiceIds && invoiceIds.length > 0) {\n      where.id = { [Op.in]: invoiceIds };\n    }\n\n    if (currencyId) {\n      where.currency_id = currencyId;\n    }\n\n    const overdueInvoices = (await Invoice.findAll({\n      where,\n      include: [{ model: PaymentIntent, as: 'paymentIntent' }],\n      attributes: ['id', 'payment_intent_id', 'subscription_id', 'customer_id', 'created_at', 'status', 'currency_id'],\n      order: [['created_at', 'ASC']],\n    })) as (Invoice & { paymentIntent?: PaymentIntent })[];\n\n    const startTime = Date.now();\n    logger.info('Found uncollectible invoices to retry', {\n      count: overdueInvoices.length,\n      criteria: options,\n      invoiceIds: overdueInvoices.map((inv) => inv.id),\n    });\n\n    const results = {\n      processed: overdueInvoices.length,\n      successful: [] as string[],\n      failed: [] as Array<{ id: string; reason: string }>,\n    };\n\n    const settledResults = await Promise.allSettled(\n      overdueInvoices.map(async (invoice, index) => {\n        const { paymentIntent } = invoice;\n        const delay = index * 2;\n        if (!paymentIntent) {\n          throw new Error('No payment intent found');\n        }\n\n        await paymentIntent.update({ status: 'requires_capture' });\n        await emitAsync(\n          'payment.queued',\n          paymentIntent.id,\n          { paymentIntentId: paymentIntent.id, retryOnError: true, ignoreMaxRetryCheck: true },\n          { sync: false, delay }\n        );\n\n        return invoice;\n      })\n    );\n\n    settledResults.forEach((result, index) => {\n      const invoice = overdueInvoices[index];\n      if (!invoice) {\n        return;\n      }\n      if (result.status === 'fulfilled') {\n        results.successful.push(invoice.id);\n        logger.info('Successfully queued uncollectible invoice retry', {\n          invoiceId: invoice.id,\n          customerId: invoice.customer_id,\n          paymentIntentId: invoice.payment_intent_id,\n        });\n      } else {\n        const error = result.reason;\n        const errorType = error.name || 'Unknown';\n        const errorCode = error.code || 'UNKNOWN_ERROR';\n\n        results.failed.push({\n          id: invoice.id,\n          reason: error.message || 'Unknown error',\n        });\n\n        logger.error('Failed to queue uncollectible invoice retry', {\n          invoiceId: invoice.id,\n          customerId: invoice.customer_id,\n          subscriptionId: invoice.subscription_id,\n          paymentIntentId: invoice.payment_intent_id,\n          errorType,\n          errorCode,\n          error,\n        });\n      }\n    });\n\n    const processingTime = Date.now() - startTime;\n    logger.info('Completed retrying uncollectible invoices', {\n      totalProcessed: results.processed,\n      successful: results.successful.length,\n      failed: results.failed.length,\n      processingTimeMs: processingTime,\n    });\n\n    return results;\n  } finally {\n    await Lock.release(lockKey);\n    logger.info('Released retry uncollectible lock', { lockKey });\n  }\n}\n\n/**\n * Migrate billing when a subscription's payment method changes.\n * Steps:\n * 1. Check if all subscription items are prepaid (licensed recurring).\n * 2. If so, check if there is an unpaid invoice for the current period with the old payment method.\n * 3. If such an invoice exists, void the old invoice and cancel its payment intent if present.\n * 4. Create a new invoice for the current period with the new payment method.\n * 5. If any step fails, throw an error and log details.\n *\n * @param subscription Subscription instance\n * @param oldCurrencyId Old payment currency ID\n * @param newCurrencyId New payment currency ID\n * @returns Migration result: { migrated, oldInvoice, newInvoice }\n */\nexport const migrateSubscriptionPaymentMethodInvoice = async (\n  subscription: Subscription,\n  oldCurrencyId: string,\n  newCurrencyId: string\n) => {\n  // 1. Check if all subscription items are prepaid (licensed recurring)\n  const subscriptionItems = await SubscriptionItem.findAll({\n    where: { subscription_id: subscription.id },\n    include: [{ model: Price, as: 'price' }],\n  });\n\n  const subscriptionItemsExpanded = await Price.expand(subscriptionItems.map((x) => x.toJSON()));\n  const isPrepaid = subscriptionItemsExpanded.every((item: TLineItemExpanded) => {\n    const price = getSubscriptionItemPrice(item);\n    return price.type === 'recurring' && price.recurring?.usage_type === 'licensed';\n  });\n\n  if (!isPrepaid) {\n    logger.info('Skip billing migration for non-prepaid items', {\n      subscriptionId: subscription.id,\n    });\n    return { migrated: false, reason: 'has_non_prepaid_items' };\n  }\n\n  // 2. Find unpaid invoice for the current period with the old payment method\n  const currentPeriodInvoice = await Invoice.findOne({\n    where: {\n      subscription_id: subscription.id,\n      billing_reason: 'subscription_cycle',\n      status: ['open', 'uncollectible'],\n      currency_id: oldCurrencyId,\n      period_start: {\n        [Op.gte]: subscription.current_period_start,\n        [Op.lt]: subscription.current_period_end,\n      },\n    },\n    order: [['created_at', 'DESC']],\n  });\n\n  let voidedInvoice: Invoice | null = null;\n\n  if (!currentPeriodInvoice) {\n    voidedInvoice = await Invoice.findOne({\n      where: {\n        subscription_id: subscription.id,\n        billing_reason: 'subscription_cycle',\n        status: 'void',\n        currency_id: oldCurrencyId,\n        period_start: {\n          [Op.gte]: subscription.current_period_start,\n          [Op.lt]: subscription.current_period_end,\n        },\n      },\n      order: [['created_at', 'DESC']],\n    });\n    if (!voidedInvoice) {\n      logger.info('Skip billing migration for no unpaid invoice', {\n        subscriptionId: subscription.id,\n        periodStart: subscription.current_period_start,\n        periodEnd: subscription.current_period_end,\n        oldCurrencyId,\n      });\n      return { migrated: false, reason: 'no_unpaid_invoice' };\n    }\n  }\n\n  // 3. Get old and new payment method/currency\n  const oldPaymentCurrency = await PaymentCurrency.findByPk(oldCurrencyId);\n  if (!oldPaymentCurrency) {\n    throw new Error(`Payment currency ${oldCurrencyId} not found`);\n  }\n  const oldPaymentMethod = await PaymentMethod.findByPk(oldPaymentCurrency.payment_method_id);\n  if (!oldPaymentMethod) {\n    throw new Error(`Payment method for currency ${oldCurrencyId} not found`);\n  }\n\n  const newPaymentCurrency = await PaymentCurrency.findByPk(newCurrencyId);\n  if (!newPaymentCurrency) {\n    throw new Error(`Payment currency ${newCurrencyId} not found`);\n  }\n  const newPaymentMethod = await PaymentMethod.findByPk(newPaymentCurrency.payment_method_id);\n  if (!newPaymentMethod) {\n    throw new Error(`Payment method for currency ${newCurrencyId} not found`);\n  }\n\n  // 4. Stripe payment method is not supported for migration\n  if (newPaymentMethod.type === 'stripe') {\n    logger.info('Skip billing migration for stripe payment method', {\n      subscriptionId: subscription.id,\n    });\n    return { migrated: false, reason: 'stripe_payment_method' };\n  }\n\n  try {\n    const customer = await Customer.findByPk(subscription.customer_id);\n    if (!customer) {\n      throw new Error(`Customer ${subscription.customer_id} not found`);\n    }\n\n    const cancelOldInvoice = async (invoice: Invoice) => {\n      try {\n        if (invoice.payment_intent_id) {\n          const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n          if (paymentIntent && paymentIntent.status !== 'canceled') {\n            await paymentIntent.update({\n              status: 'canceled',\n              canceled_at: dayjs().unix(),\n              cancellation_reason: 'void_invoice',\n            });\n          }\n        }\n\n        if (oldPaymentMethod.type === 'stripe' && invoice.metadata?.stripe_id) {\n          const client = oldPaymentMethod.getStripeClient();\n          await client.invoices.voidInvoice(invoice.metadata.stripe_id);\n        }\n\n        await invoice.update({\n          status: 'void',\n          status_transitions: {\n            ...(invoice.status_transitions || {}),\n            voided_at: dayjs().unix(),\n          },\n        });\n\n        logger.info('Successfully voided old invoice for payment method change', {\n          subscriptionId: subscription.id,\n          oldInvoice: invoice.id,\n          oldCurrency: oldCurrencyId,\n          newCurrency: newCurrencyId,\n        });\n      } catch (error) {\n        logger.error('Failed to void old invoice', {\n          subscription: subscription.id,\n          invoiceId: invoice.id,\n          error: error.message,\n        });\n        throw error;\n      }\n    };\n\n    const createNewInvoice = async () => {\n      const preInvoice = currentPeriodInvoice || voidedInvoice;\n      if (!preInvoice) {\n        throw new Error('No unpaid invoice found');\n      }\n      const metadata: Record<string, any> = {\n        prev_invoice_id: preInvoice.id,\n      };\n      const amount = getSubscriptionCycleAmount(subscriptionItemsExpanded, newCurrencyId);\n\n      const { invoice } = await ensureInvoiceAndItems({\n        customer,\n        currency: newPaymentCurrency,\n        subscription,\n        trialing: subscription.status === 'trialing',\n        metered: false,\n        lineItems: subscriptionItemsExpanded,\n        applyCredit: false,\n        props: {\n          status: 'open',\n          total: amount.total,\n          livemode: subscription.livemode,\n          description: 'Subscription cycle',\n          statement_descriptor: preInvoice.statement_descriptor,\n          period_start: preInvoice.period_start,\n          period_end: preInvoice.period_end,\n          auto_advance: true,\n          billing_reason: 'subscription_cycle',\n          currency_id: newCurrencyId,\n          default_payment_method_id: newPaymentMethod.id,\n          custom_fields: preInvoice.custom_fields || [],\n          footer: preInvoice.footer || '',\n          payment_settings: subscription.payment_settings,\n          metadata,\n        } as Invoice,\n      });\n      return invoice;\n    };\n\n    // 5. Cancel old invoice, then create new invoice\n    if (currentPeriodInvoice) {\n      await cancelOldInvoice(currentPeriodInvoice);\n    }\n\n    const invoice = await createNewInvoice();\n    if (invoice) {\n      await emitAsync('invoice.queued', invoice.id, { invoiceId: invoice.id, retryOnError: true }, { sync: false });\n      logger.info('Successfully queued new invoice for payment method change', {\n        subscriptionId: subscription.id,\n        invoiceId: invoice.id,\n      });\n    }\n\n    logger.info('Successfully migrated invoice for payment method change', {\n      subscriptionId: subscription.id,\n      oldInvoiceId: currentPeriodInvoice?.id || voidedInvoice?.id,\n      oldCurrency: oldCurrencyId,\n      newCurrency: newCurrencyId,\n      newInvoiceId: invoice.id,\n    });\n    return {\n      migrated: true,\n      oldInvoice: currentPeriodInvoice,\n      newInvoice: invoice,\n    };\n  } catch (error) {\n    logger.error('Failed to migrate invoice for payment method change', {\n      subscriptionId: subscription.id,\n      oldCurrencyId,\n      newCurrencyId,\n      error: error.message,\n    });\n    throw error;\n  }\n};\n\nexport async function destroyExistingInvoice(invoice: Invoice) {\n  const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n  try {\n    if (paymentMethod?.type === 'stripe' && invoice.metadata?.stripe_id) {\n      const client = paymentMethod.getStripeClient();\n      await client.invoices.del(invoice.metadata.stripe_id);\n    }\n  } catch (error) {\n    logger.error('Failed to destroy invoice on stripe', {\n      error: error.message,\n      invoiceId: invoice.id,\n    });\n  }\n  await InvoiceItem.destroy({ where: { invoice_id: invoice.id } });\n  await invoice.destroy();\n}\n","numLines":1448,"startLine":1,"totalLines":1448}}}
{"parentUuid":"fc7c8323-e4ce-448b-849b-b518c4a23e80","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DbEh9KP2tMYsYQ4fiXQY9M","type":"message","role":"assistant","content":[{"type":"text","text":"让我继续查看关键文件来理解payment流程："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":155,"cache_creation_input_tokens":21839,"cache_read_input_tokens":14745,"cache_creation":{"ephemeral_5m_input_tokens":21839,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL1s4aD6DuXRzeqXpi9","type":"assistant","uuid":"b3d3b498-fd39-4619-946e-eb59d4b57bf5","timestamp":"2026-01-06T15:03:47.852Z"}
{"parentUuid":"b3d3b498-fd39-4619-946e-eb59d4b57bf5","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DbEh9KP2tMYsYQ4fiXQY9M","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RtsGvBdmVER3NwyKj4M8h2","name":"Grep","input":{"pattern":"attachQuotesToLineItems","output_mode":"content","-B":5,"-A":10,"path":"~/Arcblock/payment-kit-master/blocklets/core/api/src"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":155,"cache_creation_input_tokens":21839,"cache_read_input_tokens":14745,"cache_creation":{"ephemeral_5m_input_tokens":21839,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL1s4aD6DuXRzeqXpi9","type":"assistant","uuid":"dfa486cb-aede-4eb8-ad4a-8ec3391aa3f1","timestamp":"2026-01-06T15:03:50.267Z"}
{"parentUuid":"dfa486cb-aede-4eb8-ad4a-8ec3391aa3f1","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DbEh9KP2tMYsYQ4fiXQY9M","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T6eyTwVTRUniCPYyLzNsfS","name":"Grep","input":{"pattern":"ensureInvoiceForCheckout","output_mode":"content","-B":5,"-A":20,"path":"~/Arcblock/payment-kit-master/blocklets/core/api/src"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":155,"cache_creation_input_tokens":21839,"cache_read_input_tokens":14745,"cache_creation":{"ephemeral_5m_input_tokens":21839,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL1s4aD6DuXRzeqXpi9","type":"assistant","uuid":"90e18aa8-ab7c-4af6-b6a5-b44c90a2d6ac","timestamp":"2026-01-06T15:03:51.429Z"}
{"parentUuid":"90e18aa8-ab7c-4af6-b6a5-b44c90a2d6ac","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01DbEh9KP2tMYsYQ4fiXQY9M","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012AYcfGidsWMYPinn7wMdSp","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":155,"cache_creation_input_tokens":21839,"cache_read_input_tokens":14745,"cache_creation":{"ephemeral_5m_input_tokens":21839,"ephemeral_1h_input_tokens":0},"output_tokens":381,"service_tier":"standard"}},"requestId":"req_011CWrL1s4aD6DuXRzeqXpi9","type":"assistant","uuid":"37c68e2a-4164-452e-8a42-6c6f384c59d6","timestamp":"2026-01-06T15:03:52.037Z"}
{"parentUuid":"37c68e2a-4164-452e-8a42-6c6f384c59d6","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RtsGvBdmVER3NwyKj4M8h2","type":"tool_result","content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1527-  const quantityBN = new BN(quantity);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1528-  const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1529-  return fromUnitToToken(totalBaseAmountBN.toString(), USD_DECIMALS);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1530-}\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1531-\napi/src/routes/checkout-sessions.ts:1532:async function attachQuotesToLineItems(options: {\napi/src/routes/checkout-sessions.ts-1533-  checkoutSession: CheckoutSession;\napi/src/routes/checkout-sessions.ts-1534-  lineItems: TLineItemExpanded[];\napi/src/routes/checkout-sessions.ts-1535-  paymentCurrencyId: string;\napi/src/routes/checkout-sessions.ts-1536-  quotesInput?: QuoteInput[];\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1537-}) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1538-  const { checkoutSession, lineItems, paymentCurrencyId, quotesInput = [] } = options;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1539-  const dynamicItems = lineItems.filter((item) => (item.upsell_price || item.price).pricing_type === 'dynamic');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1540-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1541-  if (!dynamicItems.length) {\napi/src/routes/checkout-sessions.ts-1542-    return { lineItems, consumedQuotes: [] as PriceQuote[] };\n--\napi/src/routes/checkout-sessions.ts-1813-    const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1814-    let lineItemsWithQuotes = expandedLineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1815-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1816-    try {\napi/src/routes/checkout-sessions.ts-1817-      / TODO: why we need to attach quotes to line items here?\napi/src/routes/checkout-sessions.ts:1818:      const quoteResult = await attachQuotesToLineItems({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1819-        checkoutSession,\napi/src/routes/checkout-sessions.ts-1820-        lineItems: expandedLineItems,\napi/src/routes/checkout-sessions.ts-1821-        paymentCurrencyId: paymentCurrency.id,\napi/src/routes/checkout-sessions.ts-1822-        quotesInput: req.body.quotes,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1823-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1824-      consumedQuotes = quoteResult.consumedQuotes;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1825-      lineItemsWithQuotes = quoteResult.lineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1826-    } catch (err) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1827-      if (err instanceof CustomError) {\napi/src/routes/checkout-sessions.ts-1828-        return res.status(400).json({ code: err.code || 'QUOTE_INVALID', error: err.message });\n--\napi/src/routes/checkout-sessions.ts-2469-    await checkoutSession.update({ currency_id: paymentCurrency.id });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2470-\napi/src/routes/checkout-sessions.ts-2471-    const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2472-    let lineItemsWithQuotes = expandedLineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2473-    try {\napi/src/routes/checkout-sessions.ts:2474:      const quoteResult = await attachQuotesToLineItems({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2475-        checkoutSession,\napi/src/routes/checkout-sessions.ts-2476-        lineItems: expandedLineItems,\napi/src/routes/checkout-sessions.ts-2477-        paymentCurrencyId: paymentCurrency.id,\napi/src/routes/checkout-sessions.ts-2478-        quotesInput: req.body.quotes,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2479-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2480-      consumedQuotes = quoteResult.consumedQuotes;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2481-      lineItemsWithQuotes = quoteResult.lineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2482-    } catch (err) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2483-      if (err instanceof CustomError) {\napi/src/routes/checkout-sessions.ts-2484-        return res.status(400).json({ code: err.code || 'QUOTE_INVALID', error: err.message });\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2599-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2600-\napi/src/routes/checkout-sessions.ts-2601-    const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2602-    let lineItemsWithQuotes = expandedLineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2603-    try {\napi/src/routes/checkout-sessions.ts:2604:      const quoteResult = await attachQuotesToLineItems({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2605-        checkoutSession,\napi/src/routes/checkout-sessions.ts-2606-        lineItems: expandedLineItems,\napi/src/routes/checkout-sessions.ts-2607-        paymentCurrencyId: paymentCurrency.id,\napi/src/routes/checkout-sessions.ts-2608-        quotesInput: req.body.quotes,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2609-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2610-      consumedQuotes = quoteResult.consumedQuotes;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2611-      lineItemsWithQuotes = quoteResult.lineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2612-    } catch (err) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2613-      if (err instanceof CustomError) {\napi/src/routes/checkout-sessions.ts-2614-        return res.status(400).json({ code: err.code || 'QUOTE_INVALID', error: err.message });"}]},"uuid":"18b37c8b-67db-4e96-8174-2b46e8ce7f4f","timestamp":"2026-01-06T15:03:52.102Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1527-  const quantityBN = new BN(quantity);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1528-  const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1529-  return fromUnitToToken(totalBaseAmountBN.toString(), USD_DECIMALS);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1530-}\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1531-\napi/src/routes/checkout-sessions.ts:1532:async function attachQuotesToLineItems(options: {\napi/src/routes/checkout-sessions.ts-1533-  checkoutSession: CheckoutSession;\napi/src/routes/checkout-sessions.ts-1534-  lineItems: TLineItemExpanded[];\napi/src/routes/checkout-sessions.ts-1535-  paymentCurrencyId: string;\napi/src/routes/checkout-sessions.ts-1536-  quotesInput?: QuoteInput[];\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1537-}) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1538-  const { checkoutSession, lineItems, paymentCurrencyId, quotesInput = [] } = options;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1539-  const dynamicItems = lineItems.filter((item) => (item.upsell_price || item.price).pricing_type === 'dynamic');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1540-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1541-  if (!dynamicItems.length) {\napi/src/routes/checkout-sessions.ts-1542-    return { lineItems, consumedQuotes: [] as PriceQuote[] };\n--\napi/src/routes/checkout-sessions.ts-1813-    const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1814-    let lineItemsWithQuotes = expandedLineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1815-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1816-    try {\napi/src/routes/checkout-sessions.ts-1817-      / TODO: why we need to attach quotes to line items here?\napi/src/routes/checkout-sessions.ts:1818:      const quoteResult = await attachQuotesToLineItems({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1819-        checkoutSession,\napi/src/routes/checkout-sessions.ts-1820-        lineItems: expandedLineItems,\napi/src/routes/checkout-sessions.ts-1821-        paymentCurrencyId: paymentCurrency.id,\napi/src/routes/checkout-sessions.ts-1822-        quotesInput: req.body.quotes,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1823-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1824-      consumedQuotes = quoteResult.consumedQuotes;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1825-      lineItemsWithQuotes = quoteResult.lineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1826-    } catch (err) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1827-      if (err instanceof CustomError) {\napi/src/routes/checkout-sessions.ts-1828-        return res.status(400).json({ code: err.code || 'QUOTE_INVALID', error: err.message });\n--\napi/src/routes/checkout-sessions.ts-2469-    await checkoutSession.update({ currency_id: paymentCurrency.id });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2470-\napi/src/routes/checkout-sessions.ts-2471-    const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2472-    let lineItemsWithQuotes = expandedLineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2473-    try {\napi/src/routes/checkout-sessions.ts:2474:      const quoteResult = await attachQuotesToLineItems({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2475-        checkoutSession,\napi/src/routes/checkout-sessions.ts-2476-        lineItems: expandedLineItems,\napi/src/routes/checkout-sessions.ts-2477-        paymentCurrencyId: paymentCurrency.id,\napi/src/routes/checkout-sessions.ts-2478-        quotesInput: req.body.quotes,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2479-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2480-      consumedQuotes = quoteResult.consumedQuotes;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2481-      lineItemsWithQuotes = quoteResult.lineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2482-    } catch (err) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2483-      if (err instanceof CustomError) {\napi/src/routes/checkout-sessions.ts-2484-        return res.status(400).json({ code: err.code || 'QUOTE_INVALID', error: err.message });\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2599-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2600-\napi/src/routes/checkout-sessions.ts-2601-    const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2602-    let lineItemsWithQuotes = expandedLineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2603-    try {\napi/src/routes/checkout-sessions.ts:2604:      const quoteResult = await attachQuotesToLineItems({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2605-        checkoutSession,\napi/src/routes/checkout-sessions.ts-2606-        lineItems: expandedLineItems,\napi/src/routes/checkout-sessions.ts-2607-        paymentCurrencyId: paymentCurrency.id,\napi/src/routes/checkout-sessions.ts-2608-        quotesInput: req.body.quotes,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2609-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2610-      consumedQuotes = quoteResult.consumedQuotes;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2611-      lineItemsWithQuotes = quoteResult.lineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2612-    } catch (err) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2613-      if (err instanceof CustomError) {\napi/src/routes/checkout-sessions.ts-2614-        return res.status(400).json({ code: err.code || 'QUOTE_INVALID', error: err.message });","numLines":67}}
{"parentUuid":"18b37c8b-67db-4e96-8174-2b46e8ce7f4f","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T6eyTwVTRUniCPYyLzNsfS","type":"tool_result","content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-1-/* eslint-disable no-await-in-loop */\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-2-import { Op } from 'sequelize';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-3-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-4-import { mintNftForCheckoutSession } from '../integrations/arcblock/nft';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-5-import { ensurePassportIssued } from '../integrations/blocklet/passport';\napi/src/queues/checkout-session.ts:6:import { ensureInvoiceForCheckout } from '../routes/connect/shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-7-import dayjs from '../libs/dayjs';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-8-import { events } from '../libs/event';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-9-import logger from '../libs/logger';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-10-import createQueue from '../libs/queue';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-11-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-12-  CheckoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-13-  Customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-14-  Invoice,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-15-  InvoiceItem,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-16-  PaymentIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-17-  PaymentMethod,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-18-  Price,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-19-  SetupIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-20-  Subscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-21-  SubscriptionItem,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-22-} from '../store/models';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-23-import { getCheckoutSessionSubscriptionIds } from '../libs/session';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-24-import { rollbackDiscountUsageForCheckoutSession } from '../libs/discount/discount';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-25-import { destroyExistingInvoice } from '../libs/invoice';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-26-\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-301-    const customer = await Customer.findByPk(checkoutSession.customer_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-302-    if (!customer) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-303-      return;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-304-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-305-\napi/src/queues/checkout-session.ts:306:    await ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-307-      checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-308-      paymentIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-309-      customer,\napi/src/queues/checkout-session.ts-310-      props: {\napi/src/queues/checkout-session.ts-311-        status: 'paid',\napi/src/queues/checkout-session.ts-312-        amount_due: '0',\napi/src/queues/checkout-session.ts-313-        amount_paid: checkoutSession.amount_total,\napi/src/queues/checkout-session.ts-314-        amount_remaining: '0',\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-315-      },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-316-    });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-317-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-318-);\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-88-  ensureStripeSubscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-89-} from '../integrations/stripe/resource';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-90-import { handleStripePaymentSucceed } from '../integrations/stripe/handlers/payment-intent';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-91-import { paymentQueue } from '../queues/payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-92-import { invoiceQueue } from '../queues/invoice';\napi/src/routes/checkout-sessions.ts:93:import { ensureInvoiceForCheckout, ensureInvoicesForSubscriptions } from './connect/shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-94-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-95-  isCreditGrantSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-96-  isCreditSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-97-  isDelegationSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-98-  SufficientForPaymentResult,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-99-} from '../libs/payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-100-import { handleStripeSubscriptionSucceed } from '../integrations/stripe/handlers/subscription';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-101-import { CHARGE_SUPPORTED_CHAIN_TYPES } from '../libs/constants';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-102-import { blocklet } from '../libs/auth';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-103-import { addSubscriptionJob } from '../queues/subscription';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-104-import { updateDataConcurrency } from '../libs/env';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-105-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-106-  expandLineItemsWithCouponInfo,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-107-  expandDiscountsWithDetails,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-108-  checkPromotionCodeEligibility,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-109-  createDiscountRecordsForCheckout,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-110-  updateSubscriptionDiscountReferences,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-111-} from '../libs/discount/coupon';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-112-import { rollbackDiscountUsageForCheckoutSession, applyDiscountsToLineItems } from '../libs/discount/discount';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-113-import { formatToShortUrl } from '../libs/url';\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2755-        logger.info(`CheckoutSession ${checkoutSession.id} will pay from delegation ${paymentIntent?.id}`);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2756-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2757-      if (balance.sufficient || delegation.sufficient) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2758-        fastPaid = true;\napi/src/routes/checkout-sessions.ts-2759-        await paymentIntent.update({ status: 'requires_capture' });\napi/src/routes/checkout-sessions.ts:2760:        const { invoice } = await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2761-        if (invoice) {\napi/src/routes/checkout-sessions.ts-2762-          await invoice.update({ auto_advance: true, payment_settings: paymentSettings });\napi/src/routes/checkout-sessions.ts-2763-          invoiceQueue.push({ id: invoice.id, job: { invoiceId: invoice.id, retryOnError: false } });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2764-        } else {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2765-          paymentQueue.push({\napi/src/routes/checkout-sessions.ts-2766-            id: paymentIntent.id,\napi/src/routes/checkout-sessions.ts-2767-            job: { paymentIntentId: paymentIntent.id, paymentSettings, retryOnError: false },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2768-          });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2769-        }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2770-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2771-    } else if (\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2772-      paymentMethod.type === 'arcblock' &&\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2773-      checkoutSession.mode === 'subscription' &&\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2774-      checkoutSession.subscription_data?.no_stake\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2775-    ) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2776-      const subscriptionIds = getCheckoutSessionSubscriptionIds(checkoutSession);\napi/src/routes/checkout-sessions.ts-2777-      const subscriptions = await Subscription.findAll({ where: { id: subscriptionIds } });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2778-      // if we can complete purchase without any wallet interaction\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2779-      const result = await processSubscriptionFastCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2780-        checkoutSession,\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-8-import logger from '../../libs/logger';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-9-import { getGasPayerExtra } from '../../libs/payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-10-import { createPaymentOutput } from '../../libs/session';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-11-import { getTxMetadata } from '../../libs/util';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-12-import { handlePaymentSucceed } from '../../queues/payment';\napi/src/routes/connect/pay.ts:13:import { ensureInvoiceForCheckout, ensurePaymentIntent, getAuthPrincipalClaim } from './shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-14-import { EVMChainType } from '../../store/models';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-15-import { EVM_CHAIN_TYPES } from '../../libs/constants';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-16-import { validateQuoteForPayment, handleExpiredQuotePayment } from '../../libs/quote-validation';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-17-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-18-export default {\napi/src/routes/connect/pay.ts-19-  action: 'payment',\napi/src/routes/connect/pay.ts-20-  authPrincipal: false,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-21-\napi/src/routes/connect/pay.ts-22-  claims: {\napi/src/routes/connect/pay.ts-23-    authPrincipal: async ({ extraParams }: CallbackArgs) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-24-      const { paymentMethod } = await ensurePaymentIntent(extraParams.checkoutSessionId, '', true);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-25-      return getAuthPrincipalClaim(paymentMethod, 'pay');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-26-    },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-27-  },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-28-\napi/src/routes/connect/pay.ts-29-  onConnect: async (args: CallbackArgs) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-30-    const { userDid, userPk, extraParams } = args;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-31-    const { checkoutSessionId, connectedDid, sessionUserDid } = extraParams;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-32-    const { paymentIntent, paymentCurrency, paymentMethod } = await ensurePaymentIntent(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-33-      checkoutSessionId,\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-95-    );\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-96-    if (!paymentIntent) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-97-      throw new Error('Payment intent not found');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-98-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-99-\napi/src/routes/connect/pay.ts:100:    await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-101-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-102-    if (paymentMethod.type === 'arcblock') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-103-      try {\napi/src/routes/connect/pay.ts-104-        await paymentIntent.update({ status: 'processing' });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-105-        const client = paymentMethod.getOcapClient();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-106-        const claim = claims.find((x) => x.type === 'prepareTx');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-107-\napi/src/routes/connect/pay.ts-108-        const tx: Partial<Transaction> = client.decodeTx(claim.finalTx);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-109-        if (claim.delegator && claim.from) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-110-          tx.delegator = claim.delegator;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-111-          tx.from = claim.from;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-112-        }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-113-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-114-        // @ts-ignore\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-115-        const { buffer } = await client.encodeTransferV3Tx({ tx });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-116-        const txHash = await client.sendTransferV3Tx(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-117-          // @ts-ignore\napi/src/routes/connect/pay.ts-118-          { tx, wallet: fromAddress(userDid) },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-119-          await getGasPayerExtra(buffer, client.pickGasPayerHeaders(request))\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-120-        );\n--\napi/src/routes/connect/shared.ts-382-  props?: Partial<TInvoice>;\napi/src/routes/connect/shared.ts-383-  subscriptions?: Subscription[];\napi/src/routes/connect/shared.ts-384-  lineItems?: TLineItemExpanded[];\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-385-};\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-386-\napi/src/routes/connect/shared.ts:387:export async function ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-388-  checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-389-  customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-390-  paymentIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-391-  subscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-392-  props,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-393\n\n... [42 lines truncated] ..."}]},"uuid":"70e9d58f-b3de-4e91-b05e-d89c0a1f1125","timestamp":"2026-01-06T15:03:52.104Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-1-/* eslint-disable no-await-in-loop */\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-2-import { Op } from 'sequelize';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-3-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-4-import { mintNftForCheckoutSession } from '../integrations/arcblock/nft';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-5-import { ensurePassportIssued } from '../integrations/blocklet/passport';\napi/src/queues/checkout-session.ts:6:import { ensureInvoiceForCheckout } from '../routes/connect/shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-7-import dayjs from '../libs/dayjs';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-8-import { events } from '../libs/event';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-9-import logger from '../libs/logger';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-10-import createQueue from '../libs/queue';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-11-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-12-  CheckoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-13-  Customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-14-  Invoice,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-15-  InvoiceItem,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-16-  PaymentIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-17-  PaymentMethod,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-18-  Price,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-19-  SetupIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-20-  Subscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-21-  SubscriptionItem,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-22-} from '../store/models';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-23-import { getCheckoutSessionSubscriptionIds } from '../libs/session';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-24-import { rollbackDiscountUsageForCheckoutSession } from '../libs/discount/discount';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-25-import { destroyExistingInvoice } from '../libs/invoice';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-26-\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-301-    const customer = await Customer.findByPk(checkoutSession.customer_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-302-    if (!customer) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-303-      return;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-304-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-305-\napi/src/queues/checkout-session.ts:306:    await ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-307-      checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-308-      paymentIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-309-      customer,\napi/src/queues/checkout-session.ts-310-      props: {\napi/src/queues/checkout-session.ts-311-        status: 'paid',\napi/src/queues/checkout-session.ts-312-        amount_due: '0',\napi/src/queues/checkout-session.ts-313-        amount_paid: checkoutSession.amount_total,\napi/src/queues/checkout-session.ts-314-        amount_remaining: '0',\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-315-      },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-316-    });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-317-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-318-);\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-88-  ensureStripeSubscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-89-} from '../integrations/stripe/resource';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-90-import { handleStripePaymentSucceed } from '../integrations/stripe/handlers/payment-intent';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-91-import { paymentQueue } from '../queues/payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-92-import { invoiceQueue } from '../queues/invoice';\napi/src/routes/checkout-sessions.ts:93:import { ensureInvoiceForCheckout, ensureInvoicesForSubscriptions } from './connect/shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-94-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-95-  isCreditGrantSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-96-  isCreditSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-97-  isDelegationSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-98-  SufficientForPaymentResult,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-99-} from '../libs/payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-100-import { handleStripeSubscriptionSucceed } from '../integrations/stripe/handlers/subscription';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-101-import { CHARGE_SUPPORTED_CHAIN_TYPES } from '../libs/constants';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-102-import { blocklet } from '../libs/auth';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-103-import { addSubscriptionJob } from '../queues/subscription';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-104-import { updateDataConcurrency } from '../libs/env';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-105-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-106-  expandLineItemsWithCouponInfo,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-107-  expandDiscountsWithDetails,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-108-  checkPromotionCodeEligibility,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-109-  createDiscountRecordsForCheckout,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-110-  updateSubscriptionDiscountReferences,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-111-} from '../libs/discount/coupon';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-112-import { rollbackDiscountUsageForCheckoutSession, applyDiscountsToLineItems } from '../libs/discount/discount';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-113-import { formatToShortUrl } from '../libs/url';\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2755-        logger.info(`CheckoutSession ${checkoutSession.id} will pay from delegation ${paymentIntent?.id}`);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2756-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2757-      if (balance.sufficient || delegation.sufficient) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2758-        fastPaid = true;\napi/src/routes/checkout-sessions.ts-2759-        await paymentIntent.update({ status: 'requires_capture' });\napi/src/routes/checkout-sessions.ts:2760:        const { invoice } = await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2761-        if (invoice) {\napi/src/routes/checkout-sessions.ts-2762-          await invoice.update({ auto_advance: true, payment_settings: paymentSettings });\napi/src/routes/checkout-sessions.ts-2763-          invoiceQueue.push({ id: invoice.id, job: { invoiceId: invoice.id, retryOnError: false } });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2764-        } else {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2765-          paymentQueue.push({\napi/src/routes/checkout-sessions.ts-2766-            id: paymentIntent.id,\napi/src/routes/checkout-sessions.ts-2767-            job: { paymentIntentId: paymentIntent.id, paymentSettings, retryOnError: false },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2768-          });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2769-        }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2770-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2771-    } else if (\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2772-      paymentMethod.type === 'arcblock' &&\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2773-      checkoutSession.mode === 'subscription' &&\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2774-      checkoutSession.subscription_data?.no_stake\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2775-    ) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2776-      const subscriptionIds = getCheckoutSessionSubscriptionIds(checkoutSession);\napi/src/routes/checkout-sessions.ts-2777-      const subscriptions = await Subscription.findAll({ where: { id: subscriptionIds } });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2778-      // if we can complete purchase without any wallet interaction\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2779-      const result = await processSubscriptionFastCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2780-        checkoutSession,\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-8-import logger from '../../libs/logger';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-9-import { getGasPayerExtra } from '../../libs/payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-10-import { createPaymentOutput } from '../../libs/session';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-11-import { getTxMetadata } from '../../libs/util';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-12-import { handlePaymentSucceed } from '../../queues/payment';\napi/src/routes/connect/pay.ts:13:import { ensureInvoiceForCheckout, ensurePaymentIntent, getAuthPrincipalClaim } from './shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-14-import { EVMChainType } from '../../store/models';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-15-import { EVM_CHAIN_TYPES } from '../../libs/constants';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-16-import { validateQuoteForPayment, handleExpiredQuotePayment } from '../../libs/quote-validation';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-17-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-18-export default {\napi/src/routes/connect/pay.ts-19-  action: 'payment',\napi/src/routes/connect/pay.ts-20-  authPrincipal: false,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-21-\napi/src/routes/connect/pay.ts-22-  claims: {\napi/src/routes/connect/pay.ts-23-    authPrincipal: async ({ extraParams }: CallbackArgs) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-24-      const { paymentMethod } = await ensurePaymentIntent(extraParams.checkoutSessionId, '', true);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-25-      return getAuthPrincipalClaim(paymentMethod, 'pay');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-26-    },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-27-  },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-28-\napi/src/routes/connect/pay.ts-29-  onConnect: async (args: CallbackArgs) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-30-    const { userDid, userPk, extraParams } = args;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-31-    const { checkoutSessionId, connectedDid, sessionUserDid } = extraParams;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-32-    const { paymentIntent, paymentCurrency, paymentMethod } = await ensurePaymentIntent(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-33-      checkoutSessionId,\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-95-    );\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-96-    if (!paymentIntent) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-97-      throw new Error('Payment intent not found');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-98-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-99-\napi/src/routes/connect/pay.ts:100:    await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-101-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-102-    if (paymentMethod.type === 'arcblock') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-103-      try {\napi/src/routes/connect/pay.ts-104-        await paymentIntent.update({ status: 'processing' });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-105-        const client = paymentMethod.getOcapClient();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-106-        const claim = claims.find((x) => x.type === 'prepareTx');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-107-\napi/src/routes/connect/pay.ts-108-        const tx: Partial<Transaction> = client.decodeTx(claim.finalTx);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-109-        if (claim.delegator && claim.from) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-110-          tx.delegator = claim.delegator;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-111-          tx.from = claim.from;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-112-        }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-113-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-114-        // @ts-ignore\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-115-        const { buffer } = await client.encodeTransferV3Tx({ tx });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-116-        const txHash = await client.sendTransferV3Tx(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-117-          // @ts-ignore\napi/src/routes/connect/pay.ts-118-          { tx, wallet: fromAddress(userDid) },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-119-          await getGasPayerExtra(buffer, client.pickGasPayerHeaders(request))\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-120-        );\n--\napi/src/routes/connect/shared.ts-382-  props?: Partial<TInvoice>;\napi/src/routes/connect/shared.ts-383-  subscriptions?: Subscription[];\napi/src/routes/connect/shared.ts-384-  lineItems?: TLineItemExpanded[];\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-385-};\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-386-\napi/src/routes/connect/shared.ts:387:export async function ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-388-  checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-389-  customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-390-  paymentIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-391-  subscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-392-  props,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-393-  subscriptions,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-394-  lineItems,\napi/src/routes/connect/shared.ts-395-}: Args): Promise<{ invoice: Invoice | null; items: InvoiceItem[] }> {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-396-  const isGroupInvoice = subscriptions && subscriptions.length > 1;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-397-  // invoices are optional when checkout session is in payment mode\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-398-  if (checkoutSession.mode === 'payment' && !checkoutSession.invoice_creation?.enabled) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-399-    logger.warn('Invoice creation disabled for payment mode');\napi/src/routes/connect/shared.ts-400-    return { invoice: null, items: [] };\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-401-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-402-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-403-  const existingInvoice = checkoutSession.invoice_id || (isGroupInvoice && subscription?.latest_invoice_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-404-  // Do not create invoice if it's already created\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-405-  if (existingInvoice) {\napi/src/routes/connect/shared.ts-406-    logger.info(`Invoice already created for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-407-    const invoice = await Invoice.findByPk(existingInvoice);\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-619-  const primarySubscription = (subscriptions.find((x) => x.metadata.is_primary_subscription) ||\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-620-    subscriptions[0]) as Subscription;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-621-  const invoices = await Promise.all(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-622-    subscriptions.map(async (subscription) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-623-      const subItems = await getSubscriptionLineItems(subscription, lineItems, primarySubscription);\napi/src/routes/connect/shared.ts:624:      const { invoice } = await ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-625-        checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-626-        customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-627-        subscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-628-        subscriptions,\napi/src/routes/connect/shared.ts-629-        lineItems: subItems,\napi/src/routes/connect/shared.ts-630-        props: invoiceProps,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-631-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-632-      return invoice;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-633-    })\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-634-  );\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-635-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-636-  const createdInvoices = invoices.filter(Boolean);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-637-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-638-  logger.info(`Created ${createdInvoices.length} invoices for subscriptions`, {\napi/src/routes/connect/shared.ts-639-    checkoutSessionId: checkoutSession.id,\napi/src/routes/connect/shared.ts-640-    invoiceIds: createdInvoices.map((inv) => inv?.id),\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-641-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-642-\napi/src/routes/connect/shared.ts-643-  return { invoices: createdInvoices as Invoice[] };\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-644-}","numLines":207}}
{"parentUuid":"70e9d58f-b3de-4e91-b05e-d89c0a1f1125","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012AYcfGidsWMYPinn7wMdSp","type":"tool_result","content":"     1→import { env } from '@blocklet/sdk/lib/config';\n     2→import type { TransactionInput } from '@ocap/client';\n     3→import { BN, fromTokenToUnit } from '@ocap/util';\n     4→import cloneDeep from 'lodash/cloneDeep';\n     5→import isEqual from 'lodash/isEqual';\n     6→import pAll from 'p-all';\n     7→import { omit } from 'lodash';\n     8→import dayjs from './dayjs';\n     9→import { validCoupon } from './discount/coupon';\n    10→import { getPriceUintAmountByCurrency, getPriceCurrencyOptions } from './price';\n    11→\n    12→import {\n    13→  Coupon,\n    14→  Customer,\n    15→  Invoice,\n    16→  PaymentCurrency,\n    17→  PaymentMethod,\n    18→  SetupIntent,\n    19→  Subscription,\n    20→  SubscriptionItem,\n    21→  TPriceExpanded,\n    22→  type CheckoutSession,\n    23→  type TLineItemExpanded,\n    24→  type TPaymentCurrency,\n    25→  type TPaymentMethodExpanded,\n    26→} from '../store/models';\n    27→import { Price, Price as TPrice } from '../store/models/price';\n    28→import type { Product } from '../store/models/product';\n    29→import type {\n    30→  ChainType,\n    31→  PaymentBeneficiary,\n    32→  PriceRecurring,\n    33→  SubscriptionBillingThresholds,\n    34→} from '../store/models/types';\n    35→import { wallet } from './auth';\n    36→import logger from './logger';\n    37→import { applyDiscountsToLineItems } from './discount/discount';\n    38→import { getQuoteService, QuoteResponse } from './quote-service';\n    39→import { getExchangeRateService } from './exchange-rate';\n    40→import { getExchangeRateSymbol } from './exchange-rate/token-address-mapping';\n    41→\n    42→export function getStatementDescriptor(items: any[]) {\n    43→  for (const item of items) {\n    44→    if (item.price?.product?.statement_descriptor) {\n    45→      return item.price?.product?.statement_descriptor;\n    46→    }\n    47→  }\n    48→\n    49→  return env.appName;\n    50→}\n    51→\n    52→export function getCheckoutMode(items: TLineItemExpanded[] = []) {\n    53→  if (items.length === 0) {\n    54→    return 'setup';\n    55→  }\n    56→\n    57→  // all metered\n    58→  if (items.every((x) => x.price.type === 'recurring' && x.price.recurring?.usage_type === 'metered')) {\n    59→    return 'setup';\n    60→  }\n    61→\n    62→  if (items.some((x) => x.price.type === 'recurring')) {\n    63→    return 'subscription';\n    64→  }\n    65→\n    66→  return 'payment';\n    67→}\n    68→\n    69→// Calculate checkout amount with optional discount processing\n    70→export async function getCheckoutAmount(\n    71→  items: TLineItemExpanded[],\n    72→  currencyId: string,\n    73→  trialing = false,\n    74→  discountConfig?: {\n    75→    promotionCodeId?: string;\n    76→    couponId?: string;\n    77→    customerId?: string;\n    78→  }\n    79→) {\n    80→  let processedItems = items;\n    81→  let renew = new BN(0);\n    82→\n    83→  if (items.find((x) => (x.upsell_price || x.price).custom_unit_amount) && items.length > 1) {\n    84→    throw new Error('Multiple items with custom unit amount are not supported');\n    85→  }\n    86→\n    87→  // Apply discounts if discount configuration is provided\n    88→  if (discountConfig?.couponId && discountConfig?.customerId) {\n    89→    try {\n    90→      const currency = await PaymentCurrency.findByPk(currencyId);\n    91→      if (currency) {\n    92→        const discountResult = await applyDiscountsToLineItems({\n    93→          lineItems: items,\n    94→          promotionCodeId: discountConfig.promotionCodeId,\n    95→          couponId: discountConfig.couponId,\n    96→          customerId: discountConfig.customerId,\n    97→          currency,\n    98→          billingContext: {\n    99→            trialing,\n   100→          },\n   101→        });\n   102→\n   103→        if (discountResult.discountSummary.appliedCoupon) {\n   104→          processedItems = discountResult.enhancedLineItems;\n   105→        }\n   106→      }\n   107→    } catch (error) {\n   108→      // If discount processing fails, continue with original items\n   109→      console.warn('Failed to apply discounts in getCheckoutAmount:', error.message);\n   110→    }\n   111→  }\n   112→\n   113→  const subtotal = processedItems\n   114→    .reduce((acc, x) => {\n   115→      if (x.custom_amount) {\n   116→        return acc.add(new BN(x.custom_amount));\n   117→      }\n   118→\n   119→      const price = x.upsell_price || x.price;\n   120→      const unitPrice = getPriceUintAmountByCurrency(price, currencyId);\n   121→      if (price.custom_unit_amount) {\n   122→        if (unitPrice) {\n   123→          return acc.add(new BN(unitPrice).mul(new BN(x.quantity)));\n   124→        }\n   125→      }\n   126→\n   127→      if (price?.type === 'recurring') {\n   128→        renew = renew.add(new BN(unitPrice).mul(new BN(x.quantity)));\n   129→\n   130→        if (trialing) {\n   131→          return acc;\n   132→        }\n   133→        if (price?.recurring?.usage_type === 'metered') {\n   134→          return acc;\n   135→        }\n   136→      }\n   137→\n   138→      return acc.add(new BN(unitPrice).mul(new BN(x.quantity)));\n   139→    }, new BN(0))\n   140→    .toString();\n   141→\n   142→  // Calculate total discount amount from processed line items\n   143→  let totalDiscountAmount = new BN(0);\n   144→  processedItems.forEach((item) => {\n   145→    if ((item as any).discount_amounts?.length > 0) {\n   146→      (item as any).discount_amounts.forEach((discountAmount: any) => {\n   147→        totalDiscountAmount = totalDiscountAmount.add(new BN(discountAmount.amount || '0'));\n   148→      });\n   149→    }\n   150→  });\n   151→\n   152→  // Ensure discount doesn't exceed subtotal\n   153→  const adjustedDiscount = totalDiscountAmount.gt(new BN(subtotal)) ? new BN(subtotal) : totalDiscountAmount;\n   154→\n   155→  const finalTotal = new BN(subtotal).sub(adjustedDiscount);\n   156→  const adjustedTotal = finalTotal.lt(new BN('0')) ? '0' : finalTotal.toString();\n   157→\n   158→  return {\n   159→    subtotal: subtotal || '0',\n   160→    total: adjustedTotal,\n   161→    renew: renew.toString() || '0',\n   162→    discount: adjustedDiscount.toString(),\n   163→    shipping: '0',\n   164→    tax: '0',\n   165→    processedItems, // Return processed items with discount information\n   166→  };\n   167→}\n   168→\n   169→export function getRecurringPeriod(recurring: PriceRecurring) {\n   170→  const { interval } = recurring || {};\n   171→  if (!interval) {\n   172→    return 0;\n   173→  }\n   174→  const count = +recurring.interval_count || 1;\n   175→  const dayInMs = 24 * 60 * 60 * 1000;\n   176→\n   177→  switch (interval) {\n   178→    case 'hour':\n   179→      return 60 * 60 * 1000;\n   180→    case 'day':\n   181→      return count * dayInMs;\n   182→    case 'week':\n   183→      return count * 7 * dayInMs;\n   184→    case 'month':\n   185→      return count * 30 * dayInMs;\n   186→    case 'year':\n   187→      return count * 365 * dayInMs;\n   188→    default:\n   189→      return 0;\n   190→  }\n   191→}\n   192→\n   193→export function expandLineItems(\n   194→  items: any[],\n   195→  products: Product[],\n   196→  prices: Price[],\n   197→  creditCurrencies?: TPaymentCurrency[]\n   198→) {\n   199→  items.forEach((item) => {\n   200→    item.price = prices.find((x) => x.id === item.price_id);\n   201→    if (item.price) {\n   202→      item.price.product = products.find((x) => x.id === item.price.product_id);\n   203→      if (item.price.product?.type === 'credit' && item.price.metadata?.credit_config) {\n   204→        item.price.credit = {\n   205→          amount: Number(item.price.metadata.credit_config.credit_amount || 0) * Number(item.quantity),\n   206→          currency_id: item.price.metadata.credit_config.currency_id,\n   207→          currency: creditCurrencies?.find((x) => x.id === item.price.metadata.credit_config.currency_id),\n   208→        };\n   209→      }\n   210→    }\n   211→  });\n   212→\n   213→  return items;\n   214→}\n   215→\n   216→export function filterCurrencies(method: TPaymentMethodExpanded, hasSelected: (currency: TPaymentCurrency) => boolean) {\n   217→  method.payment_currencies = method.payment_currencies.filter((x) => hasSelected(x));\n   218→  return method;\n   219→}\n   220→\n   221→export function getSupportedPaymentMethods(\n   222→  methods: TPaymentMethodExpanded[],\n   223→  hasSelected: (currency: TPaymentCurrency) => boolean\n   224→) {\n   225→  const filtered = cloneDeep(methods).map((x) => filterCurrencies(x, hasSelected));\n   226→  return filtered.filter((x) => x.payment_currencies.length);\n   227→}\n   228→\n   229→export function getSupportedPaymentCurrencies(items: TLineItemExpanded[]) {\n   230→  const currencies = items.reduce((acc: string[], x: any) => {\n   231→    return acc.concat(getPriceCurrencyOptions(x.price).map((c: any) => c.currency_id));\n   232→  }, []);\n   233→  return Array.from(new Set(currencies));\n   234→}\n   235→\n   236→export function isLineItemCurrencyAligned(list: TLineItemExpanded[], index: number) {\n   237→  const prices = list.map((x) => x.upsell_price || x.price);\n   238→\n   239→  const current = getPriceCurrencyOptions(prices[index] as any)\n   240→    .map((x) => x.currency_id)\n   241→    .sort();\n   242→\n   243→  for (let i = 0; i < index; i++) {\n   244→    const previous = getPriceCurrencyOptions(prices[i] as any)\n   245→      .map((x) => x.currency_id)\n   246→      .sort();\n   247→    if (isEqual(current, previous) === false) {\n   248→      return false;\n   249→    }\n   250→  }\n   251→\n   252→  return true;\n   253→}\n   254→\n   255→export function isLineItemRecurringAligned(list: TLineItemExpanded[], index: number) {\n   256→  const prices = list.map((x) => x.upsell_price || x.price);\n   257→\n   258→  if (prices[index]?.type !== 'recurring') {\n   259→    return true;\n   260→  }\n   261→\n   262→  const recurring = prices.slice(0, index).find((x) => x?.type === 'recurring')?.recurring;\n   263→  if (!recurring) {\n   264→    return true;\n   265→  }\n   266→\n   267→  return prices.slice(0, index + 1).every((x: any) => {\n   268→    if (x.type !== 'recurring') {\n   269→      return true;\n   270→    }\n   271→\n   272→    // If the interval and interval_count are different, the recurring is not aligned\n   273→    if (\n   274→      String(recurring?.interval) !== String(x.recurring?.interval) ||\n   275→      Number(recurring?.interval_count) !== Number(x.recurring?.interval_count)\n   276→    ) {\n   277→      return false;\n   278→    }\n   279→\n   280→    return true;\n   281→  });\n   282→}\n   283→\n   284→export function isLineItemAligned(list: TLineItemExpanded[], index: number) {\n   285→  const currency = isLineItemCurrencyAligned(list, index);\n   286→  const recurring = isLineItemRecurringAligned(list, index);\n   287→  return {\n   288→    currency,\n   289→    recurring,\n   290→    aligned: currency && recurring,\n   291→  };\n   292→}\n   293→\n   294→// FIXME: upsell validate https://stripe.com/docs/payments/checkout/upsells\n   295→export function canUpsell(from: TPrice, to: TPrice) {\n   296→  if (from.id === to.id) {\n   297→    return false;\n   298→  }\n   299→  if (from.product_id !== to.product_id) {\n   300→    return false;\n   301→  }\n   302→  if (to.active === false) {\n   303→    return false;\n   304→  }\n   305→  if (to.type !== 'recurring') {\n   306→    return false;\n   307→  }\n   308→\n   309→  // longer periods\n   310→  const fromPeriod = getRecurringPeriod(from.recurring as PriceRecurring);\n   311→  const toPeriod = getRecurringPeriod(to.recurring as PriceRecurring);\n   312→  if (!fromPeriod || !toPeriod) {\n   313→    return false;\n   314→  }\n   315→  if (fromPeriod >= toPeriod) {\n   316→    return false;\n   317→  }\n   318→\n   319→  // and lower prices\n   320→  const fromPrice = new BN(from.unit_amount).div(new BN(fromPeriod));\n   321→  const toPrice = new BN(to.unit_amount).div(new BN(toPeriod));\n   322→  if (fromPrice.lt(toPrice)) {\n   323→    return false;\n   324→  }\n   325→\n   326→  return true;\n   327→}\n   328→\n   329→export async function getFastCheckoutAmount({\n   330→  items,\n   331→  mode,\n   332→  currencyId,\n   333→  trialing = false,\n   334→  minimumCycle = 1,\n   335→  discountConfig,\n   336→}: {\n   337→  items: TLineItemExpanded[];\n   338→  mode: string;\n   339→  currencyId: string;\n   340→  trialing?: boolean;\n   341→  minimumCycle?: number;\n   342→  discountConfig?: {\n   343→    promotionCodeId?: string;\n   344→    couponId?: string;\n   345→    customerId?: string;\n   346→  };\n   347→}) {\n   348→  if (!minimumCycle || minimumCycle < 1) {\n   349→    // eslint-disable-next-line no-param-reassign\n   350→    minimumCycle = 1;\n   351→  }\n   352→\n   353→  const { total, renew } = await getCheckoutAmount(items, currencyId, trialing, discountConfig);\n   354→\n   355→  if (mode === 'payment' || mode === 'auto-recharge-auth') {\n   356→    return total;\n   357→  }\n   358→\n   359→  if (mode === 'setup') {\n   360→    return new BN(renew).mul(new BN(minimumCycle)).toString();\n   361→  }\n   362→\n   363→  if (mode === 'subscription') {\n   364→    return new BN(total).add(new BN(renew).mul(new BN(trialing ? minimumCycle : minimumCycle - 1))).toString();\n   365→  }\n   366→\n   367→  return '0';\n   368→}\n   369→\n   370→export function getBillingThreshold(config: Record<string, any> = {}) {\n   371→  if (config?.billing_threshold_amount) {\n   372→    const threshold = +(config.billing_threshold_amount as string);\n   373→    if (threshold > 0) {\n   374→      return threshold;\n   375→    }\n   376→  }\n   377→\n   378→  const threshold = +(process.env.PAYMENT_BILLING_THRESHOLD as string);\n   379→  if (threshold > 0) {\n   380→    return threshold;\n   381→  }\n   382→\n   383→  return 0;\n   384→}\n   385→\n   386→export function getMinStakeAmount(config: Record<string, any> = {}) {\n   387→  if (config?.min_stake_amount) {\n   388→    const threshold = +(config.min_stake_amount as string);\n   389→    if (threshold > 0) {\n   390→      return threshold;\n   391→    }\n   392→  }\n   393→\n   394→  const threshold = +(process.env.PAYMENT_MIN_STAKE_AMOUNT as string);\n   395→  if (threshold > 0) {\n   396→    return threshold;\n   397→  }\n   398→\n   399→  return 0;\n   400→}\n   401→\n   402→export function canPayWithDelegation(beneficiaries: PaymentBeneficiary[]) {\n   403→  return beneficiaries.length === 0 || beneficiaries.every((x) => x.address === wallet.address);\n   404→}\n   405→\n   406→export function createPaymentBeneficiaries(total: string, beneficiaries: PaymentBeneficiary[]) {\n   407→  if (beneficiaries.length) {\n   408→    const shares = beneficiaries.reduce((acc, x) => acc + parseInt(x.share, 10), 0);\n   409→    const result: PaymentBeneficiary[] = [];\n   410→    beneficiaries.forEach((x, i) => {\n   411→      let share = new BN(total).div(new BN(shares)).mul(new BN(x.share)).toString();\n   412→      if (i === beneficiaries.length - 1) {\n   413→        share = result.reduce((acc, d) => acc.sub(new BN(d.share)), new BN(total)).toString();\n   414→      }\n   415→\n   416→      result.push({ ...x, share });\n   417→    });\n   418→\n   419→    return result;\n   420→  }\n   421→\n   422→  return [];\n   423→}\n   424→\n   425→export function createPaymentOutput(\n   426→  total: string,\n   427→  contract: string,\n   428→  beneficiaries: PaymentBeneficiary[]\n   429→): TransactionInput[] {\n   430→  if (beneficiaries.length) {\n   431→    return beneficiaries.map((x) => ({\n   432→      owner: x.address,\n   433→      assets: [],\n   434→      tokens: [\n   435→        {\n   436→          address: contract,\n   437→          value: x.share,\n   438→        },\n   439→      ],\n   440→    }));\n   441→  }\n   442→\n   443→  return [\n   444→    {\n   445→      owner: wallet.address,\n   446→      assets: [],\n   447→      tokens: [\n   448→        {\n   449→          address: contract,\n   450→          value: total,\n   451→        },\n   452→      ],\n   453→    },\n   454→  ];\n   455→}\n   456→\n   457→export function isDonationCheckoutSession(checkoutSession: CheckoutSession): boolean {\n   458→  return (\n   459→    checkoutSession.submit_type === 'donate' ||\n   460→    checkoutSession.metadata?.type === 'donation' ||\n   461→    !!checkoutSession.metadata?.is_donation\n   462→  );\n   463→}\n   464→\n   465→/**\n   466→ * Format subscription product name based on line items\n   467→ */\n   468→export function formatSubscriptionProduct(items: TLineItemExpanded[], maxLength = 3) {\n   469→  const names = items.map((x) => x.price?.product?.name || '').filter(Boolean);\n   470→  return names.length > maxLength ? `${names.slice(0, maxLength).join(', ')} ...` : names.join(', ');\n   471→}\n   472→\n   473→/**\n   474→ * Setup subscription creation parameters\n   475→ */\n   476→export function getSubscriptionCreateSetup(\n   477→  items: TLineItemExpanded[],\n   478→  currencyId: string,\n   479→  trialInDays = 0,\n   480→  trialEnd = 0\n   481→) {\n   482→  let setup = new BN(0);\n   483→\n   484→  items.forEach((x) => {\n   485→    const price = x.upsell_price || x.price;\n   486→    const unit = getPriceUintAmountByCurrency(price, currencyId);\n   487→    const amount = new BN(unit).mul(new BN(x.quantity));\n   488→    if (price.type === 'recurring') {\n   489→      if (price.recurring?.usage_type === 'licensed') {\n   490→        setup = setup.add(amount);\n   491→      }\n   492→    }\n   493→    if (price.type === 'one_time') {\n   494→      setup = setup.add(amount);\n   495→    }\n   496→  });\n   497→\n   498→  const now = dayjs().unix();\n   499→  const item = items.find((x) => (x.upsell_price || x.price).type === 'recurring');\n   500→  const recurring = (item?.upsell_price || item?.price)?.recurring as PriceRecurring;\n   501→  const cycle = getRecurringPeriod(recurring);\n   502→\n   503→  let trialStartAt = 0;\n   504→  let trialEndAt = 0;\n   505→  if (+trialEnd && trialEnd > now) {\n   506→    trialStartAt = now;\n   507→    trialEndAt = trialEnd;\n   508→  } else if (trialInDays) {\n   509→    trialStartAt = now;\n   510→    trialEndAt = dayjs().add(trialInDays, 'day').unix();\n   511→  }\n   512→\n   513→  const periodStart = trialStartAt || now;\n   514→  const periodEnd = trialEndAt || dayjs().add(cycle, 'millisecond').unix();\n   515→\n   516→  return {\n   517→    recurring,\n   518→    cycle: {\n   519→      duration: cycle,\n   520→      anchor: periodEnd,\n   521→    },\n   522→    trial: {\n   523→      start: trialStartAt,\n   524→      end: trialEndAt,\n   525→    },\n   526→    period: {\n   527→      start: periodStart,\n   528→      end: periodEnd,\n   529→    },\n   530→    amount: {\n   531→      setup: setup.toString(),\n   532→    },\n   533→  };\n   534→}\n   535→\n   536→/**\n   537→ * Creates subscription groupings based on checkout session configuration\n   538→ * @param {Object} params - Parameters for subscription creation\n   539→ * @returns {Object} Created subscription information\n   540→ */\n   541→export async function createGroupSubscriptions({\n   542→  checkoutSession,\n   543→  lineItems,\n   544→  customer,\n   545→  paymentSettings,\n   546→  setupIntent,\n   547→  trialConfig = {},\n   548→}: {\n   549→  checkoutSession: CheckoutSession;\n   550→  lineItems: TLineItemExpanded[];\n   551→  customer: Customer;\n   552→  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n   553→  setupIntent: SetupIntent | null;\n   554→  trialConfig?: { trialInDays?: number; trialEnd?: number };\n   555→}) {\n   556→  const enableGrouping = checkoutSession.enable_subscription_grouping;\n   557→\n   558→  // Filter recurring items only\n   559→  const recurringItems = getRecurringLineItems(lineItems);\n   560→  if (recurringItems.length === 0) {\n   561→    logger.info('No recurring items found for subscription', {\n   562→      session: checkoutSession.id,\n   563→    });\n   564→    return { subscriptions: [], subscriptionGroups: {}, primarySubscription: null };\n   565→  }\n   566→\n   567→  try {\n   568→    // Process based on grouping mode\n   569→    if (!enableGrouping) {\n   570→      // Single subscription mode\n   571→      const result = await createSingleSubscription({\n   572→        checkoutSession,\n   573→        lineItems: recurringItems,\n   574→        customer,\n   575→        paymentSettings,\n   576→        setupIntent,\n   577→        trialConfig,\n   578→      });\n   579→      return result;\n   580→    }\n   581→    // Multiple subscriptions mode\n   582→    const result = await createMultipleSubscriptions({\n   583→      checkoutSession,\n   584→      lineItems,\n   585→      customer,\n   586→      paymentSettings,\n   587→      setupIntent,\n   588→      trialConfig,\n   589→    });\n   590→    return result;\n   591→  } catch (error) {\n   592→    logger.error('Failed to create subscriptions', {\n   593→      error: error.message,\n   594→      session: checkoutSession.id,\n   595→      stack: error.stack,\n   596→    });\n   597→    throw error;\n   598→  }\n   599→}\n   600→\n   601→/**\n   602→ * Creates a single subscription for all items\n   603→ */\n   604→async function createSingleSubscription(params: {\n   605→  checkoutSession: CheckoutSession;\n   606→  lineItems: TLineItemExpanded[];\n   607→  customer: Customer;\n   608→  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n   609→  setupIntent: SetupIntent | null;\n   610→  trialConfig?: { trialInDays?: number; trialEnd?: number };\n   611→}) {\n   612→  const { checkoutSession, lineItems, customer, paymentSettings, setupIntent, trialConfig } = params;\n   613→  const existingSubscriptionId = checkoutSession.subscription_id;\n   614→\n   615→  const subscription = await createOrUpdateSubscription({\n   616→    existingSubscriptionId,\n   617→    checkoutSession,\n   618→    lineItems,\n   619→    customer,\n   620→    paymentSettings,\n   621→    setupIntent,\n   622→    trialConfig,\n   623→  });\n   624→\n   625→  logger.info('Single subscription processed', {\n   626→    session: checkoutSession.id,\n   627→    subscription: subscription?.id,\n   628→    isNew: !existingSubscriptionId,\n   629→  });\n   630→\n   631→  return {\n   632→    subscriptions: subscription ? [subscription] : [],\n   633→    subscriptionGroups: {},\n   634→    primarySubscription: subscription,\n   635→  };\n   636→}\n   637→\n   638→/**\n   639→ * Creates multiple subscriptions grouped by price ID\n   640→ */\n   641→async function createMultipleSubscriptions(params: {\n   642→  checkoutSession: CheckoutSession;\n   643→  lineItems: TLineItemExpanded[];\n   644→  customer: Customer;\n   645→  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n   646→  setupIntent: SetupIntent | null;\n   647→  trialConfig?: { trialInDays?: number; trialEnd?: number };\n   648→}) {\n   649→  const { checkoutSession, lineItems, customer, paymentSettings, setupIntent, trialConfig } = params;\n   650→\n   651→  // Group items by price ID\n   652→  const priceGroups = groupLineItemsByPrice(lineItems);\n   653→  const existingGroups = checkoutSession.subscription_groups || {};\n   654→\n   655→  const subscriptions: any[] = [];\n   656→  const subscriptionGroups: Record<string, string> = {};\n   657→  let primarySubscription: any = null;\n   658→\n   659→  const noStake = !!checkoutSession.subscription_data?.no_stake;\n   660→  const billingThreshold = getBillingThreshold(checkoutSession.subscription_data);\n   661→  const minStakeAmount = getMinStakeAmount(checkoutSession.subscription_data);\n   662→\n   663→  // Create a task for each price group\n   664→  const tasks = Object.entries(priceGroups).map(([priceId, items], index) => async () => {\n   665→    try {\n   666→      const existingSubscriptionId = existingGroups[priceId];\n   667→      const isPrimary = index === 0;\n   668→      const subscriptionMetadata = {\n   669→        price_id: priceId,\n   670→        checkout_session_id: checkoutSession.id,\n   671→        ...(isPrimary ? { is_primary_subscription: true } : {}),\n   672→      };\n   673→\n   674→      const subscriptionItems = items;\n   675→\n   676→      // Set different stake configurations for different subscriptions\n   677→      let billingThresholds = {};\n   678→      if (isPrimary) {\n   679→        billingThresholds = {\n   680→          amount_gte: billingThreshold,\n   681→          stake_gte: minStakeAmount,\n   682→          reset_billing_cycle_anchor: false,\n   683→          no_stake: noStake,\n   684→        };\n   685→      } else {\n   686→        // if not primary subscription, set stake to 0\n   687→        billingThresholds = {\n   688→          amount_gte: 0,\n   689→          stake_gte: 0,\n   690→          reset_billing_cycle_anchor: false,\n   691→          no_stake: true,\n   692→          references_primary_stake: true,\n   693→        };\n   694→      }\n   695→\n   696→      const subscription = await createOrUpdateSubscription({\n   697→        existingSubscriptionId,\n   698→        checkoutSession,\n   699→        lineItems: subscriptionItems,\n   700→        customer,\n   701→        paymentSettings,\n   702→        setupIntent,\n   703→        trialConfig,\n   704→        metadata: subscriptionMetadata,\n   705→        billing_thresholds: billingThresholds as SubscriptionBillingThresholds,\n   706→      });\n   707→\n   708→      if (!subscription) {\n   709→        return { success: false, priceId, error: 'Failed to create subscription' };\n   710→      }\n   711→\n   712→      return { success: true, priceId, subscription, isPrimary };\n   713→    } catch (error) {\n   714→      logger.error('Failed to create subscription for price group', {\n   715→        priceId,\n   716→        error: error.message,\n   717→        session: checkoutSession.id,\n   718→        stack: error.stack,\n   719→      });\n   720→      return { success: false, priceId, error: error.message };\n   721→    }\n   722→  });\n   723→\n   724→  const results = await pAll(tasks, { concurrency: 5 });\n   725→\n   726→  results.forEach((result) => {\n   727→    if (result.success && result.subscription) {\n   728→      subscriptionGroups[result.priceId] = result.subscription.id;\n   729→      subscriptions.push(result.subscription);\n   730→      if (result.isPrimary) {\n   731→        primarySubscription = result.subscription;\n   732→      }\n   733→    }\n   734→  });\n   735→\n   736→  return {\n   737→    subscriptions,\n   738→    subscriptionGroups,\n   739→    primarySubscription,\n   740→  };\n   741→}\n   742→\n   743→/**\n   744→ * Core logic for creating or updating a single subscription\n   745→ */\n   746→async function createOrUpdateSubscription(params: {\n   747→  existingSubscriptionId?: string | null;\n   748→  checkoutSession: CheckoutSession;\n   749→  lineItems: TLineItemExpanded[];\n   750→  customer: Customer;\n   751→  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n   752→  setupIntent: SetupIntent | null;\n   753→  trialConfig?: { trialInDays?: number; trialEnd?: number };\n   754→  metadata?: Record<string, any>;\n   755→  billing_thresholds?: SubscriptionBillingThresholds;\n   756→}): Promise<any> {\n   757→  const {\n   758→    existingSubscriptionId,\n   759→    checkoutSession,\n   760→    lineItems,\n   761→    customer,\n   762→    paymentSettings,\n   763→    setupIntent,\n   764→    trialConfig = {},\n   765→    metadata = {},\n   766→    billing_thresholds: billingThresholds,\n   767→  } = params;\n   768→\n   769→  const { trialInDays = 0, trialEnd = 0 } = trialConfig;\n   770→  const { method: paymentMethod, currency: paymentCurrency } = paymentSettings;\n   771→\n   772→  try {\n   773→    const itemsSubscriptionData = mergeSubscriptionDataFromLineItems(lineItems);\n   774→    let subscription = null;\n   775→    const setup = getSubscriptionCreateSetup(lineItems, paymentCurrency.id, trialInDays, trialEnd);\n   776→\n   777→    if (existingSubscriptionId) {\n   778→      subscription = await Subscription.findByPk(existingSubscriptionId);\n   779→    }\n   780→\n   781→    if (subscription) {\n   782→      // Validate subscription status\n   783→      if (subscription.status !== 'incomplete') {\n   784→        throw new Error(`Subscription ${subscription.id} status not incomplete: ${subscription.status}`);\n   785→      }\n   786→\n   787→      const billingCycleAnchor =\n   788→        itemsSubscriptionData?.billing_cycle_anchor ||\n   789→        checkoutSession.subscription_data?.billing_cycle_anchor ||\n   790→        setup.cycle.anchor;\n   791→\n   792→      // Update existing subscription\n   793→      subscription = await subscription.update({\n   794→        currency_id: paymentCurrency.id,\n   795→        customer_id: customer.id,\n   796→        default_payment_method_id: paymentMethod.id,\n   797→        current_period_start: setup.period.start,\n   798→        current_period_end: setup.period.end,\n   799→        billing_cycle_anchor: billingCycleAnchor,\n   800→        trial_end: setup.trial.end,\n   801→        trial_start: setup.trial.start,\n   802→        pending_invoice_item_interval: setup.recurring,\n   803→        pending_setup_intent: setupIntent?.id,\n   804→      });\n   805→\n   806→      logger.info('Subscription updated', {\n   807→        session: checkoutSession.id,\n   808→        subscription: subscription.id,\n   809→      });\n   810→\n   811→      // Rebuild subscription items\n   812→      await SubscriptionItem.destroy({ where: { subscription_id: subscription.id } });\n   813→      await createSubscriptionItems(subscription.id, lineItems, checkoutSession, itemsSubscriptionData);\n   814→\n   815→      // Update invoice customer if needed\n   816→      const invoice = await Invoice.findByPk(subscription.latest_invoice_id);\n   817→      if (invoice && invoice.customer_id !== customer.id) {\n   818→        await invoice.update({ customer_id: customer.id });\n   819→      }\n   820→    } else {\n   821→      // Create new subscription\n   822→      const recoveredFromId =\n   823→        itemsSubscriptionData.recovered_from || checkoutSession.subscription_data?.recovered_from || '';\n   824→      const recoveredFrom = recoveredFromId ? await Subscription.findByPk(recoveredFromId) : null;\n   825→\n   826→      const safeMetadata = {\n   827→        ...(checkoutSession.subscription_data?.notification_settings\n   828→          ? {\n   829→              notification_settings: checkoutSession.subscription_data.notification_settings,\n   830→            }\n   831→          : {}),\n   832→        ...omit(checkoutSession.metadata || {}, ['days_until_due', 'days_until_cancel', 'page_info']),\n   833→        ...(itemsSubscriptionData.metadata || {}),\n   834→        ...metadata,\n   835→      };\n   836→\n   837→      const subscriptionData = {\n   838→        ...checkoutSession.subscription_data,\n   839→        ...itemsSubscriptionData,\n   840→      };\n   841→\n   842→      const subscriptionBillingThresholds = billingThresholds || {\n   843→        amount_gte: getBillingThreshold(subscriptionData),\n   844→        stake_gte: getMinStakeAmount(subscriptionData),\n   845→        reset_billing_cycle_anchor: false,\n   846→        no_stake: subscriptionData.no_stake,\n   847→      };\n   848→\n   849→      subscription = await Subscription.create({\n   850→        livemode: !!checkoutSession.livemode,\n   851→        currency_id: paymentCurrency.id,\n   852→        customer_id: customer.id,\n   853→        status: 'incomplete',\n   854→        current_period_start: setup.period.start,\n   855→        current_period_end: setup.period.end,\n   856→        // FIXME: billing_cycle_anchor implementation is not aligned with stripe\n   857→        billing_cycle_anchor: subscriptionData.billing_cycle_anchor || setup.cycle.anchor,\n   858→        start_date: dayjs().unix(),\n   859→        trial_end: setup.trial.end,\n   860→        trial_start: setup.trial.start,\n   861→        trial_settings: {\n   862→          end_behavior: {\n   863→            missing_payment_method: 'create_invoice',\n   864→          },\n   865→        },\n   866→        billing_thresholds: subscriptionBillingThresholds,\n   867→        pending_invoice_item_interval: setup.recurring,\n   868→        pending_setup_intent: setupIntent?.id,\n   869→        default_payment_method_id: paymentMethod.id,\n   870→        cancel_at_period_end: false,\n   871→        collection_method: 'charge_automatically',\n   872→        description: subscriptionData.description || formatSubscriptionProduct(lineItems),\n   873→        proration_behavior: subscriptionData.proration_behavior || 'none',\n   874→        payment_behavior: 'default_incomplete',\n   875→        days_until_due: subscriptionData.days_until_due,\n   876→        days_until_cancel: subscriptionData.days_until_cancel,\n   877→        recovered_from: recoveredFrom?.id,\n   878→        metadata: safeMetadata,\n   879→        service_actions: subscriptionData.service_actions || [],\n   880→      });\n   881→\n   882→      logger.info('Subscription created', {\n   883→        session: checkoutSession.id,\n   884→        subscription: subscription.id,\n   885→      });\n   886→\n   887→      // Create subscription items with item-specific metadata\n   888→      await createSubscriptionItems(subscription.id, lineItems, checkoutSession, itemsSubscriptionData);\n   889→    }\n   890→\n   891→    return subscription;\n   892→  } catch (error) {\n   893→    logger.error('Failed in createOrUpdateSubscription', {\n   894→      existingSubscriptionId,\n   895→      error: error.message,\n   896→      stack: error.stack,\n   897→      session: checkoutSession.id,\n   898→    });\n   899→    throw error;\n   900→  }\n   901→}\n   902→\n   903→/**\n   904→ * Creates subscription items for a subscription\n   905→ */\n   906→async function createSubscriptionItems(\n   907→  subscriptionId: string,\n   908→  lineItems: TLineItemExpanded[],\n   909→  checkoutSession: CheckoutSession,\n   910→  itemsSubscriptionData: Record<string, any>\n   911→) {\n   912→  try {\n   913→    const metadata = {\n   914→      ...(itemsSubscriptionData?.metadata || {}),\n   915→      ...(checkoutSession.metadata || {}),\n   916→    };\n   917→\n   918→    const subItems = await Promise.all(\n   919→      lineItems.map((item) =>\n   920→        SubscriptionItem.create({\n   921→          livemode: !!checkoutSession.livemode,\n   922→          subscription_id: subscriptionId,\n   923→          price_id: item.upsell_price_id || item.price_id,\n   924→          quantity: item.quantity,\n   925→          metadata,\n   926→        })\n   927→      )\n   928→    );\n   929→\n   930→    logger.info('Subscription items created', {\n   931→      session: checkoutSession.id,\n   932→      subscription: subscriptionId,\n   933→      items: subItems.map((x) => x.id),\n   934→    });\n   935→\n   936→    return subItems;\n   937→  } catch (error) {\n   938→    logger.error('Failed to create subscription items', {\n   939→      subscriptionId,\n   940→      error: error.message,\n   941→      stack: error.stack,\n   942→      session: checkoutSession.id,\n   943→    });\n   944→    throw error;\n   945→  }\n   946→}\n   947→\n   948→/**\n   949→ * Groups line items by price ID\n   950→ */\n   951→function groupLineItemsByPrice(lineItems: TLineItemExpanded[]): Record<string, TLineItemExpanded[]> {\n   952→  const groups: Record<string, TLineItemExpanded[]> = {};\n   953→  const recurringLineItems = getRecurringLineItems(lineItems);\n   954→\n   955→  recurringLineItems.forEach((item) => {\n   956→    const priceId = item.upsell_price_id || item.price_id;\n   957→    if (!groups[priceId]) {\n   958→      groups[priceId] = [];\n   959→    }\n   960→    groups[priceId].push(item);\n   961→  });\n   962→\n   963→  return groups;\n   964→}\n   965→\n   966→export function getCheckoutSessionSubscriptionIds(checkoutSession: CheckoutSession) {\n   967→  const enableGrouping = checkoutSession.enable_subscription_grouping;\n   968→  if (!enableGrouping && checkoutSession.subscription_id) {\n   969→    return [checkoutSession.subscription_id];\n   970→  }\n   971→  return Object.values(checkoutSession.subscription_groups || {}).filter(Boolean);\n   972→}\n   973→\n   974→export function getOneTimeLineItems(lineItems: TLineItemExpanded[]) {\n   975→  return lineItems.filter((item) => item.price?.type === 'one_time');\n   976→}\n   977→\n   978→export function getRecurringLineItems(lineItems: TLineItemExpanded[]) {\n   979→  return lineItems.filter((item) => item.price?.type === 'recurring');\n   980→}\n   981→\n   982→export function mergeSubscriptionDataFromLineItems(lineItems: TLineItemExpanded[]): Record<string, any> {\n   983→  if (lineItems.length === 0) {\n   984→    return {};\n   985→  }\n   986→  const mergedData: Record<string, any> = {};\n   987→  const mergedMetadata: Record<string, any> = {};\n   988→  lineItems.forEach((item: TLineItemExpanded) => {\n   989→    const subData = (item.subscription_data || {}) as any;\n   990→    if (subData.metadata) {\n   991→      Object.assign(mergedMetadata, subData.metadata);\n   992→    }\n   993→    Object.entries(subData).forEach(([key, value]) => {\n   994→      if (key !== 'metadata') {\n   995→        mergedData[key] = value;\n   996→      }\n   997→    });\n   998→  });\n   999→\n  1000→  if (Object.keys(mergedMetadata).length > 0) {\n  1001→    mergedData.metadata = mergedMetadata;\n  1002→  }\n  1003→\n  1004→  return mergedData;\n  1005→}\n  1006→\n  1007→/**\n  1008→ * Get line items related to a specific subscription\n  1009→ * @param subscription The subscription object\n  1010→ * @param lineItems All line items from checkout session\n  1011→ * @param primarySubscription Optional primary subscription to check one-time items\n  1012→ * @returns Line items associated with the subscription\n  1013→ */\n  1014→export async function getSubscriptionLineItems(\n  1015→  subscription: Subscription,\n  1016→  lineItems: TLineItemExpanded[],\n  1017→  primarySubscription?: Subscription\n  1018→): Promise<TLineItemExpanded[]> {\n  1019→  const subscriptionItems = await SubscriptionItem.findAll({\n  1020→    where: { subscription_id: subscription.id },\n  1021→  });\n  1022→\n  1023→  let subItems = lineItems.filter((x) =>\n  1024→    subscriptionItems.some((y) => y.price_id === x.price_id || y.price_id === x.upsell_price_id)\n  1025→  );\n  1026→\n  1027→  // Add one-time items if this is the primary subscription\n  1028→  if (primarySubscription && subscription.id === primarySubscription.id) {\n  1029→    subItems = [...subItems, ...getOneTimeLineItems(lineItems)];\n  1030→  }\n  1031→\n  1032→  return subItems;\n  1033→}\n  1034→\n  1035→export function isCreditMetered(price: TPrice | TPriceExpanded) {\n  1036→  return price.type === 'recurring' && price.recurring?.usage_type === 'metered' && !!price.recurring?.meter_id;\n  1037→}\n  1038→\n  1039→export function isCreditMeteredLineItems(lineItems: TLineItemExpanded[]) {\n  1040→  return lineItems.every((item) => item.price && isCreditMetered(item.price));\n  1041→}\n  1042→\n  1043→export function validateStripePaymentAmounts(amount: string, currency: PaymentCurrency) {\n  1044→  const minAmountInUnits = fromTokenToUnit(0.5, currency.decimal);\n  1045→  return new BN(amount).gte(new BN(minAmountInUnits)); // 0.5 USD\n  1046→}\n  1047→\n  1048→/**\n  1049→ * Validates payment amounts meet minimum requirements\n  1050→ * @param lineItems Line items to validate\n  1051→ * @param currencyId Currency ID for validation\n  1052→ * @param mode Checkout mode\n  1053→ * @returns Validation result with error message if any\n  1054→ */\n  1055→export async function validatePaymentAmounts(\n  1056→  lineItems: TLineItemExpanded[],\n  1057→  currency: PaymentCurrency,\n  1058→  checkoutSession: CheckoutSession\n  1059→): Promise<{ valid: boolean; error?: string }> {\n  1060→  const enableGrouping = checkoutSession.enable_subscription_grouping;\n  1061→  const oneTimeItems = getOneTimeLineItems(lineItems);\n  1062→  const recurringItems = getRecurringLineItems(lineItems);\n  1063→\n  1064→  const minAmountInUnits = fromTokenToUnit(0.5, currency.decimal);\n  1065→\n  1066→  // Case 1: All one-time items - validate total payment amount\n  1067→  if (recurringItems.length === 0 && oneTimeItems.length > 0) {\n  1068→    const { total } = await getCheckoutAmount(lineItems, currency.id);\n  1069→    if (new BN(total).lt(new BN(minAmountInUnits))) {\n  1070→      return {\n  1071→        valid: false,\n  1072→        error: 'Total payment amount must be greater or equal to 0.5 USD',\n  1073→      };\n  1074→    }\n  1075→    return { valid: true };\n  1076→  }\n  1077→\n  1078→  // Case 2: Mixed or subscription only - validate subscription pricing\n  1079→  if (recurringItems.length > 0) {\n  1080→    if (enableGrouping) {\n  1081→      // When grouping is enabled, validate each subscription product's unit price\n  1082→      const priceGroups = groupLineItemsByPrice(lineItems);\n  1083→\n  1084→      for (const [priceId, items] of Object.entries(priceGroups)) {\n  1085→        // Calculate total unit price for this subscription product\n  1086→        let totalUnitPrice = new BN(0);\n  1087→\n  1088→        items.forEach((item) => {\n  1089→          const price = item.upsell_price || item.price;\n  1090→          const unitPrice = getPriceUintAmountByCurrency(price, currency.id);\n  1091→          totalUnitPrice = totalUnitPrice.add(new BN(unitPrice).mul(new BN(item.quantity)));\n  1092→        });\n  1093→\n  1094→        if (totalUnitPrice.lt(new BN(minAmountInUnits))) {\n  1095→          const productName = items[0]?.price?.product?.name || `Product ${priceId}`;\n  1096→          return {\n  1097→            valid: false,\n  1098→            error: `product \"${productName}\" unit price must be greater or equal to 0.5 USD`,\n  1099→          };\n  1100→        }\n  1101→      }\n  1102→    } else {\n  1103→      // When grouping is disabled, validate total subscription amount\n  1104→      const { renew } = await getCheckoutAmount(lineItems, currency.id);\n  1105→      if (new BN(renew).lt(new BN(minAmountInUnits))) {\n  1106→        return {\n  1107→          valid: false,\n  1108→          error: 'Total subscription amount must be greater or equal to 0.5 USD',\n  1109→        };\n  1110→      }\n  1111→    }\n  1112→  }\n  1113→\n  1114→  return { valid: true };\n  1115→}\n  1116→\n  1117→/**\n  1118→ * Process discount application for checkout session data\n  1119→ * Validates coupon existence and basic validity, calculates discount amounts\n  1120→ * Customer-specific validations are done later during checkout submission\n  1121→ */\n  1122→export async function processCheckoutSessionDiscounts(\n  1123→  checkoutData: {\n  1124→    currency_id: string;\n  1125→    amount_total: string;\n  1126→    line_items?: any[];\n  1127→  },\n  1128→  discounts: Array<{ coupon: string }>\n  1129→): Promise<\n  1130→  Array<{\n  1131→    coupon: string;\n  1132→    verification_method: string;\n  1133→  }>\n  1134→> {\n  1135→  if (!discounts || !Array.isArray(discounts) || discounts.length === 0) {\n  1136→    return [];\n  1137→  }\n  1138→\n  1139→  // Get currency for discount calculations\n  1140→  const currency = await PaymentCurrency.findByPk(checkoutData.currency_id);\n  1141→  if (!currency) {\n  1142→    throw new Error('Currency not found');\n  1143→  }\n  1144→\n  1145→  const processedDiscounts: Array<{\n  1146→    coupon: string;\n  1147→    verification_method: string;\n  1148→  }> = [];\n  1149→\n  1150→  const expandedItems = await Price.expand(checkoutData.line_items || [], { product: true, upsell: true });\n  1151→\n  1152→  // Process discounts concurrently for better performance\n  1153→  const discountProcessingTasks = discounts.map((discountSpec, index) => async () => {\n  1154→    if (!discountSpec.coupon) {\n  1155→      throw new Error(`Coupon ID is required for discount at index ${index}`);\n  1156→    }\n  1157→\n  1158→    const coupon = await Coupon.findByPk(discountSpec.coupon);\n  1159→    if (!coupon) {\n  1160→      throw new Error(`Coupon '${discountSpec.coupon}' not found`);\n  1161→    }\n  1162→\n  1163→    // Validate coupon basic validity\n  1164→    const couponValidation = validCoupon(coupon, expandedItems as TLineItemExpanded[]);\n  1165→    if (!couponValidation.valid) {\n  1166→      throw new Error(`Coupon '${discountSpec.coupon}' is not valid: ${couponValidation.reason}`);\n  1167→    }\n  1168→    return {\n  1169→      coupon: coupon.id,\n  1170→      verification_method: 'direct',\n  1171→    };\n  1172→  });\n  1173→\n  1174→  const processedDiscountsArray = await pAll(discountProcessingTasks, { concurrency: 5 });\n  1175→  processedDiscounts.push(...processedDiscountsArray);\n  1176→\n  1177→  return processedDiscounts;\n  1178→}\n  1179→\n  1180→/**\n  1181→ * Recalculate checkout session amounts with applied discounts\n  1182→ */\n  1183→export async function getCheckoutSessionAmounts(checkoutSession: CheckoutSession) {\n  1184→  const { discounts } = checkoutSession;\n  1185→\n  1186→  // Ensure we always have safe default values\n  1187→  const safeSubtotal = checkoutSession.amount_subtotal || '0';\n  1188→  const safeTotal = checkoutSession.amount_total || '0';\n  1189→  const safeTotalDetails = checkoutSession.total_details || {\n  1190→    amount_discount: '0',\n  1191→    amount_shipping: '0',\n  1192→    amount_tax: '0',\n  1193→  };\n  1194→\n  1195→  // If no discounts, return current amounts with safe defaults\n  1196→  if (!discounts || discounts.length === 0) {\n  1197→    return {\n  1198→      amount_subtotal: safeSubtotal,\n  1199→      amount_total: safeTotal,\n  1200→      total_details: {\n  1201→        amount_discount: safeTotalDetails.amount_discount || '0',\n  1202→        amount_shipping: safeTotalDetails.amount_shipping || '0',\n  1203→        amount_tax: safeTotalDetails.amount_tax || '0',\n  1204→      },\n  1205→    };\n  1206→  }\n  1207→\n  1208→  const originalTotal = safeTotal;\n  1209→  let totalDiscountAmount = new BN('0');\n  1210→\n  1211→  // Calculate discount for each coupon\n  1212→  const discountPromises = discounts.map(async (discount) => {\n  1213→    if (!discount.coupon) {\n  1214→      return new BN('0');\n  1215→    }\n  1216→\n  1217→    const coupon = await Coupon.findByPk(discount.coupon);\n  1218→\n  1219→    if (!coupon || !coupon.valid) {\n  1220→      return new BN('0');\n  1221→    }\n  1222→\n  1223→    let discountAmount = new BN('0');\n  1224→    const baseAmount = new BN(originalTotal);\n  1225→\n  1226→    if (coupon.percent_off > 0) {\n  1227→      // Percentage discount\n  1228→      discountAmount = baseAmount.mul(new BN(coupon.percent_off)).div(new BN(100));\n  1229→    } else if (coupon.amount_off && new BN(coupon.amount_off).gt(new BN('0'))) {\n  1230→      // Fixed amount discount\n  1231→      discountAmount = new BN(coupon.amount_off);\n  1232→    }\n  1233→\n  1234→    // Ensure discount doesn't exceed original amount\n  1235→    if (discountAmount.gt(baseAmount)) {\n  1236→      discountAmount = baseAmount;\n  1237→    }\n  1238→\n  1239→    return discountAmount;\n  1240→  });\n  1241→\n  1242→  const discountAmounts = await Promise.all(discountPromises);\n  1243→  totalDiscountAmount = discountAmounts.reduce((sum: BN, amount: BN) => sum.add(amount), new BN('0'));\n  1244→\n  1245→  // Ensure total discount doesn't exceed original amount\n  1246→  if (totalDiscountAmount.gt(new BN(originalTotal))) {\n  1247→    totalDiscountAmount = new BN(originalTotal);\n  1248→  }\n  1249→\n  1250→  const finalTotal = new BN(originalTotal).sub(totalDiscountAmount);\n  1251→  // Ensure total doesn't go below 0\n  1252→  const adjustedTotal = finalTotal.lt(new BN('0')) ? '0' : finalTotal.toString();\n  1253→\n  1254→  return {\n  1255→    amount_subtotal: safeSubtotal,\n  1256→    amount_total: adjustedTotal,\n  1257→    total_details: {\n  1258→      amount_discount: totalDiscountAmount.toString(),\n  1259→      amount_shipping: safeTotalDetails.amount_shipping || '0',\n  1260→      amount_tax: safeTotalDetails.amount_tax || '0',\n  1261→    },\n  1262→    discounts,\n  1263→  };\n  1264→}\n  1265→\n  1266→/**\n  1267→ * Enrich checkout session with dynamic pricing quotes\n  1268→ * For each dynamic price, create or reuse a quote and attach quote info to line items\n  1269→ */\n  1270→export async function enrichCheckoutSessionWithQuotes(\n  1271→  checkoutSession: CheckoutSession,\n  1272→  lineItems: TLineItemExpanded[],\n  1273→  currencyId: string\n  1274→): Promise<{\n  1275→  lineItems: TLineItemExpanded[];\n  1276→  quotes: Record<\n  1277→    string,\n  1278→    {\n  1279→      quote_id: string;\n  1280→      expires_at: number;\n  1281→      quoted_amount: string;\n  1282→      exchange_rate?: string;\n  1283→      rate_provider_name?: string;\n  1284→      rate_provider_id?: string;\n  1285→    }\n  1286→  >;\n  1287→  rateUnavailable?: boolean;\n  1288→  rateError?: string;\n  1289→}> {\n  1290→  const quoteService = getQuoteService();\n  1291→\n  1292→  const quotes: Record<\n  1293→    string,\n  1294→    {\n  1295→      quote_id: string;\n  1296→      expires_at: number;\n  1297→      quoted_amount: string;\n  1298→      exchange_rate: string;\n  1299→      rate_provider_name: string;\n  1300→      rate_provider_id: string;\n  1301→    }\n  1302→  > = {};\n  1303→\n  1304→  // Find all dynamic pricing items\n  1305→  const dynamicItems = lineItems.filter((item) => item.price.pricing_type === 'dynamic');\n  1306→\n  1307→  // If no dynamic items, return early\n  1308→  if (dynamicItems.length === 0) {\n  1309→    return { lineItems, quotes };\n  1310→  }\n  1311→\n  1312→  // Fetch exchange rate once for all dynamic items (they all use the same target currency)\n  1313→  const currency = (await PaymentCurrency.findByPk(currencyId, {\n  1314→    include: [{ model: PaymentMethod, as: 'payment_method' }],\n  1315→  })) as PaymentCurrency & { payment_method: PaymentMethod };\n  1316→  if (!currency) {\n  1317→    throw new Error(`Currency ${currencyId} not found`);\n  1318→  }\n  1319→\n  1320→  if (currency.payment_method?.type === 'stripe') {\n  1321→    return { lineItems, quotes };\n  1322→  }\n  1323→\n  1324→  const exchangeRateService = getExchangeRateService();\n  1325→\n  1326→  // Try to get exchange rate, but don't block checkout if unavailable\n  1327→  let rateResult;\n  1328→  try {\n  1329→    // For ArcBlock payment method, always use ABT for exchange rate\n  1330→    // For other methods, use the currency's symbol\n  1331→    const rateSymbol = getExchangeRateSymbol(currency.symbol, currency.payment_method?.type as ChainType);\n  1332→    rateResult = await exchangeRateService.getRate(rateSymbol);\n  1333→  } catch (error: any) {\n  1334→    logger.warn('Exchange rate unavailable for checkout session', {\n  1335→      checkoutSessionId: checkoutSession.id,\n  1336→      currencyId,\n  1337→      currencySymbol: currency.symbol,\n  1338→      error: error.message,\n  1339→    });\n  1340→\n  1341→    // Return without quotes, frontend will show warning\n  1342→    return {\n  1343→      lineItems,\n  1344→      quotes: {},\n  1345→      rateUnavailable: true,\n  1346→      rateError: error.message || 'Exchange rate service unavailable',\n  1347→    };\n  1348→  }\n  1349→\n  1350→  logger.info('Fetched exchange rate for batch quote creation', {\n  1351→    currencyId,\n  1352→    currencySymbol: currency.symbol,\n  1353→    rate: rateResult.rate,\n  1354→    provider: rateResult.provider_name,\n  1355→    dynamicItemsCount: dynamicItems.length,\n  1356→  });\n  1357→\n  1358→  // Create quotes for all dynamic items using the same exchange rate\n  1359→  const quoteResults = await Promise.all(\n  1360→    dynamicItems.map(async (item) => {\n  1361→      const { price, quantity } = item;\n  1362→\n  1363→      try {\n  1364→        const quoteResponse = await quoteService.createQuoteWithRate({\n  1365→          price_id: price.id,\n  1366→          session_id: checkoutSession.id,\n  1367→          target_currency_id: currencyId,\n  1368→          quantity,\n  1369→          rateResult,\n  1370→        });\n  1371→\n  1372→        return {\n  1373→          item,\n  1374→          quoteResponse,\n  1375→        };\n  1376→      } catch (error) {\n  1377→        logger.error('Failed to create quote for dynamic price', {\n  1378→          priceId: price.id,\n  1379→          checkoutSessionId: checkoutSession.id,\n  1380→          currencyId,\n  1381→          error: (error as Error).message,\n  1382→        });\n  1383→        throw error;\n  1384→      }\n  1385→    })\n  1386→  );\n  1387→\n  1388→  // Build quote map for quick lookup\n  1389→  const quoteByPriceId = new Map<string, (typeof quoteResults)[0]>();\n  1390→  quoteResults.forEach((result) => {\n  1391→    quoteByPriceId.set(result.item.price.id, result);\n  1392→  });\n  1393→\n  1394→  // Extract quote info helper\n  1395→  const extractQuoteInfo = (quoteResponse: QuoteResponse) => ({\n  1396→    quote_id: quoteResponse.quote.id,\n  1397→    expires_at: quoteResponse.expires_at,\n  1398→    quoted_amount: quoteResponse.computed_unit_amount,\n  1399→    exchange_rate: quoteResponse.quote.exchange_rate,\n  1400→    rate_provider_name: quoteResponse.quote.rate_provider_name,\n  1401→    rate_provider_id: quoteResponse.quote.rate_provider_id,\n  1402→  });\n  1403→\n  1404→  // Build quotes object\n  1405→  quoteResults.forEach((result) => {\n  1406→    const quoteKey = `${result.item.price.id}_${currencyId}`;\n  1407→    quotes[quoteKey] = extractQuoteInfo(result.quoteResponse);\n  1408→  });\n  1409→\n  1410→  // Enrich line items with quote information\n  1411→  const enrichedLineItems = lineItems.map((item) => {\n  1412→    const quoteInfo = quoteByPriceId.get(item.price.id);\n  1413→    if (!quoteInfo) {\n  1414→      return item;\n  1415→    }\n  1416→\n  1417→    const quoteData = extractQuoteInfo(quoteInfo.quoteResponse);\n  1418→    return {\n  1419→      ...item,\n  1420→      ...quoteData,\n  1421→      custom_amount: quoteInfo.quoteResponse.computed_unit_amount,\n  1422→    };\n  1423→  });\n  1424→\n  1425→  return {\n  1426→    lineItems: enrichedLineItems,\n  1427→    quotes,\n  1428→  };\n  1429→}\n  1430→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"90274154-3173-45fd-993f-68455c30646f","timestamp":"2026-01-06T15:03:53.101Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts","content":"import { env } from '@blocklet/sdk/lib/config';\nimport type { TransactionInput } from '@ocap/client';\nimport { BN, fromTokenToUnit } from '@ocap/util';\nimport cloneDeep from 'lodash/cloneDeep';\nimport isEqual from 'lodash/isEqual';\nimport pAll from 'p-all';\nimport { omit } from 'lodash';\nimport dayjs from './dayjs';\nimport { validCoupon } from './discount/coupon';\nimport { getPriceUintAmountByCurrency, getPriceCurrencyOptions } from './price';\n\nimport {\n  Coupon,\n  Customer,\n  Invoice,\n  PaymentCurrency,\n  PaymentMethod,\n  SetupIntent,\n  Subscription,\n  SubscriptionItem,\n  TPriceExpanded,\n  type CheckoutSession,\n  type TLineItemExpanded,\n  type TPaymentCurrency,\n  type TPaymentMethodExpanded,\n} from '../store/models';\nimport { Price, Price as TPrice } from '../store/models/price';\nimport type { Product } from '../store/models/product';\nimport type {\n  ChainType,\n  PaymentBeneficiary,\n  PriceRecurring,\n  SubscriptionBillingThresholds,\n} from '../store/models/types';\nimport { wallet } from './auth';\nimport logger from './logger';\nimport { applyDiscountsToLineItems } from './discount/discount';\nimport { getQuoteService, QuoteResponse } from './quote-service';\nimport { getExchangeRateService } from './exchange-rate';\nimport { getExchangeRateSymbol } from './exchange-rate/token-address-mapping';\n\nexport function getStatementDescriptor(items: any[]) {\n  for (const item of items) {\n    if (item.price?.product?.statement_descriptor) {\n      return item.price?.product?.statement_descriptor;\n    }\n  }\n\n  return env.appName;\n}\n\nexport function getCheckoutMode(items: TLineItemExpanded[] = []) {\n  if (items.length === 0) {\n    return 'setup';\n  }\n\n  // all metered\n  if (items.every((x) => x.price.type === 'recurring' && x.price.recurring?.usage_type === 'metered')) {\n    return 'setup';\n  }\n\n  if (items.some((x) => x.price.type === 'recurring')) {\n    return 'subscription';\n  }\n\n  return 'payment';\n}\n\n// Calculate checkout amount with optional discount processing\nexport async function getCheckoutAmount(\n  items: TLineItemExpanded[],\n  currencyId: string,\n  trialing = false,\n  discountConfig?: {\n    promotionCodeId?: string;\n    couponId?: string;\n    customerId?: string;\n  }\n) {\n  let processedItems = items;\n  let renew = new BN(0);\n\n  if (items.find((x) => (x.upsell_price || x.price).custom_unit_amount) && items.length > 1) {\n    throw new Error('Multiple items with custom unit amount are not supported');\n  }\n\n  // Apply discounts if discount configuration is provided\n  if (discountConfig?.couponId && discountConfig?.customerId) {\n    try {\n      const currency = await PaymentCurrency.findByPk(currencyId);\n      if (currency) {\n        const discountResult = await applyDiscountsToLineItems({\n          lineItems: items,\n          promotionCodeId: discountConfig.promotionCodeId,\n          couponId: discountConfig.couponId,\n          customerId: discountConfig.customerId,\n          currency,\n          billingContext: {\n            trialing,\n          },\n        });\n\n        if (discountResult.discountSummary.appliedCoupon) {\n          processedItems = discountResult.enhancedLineItems;\n        }\n      }\n    } catch (error) {\n      // If discount processing fails, continue with original items\n      console.warn('Failed to apply discounts in getCheckoutAmount:', error.message);\n    }\n  }\n\n  const subtotal = processedItems\n    .reduce((acc, x) => {\n      if (x.custom_amount) {\n        return acc.add(new BN(x.custom_amount));\n      }\n\n      const price = x.upsell_price || x.price;\n      const unitPrice = getPriceUintAmountByCurrency(price, currencyId);\n      if (price.custom_unit_amount) {\n        if (unitPrice) {\n          return acc.add(new BN(unitPrice).mul(new BN(x.quantity)));\n        }\n      }\n\n      if (price?.type === 'recurring') {\n        renew = renew.add(new BN(unitPrice).mul(new BN(x.quantity)));\n\n        if (trialing) {\n          return acc;\n        }\n        if (price?.recurring?.usage_type === 'metered') {\n          return acc;\n        }\n      }\n\n      return acc.add(new BN(unitPrice).mul(new BN(x.quantity)));\n    }, new BN(0))\n    .toString();\n\n  // Calculate total discount amount from processed line items\n  let totalDiscountAmount = new BN(0);\n  processedItems.forEach((item) => {\n    if ((item as any).discount_amounts?.length > 0) {\n      (item as any).discount_amounts.forEach((discountAmount: any) => {\n        totalDiscountAmount = totalDiscountAmount.add(new BN(discountAmount.amount || '0'));\n      });\n    }\n  });\n\n  // Ensure discount doesn't exceed subtotal\n  const adjustedDiscount = totalDiscountAmount.gt(new BN(subtotal)) ? new BN(subtotal) : totalDiscountAmount;\n\n  const finalTotal = new BN(subtotal).sub(adjustedDiscount);\n  const adjustedTotal = finalTotal.lt(new BN('0')) ? '0' : finalTotal.toString();\n\n  return {\n    subtotal: subtotal || '0',\n    total: adjustedTotal,\n    renew: renew.toString() || '0',\n    discount: adjustedDiscount.toString(),\n    shipping: '0',\n    tax: '0',\n    processedItems, // Return processed items with discount information\n  };\n}\n\nexport function getRecurringPeriod(recurring: PriceRecurring) {\n  const { interval } = recurring || {};\n  if (!interval) {\n    return 0;\n  }\n  const count = +recurring.interval_count || 1;\n  const dayInMs = 24 * 60 * 60 * 1000;\n\n  switch (interval) {\n    case 'hour':\n      return 60 * 60 * 1000;\n    case 'day':\n      return count * dayInMs;\n    case 'week':\n      return count * 7 * dayInMs;\n    case 'month':\n      return count * 30 * dayInMs;\n    case 'year':\n      return count * 365 * dayInMs;\n    default:\n      return 0;\n  }\n}\n\nexport function expandLineItems(\n  items: any[],\n  products: Product[],\n  prices: Price[],\n  creditCurrencies?: TPaymentCurrency[]\n) {\n  items.forEach((item) => {\n    item.price = prices.find((x) => x.id === item.price_id);\n    if (item.price) {\n      item.price.product = products.find((x) => x.id === item.price.product_id);\n      if (item.price.product?.type === 'credit' && item.price.metadata?.credit_config) {\n        item.price.credit = {\n          amount: Number(item.price.metadata.credit_config.credit_amount || 0) * Number(item.quantity),\n          currency_id: item.price.metadata.credit_config.currency_id,\n          currency: creditCurrencies?.find((x) => x.id === item.price.metadata.credit_config.currency_id),\n        };\n      }\n    }\n  });\n\n  return items;\n}\n\nexport function filterCurrencies(method: TPaymentMethodExpanded, hasSelected: (currency: TPaymentCurrency) => boolean) {\n  method.payment_currencies = method.payment_currencies.filter((x) => hasSelected(x));\n  return method;\n}\n\nexport function getSupportedPaymentMethods(\n  methods: TPaymentMethodExpanded[],\n  hasSelected: (currency: TPaymentCurrency) => boolean\n) {\n  const filtered = cloneDeep(methods).map((x) => filterCurrencies(x, hasSelected));\n  return filtered.filter((x) => x.payment_currencies.length);\n}\n\nexport function getSupportedPaymentCurrencies(items: TLineItemExpanded[]) {\n  const currencies = items.reduce((acc: string[], x: any) => {\n    return acc.concat(getPriceCurrencyOptions(x.price).map((c: any) => c.currency_id));\n  }, []);\n  return Array.from(new Set(currencies));\n}\n\nexport function isLineItemCurrencyAligned(list: TLineItemExpanded[], index: number) {\n  const prices = list.map((x) => x.upsell_price || x.price);\n\n  const current = getPriceCurrencyOptions(prices[index] as any)\n    .map((x) => x.currency_id)\n    .sort();\n\n  for (let i = 0; i < index; i++) {\n    const previous = getPriceCurrencyOptions(prices[i] as any)\n      .map((x) => x.currency_id)\n      .sort();\n    if (isEqual(current, previous) === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isLineItemRecurringAligned(list: TLineItemExpanded[], index: number) {\n  const prices = list.map((x) => x.upsell_price || x.price);\n\n  if (prices[index]?.type !== 'recurring') {\n    return true;\n  }\n\n  const recurring = prices.slice(0, index).find((x) => x?.type === 'recurring')?.recurring;\n  if (!recurring) {\n    return true;\n  }\n\n  return prices.slice(0, index + 1).every((x: any) => {\n    if (x.type !== 'recurring') {\n      return true;\n    }\n\n    // If the interval and interval_count are different, the recurring is not aligned\n    if (\n      String(recurring?.interval) !== String(x.recurring?.interval) ||\n      Number(recurring?.interval_count) !== Number(x.recurring?.interval_count)\n    ) {\n      return false;\n    }\n\n    return true;\n  });\n}\n\nexport function isLineItemAligned(list: TLineItemExpanded[], index: number) {\n  const currency = isLineItemCurrencyAligned(list, index);\n  const recurring = isLineItemRecurringAligned(list, index);\n  return {\n    currency,\n    recurring,\n    aligned: currency && recurring,\n  };\n}\n\n// FIXME: upsell validate https://stripe.com/docs/payments/checkout/upsells\nexport function canUpsell(from: TPrice, to: TPrice) {\n  if (from.id === to.id) {\n    return false;\n  }\n  if (from.product_id !== to.product_id) {\n    return false;\n  }\n  if (to.active === false) {\n    return false;\n  }\n  if (to.type !== 'recurring') {\n    return false;\n  }\n\n  // longer periods\n  const fromPeriod = getRecurringPeriod(from.recurring as PriceRecurring);\n  const toPeriod = getRecurringPeriod(to.recurring as PriceRecurring);\n  if (!fromPeriod || !toPeriod) {\n    return false;\n  }\n  if (fromPeriod >= toPeriod) {\n    return false;\n  }\n\n  // and lower prices\n  const fromPrice = new BN(from.unit_amount).div(new BN(fromPeriod));\n  const toPrice = new BN(to.unit_amount).div(new BN(toPeriod));\n  if (fromPrice.lt(toPrice)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport async function getFastCheckoutAmount({\n  items,\n  mode,\n  currencyId,\n  trialing = false,\n  minimumCycle = 1,\n  discountConfig,\n}: {\n  items: TLineItemExpanded[];\n  mode: string;\n  currencyId: string;\n  trialing?: boolean;\n  minimumCycle?: number;\n  discountConfig?: {\n    promotionCodeId?: string;\n    couponId?: string;\n    customerId?: string;\n  };\n}) {\n  if (!minimumCycle || minimumCycle < 1) {\n    // eslint-disable-next-line no-param-reassign\n    minimumCycle = 1;\n  }\n\n  const { total, renew } = await getCheckoutAmount(items, currencyId, trialing, discountConfig);\n\n  if (mode === 'payment' || mode === 'auto-recharge-auth') {\n    return total;\n  }\n\n  if (mode === 'setup') {\n    return new BN(renew).mul(new BN(minimumCycle)).toString();\n  }\n\n  if (mode === 'subscription') {\n    return new BN(total).add(new BN(renew).mul(new BN(trialing ? minimumCycle : minimumCycle - 1))).toString();\n  }\n\n  return '0';\n}\n\nexport function getBillingThreshold(config: Record<string, any> = {}) {\n  if (config?.billing_threshold_amount) {\n    const threshold = +(config.billing_threshold_amount as string);\n    if (threshold > 0) {\n      return threshold;\n    }\n  }\n\n  const threshold = +(process.env.PAYMENT_BILLING_THRESHOLD as string);\n  if (threshold > 0) {\n    return threshold;\n  }\n\n  return 0;\n}\n\nexport function getMinStakeAmount(config: Record<string, any> = {}) {\n  if (config?.min_stake_amount) {\n    const threshold = +(config.min_stake_amount as string);\n    if (threshold > 0) {\n      return threshold;\n    }\n  }\n\n  const threshold = +(process.env.PAYMENT_MIN_STAKE_AMOUNT as string);\n  if (threshold > 0) {\n    return threshold;\n  }\n\n  return 0;\n}\n\nexport function canPayWithDelegation(beneficiaries: PaymentBeneficiary[]) {\n  return beneficiaries.length === 0 || beneficiaries.every((x) => x.address === wallet.address);\n}\n\nexport function createPaymentBeneficiaries(total: string, beneficiaries: PaymentBeneficiary[]) {\n  if (beneficiaries.length) {\n    const shares = beneficiaries.reduce((acc, x) => acc + parseInt(x.share, 10), 0);\n    const result: PaymentBeneficiary[] = [];\n    beneficiaries.forEach((x, i) => {\n      let share = new BN(total).div(new BN(shares)).mul(new BN(x.share)).toString();\n      if (i === beneficiaries.length - 1) {\n        share = result.reduce((acc, d) => acc.sub(new BN(d.share)), new BN(total)).toString();\n      }\n\n      result.push({ ...x, share });\n    });\n\n    return result;\n  }\n\n  return [];\n}\n\nexport function createPaymentOutput(\n  total: string,\n  contract: string,\n  beneficiaries: PaymentBeneficiary[]\n): TransactionInput[] {\n  if (beneficiaries.length) {\n    return beneficiaries.map((x) => ({\n      owner: x.address,\n      assets: [],\n      tokens: [\n        {\n          address: contract,\n          value: x.share,\n        },\n      ],\n    }));\n  }\n\n  return [\n    {\n      owner: wallet.address,\n      assets: [],\n      tokens: [\n        {\n          address: contract,\n          value: total,\n        },\n      ],\n    },\n  ];\n}\n\nexport function isDonationCheckoutSession(checkoutSession: CheckoutSession): boolean {\n  return (\n    checkoutSession.submit_type === 'donate' ||\n    checkoutSession.metadata?.type === 'donation' ||\n    !!checkoutSession.metadata?.is_donation\n  );\n}\n\n/**\n * Format subscription product name based on line items\n */\nexport function formatSubscriptionProduct(items: TLineItemExpanded[], maxLength = 3) {\n  const names = items.map((x) => x.price?.product?.name || '').filter(Boolean);\n  return names.length > maxLength ? `${names.slice(0, maxLength).join(', ')} ...` : names.join(', ');\n}\n\n/**\n * Setup subscription creation parameters\n */\nexport function getSubscriptionCreateSetup(\n  items: TLineItemExpanded[],\n  currencyId: string,\n  trialInDays = 0,\n  trialEnd = 0\n) {\n  let setup = new BN(0);\n\n  items.forEach((x) => {\n    const price = x.upsell_price || x.price;\n    const unit = getPriceUintAmountByCurrency(price, currencyId);\n    const amount = new BN(unit).mul(new BN(x.quantity));\n    if (price.type === 'recurring') {\n      if (price.recurring?.usage_type === 'licensed') {\n        setup = setup.add(amount);\n      }\n    }\n    if (price.type === 'one_time') {\n      setup = setup.add(amount);\n    }\n  });\n\n  const now = dayjs().unix();\n  const item = items.find((x) => (x.upsell_price || x.price).type === 'recurring');\n  const recurring = (item?.upsell_price || item?.price)?.recurring as PriceRecurring;\n  const cycle = getRecurringPeriod(recurring);\n\n  let trialStartAt = 0;\n  let trialEndAt = 0;\n  if (+trialEnd && trialEnd > now) {\n    trialStartAt = now;\n    trialEndAt = trialEnd;\n  } else if (trialInDays) {\n    trialStartAt = now;\n    trialEndAt = dayjs().add(trialInDays, 'day').unix();\n  }\n\n  const periodStart = trialStartAt || now;\n  const periodEnd = trialEndAt || dayjs().add(cycle, 'millisecond').unix();\n\n  return {\n    recurring,\n    cycle: {\n      duration: cycle,\n      anchor: periodEnd,\n    },\n    trial: {\n      start: trialStartAt,\n      end: trialEndAt,\n    },\n    period: {\n      start: periodStart,\n      end: periodEnd,\n    },\n    amount: {\n      setup: setup.toString(),\n    },\n  };\n}\n\n/**\n * Creates subscription groupings based on checkout session configuration\n * @param {Object} params - Parameters for subscription creation\n * @returns {Object} Created subscription information\n */\nexport async function createGroupSubscriptions({\n  checkoutSession,\n  lineItems,\n  customer,\n  paymentSettings,\n  setupIntent,\n  trialConfig = {},\n}: {\n  checkoutSession: CheckoutSession;\n  lineItems: TLineItemExpanded[];\n  customer: Customer;\n  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n  setupIntent: SetupIntent | null;\n  trialConfig?: { trialInDays?: number; trialEnd?: number };\n}) {\n  const enableGrouping = checkoutSession.enable_subscription_grouping;\n\n  // Filter recurring items only\n  const recurringItems = getRecurringLineItems(lineItems);\n  if (recurringItems.length === 0) {\n    logger.info('No recurring items found for subscription', {\n      session: checkoutSession.id,\n    });\n    return { subscriptions: [], subscriptionGroups: {}, primarySubscription: null };\n  }\n\n  try {\n    // Process based on grouping mode\n    if (!enableGrouping) {\n      // Single subscription mode\n      const result = await createSingleSubscription({\n        checkoutSession,\n        lineItems: recurringItems,\n        customer,\n        paymentSettings,\n        setupIntent,\n        trialConfig,\n      });\n      return result;\n    }\n    // Multiple subscriptions mode\n    const result = await createMultipleSubscriptions({\n      checkoutSession,\n      lineItems,\n      customer,\n      paymentSettings,\n      setupIntent,\n      trialConfig,\n    });\n    return result;\n  } catch (error) {\n    logger.error('Failed to create subscriptions', {\n      error: error.message,\n      session: checkoutSession.id,\n      stack: error.stack,\n    });\n    throw error;\n  }\n}\n\n/**\n * Creates a single subscription for all items\n */\nasync function createSingleSubscription(params: {\n  checkoutSession: CheckoutSession;\n  lineItems: TLineItemExpanded[];\n  customer: Customer;\n  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n  setupIntent: SetupIntent | null;\n  trialConfig?: { trialInDays?: number; trialEnd?: number };\n}) {\n  const { checkoutSession, lineItems, customer, paymentSettings, setupIntent, trialConfig } = params;\n  const existingSubscriptionId = checkoutSession.subscription_id;\n\n  const subscription = await createOrUpdateSubscription({\n    existingSubscriptionId,\n    checkoutSession,\n    lineItems,\n    customer,\n    paymentSettings,\n    setupIntent,\n    trialConfig,\n  });\n\n  logger.info('Single subscription processed', {\n    session: checkoutSession.id,\n    subscription: subscription?.id,\n    isNew: !existingSubscriptionId,\n  });\n\n  return {\n    subscriptions: subscription ? [subscription] : [],\n    subscriptionGroups: {},\n    primarySubscription: subscription,\n  };\n}\n\n/**\n * Creates multiple subscriptions grouped by price ID\n */\nasync function createMultipleSubscriptions(params: {\n  checkoutSession: CheckoutSession;\n  lineItems: TLineItemExpanded[];\n  customer: Customer;\n  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n  setupIntent: SetupIntent | null;\n  trialConfig?: { trialInDays?: number; trialEnd?: number };\n}) {\n  const { checkoutSession, lineItems, customer, paymentSettings, setupIntent, trialConfig } = params;\n\n  // Group items by price ID\n  const priceGroups = groupLineItemsByPrice(lineItems);\n  const existingGroups = checkoutSession.subscription_groups || {};\n\n  const subscriptions: any[] = [];\n  const subscriptionGroups: Record<string, string> = {};\n  let primarySubscription: any = null;\n\n  const noStake = !!checkoutSession.subscription_data?.no_stake;\n  const billingThreshold = getBillingThreshold(checkoutSession.subscription_data);\n  const minStakeAmount = getMinStakeAmount(checkoutSession.subscription_data);\n\n  // Create a task for each price group\n  const tasks = Object.entries(priceGroups).map(([priceId, items], index) => async () => {\n    try {\n      const existingSubscriptionId = existingGroups[priceId];\n      const isPrimary = index === 0;\n      const subscriptionMetadata = {\n        price_id: priceId,\n        checkout_session_id: checkoutSession.id,\n        ...(isPrimary ? { is_primary_subscription: true } : {}),\n      };\n\n      const subscriptionItems = items;\n\n      // Set different stake configurations for different subscriptions\n      let billingThresholds = {};\n      if (isPrimary) {\n        billingThresholds = {\n          amount_gte: billingThreshold,\n          stake_gte: minStakeAmount,\n          reset_billing_cycle_anchor: false,\n          no_stake: noStake,\n        };\n      } else {\n        // if not primary subscription, set stake to 0\n        billingThresholds = {\n          amount_gte: 0,\n          stake_gte: 0,\n          reset_billing_cycle_anchor: false,\n          no_stake: true,\n          references_primary_stake: true,\n        };\n      }\n\n      const subscription = await createOrUpdateSubscription({\n        existingSubscriptionId,\n        checkoutSession,\n        lineItems: subscriptionItems,\n        customer,\n        paymentSettings,\n        setupIntent,\n        trialConfig,\n        metadata: subscriptionMetadata,\n        billing_thresholds: billingThresholds as SubscriptionBillingThresholds,\n      });\n\n      if (!subscription) {\n        return { success: false, priceId, error: 'Failed to create subscription' };\n      }\n\n      return { success: true, priceId, subscription, isPrimary };\n    } catch (error) {\n      logger.error('Failed to create subscription for price group', {\n        priceId,\n        error: error.message,\n        session: checkoutSession.id,\n        stack: error.stack,\n      });\n      return { success: false, priceId, error: error.message };\n    }\n  });\n\n  const results = await pAll(tasks, { concurrency: 5 });\n\n  results.forEach((result) => {\n    if (result.success && result.subscription) {\n      subscriptionGroups[result.priceId] = result.subscription.id;\n      subscriptions.push(result.subscription);\n      if (result.isPrimary) {\n        primarySubscription = result.subscription;\n      }\n    }\n  });\n\n  return {\n    subscriptions,\n    subscriptionGroups,\n    primarySubscription,\n  };\n}\n\n/**\n * Core logic for creating or updating a single subscription\n */\nasync function createOrUpdateSubscription(params: {\n  existingSubscriptionId?: string | null;\n  checkoutSession: CheckoutSession;\n  lineItems: TLineItemExpanded[];\n  customer: Customer;\n  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n  setupIntent: SetupIntent | null;\n  trialConfig?: { trialInDays?: number; trialEnd?: number };\n  metadata?: Record<string, any>;\n  billing_thresholds?: SubscriptionBillingThresholds;\n}): Promise<any> {\n  const {\n    existingSubscriptionId,\n    checkoutSession,\n    lineItems,\n    customer,\n    paymentSettings,\n    setupIntent,\n    trialConfig = {},\n    metadata = {},\n    billing_thresholds: billingThresholds,\n  } = params;\n\n  const { trialInDays = 0, trialEnd = 0 } = trialConfig;\n  const { method: paymentMethod, currency: paymentCurrency } = paymentSettings;\n\n  try {\n    const itemsSubscriptionData = mergeSubscriptionDataFromLineItems(lineItems);\n    let subscription = null;\n    const setup = getSubscriptionCreateSetup(lineItems, paymentCurrency.id, trialInDays, trialEnd);\n\n    if (existingSubscriptionId) {\n      subscription = await Subscription.findByPk(existingSubscriptionId);\n    }\n\n    if (subscription) {\n      // Validate subscription status\n      if (subscription.status !== 'incomplete') {\n        throw new Error(`Subscription ${subscription.id} status not incomplete: ${subscription.status}`);\n      }\n\n      const billingCycleAnchor =\n        itemsSubscriptionData?.billing_cycle_anchor ||\n        checkoutSession.subscription_data?.billing_cycle_anchor ||\n        setup.cycle.anchor;\n\n      // Update existing subscription\n      subscription = await subscription.update({\n        currency_id: paymentCurrency.id,\n        customer_id: customer.id,\n        default_payment_method_id: paymentMethod.id,\n        current_period_start: setup.period.start,\n        current_period_end: setup.period.end,\n        billing_cycle_anchor: billingCycleAnchor,\n        trial_end: setup.trial.end,\n        trial_start: setup.trial.start,\n        pending_invoice_item_interval: setup.recurring,\n        pending_setup_intent: setupIntent?.id,\n      });\n\n      logger.info('Subscription updated', {\n        session: checkoutSession.id,\n        subscription: subscription.id,\n      });\n\n      // Rebuild subscription items\n      await SubscriptionItem.destroy({ where: { subscription_id: subscription.id } });\n      await createSubscriptionItems(subscription.id, lineItems, checkoutSession, itemsSubscriptionData);\n\n      // Update invoice customer if needed\n      const invoice = await Invoice.findByPk(subscription.latest_invoice_id);\n      if (invoice && invoice.customer_id !== customer.id) {\n        await invoice.update({ customer_id: customer.id });\n      }\n    } else {\n      // Create new subscription\n      const recoveredFromId =\n        itemsSubscriptionData.recovered_from || checkoutSession.subscription_data?.recovered_from || '';\n      const recoveredFrom = recoveredFromId ? await Subscription.findByPk(recoveredFromId) : null;\n\n      const safeMetadata = {\n        ...(checkoutSession.subscription_data?.notification_settings\n          ? {\n              notification_settings: checkoutSession.subscription_data.notification_settings,\n            }\n          : {}),\n        ...omit(checkoutSession.metadata || {}, ['days_until_due', 'days_until_cancel', 'page_info']),\n        ...(itemsSubscriptionData.metadata || {}),\n        ...metadata,\n      };\n\n      const subscriptionData = {\n        ...checkoutSession.subscription_data,\n        ...itemsSubscriptionData,\n      };\n\n      const subscriptionBillingThresholds = billingThresholds || {\n        amount_gte: getBillingThreshold(subscriptionData),\n        stake_gte: getMinStakeAmount(subscriptionData),\n        reset_billing_cycle_anchor: false,\n        no_stake: subscriptionData.no_stake,\n      };\n\n      subscription = await Subscription.create({\n        livemode: !!checkoutSession.livemode,\n        currency_id: paymentCurrency.id,\n        customer_id: customer.id,\n        status: 'incomplete',\n        current_period_start: setup.period.start,\n        current_period_end: setup.period.end,\n        // FIXME: billing_cycle_anchor implementation is not aligned with stripe\n        billing_cycle_anchor: subscriptionData.billing_cycle_anchor || setup.cycle.anchor,\n        start_date: dayjs().unix(),\n        trial_end: setup.trial.end,\n        trial_start: setup.trial.start,\n        trial_settings: {\n          end_behavior: {\n            missing_payment_method: 'create_invoice',\n          },\n        },\n        billing_thresholds: subscriptionBillingThresholds,\n        pending_invoice_item_interval: setup.recurring,\n        pending_setup_intent: setupIntent?.id,\n        default_payment_method_id: paymentMethod.id,\n        cancel_at_period_end: false,\n        collection_method: 'charge_automatically',\n        description: subscriptionData.description || formatSubscriptionProduct(lineItems),\n        proration_behavior: subscriptionData.proration_behavior || 'none',\n        payment_behavior: 'default_incomplete',\n        days_until_due: subscriptionData.days_until_due,\n        days_until_cancel: subscriptionData.days_until_cancel,\n        recovered_from: recoveredFrom?.id,\n        metadata: safeMetadata,\n        service_actions: subscriptionData.service_actions || [],\n      });\n\n      logger.info('Subscription created', {\n        session: checkoutSession.id,\n        subscription: subscription.id,\n      });\n\n      // Create subscription items with item-specific metadata\n      await createSubscriptionItems(subscription.id, lineItems, checkoutSession, itemsSubscriptionData);\n    }\n\n    return subscription;\n  } catch (error) {\n    logger.error('Failed in createOrUpdateSubscription', {\n      existingSubscriptionId,\n      error: error.message,\n      stack: error.stack,\n      session: checkoutSession.id,\n    });\n    throw error;\n  }\n}\n\n/**\n * Creates subscription items for a subscription\n */\nasync function createSubscriptionItems(\n  subscriptionId: string,\n  lineItems: TLineItemExpanded[],\n  checkoutSession: CheckoutSession,\n  itemsSubscriptionData: Record<string, any>\n) {\n  try {\n    const metadata = {\n      ...(itemsSubscriptionData?.metadata || {}),\n      ...(checkoutSession.metadata || {}),\n    };\n\n    const subItems = await Promise.all(\n      lineItems.map((item) =>\n        SubscriptionItem.create({\n          livemode: !!checkoutSession.livemode,\n          subscription_id: subscriptionId,\n          price_id: item.upsell_price_id || item.price_id,\n          quantity: item.quantity,\n          metadata,\n        })\n      )\n    );\n\n    logger.info('Subscription items created', {\n      session: checkoutSession.id,\n      subscription: subscriptionId,\n      items: subItems.map((x) => x.id),\n    });\n\n    return subItems;\n  } catch (error) {\n    logger.error('Failed to create subscription items', {\n      subscriptionId,\n      error: error.message,\n      stack: error.stack,\n      session: checkoutSession.id,\n    });\n    throw error;\n  }\n}\n\n/**\n * Groups line items by price ID\n */\nfunction groupLineItemsByPrice(lineItems: TLineItemExpanded[]): Record<string, TLineItemExpanded[]> {\n  const groups: Record<string, TLineItemExpanded[]> = {};\n  const recurringLineItems = getRecurringLineItems(lineItems);\n\n  recurringLineItems.forEach((item) => {\n    const priceId = item.upsell_price_id || item.price_id;\n    if (!groups[priceId]) {\n      groups[priceId] = [];\n    }\n    groups[priceId].push(item);\n  });\n\n  return groups;\n}\n\nexport function getCheckoutSessionSubscriptionIds(checkoutSession: CheckoutSession) {\n  const enableGrouping = checkoutSession.enable_subscription_grouping;\n  if (!enableGrouping && checkoutSession.subscription_id) {\n    return [checkoutSession.subscription_id];\n  }\n  return Object.values(checkoutSession.subscription_groups || {}).filter(Boolean);\n}\n\nexport function getOneTimeLineItems(lineItems: TLineItemExpanded[]) {\n  return lineItems.filter((item) => item.price?.type === 'one_time');\n}\n\nexport function getRecurringLineItems(lineItems: TLineItemExpanded[]) {\n  return lineItems.filter((item) => item.price?.type === 'recurring');\n}\n\nexport function mergeSubscriptionDataFromLineItems(lineItems: TLineItemExpanded[]): Record<string, any> {\n  if (lineItems.length === 0) {\n    return {};\n  }\n  const mergedData: Record<string, any> = {};\n  const mergedMetadata: Record<string, any> = {};\n  lineItems.forEach((item: TLineItemExpanded) => {\n    const subData = (item.subscription_data || {}) as any;\n    if (subData.metadata) {\n      Object.assign(mergedMetadata, subData.metadata);\n    }\n    Object.entries(subData).forEach(([key, value]) => {\n      if (key !== 'metadata') {\n        mergedData[key] = value;\n      }\n    });\n  });\n\n  if (Object.keys(mergedMetadata).length > 0) {\n    mergedData.metadata = mergedMetadata;\n  }\n\n  return mergedData;\n}\n\n/**\n * Get line items related to a specific subscription\n * @param subscription The subscription object\n * @param lineItems All line items from checkout session\n * @param primarySubscription Optional primary subscription to check one-time items\n * @returns Line items associated with the subscription\n */\nexport async function getSubscriptionLineItems(\n  subscription: Subscription,\n  lineItems: TLineItemExpanded[],\n  primarySubscription?: Subscription\n): Promise<TLineItemExpanded[]> {\n  const subscriptionItems = await SubscriptionItem.findAll({\n    where: { subscription_id: subscription.id },\n  });\n\n  let subItems = lineItems.filter((x) =>\n    subscriptionItems.some((y) => y.price_id === x.price_id || y.price_id === x.upsell_price_id)\n  );\n\n  // Add one-time items if this is the primary subscription\n  if (primarySubscription && subscription.id === primarySubscription.id) {\n    subItems = [...subItems, ...getOneTimeLineItems(lineItems)];\n  }\n\n  return subItems;\n}\n\nexport function isCreditMetered(price: TPrice | TPriceExpanded) {\n  return price.type === 'recurring' && price.recurring?.usage_type === 'metered' && !!price.recurring?.meter_id;\n}\n\nexport function isCreditMeteredLineItems(lineItems: TLineItemExpanded[]) {\n  return lineItems.every((item) => item.price && isCreditMetered(item.price));\n}\n\nexport function validateStripePaymentAmounts(amount: string, currency: PaymentCurrency) {\n  const minAmountInUnits = fromTokenToUnit(0.5, currency.decimal);\n  return new BN(amount).gte(new BN(minAmountInUnits)); // 0.5 USD\n}\n\n/**\n * Validates payment amounts meet minimum requirements\n * @param lineItems Line items to validate\n * @param currencyId Currency ID for validation\n * @param mode Checkout mode\n * @returns Validation result with error message if any\n */\nexport async function validatePaymentAmounts(\n  lineItems: TLineItemExpanded[],\n  currency: PaymentCurrency,\n  checkoutSession: CheckoutSession\n): Promise<{ valid: boolean; error?: string }> {\n  const enableGrouping = checkoutSession.enable_subscription_grouping;\n  const oneTimeItems = getOneTimeLineItems(lineItems);\n  const recurringItems = getRecurringLineItems(lineItems);\n\n  const minAmountInUnits = fromTokenToUnit(0.5, currency.decimal);\n\n  // Case 1: All one-time items - validate total payment amount\n  if (recurringItems.length === 0 && oneTimeItems.length > 0) {\n    const { total } = await getCheckoutAmount(lineItems, currency.id);\n    if (new BN(total).lt(new BN(minAmountInUnits))) {\n      return {\n        valid: false,\n        error: 'Total payment amount must be greater or equal to 0.5 USD',\n      };\n    }\n    return { valid: true };\n  }\n\n  // Case 2: Mixed or subscription only - validate subscription pricing\n  if (recurringItems.length > 0) {\n    if (enableGrouping) {\n      // When grouping is enabled, validate each subscription product's unit price\n      const priceGroups = groupLineItemsByPrice(lineItems);\n\n      for (const [priceId, items] of Object.entries(priceGroups)) {\n        // Calculate total unit price for this subscription product\n        let totalUnitPrice = new BN(0);\n\n        items.forEach((item) => {\n          const price = item.upsell_price || item.price;\n          const unitPrice = getPriceUintAmountByCurrency(price, currency.id);\n          totalUnitPrice = totalUnitPrice.add(new BN(unitPrice).mul(new BN(item.quantity)));\n        });\n\n        if (totalUnitPrice.lt(new BN(minAmountInUnits))) {\n          const productName = items[0]?.price?.product?.name || `Product ${priceId}`;\n          return {\n            valid: false,\n            error: `product \"${productName}\" unit price must be greater or equal to 0.5 USD`,\n          };\n        }\n      }\n    } else {\n      // When grouping is disabled, validate total subscription amount\n      const { renew } = await getCheckoutAmount(lineItems, currency.id);\n      if (new BN(renew).lt(new BN(minAmountInUnits))) {\n        return {\n          valid: false,\n          error: 'Total subscription amount must be greater or equal to 0.5 USD',\n        };\n      }\n    }\n  }\n\n  return { valid: true };\n}\n\n/**\n * Process discount application for checkout session data\n * Validates coupon existence and basic validity, calculates discount amounts\n * Customer-specific validations are done later during checkout submission\n */\nexport async function processCheckoutSessionDiscounts(\n  checkoutData: {\n    currency_id: string;\n    amount_total: string;\n    line_items?: any[];\n  },\n  discounts: Array<{ coupon: string }>\n): Promise<\n  Array<{\n    coupon: string;\n    verification_method: string;\n  }>\n> {\n  if (!discounts || !Array.isArray(discounts) || discounts.length === 0) {\n    return [];\n  }\n\n  // Get currency for discount calculations\n  const currency = await PaymentCurrency.findByPk(checkoutData.currency_id);\n  if (!currency) {\n    throw new Error('Currency not found');\n  }\n\n  const processedDiscounts: Array<{\n    coupon: string;\n    verification_method: string;\n  }> = [];\n\n  const expandedItems = await Price.expand(checkoutData.line_items || [], { product: true, upsell: true });\n\n  // Process discounts concurrently for better performance\n  const discountProcessingTasks = discounts.map((discountSpec, index) => async () => {\n    if (!discountSpec.coupon) {\n      throw new Error(`Coupon ID is required for discount at index ${index}`);\n    }\n\n    const coupon = await Coupon.findByPk(discountSpec.coupon);\n    if (!coupon) {\n      throw new Error(`Coupon '${discountSpec.coupon}' not found`);\n    }\n\n    // Validate coupon basic validity\n    const couponValidation = validCoupon(coupon, expandedItems as TLineItemExpanded[]);\n    if (!couponValidation.valid) {\n      throw new Error(`Coupon '${discountSpec.coupon}' is not valid: ${couponValidation.reason}`);\n    }\n    return {\n      coupon: coupon.id,\n      verification_method: 'direct',\n    };\n  });\n\n  const processedDiscountsArray = await pAll(discountProcessingTasks, { concurrency: 5 });\n  processedDiscounts.push(...processedDiscountsArray);\n\n  return processedDiscounts;\n}\n\n/**\n * Recalculate checkout session amounts with applied discounts\n */\nexport async function getCheckoutSessionAmounts(checkoutSession: CheckoutSession) {\n  const { discounts } = checkoutSession;\n\n  // Ensure we always have safe default values\n  const safeSubtotal = checkoutSession.amount_subtotal || '0';\n  const safeTotal = checkoutSession.amount_total || '0';\n  const safeTotalDetails = checkoutSession.total_details || {\n    amount_discount: '0',\n    amount_shipping: '0',\n    amount_tax: '0',\n  };\n\n  // If no discounts, return current amounts with safe defaults\n  if (!discounts || discounts.length === 0) {\n    return {\n      amount_subtotal: safeSubtotal,\n      amount_total: safeTotal,\n      total_details: {\n        amount_discount: safeTotalDetails.amount_discount || '0',\n        amount_shipping: safeTotalDetails.amount_shipping || '0',\n        amount_tax: safeTotalDetails.amount_tax || '0',\n      },\n    };\n  }\n\n  const originalTotal = safeTotal;\n  let totalDiscountAmount = new BN('0');\n\n  // Calculate discount for each coupon\n  const discountPromises = discounts.map(async (discount) => {\n    if (!discount.coupon) {\n      return new BN('0');\n    }\n\n    const coupon = await Coupon.findByPk(discount.coupon);\n\n    if (!coupon || !coupon.valid) {\n      return new BN('0');\n    }\n\n    let discountAmount = new BN('0');\n    const baseAmount = new BN(originalTotal);\n\n    if (coupon.percent_off > 0) {\n      // Percentage discount\n      discountAmount = baseAmount.mul(new BN(coupon.percent_off)).div(new BN(100));\n    } else if (coupon.amount_off && new BN(coupon.amount_off).gt(new BN('0'))) {\n      // Fixed amount discount\n      discountAmount = new BN(coupon.amount_off);\n    }\n\n    // Ensure discount doesn't exceed original amount\n    if (discountAmount.gt(baseAmount)) {\n      discountAmount = baseAmount;\n    }\n\n    return discountAmount;\n  });\n\n  const discountAmounts = await Promise.all(discountPromises);\n  totalDiscountAmount = discountAmounts.reduce((sum: BN, amount: BN) => sum.add(amount), new BN('0'));\n\n  // Ensure total discount doesn't exceed original amount\n  if (totalDiscountAmount.gt(new BN(originalTotal))) {\n    totalDiscountAmount = new BN(originalTotal);\n  }\n\n  const finalTotal = new BN(originalTotal).sub(totalDiscountAmount);\n  // Ensure total doesn't go below 0\n  const adjustedTotal = finalTotal.lt(new BN('0')) ? '0' : finalTotal.toString();\n\n  return {\n    amount_subtotal: safeSubtotal,\n    amount_total: adjustedTotal,\n    total_details: {\n      amount_discount: totalDiscountAmount.toString(),\n      amount_shipping: safeTotalDetails.amount_shipping || '0',\n      amount_tax: safeTotalDetails.amount_tax || '0',\n    },\n    discounts,\n  };\n}\n\n/**\n * Enrich checkout session with dynamic pricing quotes\n * For each dynamic price, create or reuse a quote and attach quote info to line items\n */\nexport async function enrichCheckoutSessionWithQuotes(\n  checkoutSession: CheckoutSession,\n  lineItems: TLineItemExpanded[],\n  currencyId: string\n): Promise<{\n  lineItems: TLineItemExpanded[];\n  quotes: Record<\n    string,\n    {\n      quote_id: string;\n      expires_at: number;\n      quoted_amount: string;\n      exchange_rate?: string;\n      rate_provider_name?: string;\n      rate_provider_id?: string;\n    }\n  >;\n  rateUnavailable?: boolean;\n  rateError?: string;\n}> {\n  const quoteService = getQuoteService();\n\n  const quotes: Record<\n    string,\n    {\n      quote_id: string;\n      expires_at: number;\n      quoted_amount: string;\n      exchange_rate: string;\n      rate_provider_name: string;\n      rate_provider_id: string;\n    }\n  > = {};\n\n  // Find all dynamic pricing items\n  const dynamicItems = lineItems.filter((item) => item.price.pricing_type === 'dynamic');\n\n  // If no dynamic items, return early\n  if (dynamicItems.length === 0) {\n    return { lineItems, quotes };\n  }\n\n  // Fetch exchange rate once for all dynamic items (they all use the same target currency)\n  const currency = (await PaymentCurrency.findByPk(currencyId, {\n    include: [{ model: PaymentMethod, as: 'payment_method' }],\n  })) as PaymentCurrency & { payment_method: PaymentMethod };\n  if (!currency) {\n    throw new Error(`Currency ${currencyId} not found`);\n  }\n\n  if (currency.payment_method?.type === 'stripe') {\n    return { lineItems, quotes };\n  }\n\n  const exchangeRateService = getExchangeRateService();\n\n  // Try to get exchange rate, but don't block checkout if unavailable\n  let rateResult;\n  try {\n    // For ArcBlock payment method, always use ABT for exchange rate\n    // For other methods, use the currency's symbol\n    const rateSymbol = getExchangeRateSymbol(currency.symbol, currency.payment_method?.type as ChainType);\n    rateResult = await exchangeRateService.getRate(rateSymbol);\n  } catch (error: any) {\n    logger.warn('Exchange rate unavailable for checkout session', {\n      checkoutSessionId: checkoutSession.id,\n      currencyId,\n      currencySymbol: currency.symbol,\n      error: error.message,\n    });\n\n    // Return without quotes, frontend will show warning\n    return {\n      lineItems,\n      quotes: {},\n      rateUnavailable: true,\n      rateError: error.message || 'Exchange rate service unavailable',\n    };\n  }\n\n  logger.info('Fetched exchange rate for batch quote creation', {\n    currencyId,\n    currencySymbol: currency.symbol,\n    rate: rateResult.rate,\n    provider: rateResult.provider_name,\n    dynamicItemsCount: dynamicItems.length,\n  });\n\n  // Create quotes for all dynamic items using the same exchange rate\n  const quoteResults = await Promise.all(\n    dynamicItems.map(async (item) => {\n      const { price, quantity } = item;\n\n      try {\n        const quoteResponse = await quoteService.createQuoteWithRate({\n          price_id: price.id,\n          session_id: checkoutSession.id,\n          target_currency_id: currencyId,\n          quantity,\n          rateResult,\n        });\n\n        return {\n          item,\n          quoteResponse,\n        };\n      } catch (error) {\n        logger.error('Failed to create quote for dynamic price', {\n          priceId: price.id,\n          checkoutSessionId: checkoutSession.id,\n          currencyId,\n          error: (error as Error).message,\n        });\n        throw error;\n      }\n    })\n  );\n\n  // Build quote map for quick lookup\n  const quoteByPriceId = new Map<string, (typeof quoteResults)[0]>();\n  quoteResults.forEach((result) => {\n    quoteByPriceId.set(result.item.price.id, result);\n  });\n\n  // Extract quote info helper\n  const extractQuoteInfo = (quoteResponse: QuoteResponse) => ({\n    quote_id: quoteResponse.quote.id,\n    expires_at: quoteResponse.expires_at,\n    quoted_amount: quoteResponse.computed_unit_amount,\n    exchange_rate: quoteResponse.quote.exchange_rate,\n    rate_provider_name: quoteResponse.quote.rate_provider_name,\n    rate_provider_id: quoteResponse.quote.rate_provider_id,\n  });\n\n  // Build quotes object\n  quoteResults.forEach((result) => {\n    const quoteKey = `${result.item.price.id}_${currencyId}`;\n    quotes[quoteKey] = extractQuoteInfo(result.quoteResponse);\n  });\n\n  // Enrich line items with quote information\n  const enrichedLineItems = lineItems.map((item) => {\n    const quoteInfo = quoteByPriceId.get(item.price.id);\n    if (!quoteInfo) {\n      return item;\n    }\n\n    const quoteData = extractQuoteInfo(quoteInfo.quoteResponse);\n    return {\n      ...item,\n      ...quoteData,\n      custom_amount: quoteInfo.quoteResponse.computed_unit_amount,\n    };\n  });\n\n  return {\n    lineItems: enrichedLineItems,\n    quotes,\n  };\n}\n","numLines":1430,"startLine":1,"totalLines":1430}}}
{"parentUuid":"90274154-3173-45fd-993f-68455c30646f","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VzUJT35h7vT1GXH6b6UEN4","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我查看connect/shared.ts中的关键函数："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":28855,"cache_read_input_tokens":36584,"cache_creation":{"ephemeral_5m_input_tokens":28855,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL2ZRDJa72gaUz4ZChN","type":"assistant","uuid":"ab10c2ac-750c-49a3-b7fa-759c909f4125","timestamp":"2026-01-06T15:03:57.272Z"}
{"parentUuid":"ab10c2ac-750c-49a3-b7fa-759c909f4125","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VzUJT35h7vT1GXH6b6UEN4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HuvuXYAPz6HCEZbyn8toxp","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts","offset":380,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":28855,"cache_read_input_tokens":36584,"cache_creation":{"ephemeral_5m_input_tokens":28855,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL2ZRDJa72gaUz4ZChN","type":"assistant","uuid":"aff71b62-4e78-4010-ba8b-909b37cf3960","timestamp":"2026-01-06T15:03:59.217Z"}
{"parentUuid":"aff71b62-4e78-4010-ba8b-909b37cf3960","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VzUJT35h7vT1GXH6b6UEN4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JtMA3FCMtPGNARnACZSpGy","name":"Grep","input":{"pattern":"lineItemsWithQuotes","output_mode":"content","-B":10,"-A":20,"path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","head_limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":28855,"cache_read_input_tokens":36584,"cache_creation":{"ephemeral_5m_input_tokens":28855,"ephemeral_1h_input_tokens":0},"output_tokens":305,"service_tier":"standard"}},"requestId":"req_011CWrL2ZRDJa72gaUz4ZChN","type":"assistant","uuid":"492ffc1a-4c6a-4a58-a458-e22a00c0d7be","timestamp":"2026-01-06T15:04:01.075Z"}
{"parentUuid":"492ffc1a-4c6a-4a58-a458-e22a00c0d7be","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HuvuXYAPz6HCEZbyn8toxp","type":"tool_result","content":"   380→  paymentIntent?: PaymentIntent;\n   381→  subscription?: Subscription;\n   382→  props?: Partial<TInvoice>;\n   383→  subscriptions?: Subscription[];\n   384→  lineItems?: TLineItemExpanded[];\n   385→};\n   386→\n   387→export async function ensureInvoiceForCheckout({\n   388→  checkoutSession,\n   389→  customer,\n   390→  paymentIntent,\n   391→  subscription,\n   392→  props,\n   393→  subscriptions,\n   394→  lineItems,\n   395→}: Args): Promise<{ invoice: Invoice | null; items: InvoiceItem[] }> {\n   396→  const isGroupInvoice = subscriptions && subscriptions.length > 1;\n   397→  // invoices are optional when checkout session is in payment mode\n   398→  if (checkoutSession.mode === 'payment' && !checkoutSession.invoice_creation?.enabled) {\n   399→    logger.warn('Invoice creation disabled for payment mode');\n   400→    return { invoice: null, items: [] };\n   401→  }\n   402→\n   403→  const existingInvoice = checkoutSession.invoice_id || (isGroupInvoice && subscription?.latest_invoice_id);\n   404→  // Do not create invoice if it's already created\n   405→  if (existingInvoice) {\n   406→    logger.info(`Invoice already created for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n   407→    const invoice = await Invoice.findByPk(existingInvoice);\n   408→    if (invoice) {\n   409→      if (invoice.status === 'paid') {\n   410→        logger.info(`Invoice already paid for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n   411→        throw new Error('Invoice already paid');\n   412→      }\n   413→\n   414→      // invoice currency is aligned\n   415→      if (invoice.currency_id === checkoutSession.currency_id && invoice.status !== 'draft') {\n   416→        await invoice.update({ status: 'open' });\n   417→        logger.info(`Invoice status reset for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n   418→\n   419→        if (invoice.payment_intent_id) {\n   420→          await PaymentIntent.update({ status: 'requires_capture' }, { where: { id: invoice.payment_intent_id } });\n   421→          logger.info(\n   422→            `PaymentIntent status reset for checkout session ${checkoutSession.id}: ${invoice.payment_intent_id}`\n   423→          );\n   424→        }\n   425→\n   426→        // Reset related quotes to allow retry payment\n   427→        // Find quotes associated with this invoice and checkout session\n   428→        const relatedQuotes = await PriceQuote.findAll({\n   429→          where: {\n   430→            [Op.or]: [\n   431→              { session_id: checkoutSession.id },\n   432→              { invoice_id: existingInvoice }\n   433→            ],\n   434→            status: { [Op.in]: ['used', 'paid'] }\n   435→          }\n   436→        });\n   437→\n   438→        // Reset non-expired quotes to 'active' status, mark expired ones as 'expired'\n   439→        const now = Math.floor(Date.now() / 1000);\n   440→        const resetToActivePromises = relatedQuotes\n   441→          .filter((quote) => quote.expires_at > now)\n   442→          .map((quote) => quote.update({ status: 'active' }));\n   443→\n   444→        const markExpiredPromises = relatedQuotes\n   445→          .filter((quote) => quote.expires_at <= now)\n   446→          .map((quote) => quote.update({ status: 'expired' }));\n   447→\n   448→        const allPromises = [...resetToActivePromises, ...markExpiredPromises];\n   449→        if (allPromises.length > 0) {\n   450→          await Promise.all(allPromises);\n   451→          logger.info('Reset quotes for retry payment', {\n   452→            checkoutSessionId: checkoutSession.id,\n   453→            invoiceId: existingInvoice,\n   454→            resetToActive: resetToActivePromises.length,\n   455→            markedExpired: markExpiredPromises.length,\n   456→            quoteIds: relatedQuotes.map((q) => q.id),\n   457→          });\n   458→        }\n   459→\n   460→        return {\n   461→          invoice,\n   462→          items: await InvoiceItem.findAll({ where: { invoice_id: existingInvoice } }),\n   463→        };\n   464→      }\n   465→\n   466→      // invalid currency not aligned: we should generate new invoice\n   467→      await invoice.update({ status: 'void' });\n   468→      logger.info(`Invoice marked void for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n   469→      const method = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n   470→      if (method?.type === 'stripe' && invoice.metadata?.stripe_id) {\n   471→        const client = method.getStripeClient();\n   472→        client.invoices\n   473→          .voidInvoice(invoice.metadata.stripe_id)\n   474→          .then(() => {\n   475→            logger.info(`Invoice marked void on stripe for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n   476→          })\n   477→          .catch((err) => {\n   478→            logger.error(\n   479→              `Invoice marked void on stripe failed for checkout session ${checkoutSession.id}: ${existingInvoice}`,\n   480→              err\n   481→            );\n   482→          });\n   483→      }\n   484→    }\n   485→  }\n   486→\n   487→  const currency = await PaymentCurrency.findByPk(checkoutSession.currency_id);\n   488→\n   489→  const metadata = {\n   490→    ...(checkoutSession.invoice_creation?.invoice_data?.metadata || {}),\n   491→  };\n   492→\n   493→  if (isGroupInvoice) {\n   494→    metadata.subscription_ids = subscriptions.map((sub) => sub.id);\n   495→    metadata.is_group_invoice = true;\n   496→  }\n   497→\n   498→  const trialInDays = Number(checkoutSession.subscription_data?.trial_period_days || 0);\n   499→  const trialEnd = Number(checkoutSession.subscription_data?.trial_end || 0);\n   500→  const now = dayjs().unix();\n   501→  const invoiceItems = lineItems || (await Price.expand(checkoutSession.line_items, { product: true }));\n   502→\n   503→  // Get discount records for this checkout session\n   504→  let discountInfo: { appliedDiscounts: string[]; discountBreakdown: Array<{ amount: string; discount: string }> } = {\n   505→    appliedDiscounts: [],\n   506→    discountBreakdown: [],\n   507→  };\n   508→\n   509→  // Prepare discount configuration for getCheckoutAmount\n   510→  let discountConfig;\n   511→  try {\n   512→    discountInfo = await getDiscountRecordsForCheckout({\n   513→      checkoutSessionId: checkoutSession.id,\n   514→      customerId: customer.id,\n   515→    });\n   516→\n   517→    // Apply discount if we have discount records\n   518→    if (discountInfo.appliedDiscounts.length > 0 && checkoutSession.discounts?.length) {\n   519→      const firstDiscount = checkoutSession.discounts[0];\n   520→      if (firstDiscount?.coupon && firstDiscount?.promotion_code) {\n   521→        discountConfig = {\n   522→          promotionCodeId: firstDiscount.promotion_code,\n   523→          couponId: firstDiscount.coupon,\n   524→          customerId: customer.id,\n   525→        };\n   526→      }\n   527→    }\n   528→  } catch (error) {\n   529→    logger.warn('Failed to get discount records for checkout session', {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b5d22716-8521-4c96-bc23-bc0699e92a5e","timestamp":"2026-01-06T15:04:01.133Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts","content":"  paymentIntent?: PaymentIntent;\n  subscription?: Subscription;\n  props?: Partial<TInvoice>;\n  subscriptions?: Subscription[];\n  lineItems?: TLineItemExpanded[];\n};\n\nexport async function ensureInvoiceForCheckout({\n  checkoutSession,\n  customer,\n  paymentIntent,\n  subscription,\n  props,\n  subscriptions,\n  lineItems,\n}: Args): Promise<{ invoice: Invoice | null; items: InvoiceItem[] }> {\n  const isGroupInvoice = subscriptions && subscriptions.length > 1;\n  // invoices are optional when checkout session is in payment mode\n  if (checkoutSession.mode === 'payment' && !checkoutSession.invoice_creation?.enabled) {\n    logger.warn('Invoice creation disabled for payment mode');\n    return { invoice: null, items: [] };\n  }\n\n  const existingInvoice = checkoutSession.invoice_id || (isGroupInvoice && subscription?.latest_invoice_id);\n  // Do not create invoice if it's already created\n  if (existingInvoice) {\n    logger.info(`Invoice already created for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n    const invoice = await Invoice.findByPk(existingInvoice);\n    if (invoice) {\n      if (invoice.status === 'paid') {\n        logger.info(`Invoice already paid for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n        throw new Error('Invoice already paid');\n      }\n\n      // invoice currency is aligned\n      if (invoice.currency_id === checkoutSession.currency_id && invoice.status !== 'draft') {\n        await invoice.update({ status: 'open' });\n        logger.info(`Invoice status reset for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n\n        if (invoice.payment_intent_id) {\n          await PaymentIntent.update({ status: 'requires_capture' }, { where: { id: invoice.payment_intent_id } });\n          logger.info(\n            `PaymentIntent status reset for checkout session ${checkoutSession.id}: ${invoice.payment_intent_id}`\n          );\n        }\n\n        // Reset related quotes to allow retry payment\n        // Find quotes associated with this invoice and checkout session\n        const relatedQuotes = await PriceQuote.findAll({\n          where: {\n            [Op.or]: [\n              { session_id: checkoutSession.id },\n              { invoice_id: existingInvoice }\n            ],\n            status: { [Op.in]: ['used', 'paid'] }\n          }\n        });\n\n        // Reset non-expired quotes to 'active' status, mark expired ones as 'expired'\n        const now = Math.floor(Date.now() / 1000);\n        const resetToActivePromises = relatedQuotes\n          .filter((quote) => quote.expires_at > now)\n          .map((quote) => quote.update({ status: 'active' }));\n\n        const markExpiredPromises = relatedQuotes\n          .filter((quote) => quote.expires_at <= now)\n          .map((quote) => quote.update({ status: 'expired' }));\n\n        const allPromises = [...resetToActivePromises, ...markExpiredPromises];\n        if (allPromises.length > 0) {\n          await Promise.all(allPromises);\n          logger.info('Reset quotes for retry payment', {\n            checkoutSessionId: checkoutSession.id,\n            invoiceId: existingInvoice,\n            resetToActive: resetToActivePromises.length,\n            markedExpired: markExpiredPromises.length,\n            quoteIds: relatedQuotes.map((q) => q.id),\n          });\n        }\n\n        return {\n          invoice,\n          items: await InvoiceItem.findAll({ where: { invoice_id: existingInvoice } }),\n        };\n      }\n\n      // invalid currency not aligned: we should generate new invoice\n      await invoice.update({ status: 'void' });\n      logger.info(`Invoice marked void for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n      const method = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n      if (method?.type === 'stripe' && invoice.metadata?.stripe_id) {\n        const client = method.getStripeClient();\n        client.invoices\n          .voidInvoice(invoice.metadata.stripe_id)\n          .then(() => {\n            logger.info(`Invoice marked void on stripe for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n          })\n          .catch((err) => {\n            logger.error(\n              `Invoice marked void on stripe failed for checkout session ${checkoutSession.id}: ${existingInvoice}`,\n              err\n            );\n          });\n      }\n    }\n  }\n\n  const currency = await PaymentCurrency.findByPk(checkoutSession.currency_id);\n\n  const metadata = {\n    ...(checkoutSession.invoice_creation?.invoice_data?.metadata || {}),\n  };\n\n  if (isGroupInvoice) {\n    metadata.subscription_ids = subscriptions.map((sub) => sub.id);\n    metadata.is_group_invoice = true;\n  }\n\n  const trialInDays = Number(checkoutSession.subscription_data?.trial_period_days || 0);\n  const trialEnd = Number(checkoutSession.subscription_data?.trial_end || 0);\n  const now = dayjs().unix();\n  const invoiceItems = lineItems || (await Price.expand(checkoutSession.line_items, { product: true }));\n\n  // Get discount records for this checkout session\n  let discountInfo: { appliedDiscounts: string[]; discountBreakdown: Array<{ amount: string; discount: string }> } = {\n    appliedDiscounts: [],\n    discountBreakdown: [],\n  };\n\n  // Prepare discount configuration for getCheckoutAmount\n  let discountConfig;\n  try {\n    discountInfo = await getDiscountRecordsForCheckout({\n      checkoutSessionId: checkoutSession.id,\n      customerId: customer.id,\n    });\n\n    // Apply discount if we have discount records\n    if (discountInfo.appliedDiscounts.length > 0 && checkoutSession.discounts?.length) {\n      const firstDiscount = checkoutSession.discounts[0];\n      if (firstDiscount?.coupon && firstDiscount?.promotion_code) {\n        discountConfig = {\n          promotionCodeId: firstDiscount.promotion_code,\n          couponId: firstDiscount.coupon,\n          customerId: customer.id,\n        };\n      }\n    }\n  } catch (error) {\n    logger.warn('Failed to get discount records for checkout session', {","numLines":150,"startLine":380,"totalLines":1640}}}
{"parentUuid":"b5d22716-8521-4c96-bc23-bc0699e92a5e","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JtMA3FCMtPGNARnACZSpGy","type":"tool_result","content":"1804-    const { paymentMethod, paymentCurrency } = await validatePaymentSettings(\n1805-      req.body.payment_method,\n1806-      req.body.payment_currency\n1807-    );\n1808-    await checkoutSession.update({\n1809-      currency_id: paymentCurrency.id,\n1810-      metadata: { ...checkoutSession.metadata, preferred_locale: req.locale },\n1811-    });\n1812-\n1813-    const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n1814:    let lineItemsWithQuotes = expandedLineItems;\n1815-\n1816-    try {\n1817-      / TODO: why we need to attach quotes to line items here?\n1818-      const quoteResult = await attachQuotesToLineItems({\n1819-        checkoutSession,\n1820-        lineItems: expandedLineItems,\n1821-        paymentCurrencyId: paymentCurrency.id,\n1822-        quotesInput: req.body.quotes,\n1823-      });\n1824-      consumedQuotes = quoteResult.consumedQuotes;\n1825:      lineItemsWithQuotes = quoteResult.lineItems;\n1826-    } catch (err) {\n1827-      if (err instanceof CustomError) {\n1828-        return res.status(400).json({ code: err.code || 'QUOTE_INVALID', error: err.message });\n1829-      }\n1830-      throw err;\n1831-    }\n1832-\n1833-    let customer = await Customer.findOne({ where: { did: req.user.did } });\n1834-    if (!customer) {\n1835-      const { user: userInfo } = await blocklet.getUser(req.user.did);\n1836-      customer = await Customer.create({\n1837-        livemode: !!checkoutSession.livemode,\n1838-        did: req.user.did,\n1839-        name: req.body.customer_name,\n1840-        email: req.body.customer_email || userInfo?.email || '',\n1841-        phone: req.body.customer_phone || userInfo?.phone || '',\n1842-        address: req.body.billing_address || Customer.formatAddressFromUser(userInfo),\n1843-        description: userInfo?.remark || '',\n1844-        metadata: {},\n1845-        balance: '0',\n--\n1949-    }\n1950-\n1951-    await checkoutSession.update({ customer_id: customer.id, customer_did: req.user.did });\n1952-\n1953-    // Verify and recalculate amount with current discounts\n1954-    const { lineItems, trialInDays, trialEnd, now } = await calculateAndUpdateAmount(\n1955-      checkoutSession,\n1956-      paymentCurrency.id,\n1957-      true,\n1958-      {\n1959:        lineItemsOverride: lineItemsWithQuotes,\n1960-      }\n1961-    );\n1962-\n1963-    // Validate payment amounts meet minimum requirements\n1964-    if (paymentMethod.type === 'stripe') {\n1965-      const result = await validatePaymentAmounts(lineItems, paymentCurrency, checkoutSession);\n1966-      if (!result.valid) {\n1967-        return res.status(400).json({ error: result.error });\n1968-      }\n1969-    }\n1970-\n1971-    // Validate checkout session ownership if it was created for a specific customer\n1972-    if (checkoutSession.customer_did && checkoutSession.metadata?.createdBy) {\n1973-      const createdByDid = checkoutSession.metadata.createdBy;\n1974-      if (createdByDid !== req.user.did) {\n1975-        return res.status(403).json({\n1976-          error:\n1977-            \"It's not allowed to submit checkout sessions created by other users, please create your own checkout session\",\n1978-        });\n1979-      }\n--\n2462-    }\n2463-\n2464-    // validate payment settings\n2465-    const { paymentMethod, paymentCurrency } = await validatePaymentSettings(\n2466-      req.body.payment_method,\n2467-      req.body.payment_currency\n2468-    );\n2469-    await checkoutSession.update({ currency_id: paymentCurrency.id });\n2470-\n2471-    const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n2472:    let lineItemsWithQuotes = expandedLineItems;\n2473-    try {\n2474-      const quoteResult = await attachQuotesToLineItems({\n2475-        checkoutSession,\n2476-        lineItems: expandedLineItems,\n2477-        paymentCurrencyId: paymentCurrency.id,\n2478-        quotesInput: req.body.quotes,\n2479-      });\n2480-      consumedQuotes = quoteResult.consumedQuotes;\n2481:      lineItemsWithQuotes = quoteResult.lineItems;\n2482-    } catch (err) {\n2483-      if (err instanceof CustomError) {\n2484-        return res.status(400).json({ code: err.code || 'QUOTE_INVALID', error: err.message });\n2485-      }\n2486-      throw err;\n\n[Showing results with pagination = limit: 100, offset: 0]"}]},"uuid":"0de83097-f872-4e9a-a2ed-32b21e44ced2","timestamp":"2026-01-06T15:04:01.143Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"1804-    const { paymentMethod, paymentCurrency } = await validatePaymentSettings(\n1805-      req.body.payment_method,\n1806-      req.body.payment_currency\n1807-    );\n1808-    await checkoutSession.update({\n1809-      currency_id: paymentCurrency.id,\n1810-      metadata: { ...checkoutSession.metadata, preferred_locale: req.locale },\n1811-    });\n1812-\n1813-    const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n1814:    let lineItemsWithQuotes = expandedLineItems;\n1815-\n1816-    try {\n1817-      / TODO: why we need to attach quotes to line items here?\n1818-      const quoteResult = await attachQuotesToLineItems({\n1819-        checkoutSession,\n1820-        lineItems: expandedLineItems,\n1821-        paymentCurrencyId: paymentCurrency.id,\n1822-        quotesInput: req.body.quotes,\n1823-      });\n1824-      consumedQuotes = quoteResult.consumedQuotes;\n1825:      lineItemsWithQuotes = quoteResult.lineItems;\n1826-    } catch (err) {\n1827-      if (err instanceof CustomError) {\n1828-        return res.status(400).json({ code: err.code || 'QUOTE_INVALID', error: err.message });\n1829-      }\n1830-      throw err;\n1831-    }\n1832-\n1833-    let customer = await Customer.findOne({ where: { did: req.user.did } });\n1834-    if (!customer) {\n1835-      const { user: userInfo } = await blocklet.getUser(req.user.did);\n1836-      customer = await Customer.create({\n1837-        livemode: !!checkoutSession.livemode,\n1838-        did: req.user.did,\n1839-        name: req.body.customer_name,\n1840-        email: req.body.customer_email || userInfo?.email || '',\n1841-        phone: req.body.customer_phone || userInfo?.phone || '',\n1842-        address: req.body.billing_address || Customer.formatAddressFromUser(userInfo),\n1843-        description: userInfo?.remark || '',\n1844-        metadata: {},\n1845-        balance: '0',\n--\n1949-    }\n1950-\n1951-    await checkoutSession.update({ customer_id: customer.id, customer_did: req.user.did });\n1952-\n1953-    // Verify and recalculate amount with current discounts\n1954-    const { lineItems, trialInDays, trialEnd, now } = await calculateAndUpdateAmount(\n1955-      checkoutSession,\n1956-      paymentCurrency.id,\n1957-      true,\n1958-      {\n1959:        lineItemsOverride: lineItemsWithQuotes,\n1960-      }\n1961-    );\n1962-\n1963-    // Validate payment amounts meet minimum requirements\n1964-    if (paymentMethod.type === 'stripe') {\n1965-      const result = await validatePaymentAmounts(lineItems, paymentCurrency, checkoutSession);\n1966-      if (!result.valid) {\n1967-        return res.status(400).json({ error: result.error });\n1968-      }\n1969-    }\n1970-\n1971-    // Validate checkout session ownership if it was created for a specific customer\n1972-    if (checkoutSession.customer_did && checkoutSession.metadata?.createdBy) {\n1973-      const createdByDid = checkoutSession.metadata.createdBy;\n1974-      if (createdByDid !== req.user.did) {\n1975-        return res.status(403).json({\n1976-          error:\n1977-            \"It's not allowed to submit checkout sessions created by other users, please create your own checkout session\",\n1978-        });\n1979-      }\n--\n2462-    }\n2463-\n2464-    // validate payment settings\n2465-    const { paymentMethod, paymentCurrency } = await validatePaymentSettings(\n2466-      req.body.payment_method,\n2467-      req.body.payment_currency\n2468-    );\n2469-    await checkoutSession.update({ currency_id: paymentCurrency.id });\n2470-\n2471-    const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n2472:    let lineItemsWithQuotes = expandedLineItems;\n2473-    try {\n2474-      const quoteResult = await attachQuotesToLineItems({\n2475-        checkoutSession,\n2476-        lineItems: expandedLineItems,\n2477-        paymentCurrencyId: paymentCurrency.id,\n2478-        quotesInput: req.body.quotes,\n2479-      });\n2480-      consumedQuotes = quoteResult.consumedQuotes;\n2481:      lineItemsWithQuotes = quoteResult.lineItems;\n2482-    } catch (err) {\n2483-      if (err instanceof CustomError) {\n2484-        return res.status(400).json({ code: err.code || 'QUOTE_INVALID', error: err.message });\n2485-      }\n2486-      throw err;","numLines":100,"appliedLimit":100}}
{"parentUuid":"0de83097-f872-4e9a-a2ed-32b21e44ced2","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019m65UemF52u9qrbEbB36KU","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我继续查看shared.ts中的剩余逻辑和Price模型："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4362,"cache_read_input_tokens":65439,"cache_creation":{"ephemeral_5m_input_tokens":4362,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL3A6nfHbaLkSDjL5Ux","type":"assistant","uuid":"d91b1c6a-0c6a-4511-be92-ef5d85178932","timestamp":"2026-01-06T15:04:05.618Z"}
{"parentUuid":"d91b1c6a-0c6a-4511-be92-ef5d85178932","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019m65UemF52u9qrbEbB36KU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y6cWxhY5rHQMgTUDNo5Szq","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts","offset":520,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4362,"cache_read_input_tokens":65439,"cache_creation":{"ephemeral_5m_input_tokens":4362,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL3A6nfHbaLkSDjL5Ux","type":"assistant","uuid":"cc56750d-fba3-4fba-b8d7-214f3399ef99","timestamp":"2026-01-06T15:04:07.239Z"}
{"parentUuid":"cc56750d-fba3-4fba-b8d7-214f3399ef99","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019m65UemF52u9qrbEbB36KU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M268MmJwiNWXFArUhcUEKm","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts","offset":1,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4362,"cache_read_input_tokens":65439,"cache_creation":{"ephemeral_5m_input_tokens":4362,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL3A6nfHbaLkSDjL5Ux","type":"assistant","uuid":"38c0cbf0-7de6-4794-be49-6c0c267a7c0a","timestamp":"2026-01-06T15:04:08.207Z"}
{"parentUuid":"38c0cbf0-7de6-4794-be49-6c0c267a7c0a","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_019m65UemF52u9qrbEbB36KU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0127qkLKDLns9VpQ7N3pATvZ","name":"Grep","input":{"pattern":"pricing_type.*dynamic","output_mode":"content","-B":3,"-A":3,"path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4362,"cache_read_input_tokens":65439,"cache_creation":{"ephemeral_5m_input_tokens":4362,"ephemeral_1h_input_tokens":0},"output_tokens":392,"service_tier":"standard"}},"requestId":"req_011CWrL3A6nfHbaLkSDjL5Ux","type":"assistant","uuid":"cd798ad0-b00f-4a21-93ae-75dedcc3473e","timestamp":"2026-01-06T15:04:09.837Z"}
{"parentUuid":"cd798ad0-b00f-4a21-93ae-75dedcc3473e","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y6cWxhY5rHQMgTUDNo5Szq","type":"tool_result","content":"   520→      if (firstDiscount?.coupon && firstDiscount?.promotion_code) {\n   521→        discountConfig = {\n   522→          promotionCodeId: firstDiscount.promotion_code,\n   523→          couponId: firstDiscount.coupon,\n   524→          customerId: customer.id,\n   525→        };\n   526→      }\n   527→    }\n   528→  } catch (error) {\n   529→    logger.warn('Failed to get discount records for checkout session', {\n   530→      checkoutSessionId: checkoutSession.id,\n   531→      customerId: customer.id,\n   532→      error: error.message,\n   533→    });\n   534→  }\n   535→\n   536→  const totalAmount = await getCheckoutAmount(\n   537→    invoiceItems,\n   538→    checkoutSession.currency_id,\n   539→    trialInDays > 0 || trialEnd > now,\n   540→    discountConfig\n   541→  );\n   542→  const { invoice, items } = await ensureInvoiceAndItems({\n   543→    customer,\n   544→    currency: currency as PaymentCurrency,\n   545→    subscription,\n   546→    lineItems: invoiceItems,\n   547→    trialing: !!checkoutSession.subscription_data?.trial_period_days,\n   548→    metered: false,\n   549→    props: {\n   550→      livemode: checkoutSession.livemode,\n   551→      description:\n   552→        checkoutSession.invoice_creation?.invoice_data?.description ||\n   553→        paymentIntent?.description ||\n   554→        'Subscription creation',\n   555→      statement_descriptor: paymentIntent?.statement_descriptor || getStatementDescriptor(checkoutSession.line_items),\n   556→      period_start: subscription?.current_period_start ?? 0,\n   557→      period_end: subscription?.current_period_end ?? 0,\n   558→\n   559→      auto_advance: !paymentIntent,\n   560→      billing_reason: subscription ? 'subscription_create' : 'manual',\n   561→\n   562→      currency_id: checkoutSession.currency_id,\n   563→      payment_intent_id: paymentIntent?.id,\n   564→      checkout_session_id: checkoutSession.id,\n   565→\n   566→      total: totalAmount.total,\n   567→      subtotal: totalAmount.subtotal,\n   568→\n   569→      default_payment_method_id: (subscription?.default_payment_method_id ||\n   570→        paymentIntent?.payment_method_id) as string,\n   571→\n   572→      custom_fields: checkoutSession.invoice_creation?.invoice_data?.custom_fields || [],\n   573→      footer: checkoutSession.invoice_creation?.invoice_data?.footer || '',\n   574→      metadata,\n   575→\n   576→      discounts: discountInfo.appliedDiscounts,\n   577→      total_discount_amounts: discountInfo.discountBreakdown,\n   578→\n   579→      ...(props || {}),\n   580→    } as unknown as Invoice,\n   581→  });\n   582→\n   583→  logger.info('Invoice created for checkoutSession', {\n   584→    checkoutSessionId: checkoutSession.id,\n   585→    invoiceId: invoice.id,\n   586→    hasDiscounts: discountInfo.appliedDiscounts.length > 0,\n   587→    discountCount: discountInfo.appliedDiscounts.length,\n   588→  });\n   589→\n   590→  // only update invoice_id for single invoice\n   591→  if (!isGroupInvoice) {\n   592→    await checkoutSession.update({ invoice_id: invoice.id });\n   593→  }\n   594→  if (paymentIntent) {\n   595→    await paymentIntent.update({ invoice_id: invoice.id });\n   596→  }\n   597→  if (subscription) {\n   598→    await subscription.update({ latest_invoice_id: invoice.id });\n   599→  }\n   600→\n   601→  return { invoice, items };\n   602→}\n   603→\n   604→export async function ensureInvoicesForSubscriptions({\n   605→  checkoutSession,\n   606→  customer,\n   607→  subscriptions,\n   608→  invoiceProps,\n   609→}: Omit<Args, 'subscription'> & { subscriptions: Subscription[]; invoiceProps?: Partial<TInvoice> }): Promise<{\n   610→  invoices: Invoice[];\n   611→}> {\n   612→  if (!subscriptions?.length) {\n   613→    logger.warn('No subscriptions provided for invoice creation');\n   614→    return { invoices: [] };\n   615→  }\n   616→\n   617→  const lineItems = await Price.expand(checkoutSession.line_items, { product: true });\n   618→\n   619→  const primarySubscription = (subscriptions.find((x) => x.metadata.is_primary_subscription) ||\n   620→    subscriptions[0]) as Subscription;\n   621→  const invoices = await Promise.all(\n   622→    subscriptions.map(async (subscription) => {\n   623→      const subItems = await getSubscriptionLineItems(subscription, lineItems, primarySubscription);\n   624→      const { invoice } = await ensureInvoiceForCheckout({\n   625→        checkoutSession,\n   626→        customer,\n   627→        subscription,\n   628→        subscriptions,\n   629→        lineItems: subItems,\n   630→        props: invoiceProps,\n   631→      });\n   632→      return invoice;\n   633→    })\n   634→  );\n   635→\n   636→  const createdInvoices = invoices.filter(Boolean);\n   637→\n   638→  logger.info(`Created ${createdInvoices.length} invoices for subscriptions`, {\n   639→    checkoutSessionId: checkoutSession.id,\n   640→    invoiceIds: createdInvoices.map((inv) => inv?.id),\n   641→  });\n   642→\n   643→  return { invoices: createdInvoices as Invoice[] };\n   644→}\n   645→\n   646→export async function ensureInvoiceForCollect(invoiceId: string) {\n   647→  const invoice = await Invoice.findByPk(invoiceId);\n   648→  if (!invoice) {\n   649→    throw new Error(`Invoice ${invoiceId} not found`);\n   650→  }\n   651→  if (invoice.status === 'paid') {\n   652→    throw new Error(`Invoice ${invoiceId} already paid`);\n   653→  }\n   654→  if (invoice.status === 'void') {\n   655→    throw new Error(`Invoice ${invoiceId} already void`);\n   656→  }\n   657→  if (invoice.status === 'draft') {\n   658→    throw new Error(`Invoice ${invoiceId} is draft`);\n   659→  }\n   660→\n   661→  if (!invoice.payment_intent_id) {\n   662→    await invoiceQueue.pushAndWait({\n   663→      id: invoice.id,\n   664→      job: { invoiceId: invoice.id, retryOnError: false, justCreate: true },\n   665→    });\n   666→    await invoice.reload();\n   667→  }\n   668→\n   669→  const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5f37ce64-cbe4-4c92-99a4-bba1bc728115","timestamp":"2026-01-06T15:04:09.894Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts","content":"      if (firstDiscount?.coupon && firstDiscount?.promotion_code) {\n        discountConfig = {\n          promotionCodeId: firstDiscount.promotion_code,\n          couponId: firstDiscount.coupon,\n          customerId: customer.id,\n        };\n      }\n    }\n  } catch (error) {\n    logger.warn('Failed to get discount records for checkout session', {\n      checkoutSessionId: checkoutSession.id,\n      customerId: customer.id,\n      error: error.message,\n    });\n  }\n\n  const totalAmount = await getCheckoutAmount(\n    invoiceItems,\n    checkoutSession.currency_id,\n    trialInDays > 0 || trialEnd > now,\n    discountConfig\n  );\n  const { invoice, items } = await ensureInvoiceAndItems({\n    customer,\n    currency: currency as PaymentCurrency,\n    subscription,\n    lineItems: invoiceItems,\n    trialing: !!checkoutSession.subscription_data?.trial_period_days,\n    metered: false,\n    props: {\n      livemode: checkoutSession.livemode,\n      description:\n        checkoutSession.invoice_creation?.invoice_data?.description ||\n        paymentIntent?.description ||\n        'Subscription creation',\n      statement_descriptor: paymentIntent?.statement_descriptor || getStatementDescriptor(checkoutSession.line_items),\n      period_start: subscription?.current_period_start ?? 0,\n      period_end: subscription?.current_period_end ?? 0,\n\n      auto_advance: !paymentIntent,\n      billing_reason: subscription ? 'subscription_create' : 'manual',\n\n      currency_id: checkoutSession.currency_id,\n      payment_intent_id: paymentIntent?.id,\n      checkout_session_id: checkoutSession.id,\n\n      total: totalAmount.total,\n      subtotal: totalAmount.subtotal,\n\n      default_payment_method_id: (subscription?.default_payment_method_id ||\n        paymentIntent?.payment_method_id) as string,\n\n      custom_fields: checkoutSession.invoice_creation?.invoice_data?.custom_fields || [],\n      footer: checkoutSession.invoice_creation?.invoice_data?.footer || '',\n      metadata,\n\n      discounts: discountInfo.appliedDiscounts,\n      total_discount_amounts: discountInfo.discountBreakdown,\n\n      ...(props || {}),\n    } as unknown as Invoice,\n  });\n\n  logger.info('Invoice created for checkoutSession', {\n    checkoutSessionId: checkoutSession.id,\n    invoiceId: invoice.id,\n    hasDiscounts: discountInfo.appliedDiscounts.length > 0,\n    discountCount: discountInfo.appliedDiscounts.length,\n  });\n\n  // only update invoice_id for single invoice\n  if (!isGroupInvoice) {\n    await checkoutSession.update({ invoice_id: invoice.id });\n  }\n  if (paymentIntent) {\n    await paymentIntent.update({ invoice_id: invoice.id });\n  }\n  if (subscription) {\n    await subscription.update({ latest_invoice_id: invoice.id });\n  }\n\n  return { invoice, items };\n}\n\nexport async function ensureInvoicesForSubscriptions({\n  checkoutSession,\n  customer,\n  subscriptions,\n  invoiceProps,\n}: Omit<Args, 'subscription'> & { subscriptions: Subscription[]; invoiceProps?: Partial<TInvoice> }): Promise<{\n  invoices: Invoice[];\n}> {\n  if (!subscriptions?.length) {\n    logger.warn('No subscriptions provided for invoice creation');\n    return { invoices: [] };\n  }\n\n  const lineItems = await Price.expand(checkoutSession.line_items, { product: true });\n\n  const primarySubscription = (subscriptions.find((x) => x.metadata.is_primary_subscription) ||\n    subscriptions[0]) as Subscription;\n  const invoices = await Promise.all(\n    subscriptions.map(async (subscription) => {\n      const subItems = await getSubscriptionLineItems(subscription, lineItems, primarySubscription);\n      const { invoice } = await ensureInvoiceForCheckout({\n        checkoutSession,\n        customer,\n        subscription,\n        subscriptions,\n        lineItems: subItems,\n        props: invoiceProps,\n      });\n      return invoice;\n    })\n  );\n\n  const createdInvoices = invoices.filter(Boolean);\n\n  logger.info(`Created ${createdInvoices.length} invoices for subscriptions`, {\n    checkoutSessionId: checkoutSession.id,\n    invoiceIds: createdInvoices.map((inv) => inv?.id),\n  });\n\n  return { invoices: createdInvoices as Invoice[] };\n}\n\nexport async function ensureInvoiceForCollect(invoiceId: string) {\n  const invoice = await Invoice.findByPk(invoiceId);\n  if (!invoice) {\n    throw new Error(`Invoice ${invoiceId} not found`);\n  }\n  if (invoice.status === 'paid') {\n    throw new Error(`Invoice ${invoiceId} already paid`);\n  }\n  if (invoice.status === 'void') {\n    throw new Error(`Invoice ${invoiceId} already void`);\n  }\n  if (invoice.status === 'draft') {\n    throw new Error(`Invoice ${invoiceId} is draft`);\n  }\n\n  if (!invoice.payment_intent_id) {\n    await invoiceQueue.pushAndWait({\n      id: invoice.id,\n      job: { invoiceId: invoice.id, retryOnError: false, justCreate: true },\n    });\n    await invoice.reload();\n  }\n\n  const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);","numLines":150,"startLine":520,"totalLines":1640}}}
{"parentUuid":"5f37ce64-cbe4-4c92-99a4-bba1bc728115","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M268MmJwiNWXFArUhcUEKm","type":"tool_result","content":"     1→import { fromTokenToUnit } from '@ocap/util';\n     2→import isEmpty from 'lodash/isEmpty';\n     3→import omit from 'lodash/omit';\n     4→import pick from 'lodash/pick';\n     5→import {\n     6→  CreationOptional,\n     7→  DataTypes,\n     8→  FindOptions,\n     9→  InferAttributes,\n    10→  InferCreationAttributes,\n    11→  Model,\n    12→  Op,\n    13→  QueryTypes,\n    14→} from 'sequelize';\n    15→import type { LiteralUnion } from 'type-fest';\n    16→\n    17→import { createEvent } from '../../libs/audit';\n    18→import logger from '../../libs/logger';\n    19→import { createIdGenerator, formatMetadata } from '../../libs/util';\n    20→import { sequelize } from '../sequelize';\n    21→import type { TPaymentCurrency } from './payment-currency';\n    22→import type { CustomUnitAmount, LineItem, PriceCurrency, PriceRecurring, PriceTier, TransformQuantity } from './types';\n    23→import { Meter, type TMeter } from './meter';\n    24→\n    25→export const nextPriceId = createIdGenerator('price', 24);\n    26→\n    27→// Duplicate here\n    28→type TPriceExpanded = TPrice & {\n    29→  object: 'price';\n    30→  product: any;\n    31→  currency: TPaymentCurrency;\n    32→  upsell?: {\n    33→    upsells_to: TPriceExpanded;\n    34→    upsells_to_id: string;\n    35→  };\n    36→  meter?: TMeter;\n    37→};\n    38→type TLineItemExpanded = LineItem & { price: TPriceExpanded; upsell_price: TPriceExpanded };\n    39→\n    40→// @link https://stripe.com/docs/api/prices\n    41→export class Price extends Model<InferAttributes<Price>, InferCreationAttributes<Price>> {\n    42→  // Unique identifier for the object.\n    43→  declare id: CreationOptional<string>;\n    44→\n    45→  // the product id\n    46→  declare product_id: string;\n    47→\n    48→  // A brief description of the price, hidden from customers.\n    49→  declare nickname: string | null;\n    50→\n    51→  // Whether the price can be used for new purchases.\n    52→  declare active: boolean;\n    53→  declare livemode: boolean;\n    54→  declare locked: CreationOptional<boolean>;\n    55→\n    56→  // One of one_time or recurring depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.\n    57→  declare type: LiteralUnion<'one_time' | 'recurring', string>;\n    58→\n    59→  // Describes how to compute the price per period.\n    60→  declare billing_scheme: LiteralUnion<'per_unit' | 'tiered', string>;\n    61→\n    62→  // The unit amount in big number to be charged, represented as a whole integer if possible\n    63→  declare unit_amount: string;\n    64→\n    65→  // The recurring components of a price such as interval and usage_type.\n    66→  declare recurring: PriceRecurring | null;\n    67→\n    68→  // Defines if the tiering price should be graduated or volume based.\n    69→  declare tiers_mode: LiteralUnion<'graduated' | 'volume', string> | null;\n    70→\n    71→  // Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered\n    72→  declare tiers: PriceTier[] | null;\n    73→\n    74→  // When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.\n    75→  declare custom_unit_amount: CustomUnitAmount | null;\n    76→\n    77→  // A lookup key used to retrieve prices dynamically from a static string\n    78→  declare lookup_key: string | null;\n    79→\n    80→  // Set of key-value pairs that you can attach to an object.\n    81→  declare metadata: Record<string, any>;\n    82→\n    83→  declare transform_quantity: TransformQuantity | null;\n    84→\n    85→  // Payment currency id\n    86→  declare currency_id: string;\n    87→  declare currency_options: PriceCurrency[];\n    88→\n    89→  declare upsell?: { upsells_to_id: string } | null;\n    90→\n    91→  declare created_at: CreationOptional<Date>;\n    92→  declare created_via: LiteralUnion<'api' | 'dashboard' | 'portal', string>;\n    93→  declare updated_at: CreationOptional<Date>;\n    94→\n    95→  // Quantity available for purchase,  0 means no limit\n    96→  declare quantity_available: number;\n    97→  // Quantity has been sold\n    98→  declare quantity_sold: number;\n    99→  // Quantity limit per checkout, 0 means no limit\n   100→  declare quantity_limit_per_checkout: number;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"3a5addbd-6206-4dc7-a433-34f7a4d10445","timestamp":"2026-01-06T15:04:09.894Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts","content":"import { fromTokenToUnit } from '@ocap/util';\nimport isEmpty from 'lodash/isEmpty';\nimport omit from 'lodash/omit';\nimport pick from 'lodash/pick';\nimport {\n  CreationOptional,\n  DataTypes,\n  FindOptions,\n  InferAttributes,\n  InferCreationAttributes,\n  Model,\n  Op,\n  QueryTypes,\n} from 'sequelize';\nimport type { LiteralUnion } from 'type-fest';\n\nimport { createEvent } from '../../libs/audit';\nimport logger from '../../libs/logger';\nimport { createIdGenerator, formatMetadata } from '../../libs/util';\nimport { sequelize } from '../sequelize';\nimport type { TPaymentCurrency } from './payment-currency';\nimport type { CustomUnitAmount, LineItem, PriceCurrency, PriceRecurring, PriceTier, TransformQuantity } from './types';\nimport { Meter, type TMeter } from './meter';\n\nexport const nextPriceId = createIdGenerator('price', 24);\n\n// Duplicate here\ntype TPriceExpanded = TPrice & {\n  object: 'price';\n  product: any;\n  currency: TPaymentCurrency;\n  upsell?: {\n    upsells_to: TPriceExpanded;\n    upsells_to_id: string;\n  };\n  meter?: TMeter;\n};\ntype TLineItemExpanded = LineItem & { price: TPriceExpanded; upsell_price: TPriceExpanded };\n\n// @link https://stripe.com/docs/api/prices\nexport class Price extends Model<InferAttributes<Price>, InferCreationAttributes<Price>> {\n  // Unique identifier for the object.\n  declare id: CreationOptional<string>;\n\n  // the product id\n  declare product_id: string;\n\n  // A brief description of the price, hidden from customers.\n  declare nickname: string | null;\n\n  // Whether the price can be used for new purchases.\n  declare active: boolean;\n  declare livemode: boolean;\n  declare locked: CreationOptional<boolean>;\n\n  // One of one_time or recurring depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.\n  declare type: LiteralUnion<'one_time' | 'recurring', string>;\n\n  // Describes how to compute the price per period.\n  declare billing_scheme: LiteralUnion<'per_unit' | 'tiered', string>;\n\n  // The unit amount in big number to be charged, represented as a whole integer if possible\n  declare unit_amount: string;\n\n  // The recurring components of a price such as interval and usage_type.\n  declare recurring: PriceRecurring | null;\n\n  // Defines if the tiering price should be graduated or volume based.\n  declare tiers_mode: LiteralUnion<'graduated' | 'volume', string> | null;\n\n  // Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered\n  declare tiers: PriceTier[] | null;\n\n  // When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.\n  declare custom_unit_amount: CustomUnitAmount | null;\n\n  // A lookup key used to retrieve prices dynamically from a static string\n  declare lookup_key: string | null;\n\n  // Set of key-value pairs that you can attach to an object.\n  declare metadata: Record<string, any>;\n\n  declare transform_quantity: TransformQuantity | null;\n\n  // Payment currency id\n  declare currency_id: string;\n  declare currency_options: PriceCurrency[];\n\n  declare upsell?: { upsells_to_id: string } | null;\n\n  declare created_at: CreationOptional<Date>;\n  declare created_via: LiteralUnion<'api' | 'dashboard' | 'portal', string>;\n  declare updated_at: CreationOptional<Date>;\n\n  // Quantity available for purchase,  0 means no limit\n  declare quantity_available: number;\n  // Quantity has been sold\n  declare quantity_sold: number;\n  // Quantity limit per checkout, 0 means no limit\n  declare quantity_limit_per_checkout: number;","numLines":100,"startLine":1,"totalLines":545}}}
{"parentUuid":"3a5addbd-6206-4dc7-a433-34f7a4d10445","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0127qkLKDLns9VpQ7N3pATvZ","type":"tool_result","content":"api/src/store/models/price.ts-102-  declare tax_behavior?: LiteralUnion<'inclusive' | 'exclusive', string>;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-103-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-104-  // Dynamic pricing fields\napi/src/store/models/price.ts:105:  declare pricing_type: LiteralUnion<'fixed' | 'dynamic', string>;\napi/src/store/models/price.ts-106-  declare base_currency: string | null;\napi/src/store/models/price.ts-107-  declare base_amount: string | null;\napi/src/store/models/price.ts-108-  declare dynamic_pricing_config: { lock_duration?: number } | null;\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-297-\napi/src/store/models/price.ts-298-  public static formatBeforeSave(price: Partial<TPrice & { model: string }>) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-299-    // Validate dynamic pricing fields\napi/src/store/models/price.ts:300:    if (price.pricing_type === 'dynamic') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-301-      if (!price.base_currency || !price.base_amount) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-302-        throw new Error('base_currency and base_amount are required for dynamic pricing');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-303-      }"}]},"uuid":"71c689a8-428d-4d01-8020-ac40ba843085","timestamp":"2026-01-06T15:04:09.908Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"api/src/store/models/price.ts-102-  declare tax_behavior?: LiteralUnion<'inclusive' | 'exclusive', string>;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-103-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-104-  // Dynamic pricing fields\napi/src/store/models/price.ts:105:  declare pricing_type: LiteralUnion<'fixed' | 'dynamic', string>;\napi/src/store/models/price.ts-106-  declare base_currency: string | null;\napi/src/store/models/price.ts-107-  declare base_amount: string | null;\napi/src/store/models/price.ts-108-  declare dynamic_pricing_config: { lock_duration?: number } | null;\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-297-\napi/src/store/models/price.ts-298-  public static formatBeforeSave(price: Partial<TPrice & { model: string }>) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-299-    // Validate dynamic pricing fields\napi/src/store/models/price.ts:300:    if (price.pricing_type === 'dynamic') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-301-      if (!price.base_currency || !price.base_amount) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-302-        throw new Error('base_currency and base_amount are required for dynamic pricing');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts-303-      }","numLines":15}}
{"parentUuid":"71c689a8-428d-4d01-8020-ac40ba843085","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01PG2xPFhTMVZtqerWNhC4hJ","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我查看attachQuotesToLineItems函数的详细实现："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4572,"cache_read_input_tokens":69801,"cache_creation":{"ephemeral_5m_input_tokens":4572,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL3omSa16X9uJ8QP4Gs","type":"assistant","uuid":"021416ba-05fc-4e45-b7f0-2e105b1deb4e","timestamp":"2026-01-06T15:04:14.315Z"}
{"parentUuid":"021416ba-05fc-4e45-b7f0-2e105b1deb4e","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01PG2xPFhTMVZtqerWNhC4hJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01A2vn7aJo2WhrYFxgkaUBpg","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","offset":1530,"limit":150}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4572,"cache_read_input_tokens":69801,"cache_creation":{"ephemeral_5m_input_tokens":4572,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL3omSa16X9uJ8QP4Gs","type":"assistant","uuid":"7bf5cb78-6c7b-4044-b56c-30d5f15612b0","timestamp":"2026-01-06T15:04:15.360Z"}
{"parentUuid":"7bf5cb78-6c7b-4044-b56c-30d5f15612b0","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01PG2xPFhTMVZtqerWNhC4hJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RSpMmQ5e5Qg3N9aGk7HBtz","name":"Grep","input":{"pattern":"custom_amount","output_mode":"content","-B":3,"-A":3,"path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts","head_limit":30}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4572,"cache_read_input_tokens":69801,"cache_creation":{"ephemeral_5m_input_tokens":4572,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL3omSa16X9uJ8QP4Gs","type":"assistant","uuid":"033848d3-4997-4f92-bc3d-c80df5ce3c11","timestamp":"2026-01-06T15:04:17.137Z"}
{"parentUuid":"033848d3-4997-4f92-bc3d-c80df5ce3c11","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01A2vn7aJo2WhrYFxgkaUBpg","type":"tool_result","content":"  1530→}\n  1531→\n  1532→async function attachQuotesToLineItems(options: {\n  1533→  checkoutSession: CheckoutSession;\n  1534→  lineItems: TLineItemExpanded[];\n  1535→  paymentCurrencyId: string;\n  1536→  quotesInput?: QuoteInput[];\n  1537→}) {\n  1538→  const { checkoutSession, lineItems, paymentCurrencyId, quotesInput = [] } = options;\n  1539→  const dynamicItems = lineItems.filter((item) => (item.upsell_price || item.price).pricing_type === 'dynamic');\n  1540→\n  1541→  if (!dynamicItems.length) {\n  1542→    return { lineItems, consumedQuotes: [] as PriceQuote[] };\n  1543→  }\n  1544→\n  1545→  let quotes: PriceQuote[];\n  1546→\n  1547→  // ✅ Auto-find quotes if not provided by frontend\n  1548→  if (quotesInput.length === 0) {\n  1549→    logger.info('Auto-finding quotes for checkout session', { sessionId: checkoutSession.id });\n  1550→\n  1551→    // Find all active quotes for this session\n  1552→    const priceIds = dynamicItems.map((item) => item.price_id);\n  1553→    quotes = await PriceQuote.findAll({\n  1554→      where: {\n  1555→        session_id: checkoutSession.id,\n  1556→        target_currency_id: paymentCurrencyId,\n  1557→        status: 'active',\n  1558→        expires_at: { [Op.gt]: Math.floor(Date.now() / 1000) },\n  1559→        price_id: { [Op.in]: priceIds },\n  1560→      },\n  1561→      order: [['created_at', 'DESC']], // Use latest quote if multiple exist\n  1562→    });\n  1563→\n  1564→    // Validate: each dynamic item must have a corresponding quote\n  1565→    const quotesByPriceId = new Map(quotes.map((q) => [q.price_id, q]));\n  1566→\n  1567→    for (const item of dynamicItems) {\n  1568→      const quote = quotesByPriceId.get(item.price_id);\n  1569→      if (!quote) {\n  1570→        throw new CustomError(\n  1571→          400,\n  1572→          'QUOTE_NOT_FOUND',\n  1573→          `No active quote found for price ${item.price_id}. Please refresh the page to generate a new quote.`\n  1574→        );\n  1575→      }\n  1576→\n  1577→      // Validate base_amount matches (quantity * unit_price)\n  1578→      // Use same precision calculation as quote creation\n  1579→      const price = (item.upsell_price || item.price) as any;\n  1580→      const expectedBaseAmount = calculateTotalBaseAmount(price.base_amount || '0', Number(item.quantity || 0));\n  1581→      const USD_DECIMALS = 8;\n  1582→      const expectedBaseAmountTrimmed = trimDecimals(expectedBaseAmount, USD_DECIMALS);\n  1583→      const quoteBaseAmountTrimmed = trimDecimals(quote.base_amount, USD_DECIMALS);\n  1584→      if (quoteBaseAmountTrimmed !== expectedBaseAmountTrimmed) {\n  1585→        throw new CustomError(\n  1586→          400,\n  1587→          'QUOTE_AMOUNT_MISMATCH',\n  1588→          `Quote amount mismatch for price ${item.price_id}. Expected ${expectedBaseAmountTrimmed} but got ${quoteBaseAmountTrimmed}. Please refresh the page.`\n  1589→        );\n  1590→      }\n  1591→    }\n  1592→\n  1593→    logger.info('Auto-found quotes successfully', {\n  1594→      sessionId: checkoutSession.id,\n  1595→      quoteCount: quotes.length,\n  1596→      quoteIds: quotes.map((q) => q.id),\n  1597→    });\n  1598→  } else {\n  1599→    // Legacy: use quotes provided by frontend (for backward compatibility)\n  1600→    logger.info('Using frontend-provided quotes', {\n  1601→      sessionId: checkoutSession.id,\n  1602→      quotesInput,\n  1603→    });\n  1604→\n  1605→    const quoteMap = new Map<string, string>();\n  1606→    quotesInput.forEach((x) => {\n  1607→      if (x.price_id && x.quote_id) {\n  1608→        quoteMap.set(x.price_id, x.quote_id);\n  1609→      }\n  1610→    });\n  1611→\n  1612→    if (quoteMap.size < dynamicItems.length) {\n  1613→      throw new CustomError(400, 'QUOTE_REQUIRED');\n  1614→    }\n  1615→\n  1616→    const quoteIds = Array.from(quoteMap.values());\n  1617→\n  1618→    // Step 1: Pre-validation outside transaction (fast fail)\n  1619→    quotes = await PriceQuote.findAll({\n  1620→      where: { id: quoteIds },\n  1621→    });\n  1622→    const quotesById = new Map(quotes.map((q) => [q.id, q]));\n  1623→\n  1624→    // Validate all quotes before starting transaction\n  1625→    for (const item of dynamicItems) {\n  1626→      const quoteId = quoteMap.get(item.price_id);\n  1627→      if (!quoteId) {\n  1628→        throw new CustomError(400, 'QUOTE_REQUIRED');\n  1629→      }\n  1630→\n  1631→      const quoteRecord = quotesById.get(quoteId);\n  1632→      if (!quoteRecord) {\n  1633→        throw new CustomError(400, 'QUOTE_NOT_FOUND');\n  1634→      }\n  1635→      if (quoteRecord.price_id !== item.price_id) {\n  1636→        throw new CustomError(400, 'QUOTE_PRICE_MISMATCH');\n  1637→      }\n  1638→      if (quoteRecord.target_currency_id !== paymentCurrencyId) {\n  1639→        throw new CustomError(400, 'QUOTE_CURRENCY_MISMATCH');\n  1640→      }\n  1641→      if (quoteRecord.base_currency !== (item.price as any).base_currency) {\n  1642→        throw new CustomError(400, 'QUOTE_BASE_CURRENCY_MISMATCH');\n  1643→      }\n  1644→      if (quoteRecord.session_id && quoteRecord.session_id !== checkoutSession.id) {\n  1645→        throw new CustomError(400, 'QUOTE_SESSION_MISMATCH');\n  1646→      }\n  1647→\n  1648→      const price = (item.upsell_price || item.price) as any;\n  1649→      const expectedBaseAmount = calculateTotalBaseAmount(price.base_amount || '0', Number(item.quantity || 0));\n  1650→      const USD_DECIMALS = 8;\n  1651→      const expectedBaseAmountTrimmed = trimDecimals(expectedBaseAmount, USD_DECIMALS);\n  1652→      const quoteBaseAmountTrimmed = trimDecimals(quoteRecord.base_amount, USD_DECIMALS);\n  1653→      if (quoteBaseAmountTrimmed !== expectedBaseAmountTrimmed) {\n  1654→        throw new CustomError(\n  1655→          400,\n  1656→          'QUOTE_AMOUNT_MISMATCH',\n  1657→          `Quote amount mismatch for price ${item.price_id}. Expected ${expectedBaseAmountTrimmed} but got ${quoteBaseAmountTrimmed}. Please refresh the page.`\n  1658→        );\n  1659→      }\n  1660→\n  1661→      // Check if active\n  1662→      if (!quoteRecord.isActive()) {\n  1663→        throw new CustomError(400, 'QUOTE_EXPIRED_OR_USED');\n  1664→      }\n  1665→    }\n  1666→  }\n  1667→\n  1668→  // Get quote IDs for locking\n  1669→  const quoteIds = quotes.map((q) => q.id);\n  1670→\n  1671→  // Step 2: Minimal transaction - batch update status only\n  1672→  const transaction = await sequelize.transaction();\n  1673→  const consumedQuotes: PriceQuote[] = [];\n  1674→\n  1675→  try {\n  1676→    // Re-fetch with lock and verify status didn't change\n  1677→    const lockedQuotes = await PriceQuote.findAll({\n  1678→      where: { id: quoteIds },\n  1679→      transaction,\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"2d8f8284-9695-4c2d-b176-794dc5f79223","timestamp":"2026-01-06T15:04:17.238Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","content":"}\n\nasync function attachQuotesToLineItems(options: {\n  checkoutSession: CheckoutSession;\n  lineItems: TLineItemExpanded[];\n  paymentCurrencyId: string;\n  quotesInput?: QuoteInput[];\n}) {\n  const { checkoutSession, lineItems, paymentCurrencyId, quotesInput = [] } = options;\n  const dynamicItems = lineItems.filter((item) => (item.upsell_price || item.price).pricing_type === 'dynamic');\n\n  if (!dynamicItems.length) {\n    return { lineItems, consumedQuotes: [] as PriceQuote[] };\n  }\n\n  let quotes: PriceQuote[];\n\n  // ✅ Auto-find quotes if not provided by frontend\n  if (quotesInput.length === 0) {\n    logger.info('Auto-finding quotes for checkout session', { sessionId: checkoutSession.id });\n\n    // Find all active quotes for this session\n    const priceIds = dynamicItems.map((item) => item.price_id);\n    quotes = await PriceQuote.findAll({\n      where: {\n        session_id: checkoutSession.id,\n        target_currency_id: paymentCurrencyId,\n        status: 'active',\n        expires_at: { [Op.gt]: Math.floor(Date.now() / 1000) },\n        price_id: { [Op.in]: priceIds },\n      },\n      order: [['created_at', 'DESC']], // Use latest quote if multiple exist\n    });\n\n    // Validate: each dynamic item must have a corresponding quote\n    const quotesByPriceId = new Map(quotes.map((q) => [q.price_id, q]));\n\n    for (const item of dynamicItems) {\n      const quote = quotesByPriceId.get(item.price_id);\n      if (!quote) {\n        throw new CustomError(\n          400,\n          'QUOTE_NOT_FOUND',\n          `No active quote found for price ${item.price_id}. Please refresh the page to generate a new quote.`\n        );\n      }\n\n      // Validate base_amount matches (quantity * unit_price)\n      // Use same precision calculation as quote creation\n      const price = (item.upsell_price || item.price) as any;\n      const expectedBaseAmount = calculateTotalBaseAmount(price.base_amount || '0', Number(item.quantity || 0));\n      const USD_DECIMALS = 8;\n      const expectedBaseAmountTrimmed = trimDecimals(expectedBaseAmount, USD_DECIMALS);\n      const quoteBaseAmountTrimmed = trimDecimals(quote.base_amount, USD_DECIMALS);\n      if (quoteBaseAmountTrimmed !== expectedBaseAmountTrimmed) {\n        throw new CustomError(\n          400,\n          'QUOTE_AMOUNT_MISMATCH',\n          `Quote amount mismatch for price ${item.price_id}. Expected ${expectedBaseAmountTrimmed} but got ${quoteBaseAmountTrimmed}. Please refresh the page.`\n        );\n      }\n    }\n\n    logger.info('Auto-found quotes successfully', {\n      sessionId: checkoutSession.id,\n      quoteCount: quotes.length,\n      quoteIds: quotes.map((q) => q.id),\n    });\n  } else {\n    // Legacy: use quotes provided by frontend (for backward compatibility)\n    logger.info('Using frontend-provided quotes', {\n      sessionId: checkoutSession.id,\n      quotesInput,\n    });\n\n    const quoteMap = new Map<string, string>();\n    quotesInput.forEach((x) => {\n      if (x.price_id && x.quote_id) {\n        quoteMap.set(x.price_id, x.quote_id);\n      }\n    });\n\n    if (quoteMap.size < dynamicItems.length) {\n      throw new CustomError(400, 'QUOTE_REQUIRED');\n    }\n\n    const quoteIds = Array.from(quoteMap.values());\n\n    // Step 1: Pre-validation outside transaction (fast fail)\n    quotes = await PriceQuote.findAll({\n      where: { id: quoteIds },\n    });\n    const quotesById = new Map(quotes.map((q) => [q.id, q]));\n\n    // Validate all quotes before starting transaction\n    for (const item of dynamicItems) {\n      const quoteId = quoteMap.get(item.price_id);\n      if (!quoteId) {\n        throw new CustomError(400, 'QUOTE_REQUIRED');\n      }\n\n      const quoteRecord = quotesById.get(quoteId);\n      if (!quoteRecord) {\n        throw new CustomError(400, 'QUOTE_NOT_FOUND');\n      }\n      if (quoteRecord.price_id !== item.price_id) {\n        throw new CustomError(400, 'QUOTE_PRICE_MISMATCH');\n      }\n      if (quoteRecord.target_currency_id !== paymentCurrencyId) {\n        throw new CustomError(400, 'QUOTE_CURRENCY_MISMATCH');\n      }\n      if (quoteRecord.base_currency !== (item.price as any).base_currency) {\n        throw new CustomError(400, 'QUOTE_BASE_CURRENCY_MISMATCH');\n      }\n      if (quoteRecord.session_id && quoteRecord.session_id !== checkoutSession.id) {\n        throw new CustomError(400, 'QUOTE_SESSION_MISMATCH');\n      }\n\n      const price = (item.upsell_price || item.price) as any;\n      const expectedBaseAmount = calculateTotalBaseAmount(price.base_amount || '0', Number(item.quantity || 0));\n      const USD_DECIMALS = 8;\n      const expectedBaseAmountTrimmed = trimDecimals(expectedBaseAmount, USD_DECIMALS);\n      const quoteBaseAmountTrimmed = trimDecimals(quoteRecord.base_amount, USD_DECIMALS);\n      if (quoteBaseAmountTrimmed !== expectedBaseAmountTrimmed) {\n        throw new CustomError(\n          400,\n          'QUOTE_AMOUNT_MISMATCH',\n          `Quote amount mismatch for price ${item.price_id}. Expected ${expectedBaseAmountTrimmed} but got ${quoteBaseAmountTrimmed}. Please refresh the page.`\n        );\n      }\n\n      // Check if active\n      if (!quoteRecord.isActive()) {\n        throw new CustomError(400, 'QUOTE_EXPIRED_OR_USED');\n      }\n    }\n  }\n\n  // Get quote IDs for locking\n  const quoteIds = quotes.map((q) => q.id);\n\n  // Step 2: Minimal transaction - batch update status only\n  const transaction = await sequelize.transaction();\n  const consumedQuotes: PriceQuote[] = [];\n\n  try {\n    // Re-fetch with lock and verify status didn't change\n    const lockedQuotes = await PriceQuote.findAll({\n      where: { id: quoteIds },\n      transaction,","numLines":150,"startLine":1530,"totalLines":3727}}}
{"parentUuid":"2d8f8284-9695-4c2d-b176-794dc5f79223","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RSpMmQ5e5Qg3N9aGk7HBtz","type":"tool_result","content":"112-\n113-  const subtotal = processedItems\n114-    .reduce((acc, x) => {\n115:      if (x.custom_amount) {\n116:        return acc.add(new BN(x.custom_amount));\n117-      }\n118-\n119-      const price = x.upsell_price || x.price;\n--\n1418-    return {\n1419-      ...item,\n1420-      ...quoteData,\n1421:      custom_amount: quoteInfo.quoteResponse.computed_unit_amount,\n1422-    };\n1423-  });\n1424-\n\n[Showing results with pagination = limit: 30, offset: 0]"}]},"uuid":"f510c788-3557-46b0-9a13-49bab66d89cd","timestamp":"2026-01-06T15:04:17.251Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"112-\n113-  const subtotal = processedItems\n114-    .reduce((acc, x) => {\n115:      if (x.custom_amount) {\n116:        return acc.add(new BN(x.custom_amount));\n117-      }\n118-\n119-      const price = x.upsell_price || x.price;\n--\n1418-    return {\n1419-      ...item,\n1420-      ...quoteData,\n1421:      custom_amount: quoteInfo.quoteResponse.computed_unit_amount,\n1422-    };\n1423-  });\n1424-","numLines":16,"appliedLimit":30}}
{"parentUuid":"f510c788-3557-46b0-9a13-49bab66d89cd","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012AXvUHwCC4XpfnghBrHqoL","type":"message","role":"assistant","content":[{"type":"text","text":"让我继续查看attachQuotesToLineItems的剩余逻辑："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3385,"cache_read_input_tokens":74373,"cache_creation":{"ephemeral_5m_input_tokens":3385,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL4M9aYmmVqMxKW5YUx","type":"assistant","uuid":"c0b67fea-66c7-4ff3-943f-7e5c95ef22c1","timestamp":"2026-01-06T15:04:21.382Z"}
{"parentUuid":"c0b67fea-66c7-4ff3-943f-7e5c95ef22c1","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012AXvUHwCC4XpfnghBrHqoL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KBS1mt6Q1Y1SYipWzrqTaC","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","offset":1675,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3385,"cache_read_input_tokens":74373,"cache_creation":{"ephemeral_5m_input_tokens":3385,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL4M9aYmmVqMxKW5YUx","type":"assistant","uuid":"95c7dbe8-9094-4489-9b9b-3c014e7c9d5d","timestamp":"2026-01-06T15:04:22.075Z"}
{"parentUuid":"95c7dbe8-9094-4489-9b9b-3c014e7c9d5d","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_012AXvUHwCC4XpfnghBrHqoL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KELzKTjEjTJa4SC5d63CuR","name":"Grep","input":{"pattern":"calculateAndUpdateAmount","output_mode":"content","-B":5,"-A":30,"path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","head_limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3385,"cache_read_input_tokens":74373,"cache_creation":{"ephemeral_5m_input_tokens":3385,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL4M9aYmmVqMxKW5YUx","type":"assistant","uuid":"54c04604-d2b8-4a15-8a12-86e4360eeb6d","timestamp":"2026-01-06T15:04:23.630Z"}
{"parentUuid":"54c04604-d2b8-4a15-8a12-86e4360eeb6d","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KBS1mt6Q1Y1SYipWzrqTaC","type":"tool_result","content":"  1675→  try {\n  1676→    // Re-fetch with lock and verify status didn't change\n  1677→    const lockedQuotes = await PriceQuote.findAll({\n  1678→      where: { id: quoteIds },\n  1679→      transaction,\n  1680→      lock: transaction.LOCK.UPDATE,\n  1681→    });\n  1682→    const lockedQuotesById = new Map(lockedQuotes.map((q) => [q.id, q]));\n  1683→\n  1684→    // Double-check all quotes are still active under lock\n  1685→    for (const quoteId of quoteIds) {\n  1686→      const quote = lockedQuotesById.get(quoteId);\n  1687→      if (!quote || !quote.isActive()) {\n  1688→        throw new CustomError(400, 'QUOTE_EXPIRED_OR_USED');\n  1689→      }\n  1690→    }\n  1691→\n  1692→    // Batch update all quotes to 'used' status\n  1693→    // Hooks will be triggered but deferred via afterCommit\n  1694→    await PriceQuote.update(\n  1695→      { status: 'used' },\n  1696→      {\n  1697→        where: { id: quoteIds },\n  1698→        transaction,\n  1699→      }\n  1700→    );\n  1701→\n  1702→    // Fetch updated quotes for return\n  1703→    const updatedQuotes = await PriceQuote.findAll({\n  1704→      where: { id: quoteIds },\n  1705→      transaction,\n  1706→    });\n  1707→    consumedQuotes.push(...updatedQuotes);\n  1708→\n  1709→    await transaction.commit();\n  1710→\n  1711→    const quotesByPriceId = new Map(consumedQuotes.map((q) => [q.price_id, q]));\n  1712→    const enrichedLineItems = lineItems.map((item) => {\n  1713→      const quote = quotesByPriceId.get(item.price.id);\n  1714→      if (!quote) {\n  1715→        return item;\n  1716→      }\n  1717→      return {\n  1718→        ...item,\n  1719→        quote_id: quote.id,\n  1720→        quoted_amount: quote.quoted_amount,\n  1721→        expires_at: quote.expires_at,\n  1722→        exchange_rate: quote.exchange_rate,\n  1723→        rate_provider_name: quote.rate_provider_name,\n  1724→        rate_provider_id: quote.rate_provider_id,\n  1725→        custom_amount: quote.quoted_amount,\n  1726→      };\n  1727→    });\n  1728→\n  1729→    return { lineItems: enrichedLineItems, consumedQuotes };\n  1730→  } catch (err) {\n  1731→    await transaction.rollback();\n  1732→    throw err;\n  1733→  }\n  1734→}\n  1735→\n  1736→async function prefetchQuotesForCheckoutSession(checkoutSession: CheckoutSession) {\n  1737→  const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n  1738→  const hasDynamic = expandedLineItems.some((item) => (item.upsell_price || item.price).pricing_type === 'dynamic');\n  1739→  if (!hasDynamic) {\n  1740→    return;\n  1741→  }\n  1742→\n  1743→  try {\n  1744→    await enrichCheckoutSessionWithQuotes(\n  1745→      checkoutSession,\n  1746→      expandedLineItems as TLineItemExpanded[],\n  1747→      checkoutSession.currency_id\n  1748→    );\n  1749→    logger.info('Prefetched quotes for checkout session', { checkoutSessionId: checkoutSession.id });\n  1750→  } catch (error: any) {\n  1751→    logger.error('Failed to prefetch quotes for checkout session', {\n  1752→      checkoutSessionId: checkoutSession.id,\n  1753→      error: error.message,\n  1754→    });\n  1755→    throw error;\n  1756→  }\n  1757→}\n  1758→\n  1759→// submit order\n  1760→router.put('/:id/submit', user, ensureCheckoutSessionOpen, async (req, res) => {\n  1761→  let consumedQuotes: PriceQuote[] = [];\n  1762→  try {\n  1763→    if (!req.user) {\n  1764→      return res.status(403).json({ code: 'REQUIRE_LOGIN', error: 'Please login to continue' });\n  1765→    }\n  1766→\n  1767→    const hasVendorConfig = await checkVendorConfig(req.doc.line_items);\n  1768→    if (hasVendorConfig) {\n  1769→      const { user: userDetail } = await blocklet.getUser(req.user.did, { enableConnectedAccount: true });\n  1770→      if (!userDetail?.sourceAppPid) {\n  1771→        return res.status(403).json({\n  1772→          code: 'UNIFIED_APP_REQUIRED',\n  1773→          error: 'This action requires a unified account. Please switch accounts and try again.',\n  1774→        });\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"0d6fedb7-18da-45c0-8088-03ef39f02676","timestamp":"2026-01-06T15:04:23.735Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","content":"  try {\n    // Re-fetch with lock and verify status didn't change\n    const lockedQuotes = await PriceQuote.findAll({\n      where: { id: quoteIds },\n      transaction,\n      lock: transaction.LOCK.UPDATE,\n    });\n    const lockedQuotesById = new Map(lockedQuotes.map((q) => [q.id, q]));\n\n    // Double-check all quotes are still active under lock\n    for (const quoteId of quoteIds) {\n      const quote = lockedQuotesById.get(quoteId);\n      if (!quote || !quote.isActive()) {\n        throw new CustomError(400, 'QUOTE_EXPIRED_OR_USED');\n      }\n    }\n\n    // Batch update all quotes to 'used' status\n    // Hooks will be triggered but deferred via afterCommit\n    await PriceQuote.update(\n      { status: 'used' },\n      {\n        where: { id: quoteIds },\n        transaction,\n      }\n    );\n\n    // Fetch updated quotes for return\n    const updatedQuotes = await PriceQuote.findAll({\n      where: { id: quoteIds },\n      transaction,\n    });\n    consumedQuotes.push(...updatedQuotes);\n\n    await transaction.commit();\n\n    const quotesByPriceId = new Map(consumedQuotes.map((q) => [q.price_id, q]));\n    const enrichedLineItems = lineItems.map((item) => {\n      const quote = quotesByPriceId.get(item.price.id);\n      if (!quote) {\n        return item;\n      }\n      return {\n        ...item,\n        quote_id: quote.id,\n        quoted_amount: quote.quoted_amount,\n        expires_at: quote.expires_at,\n        exchange_rate: quote.exchange_rate,\n        rate_provider_name: quote.rate_provider_name,\n        rate_provider_id: quote.rate_provider_id,\n        custom_amount: quote.quoted_amount,\n      };\n    });\n\n    return { lineItems: enrichedLineItems, consumedQuotes };\n  } catch (err) {\n    await transaction.rollback();\n    throw err;\n  }\n}\n\nasync function prefetchQuotesForCheckoutSession(checkoutSession: CheckoutSession) {\n  const expandedLineItems = await Price.expand(checkoutSession.line_items, { product: true, upsell: true });\n  const hasDynamic = expandedLineItems.some((item) => (item.upsell_price || item.price).pricing_type === 'dynamic');\n  if (!hasDynamic) {\n    return;\n  }\n\n  try {\n    await enrichCheckoutSessionWithQuotes(\n      checkoutSession,\n      expandedLineItems as TLineItemExpanded[],\n      checkoutSession.currency_id\n    );\n    logger.info('Prefetched quotes for checkout session', { checkoutSessionId: checkoutSession.id });\n  } catch (error: any) {\n    logger.error('Failed to prefetch quotes for checkout session', {\n      checkoutSessionId: checkoutSession.id,\n      error: error.message,\n    });\n    throw error;\n  }\n}\n\n// submit order\nrouter.put('/:id/submit', user, ensureCheckoutSessionOpen, async (req, res) => {\n  let consumedQuotes: PriceQuote[] = [];\n  try {\n    if (!req.user) {\n      return res.status(403).json({ code: 'REQUIRE_LOGIN', error: 'Please login to continue' });\n    }\n\n    const hasVendorConfig = await checkVendorConfig(req.doc.line_items);\n    if (hasVendorConfig) {\n      const { user: userDetail } = await blocklet.getUser(req.user.did, { enableConnectedAccount: true });\n      if (!userDetail?.sourceAppPid) {\n        return res.status(403).json({\n          code: 'UNIFIED_APP_REQUIRED',\n          error: 'This action requires a unified account. Please switch accounts and try again.',\n        });","numLines":100,"startLine":1675,"totalLines":3727}}}
{"parentUuid":"0d6fedb7-18da-45c0-8088-03ef39f02676","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KELzKTjEjTJa4SC5d63CuR","type":"tool_result","content":"329-}\n330-\n331-/**\n332- * Calculate and update payment amount for checkout session\n333- */\n334:export async function calculateAndUpdateAmount(\n335-  checkoutSession: CheckoutSession,\n336-  paymentCurrencyId: string,\n337-  useTrialSetting: boolean = false,\n338-  options: { lineItemsOverride?: TLineItemExpanded[] } = {}\n339-) {\n340-  const now = dayjs().unix();\n341-  const lineItems =\n342-    options.lineItemsOverride || (await Price.expand(checkoutSession.line_items, { product: true, upsell: true }));\n343-\n344-  let trialInDays = 0;\n345-  let trialEnd = 0;\n346-\n347-  // only use trial setting for subscription\n348-  if (useTrialSetting) {\n349-    const trialSetup = getSubscriptionTrialSetup(checkoutSession.subscription_data as any, paymentCurrencyId);\n350-    trialInDays = trialSetup.trialInDays;\n351-    trialEnd = trialSetup.trialEnd;\n352-  }\n353-\n354-  // Prepare discount configuration for getCheckoutAmount\n355-  let discountConfig;\n356-  if (checkoutSession.discounts && checkoutSession.discounts.length > 0) {\n357-    const firstDiscount = checkoutSession.discounts[0];\n358-    if (firstDiscount?.coupon) {\n359-      discountConfig = {\n360-        couponId: firstDiscount.coupon,\n361-      };\n362-    }\n363-    if (firstDiscount?.promotion_code) {\n364-      discountConfig = {\n--\n1949-    }\n1950-\n1951-    await checkoutSession.update({ customer_id: customer.id, customer_did: req.user.did });\n1952-\n1953-    // Verify and recalculate amount with current discounts\n1954:    const { lineItems, trialInDays, trialEnd, now } = await calculateAndUpdateAmount(\n1955-      checkoutSession,\n1956-      paymentCurrency.id,\n1957-      true,\n1958-      {\n1959-        lineItemsOverride: lineItemsWithQuotes,\n1960-      }\n1961-    );\n\n[Showing results with pagination = limit: 50, offset: 0]"}]},"uuid":"29290063-9221-442b-8b1e-38fb2a50962d","timestamp":"2026-01-06T15:04:23.743Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"329-}\n330-\n331-/**\n332- * Calculate and update payment amount for checkout session\n333- */\n334:export async function calculateAndUpdateAmount(\n335-  checkoutSession: CheckoutSession,\n336-  paymentCurrencyId: string,\n337-  useTrialSetting: boolean = false,\n338-  options: { lineItemsOverride?: TLineItemExpanded[] } = {}\n339-) {\n340-  const now = dayjs().unix();\n341-  const lineItems =\n342-    options.lineItemsOverride || (await Price.expand(checkoutSession.line_items, { product: true, upsell: true }));\n343-\n344-  let trialInDays = 0;\n345-  let trialEnd = 0;\n346-\n347-  // only use trial setting for subscription\n348-  if (useTrialSetting) {\n349-    const trialSetup = getSubscriptionTrialSetup(checkoutSession.subscription_data as any, paymentCurrencyId);\n350-    trialInDays = trialSetup.trialInDays;\n351-    trialEnd = trialSetup.trialEnd;\n352-  }\n353-\n354-  // Prepare discount configuration for getCheckoutAmount\n355-  let discountConfig;\n356-  if (checkoutSession.discounts && checkoutSession.discounts.length > 0) {\n357-    const firstDiscount = checkoutSession.discounts[0];\n358-    if (firstDiscount?.coupon) {\n359-      discountConfig = {\n360-        couponId: firstDiscount.coupon,\n361-      };\n362-    }\n363-    if (firstDiscount?.promotion_code) {\n364-      discountConfig = {\n--\n1949-    }\n1950-\n1951-    await checkoutSession.update({ customer_id: customer.id, customer_did: req.user.did });\n1952-\n1953-    // Verify and recalculate amount with current discounts\n1954:    const { lineItems, trialInDays, trialEnd, now } = await calculateAndUpdateAmount(\n1955-      checkoutSession,\n1956-      paymentCurrency.id,\n1957-      true,\n1958-      {\n1959-        lineItemsOverride: lineItemsWithQuotes,\n1960-      }\n1961-    );","numLines":50,"appliedLimit":50}}
{"parentUuid":"29290063-9221-442b-8b1e-38fb2a50962d","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01GdFWYLo7szT4qLsG6kPKSD","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我查看calculateAndUpdateAmount的完整实现："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2628,"cache_read_input_tokens":77758,"cache_creation":{"ephemeral_5m_input_tokens":2628,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL4poUe1LVoj6Bk65ro","type":"assistant","uuid":"7935e8e0-c861-4959-8b12-1f74a9ab1755","timestamp":"2026-01-06T15:04:29.045Z"}
{"parentUuid":"7935e8e0-c861-4959-8b12-1f74a9ab1755","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01GdFWYLo7szT4qLsG6kPKSD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KsqNubYr6v912xTTZ3YWTu","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","offset":334,"limit":100}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2628,"cache_read_input_tokens":77758,"cache_creation":{"ephemeral_5m_input_tokens":2628,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL4poUe1LVoj6Bk65ro","type":"assistant","uuid":"c8b0b2d6-0191-4bea-a522-1cbed8bee0ff","timestamp":"2026-01-06T15:04:29.779Z"}
{"parentUuid":"c8b0b2d6-0191-4bea-a522-1cbed8bee0ff","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01GdFWYLo7szT4qLsG6kPKSD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01899hHw7jR2xXT4gdhkYjbt","name":"Grep","input":{"pattern":"CheckoutSession.*update.*amount_total","output_mode":"content","-B":5,"-A":5,"path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2628,"cache_read_input_tokens":77758,"cache_creation":{"ephemeral_5m_input_tokens":2628,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrL4poUe1LVoj6Bk65ro","type":"assistant","uuid":"ee8160b7-bcdc-4efa-9650-dde3f4d0e260","timestamp":"2026-01-06T15:04:31.284Z"}
{"parentUuid":"ee8160b7-bcdc-4efa-9650-dde3f4d0e260","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KsqNubYr6v912xTTZ3YWTu","type":"tool_result","content":"   334→export async function calculateAndUpdateAmount(\n   335→  checkoutSession: CheckoutSession,\n   336→  paymentCurrencyId: string,\n   337→  useTrialSetting: boolean = false,\n   338→  options: { lineItemsOverride?: TLineItemExpanded[] } = {}\n   339→) {\n   340→  const now = dayjs().unix();\n   341→  const lineItems =\n   342→    options.lineItemsOverride || (await Price.expand(checkoutSession.line_items, { product: true, upsell: true }));\n   343→\n   344→  let trialInDays = 0;\n   345→  let trialEnd = 0;\n   346→\n   347→  // only use trial setting for subscription\n   348→  if (useTrialSetting) {\n   349→    const trialSetup = getSubscriptionTrialSetup(checkoutSession.subscription_data as any, paymentCurrencyId);\n   350→    trialInDays = trialSetup.trialInDays;\n   351→    trialEnd = trialSetup.trialEnd;\n   352→  }\n   353→\n   354→  // Prepare discount configuration for getCheckoutAmount\n   355→  let discountConfig;\n   356→  if (checkoutSession.discounts && checkoutSession.discounts.length > 0) {\n   357→    const firstDiscount = checkoutSession.discounts[0];\n   358→    if (firstDiscount?.coupon) {\n   359→      discountConfig = {\n   360→        couponId: firstDiscount.coupon,\n   361→      };\n   362→    }\n   363→    if (firstDiscount?.promotion_code) {\n   364→      discountConfig = {\n   365→        ...discountConfig,\n   366→        promotionCodeId: firstDiscount.promotion_code,\n   367→      };\n   368→    }\n   369→    if (checkoutSession.customer_id) {\n   370→      discountConfig = {\n   371→        ...discountConfig,\n   372→        customerId: checkoutSession.customer_id,\n   373→      };\n   374→    }\n   375→  }\n   376→\n   377→  logger.info('Getting checkout amount', {\n   378→    discountConfig,\n   379→  });\n   380→  const amount = await getCheckoutAmount(\n   381→    lineItems,\n   382→    paymentCurrencyId,\n   383→    trialInDays > 0 || trialEnd > now,\n   384→    discountConfig\n   385→  );\n   386→\n   387→  await checkoutSession.update({\n   388→    amount_subtotal: amount.subtotal,\n   389→    amount_total: amount.total,\n   390→    total_details: {\n   391→      amount_discount: amount.discount,\n   392→      amount_shipping: amount.shipping,\n   393→      amount_tax: amount.tax,\n   394→    },\n   395→  });\n   396→\n   397→  logger.info('Amount calculated', {\n   398→    checkoutSessionId: checkoutSession.id,\n   399→    amount: {\n   400→      subtotal: amount.subtotal,\n   401→      total: amount.total,\n   402→      discount: amount.discount,\n   403→      shipping: amount.shipping,\n   404→      tax: amount.tax,\n   405→    },\n   406→  });\n   407→\n   408→  if (checkoutSession.mode === 'payment' && new BN(amount.total || '0').lt(new BN('0'))) {\n   409→    throw new Error('Payment amount should be greater or equal to 0');\n   410→  }\n   411→\n   412→  return {\n   413→    lineItems: amount.processedItems || lineItems,\n   414→    amount,\n   415→    trialInDays,\n   416→    trialEnd,\n   417→    now,\n   418→  };\n   419→}\n   420→\n   421→/**\n   422→ * 创建或更新支付意向\n   423→ */\n   424→async function createOrUpdatePaymentIntent(\n   425→  checkoutSession: CheckoutSession,\n   426→  paymentMethod: PaymentMethod,\n   427→  paymentCurrency: PaymentCurrency,\n   428→  lineItems: any[],\n   429→  customerId?: string,\n   430→  customerEmail?: string,\n   431→  formData?: any,\n   432→  options: { quoteIds?: string[] } = {}\n   433→) {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"50611c6a-8f1b-4e6e-b143-3e035664c15a","timestamp":"2026-01-06T15:04:31.388Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","content":"export async function calculateAndUpdateAmount(\n  checkoutSession: CheckoutSession,\n  paymentCurrencyId: string,\n  useTrialSetting: boolean = false,\n  options: { lineItemsOverride?: TLineItemExpanded[] } = {}\n) {\n  const now = dayjs().unix();\n  const lineItems =\n    options.lineItemsOverride || (await Price.expand(checkoutSession.line_items, { product: true, upsell: true }));\n\n  let trialInDays = 0;\n  let trialEnd = 0;\n\n  // only use trial setting for subscription\n  if (useTrialSetting) {\n    const trialSetup = getSubscriptionTrialSetup(checkoutSession.subscription_data as any, paymentCurrencyId);\n    trialInDays = trialSetup.trialInDays;\n    trialEnd = trialSetup.trialEnd;\n  }\n\n  // Prepare discount configuration for getCheckoutAmount\n  let discountConfig;\n  if (checkoutSession.discounts && checkoutSession.discounts.length > 0) {\n    const firstDiscount = checkoutSession.discounts[0];\n    if (firstDiscount?.coupon) {\n      discountConfig = {\n        couponId: firstDiscount.coupon,\n      };\n    }\n    if (firstDiscount?.promotion_code) {\n      discountConfig = {\n        ...discountConfig,\n        promotionCodeId: firstDiscount.promotion_code,\n      };\n    }\n    if (checkoutSession.customer_id) {\n      discountConfig = {\n        ...discountConfig,\n        customerId: checkoutSession.customer_id,\n      };\n    }\n  }\n\n  logger.info('Getting checkout amount', {\n    discountConfig,\n  });\n  const amount = await getCheckoutAmount(\n    lineItems,\n    paymentCurrencyId,\n    trialInDays > 0 || trialEnd > now,\n    discountConfig\n  );\n\n  await checkoutSession.update({\n    amount_subtotal: amount.subtotal,\n    amount_total: amount.total,\n    total_details: {\n      amount_discount: amount.discount,\n      amount_shipping: amount.shipping,\n      amount_tax: amount.tax,\n    },\n  });\n\n  logger.info('Amount calculated', {\n    checkoutSessionId: checkoutSession.id,\n    amount: {\n      subtotal: amount.subtotal,\n      total: amount.total,\n      discount: amount.discount,\n      shipping: amount.shipping,\n      tax: amount.tax,\n    },\n  });\n\n  if (checkoutSession.mode === 'payment' && new BN(amount.total || '0').lt(new BN('0'))) {\n    throw new Error('Payment amount should be greater or equal to 0');\n  }\n\n  return {\n    lineItems: amount.processedItems || lineItems,\n    amount,\n    trialInDays,\n    trialEnd,\n    now,\n  };\n}\n\n/**\n * 创建或更新支付意向\n */\nasync function createOrUpdatePaymentIntent(\n  checkoutSession: CheckoutSession,\n  paymentMethod: PaymentMethod,\n  paymentCurrency: PaymentCurrency,\n  lineItems: any[],\n  customerId?: string,\n  customerEmail?: string,\n  formData?: any,\n  options: { quoteIds?: string[] } = {}\n) {","numLines":100,"startLine":334,"totalLines":3727}}}
{"parentUuid":"50611c6a-8f1b-4e6e-b143-3e035664c15a","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01899hHw7jR2xXT4gdhkYjbt","type":"tool_result","content":"No matches found"}]},"uuid":"f9415de0-2739-4769-bb4b-4c3c9e5d92ca","timestamp":"2026-01-06T15:04:31.396Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0}}
{"parentUuid":"f9415de0-2739-4769-bb4b-4c3c9e5d92ca","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"af2fbc7","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01SE5Q7sVvP4tja3hUvyZqTZ","type":"message","role":"assistant","content":[{"type":"text","text":"根据我的调查，我已经找到了dynamic pricing与现有payment流程集成的关键问题。让我总结并创建分析报告：\n\n## Dynamic Pricing集成问题分析报告\n\n经过全面调查，我发现了**dynamic pricing功能与现有payment流程的关键集成断点**：\n\n### 🔴 **核心问题：CheckoutSession Submit流程中quote信息的丢失**\n\n#### 1. **CheckoutSession创建时的price信息**\n\n在CheckoutSession中，`line_items`存储的是基础价格信息：\n```typescript\n// CheckoutSession.line_items 结构\n{\n  price_id: string;\n  quantity: number;\n  // 对于dynamic pricing，这里没有quoted_amount！\n}\n```\n\n对于dynamic pricing的items：\n- `price.pricing_type = 'dynamic'`\n- `price.base_amount` = USD参考价格（如\"10.00000000\"）\n- `price.unit_amount` = \"0\"（动态定价没有固定token价格）\n\n#### 2. **Submit接口中的关键流程断点**\n\n**问题路径**：`/checkout-sessions/:id/submit` → `attachQuotesToLineItems` → `calculateAndUpdateAmount` → `ensureInvoiceForCheckout`\n\n```typescript\n// ✅ Step 1: attachQuotesToLineItems 返回 enrichedLineItems\nconst quoteResult = await attachQuotesToLineItems({\n  checkoutSession,\n  lineItems: expandedLineItems,\n  paymentCurrencyId: paymentCurrency.id,\n  quotesInput: req.body.quotes,\n});\nlineItemsWithQuotes = quoteResult.lineItems; // 包含 custom_amount\n\n// ✅ Step 2: calculateAndUpdateAmount 使用 lineItemsWithQuotes\nconst { lineItems, trialInDays, trialEnd, now } = await calculateAndUpdateAmount(\n  checkoutSession,\n  paymentCurrency.id,\n  true,\n  {\n    lineItemsOverride: lineItemsWithQuotes, // 传入了enriched line items\n  }\n);\n\n// ❌ 问题：lineItemsWithQuotes 只是临时变量！\n// 这些enriched line items没有被保存回CheckoutSession\n// 它们只在本次请求的内存中存在\n```\n\n#### 3. **`attachQuotesToLineItems`返回的enriched结构**\n\n```typescript\n// enrichedLineItems 结构（临时变量）\n{\n  price_id: string;\n  quantity: number;\n  quote_id: string;              // ✅ 新增\n  quoted_amount: string;         // ✅ 新增（实际token价格）\n  custom_amount: string;         // ✅ 新增（用于计算）\n  expires_at: number;            // ✅ 新增\n  exchange_rate: string;         // ✅ 新增\n  rate_provider_name: string;    // ✅ 新增\n  rate_provider_id: string;      // ✅ 新增\n}\n```\n\n**关键发现**：这些enriched信息**没有被持久化到CheckoutSession**！\n\n#### 4. **Invoice创建时的问题**\n\n```typescript\n// ensureInvoiceForCheckout (connect/shared.ts:387-602)\nconst invoiceItems = lineItems || (await Price.expand(checkoutSession.line_items, { product: true }));\n// ❌ 如果lineItems参数为空，会从checkoutSession.line_items重新读取\n// ❌ 此时丢失了所有的quote信息（quote_id, custom_amount等）\n\nconst totalAmount = await getCheckoutAmount(\n  invoiceItems,\n  checkoutSession.currency_id,\n  trialInDays > 0 || trialEnd > now,\n  discountConfig\n);\n// ❌ getCheckoutAmount计算时，如果没有custom_amount，会使用price.unit_amount\n// ❌ 对于dynamic pricing，price.unit_amount = \"0\"，导致金额错误！\n\nawait ensureInvoiceAndItems({\n  customer,\n  currency,\n  subscription,\n  lineItems: invoiceItems, // ❌ 可能是没有quote信息的items\n  props: {\n    total: totalAmount.total, // ❌ 可能是错误的金额（0或基于price.unit_amount）\n  }\n});\n```\n\n#### 5. **Invoice创建的所有路径分析**\n\n通过grep找到的invoice创建路径：\n\n| 路径 | 是否处理Dynamic Pricing | 风险等级 |\n|------|----------------------|----------|\n| `ensureInvoiceForCheckout` (payment模式) | ⚠️ 部分处理 | **高** |\n| `ensureInvoiceForCheckout` (subscription模式) | ✅ 有处理 | 低 |\n| `ensureInvoicesForSubscriptions` | ✅ 调用generateQuotesForInvoiceItems | 低 |\n| `createInvoiceWithItems` | ✅ 为subscription自动生成quotes | 低 |\n| `ensureRechargeInvoice` | N/A | - |\n| `ensureStakeInvoice` | N/A | - |\n| `ensureOverdraftProtectionInvoiceAndItems` | N/A | - |\n\n**关键发现**：\n- ✅ **Subscription模式**：`createInvoiceWithItems`会自动调用`generateQuotesForInvoiceItems`\n- ❌ **Payment模式**：依赖传入的`lineItems`参数包含quote信息，但这个信息容易丢失\n\n#### 6. **Price模型中的金额字段**\n\n```typescript\n// Price模型字段\n{\n  pricing_type: 'fixed' | 'dynamic',\n  unit_amount: string,        // fixed: token金额; dynamic: \"0\"\n  base_currency: string,      // dynamic: \"USD\"\n  base_amount: string,        // dynamic: USD单价（如\"10.00000000\"）\n  currency_options: [{\n    currency_id: string,\n    unit_amount: string,      // fixed: 各币种的金额; dynamic: \"0\"\n  }]\n}\n```\n\n**问题**：\n- Dynamic pricing的`price.unit_amount = \"0\"`\n- 如果InvoiceItem直接使用`price.unit_amount`，金额会是0\n- **必须使用quote.quoted_amount**\n\n### 🎯 **集成断点总结**\n\n#### **断点1：CheckoutSession与临时变量**\n```typescript\n// checkout-sessions.ts submit接口\nlineItemsWithQuotes = quoteResult.lineItems; // ❌ 只是临时变量\n// 这些enriched line items没有被保存到数据库\n```\n\n#### **断点2：`ensureInvoiceForCheckout`的参数传递**\n```typescript\n// connect/pay.ts:100 - Payment完成后\nawait ensureInvoiceForCheckout({ \n  checkoutSession, \n  customer, \n  paymentIntent \n  // ❌ 没有传入lineItems参数！\n});\n\n// connect/shared.ts:501 - 会重新读取\nconst invoiceItems = lineItems || (await Price.expand(checkoutSession.line_items, { product: true }));\n// ❌ 从checkoutSession.line_items读取，丢失了所有quote信息\n```\n\n#### **断点3：`getCheckoutAmount`的fallback逻辑**\n```typescript\n// libs/session.ts:113-120\nconst subtotal = processedItems.reduce((acc, x) => {\n  if (x.custom_amount) { // ✅ 如果有custom_amount（来自quote）\n    return acc.add(new BN(x.custom_amount));\n  }\n  const price = x.upsell_price || x.price;\n  const unitPrice = getPriceUintAmountByCurrency(price, currencyId);\n  // ❌ 对于dynamic pricing，unitPrice会是\"0\"或undefined\n  return acc.add(new BN(unitPrice).mul(new BN(x.quantity)));\n}, new BN(0));\n```\n\n### 🔧 **问题的根本原因**\n\n1. **架构设计问题**：\n   - CheckoutSession的`line_items`字段只存储基础price信息\n   - Quote信息通过临时变量传递，没有持久化到CheckoutSession\n   - 不同代码路径对lineItems的处理不一致\n\n2. **代码执行流程问题**：\n   ```\n   Submit → attachQuotes → calculateAmount → (临时变量lineItemsWithQuotes)\n                                               ↓\n   Payment → ensureInvoice → 重新读取checkoutSession.line_items\n                               ↓\n                          (丢失quote信息)\n   ```\n\n3. **Subscription vs Payment模式的差异**：\n   - Subscription：`createInvoiceWithItems`会自动为dynamic pricing生成quotes ✅\n   - Payment：依赖传入的lineItems包含quote信息，容易丢失 ❌\n\n### 💡 **建议的修复方案**\n\n#### **方案1：持久化quote信息到CheckoutSession**\n```typescript\n// 在attachQuotesToLineItems后\nawait checkoutSession.update({\n  line_items: lineItemsWithQuotes.map(item => ({\n    ...item,\n    quote_id: item.quote_id,\n    quoted_amount: item.quoted_amount,\n    // 保存其他quote相关字段\n  }))\n});\n```\n\n#### **方案2：确保所有invoice创建路径都传入enriched lineItems**\n```typescript\n// connect/pay.ts\nconst enrichedLineItems = await attachQuotesToLineItems(...);\nawait ensureInvoiceForCheckout({ \n  checkoutSession, \n  customer, \n  paymentIntent,\n  lineItems: enrichedLineItems.lineItems // ✅ 传入\n});\n```\n\n#### **方案3：在ensureInvoiceForCheckout中自动处理dynamic pricing**\n```typescript\n// connect/shared.ts ensureInvoiceForCheckout\nlet invoiceItems = lineItems || (await Price.expand(checkoutSession.line_items, { product: true }));\n\n// 检查是否有dynamic pricing items需要处理\nconst hasDynamic = await hasDynamicPricingItems(invoiceItems);\nif (hasDynamic && !lineItems) {\n  // 没有传入lineItems，需要重新attach quotes\n  const quoteResult = await attachQuotesToLineItems({\n    checkoutSession,\n    lineItems: invoiceItems,\n    paymentCurrencyId: checkoutSession.currency_id\n  });\n  invoiceItems = quoteResult.lineItems;\n}\n```\n\n### ⚠️ **需要修复的关键文件**\n\n1. `/api/src/routes/checkout-sessions.ts` - Submit接口\n2. `/api/src/routes/connect/pay.ts` - Payment完成处理\n3. `/api/src/routes/connect/shared.ts` - ensureInvoiceForCheckout\n4. `/api/src/libs/session.ts` - getCheckoutAmount\n\n这个问题非常关键，会导致dynamic pricing的payment模式下，invoice金额计算错误或为0。建议优先修复方案2+方案3的组合，确保所有路径都能正确处理dynamic pricing。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1968,"cache_read_input_tokens":80386,"cache_creation":{"ephemeral_5m_input_tokens":1968,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWrL5PfufxoSbBhF19MiJ","type":"assistant","uuid":"74568c62-c318-48ee-8697-50d5178b5641","timestamp":"2026-01-06T15:05:24.432Z"}
