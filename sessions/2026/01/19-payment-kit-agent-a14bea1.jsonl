{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":"调查账单item缺少quote信息的问题（用户认为这是最严重的问题）：\n\n**问题描述**：\n- 创建的账单item信息里面没有quote相关的信息\n- invoice router返回的接口里也没有对应的quote详情信息\n- 导致账单详情页不会展示用户当时购买的支付详细清单\n\n**背景信息**：\n- 我们之前已经修改了 api/src/libs/invoice-quote.ts 中的 generateQuotesForInvoiceItems 函数，它会把quote信息放入item.metadata中\n- 但用户报告实际创建的账单item里没有这些信息\n\n**调查重点**：\n1. 找到invoice创建的所有入口点（可能在 api/src/libs/invoice.ts 或 api/src/routes/invoices.ts）\n2. 检查这些入口点是否调用了 generateQuotesForInvoiceItems\n3. 检查invoice item的创建逻辑，看metadata是否正确传递\n4. 找到invoice查询接口（GET /invoices/:id）的实现\n5. 检查查询接口返回的数据结构，是否包含item的metadata\n6. 检查是否有序列化或数据过滤逻辑会移除metadata中的quote信息\n\n请提供：\n- Invoice创建的完整调用链\n- Invoice item metadata的传递路径\n- Invoice查询接口的返回数据结构\n- 可能导致quote信息丢失的代码位置"},"uuid":"6fcd93ba-e91c-472e-b251-c0ff38d7ec1e","timestamp":"2026-01-06T14:31:00.349Z"}
{"parentUuid":"6fcd93ba-e91c-472e-b251-c0ff38d7ec1e","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KVX2XmJ7RoeZswXXRKB4oR","type":"message","role":"assistant","content":[{"type":"text","text":"我将帮您调查账单item缺少quote信息的问题。让我系统地检查invoice创建流程和数据传递路径。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14736,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14736,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWrHXGDpBqQEA3HSyNmmD","type":"assistant","uuid":"2f812ecc-f43f-4b89-b8c1-873b354d217d","timestamp":"2026-01-06T14:31:06.224Z"}
{"parentUuid":"2f812ecc-f43f-4b89-b8c1-873b354d217d","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KVX2XmJ7RoeZswXXRKB4oR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LyopsRsBTWHKTPPUtnvWYe","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice-quote.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14736,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14736,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWrHXGDpBqQEA3HSyNmmD","type":"assistant","uuid":"782be653-8f83-4681-93ff-bd1e46ccef8c","timestamp":"2026-01-06T14:31:06.829Z"}
{"parentUuid":"782be653-8f83-4681-93ff-bd1e46ccef8c","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KVX2XmJ7RoeZswXXRKB4oR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TqXZ9CEGcRmRCFr4a2AKGD","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14736,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14736,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CWrHXGDpBqQEA3HSyNmmD","type":"assistant","uuid":"cdd28b59-4c0a-40b8-9761-3a380e5a10c4","timestamp":"2026-01-06T14:31:07.325Z"}
{"parentUuid":"cdd28b59-4c0a-40b8-9761-3a380e5a10c4","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01KVX2XmJ7RoeZswXXRKB4oR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014U75sHt3ytW1UUYfWJ2Tvb","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/invoices.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14736,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14736,"ephemeral_1h_input_tokens":0},"output_tokens":266,"service_tier":"standard"}},"requestId":"req_011CWrHXGDpBqQEA3HSyNmmD","type":"assistant","uuid":"7d865a20-91ef-41f1-b19b-50c78c8d909b","timestamp":"2026-01-06T14:31:08.009Z"}
{"parentUuid":"7d865a20-91ef-41f1-b19b-50c78c8d909b","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LyopsRsBTWHKTPPUtnvWYe","type":"tool_result","content":"     1→import { Price, PaymentCurrency } from '../store/models';\n     2→import { getQuoteService, type RateResult } from './quote-service';\n     3→import { getExchangeRateService } from './exchange-rate';\n     4→import logger from './logger';\n     5→\n     6→export interface InvoiceItemInput {\n     7→  price_id: string;\n     8→  quantity: number;\n     9→  amount: string;\n    10→  subscription_item_id?: string;\n    11→  description: string;\n    12→  period?: { start: number; end: number };\n    13→  metadata?: Record<string, any>;\n    14→  discountable?: boolean;\n    15→  discount_amounts?: any[];\n    16→}\n    17→\n    18→export interface InvoiceItemWithQuote extends InvoiceItemInput {\n    19→  quote_id?: string;\n    20→}\n    21→\n    22→/**\n    23→ * Generate quotes for dynamic pricing invoice items\n    24→ * This function checks each invoice item's price and generates a quote if it uses dynamic pricing\n    25→ */\n    26→export async function generateQuotesForInvoiceItems(params: {\n    27→  invoiceId: string;\n    28→  items: InvoiceItemInput[];\n    29→  currencyId: string;\n    30→}): Promise<InvoiceItemWithQuote[]> {\n    31→  const { invoiceId, items, currencyId } = params;\n    32→\n    33→  if (!items || items.length === 0) {\n    34→    return [];\n    35→  }\n    36→\n    37→  // Load currency with payment method\n    38→  const currency = await PaymentCurrency.findByPk(currencyId, {\n    39→    include: [{ association: 'payment_method' }],\n    40→  });\n    41→  if (!currency) {\n    42→    throw new Error(`Currency ${currencyId} not found`);\n    43→  }\n    44→\n    45→  // Get exchange rate once for all dynamic prices (for efficiency)\n    46→  // For ArcBlock payment method, always use ABT for exchange rate\n    47→  const exchangeRateService = getExchangeRateService();\n    48→  const rateSymbol = (currency as any).payment_method?.type === 'arcblock' ? 'ABT' : currency.symbol;\n    49→  let rateResult: RateResult | null = null;\n    50→\n    51→  const quoteService = getQuoteService();\n    52→  const enrichedItems: InvoiceItemWithQuote[] = [];\n    53→\n    54→  // Note: Sequential processing is intentional here\n    55→  // 1. Prices may not exist (early continue)\n    56→  // 2. Exchange rate is fetched once and reused (rateResult)\n    57→  // 3. Quote failures must be handled immediately (P0 critical)\n    58→  // eslint-disable-next-line no-restricted-syntax\n    59→  for (const item of items) {\n    60→    // eslint-disable-next-line no-await-in-loop\n    61→    const price = await Price.findByPk(item.price_id);\n    62→    if (!price) {\n    63→      logger.warn('Price not found for invoice item', { priceId: item.price_id, invoiceId });\n    64→      enrichedItems.push(item);\n    65→      // eslint-disable-next-line no-continue\n    66→      continue;\n    67→    }\n    68→\n    69→    // Check if price uses dynamic pricing\n    70→    if (price.pricing_type !== 'dynamic') {\n    71→      // Fixed pricing - use item amount as-is\n    72→      enrichedItems.push(item);\n    73→      // eslint-disable-next-line no-continue\n    74→      continue;\n    75→    }\n    76→\n    77→    // Dynamic pricing - generate quote\n    78→    try {\n    79→      // Get exchange rate if not already fetched\n    80→      if (!rateResult) {\n    81→        // eslint-disable-next-line no-await-in-loop\n    82→        rateResult = await exchangeRateService.getRate(rateSymbol);\n    83→      }\n    84→\n    85→      // Create quote for this invoice item\n    86→      // eslint-disable-next-line no-await-in-loop\n    87→      const { quote } = await quoteService.createQuoteWithRate({\n    88→        price_id: item.price_id,\n    89→        invoice_id: invoiceId,\n    90→        target_currency_id: currencyId,\n    91→        quantity: item.quantity,\n    92→        rateResult,\n    93→      });\n    94→\n    95→      logger.info('Generated quote for invoice item', {\n    96→        invoiceId,\n    97→        priceId: item.price_id,\n    98→        quoteId: quote.id,\n    99→        quotedAmount: quote.quoted_amount,\n   100→      });\n   101→\n   102→      // Update item with quote info\n   103→      enrichedItems.push({\n   104→        ...item,\n   105→        amount: quote.quoted_amount,\n   106→        quote_id: quote.id,\n   107→        metadata: {\n   108→          ...item.metadata,\n   109→          quote: {\n   110→            id: quote.id,\n   111→            // Reference price (USD)\n   112→            base_currency: quote.base_currency,\n   113→            base_amount: quote.base_amount, // Total USD amount\n   114→            // Actual payment price\n   115→            quoted_amount: quote.quoted_amount, // Total token amount\n   116→            target_currency_id: quote.target_currency_id,\n   117→            rate_currency_symbol: quote.rate_currency_symbol,\n   118→            // Exchange rate info\n   119→            exchange_rate: quote.exchange_rate, // 1 token = X USD\n   120→            rate_provider_name: quote.rate_provider_name,\n   121→            rate_provider_id: quote.rate_provider_id,\n   122→            rate_timestamp_ms: quote.rate_timestamp_ms,\n   123→            // Pricing context\n   124→            quantity: item.quantity,\n   125→            expires_at: quote.expires_at,\n   126→            status: quote.status,\n   127→          },\n   128→        },\n   129→      });\n   130→    } catch (error: any) {\n   131→      logger.error('Failed to generate quote for invoice item', {\n   132→        invoiceId,\n   133→        priceId: item.price_id,\n   134→        error: error.message,\n   135→      });\n   136→\n   137→      // P0 CRITICAL: Do not allow fallback for dynamic pricing\n   138→      // Quote is the only source of truth for dynamic pricing amounts\n   139→      // If quote generation fails, the invoice creation must fail\n   140→      throw new Error(`Failed to generate quote for dynamic price ${item.price_id}: ${error.message}`);\n   141→    }\n   142→  }\n   143→\n   144→  return enrichedItems;\n   145→}\n   146→\n   147→/**\n   148→ * Check if any invoice items use dynamic pricing\n   149→ */\n   150→export async function hasDynamicPricingItems(items: InvoiceItemInput[]): Promise<boolean> {\n   151→  if (!items || items.length === 0) {\n   152→    return false;\n   153→  }\n   154→\n   155→  const priceIds = items.map((item) => item.price_id).filter(Boolean);\n   156→  if (priceIds.length === 0) {\n   157→    return false;\n   158→  }\n   159→\n   160→  const prices = await Price.findAll({\n   161→    where: { id: priceIds },\n   162→    attributes: ['id', 'pricing_type'],\n   163→  });\n   164→\n   165→  return prices.some((price) => price.pricing_type === 'dynamic');\n   166→}\n   167→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"dd47984f-795c-4831-8610-cf89c680ec8e","timestamp":"2026-01-06T14:31:08.085Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice-quote.ts","content":"import { Price, PaymentCurrency } from '../store/models';\nimport { getQuoteService, type RateResult } from './quote-service';\nimport { getExchangeRateService } from './exchange-rate';\nimport logger from './logger';\n\nexport interface InvoiceItemInput {\n  price_id: string;\n  quantity: number;\n  amount: string;\n  subscription_item_id?: string;\n  description: string;\n  period?: { start: number; end: number };\n  metadata?: Record<string, any>;\n  discountable?: boolean;\n  discount_amounts?: any[];\n}\n\nexport interface InvoiceItemWithQuote extends InvoiceItemInput {\n  quote_id?: string;\n}\n\n/**\n * Generate quotes for dynamic pricing invoice items\n * This function checks each invoice item's price and generates a quote if it uses dynamic pricing\n */\nexport async function generateQuotesForInvoiceItems(params: {\n  invoiceId: string;\n  items: InvoiceItemInput[];\n  currencyId: string;\n}): Promise<InvoiceItemWithQuote[]> {\n  const { invoiceId, items, currencyId } = params;\n\n  if (!items || items.length === 0) {\n    return [];\n  }\n\n  // Load currency with payment method\n  const currency = await PaymentCurrency.findByPk(currencyId, {\n    include: [{ association: 'payment_method' }],\n  });\n  if (!currency) {\n    throw new Error(`Currency ${currencyId} not found`);\n  }\n\n  // Get exchange rate once for all dynamic prices (for efficiency)\n  // For ArcBlock payment method, always use ABT for exchange rate\n  const exchangeRateService = getExchangeRateService();\n  const rateSymbol = (currency as any).payment_method?.type === 'arcblock' ? 'ABT' : currency.symbol;\n  let rateResult: RateResult | null = null;\n\n  const quoteService = getQuoteService();\n  const enrichedItems: InvoiceItemWithQuote[] = [];\n\n  // Note: Sequential processing is intentional here\n  // 1. Prices may not exist (early continue)\n  // 2. Exchange rate is fetched once and reused (rateResult)\n  // 3. Quote failures must be handled immediately (P0 critical)\n  // eslint-disable-next-line no-restricted-syntax\n  for (const item of items) {\n    // eslint-disable-next-line no-await-in-loop\n    const price = await Price.findByPk(item.price_id);\n    if (!price) {\n      logger.warn('Price not found for invoice item', { priceId: item.price_id, invoiceId });\n      enrichedItems.push(item);\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    // Check if price uses dynamic pricing\n    if (price.pricing_type !== 'dynamic') {\n      // Fixed pricing - use item amount as-is\n      enrichedItems.push(item);\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    // Dynamic pricing - generate quote\n    try {\n      // Get exchange rate if not already fetched\n      if (!rateResult) {\n        // eslint-disable-next-line no-await-in-loop\n        rateResult = await exchangeRateService.getRate(rateSymbol);\n      }\n\n      // Create quote for this invoice item\n      // eslint-disable-next-line no-await-in-loop\n      const { quote } = await quoteService.createQuoteWithRate({\n        price_id: item.price_id,\n        invoice_id: invoiceId,\n        target_currency_id: currencyId,\n        quantity: item.quantity,\n        rateResult,\n      });\n\n      logger.info('Generated quote for invoice item', {\n        invoiceId,\n        priceId: item.price_id,\n        quoteId: quote.id,\n        quotedAmount: quote.quoted_amount,\n      });\n\n      // Update item with quote info\n      enrichedItems.push({\n        ...item,\n        amount: quote.quoted_amount,\n        quote_id: quote.id,\n        metadata: {\n          ...item.metadata,\n          quote: {\n            id: quote.id,\n            // Reference price (USD)\n            base_currency: quote.base_currency,\n            base_amount: quote.base_amount, // Total USD amount\n            // Actual payment price\n            quoted_amount: quote.quoted_amount, // Total token amount\n            target_currency_id: quote.target_currency_id,\n            rate_currency_symbol: quote.rate_currency_symbol,\n            // Exchange rate info\n            exchange_rate: quote.exchange_rate, // 1 token = X USD\n            rate_provider_name: quote.rate_provider_name,\n            rate_provider_id: quote.rate_provider_id,\n            rate_timestamp_ms: quote.rate_timestamp_ms,\n            // Pricing context\n            quantity: item.quantity,\n            expires_at: quote.expires_at,\n            status: quote.status,\n          },\n        },\n      });\n    } catch (error: any) {\n      logger.error('Failed to generate quote for invoice item', {\n        invoiceId,\n        priceId: item.price_id,\n        error: error.message,\n      });\n\n      // P0 CRITICAL: Do not allow fallback for dynamic pricing\n      // Quote is the only source of truth for dynamic pricing amounts\n      // If quote generation fails, the invoice creation must fail\n      throw new Error(`Failed to generate quote for dynamic price ${item.price_id}: ${error.message}`);\n    }\n  }\n\n  return enrichedItems;\n}\n\n/**\n * Check if any invoice items use dynamic pricing\n */\nexport async function hasDynamicPricingItems(items: InvoiceItemInput[]): Promise<boolean> {\n  if (!items || items.length === 0) {\n    return false;\n  }\n\n  const priceIds = items.map((item) => item.price_id).filter(Boolean);\n  if (priceIds.length === 0) {\n    return false;\n  }\n\n  const prices = await Price.findAll({\n    where: { id: priceIds },\n    attributes: ['id', 'pricing_type'],\n  });\n\n  return prices.some((price) => price.pricing_type === 'dynamic');\n}\n","numLines":167,"startLine":1,"totalLines":167}}}
{"parentUuid":"dd47984f-795c-4831-8610-cf89c680ec8e","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TqXZ9CEGcRmRCFr4a2AKGD","type":"tool_result","content":"     1→import { component } from '@blocklet/sdk';\n     2→import type { LiteralUnion } from 'type-fest';\n     3→import { withQuery } from 'ufo';\n     4→\n     5→import { BN, fromUnitToToken } from '@ocap/util';\n     6→import { Op, type WhereOptions } from 'sequelize';\n     7→import { cloneDeep, pick } from 'lodash';\n     8→import {\n     9→  Customer,\n    10→  Invoice,\n    11→  InvoiceItem,\n    12→  PaymentCurrency,\n    13→  PaymentIntent,\n    14→  PaymentMethod,\n    15→  PaymentSettings,\n    16→  Price,\n    17→  Product,\n    18→  Refund,\n    19→  SetupIntent,\n    20→  SimpleCustomField,\n    21→  Subscription,\n    22→  SubscriptionItem,\n    23→  TaxRate,\n    24→  TInvoice,\n    25→  TLineItemExpanded,\n    26→  UsageRecord,\n    27→  Lock,\n    28→  DiscountAmount,\n    29→} from '../store/models';\n    30→import { getConnectQueryParam } from './util';\n    31→import { expandLineItems } from './session';\n    32→import dayjs from './dayjs';\n    33→import {\n    34→  getSubscriptionCycleAmount,\n    35→  getSubscriptionCycleSetup,\n    36→  getSubscriptionItemPrice,\n    37→  getSubscriptionStakeAmountSetup,\n    38→  isSubscriptionOverdraftProtectionEnabled,\n    39→} from './subscription';\n    40→import logger from './logger';\n    41→import { ensureOverdraftProtectionPrice } from './overdraft-protection';\n    42→import { CHARGE_SUPPORTED_CHAIN_TYPES } from './constants';\n    43→import { emitAsync } from './event';\n    44→import { getPriceUintAmountByCurrency } from './price';\n    45→import { generateQuotesForInvoiceItems } from './invoice-quote';\n    46→\n    47→export function getCustomerInvoicePageUrl({\n    48→  invoiceId,\n    49→  userDid,\n    50→  locale = 'en',\n    51→  action = '',\n    52→}: {\n    53→  userDid: string;\n    54→  invoiceId: string;\n    55→  locale: LiteralUnion<'en' | 'zh', string>;\n    56→  action?: LiteralUnion<'pay', string>;\n    57→}) {\n    58→  return component.getUrl(\n    59→    withQuery(`customer/invoice/${invoiceId}`, {\n    60→      locale,\n    61→      action,\n    62→      ...getConnectQueryParam({ userDid }),\n    63→    })\n    64→  );\n    65→}\n    66→\n    67→export async function getOneTimeProductInfo(invoiceId: string, paymentCurrency: PaymentCurrency) {\n    68→  try {\n    69→    const doc = await Invoice.findOne({\n    70→      where: { id: invoiceId },\n    71→      include: [{ model: InvoiceItem, as: 'lines' }],\n    72→    });\n    73→    if (!doc) {\n    74→      throw new Error(`Invoice not found: ${invoiceId}`);\n    75→    }\n    76→    const json = doc.toJSON();\n    77→    const products = (await Product.findAll()).map((x) => x.toJSON());\n    78→    const prices = (await Price.findAll()).map((x) => x.toJSON());\n    79→    // @ts-ignore\n    80→    expandLineItems(json.lines, products, prices);\n    81→    const oneTimePaymentInfo: Array<{\n    82→      productName: string;\n    83→      paymentInfo: string;\n    84→      quantity: number;\n    85→    }> = [];\n    86→    // @ts-ignore\n    87→    (json.lines || []).forEach((x) => {\n    88→      const { recurring, product } = x.price;\n    89→      if (!recurring) {\n    90→        // it's one-time product\n    91→        oneTimePaymentInfo.push({\n    92→          productName: product?.name,\n    93→          paymentInfo: `${fromUnitToToken(x.amount, paymentCurrency.decimal)} ${paymentCurrency.symbol}`,\n    94→          quantity: x.quantity,\n    95→        });\n    96→      }\n    97→    });\n    98→    return oneTimePaymentInfo;\n    99→  } catch (err) {\n   100→    console.error(`Error in getOneTimeProductInfo for invoice ${invoiceId}:`, err);\n   101→    return [];\n   102→  }\n   103→}\n   104→\n   105→export async function getInvoiceShouldPayTotal(invoice: Invoice) {\n   106→  try {\n   107→    const subscription = await Subscription.findByPk(invoice.subscription_id);\n   108→    if (!subscription) {\n   109→      throw new Error(`Subscription not found: ${invoice.subscription_id}`);\n   110→    }\n   111→\n   112→    const paymentCurrency = await PaymentCurrency.findByPk(invoice.currency_id);\n   113→    if (!paymentCurrency) {\n   114→      throw new Error(`Payment currency not found: ${invoice.currency_id}`);\n   115→    }\n   116→\n   117→    const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n   118→    if (!paymentMethod) {\n   119→      throw new Error(`Payment method not found: ${paymentCurrency.payment_method_id}`);\n   120→    }\n   121→\n   122→    const subscriptionItems = await SubscriptionItem.findAll({\n   123→      where: { subscription_id: subscription.id },\n   124→    });\n   125→\n   126→    let expandedItems = await Price.expand(\n   127→      subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n   128→      { product: true }\n   129→    );\n   130→\n   131→    const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, invoice.period_start);\n   132→    let offset = 0;\n   133→    let filterFunc = (item: any) => item;\n   134→    if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type)) {\n   135→      switch (invoice.billing_reason) {\n   136→        case 'subscription_cancel':\n   137→          filterFunc = (item: any) => item.price?.recurring?.usage_type === 'metered';\n   138→          break;\n   139→        case 'subscription_cycle':\n   140→          filterFunc = (item: any) => item.price?.type === 'recurring';\n   141→          offset = setup.cycle / 1000;\n   142→          break;\n   143→        default:\n   144→          filterFunc = () => true;\n   145→      }\n   146→    }\n   147→    const previousPeriodStart = setup.period.start - offset;\n   148→    const previousPeriodEnd = setup.period.end - offset;\n   149→    expandedItems = await Promise.all(\n   150→      expandedItems.filter(filterFunc).map(async (item: any) => {\n   151→        const { price } = item;\n   152→        if (price?.recurring?.usage_type === 'metered') {\n   153→          const rawQuantity = await UsageRecord.getSummary({\n   154→            id: item.id,\n   155→            start: previousPeriodStart,\n   156→            end: previousPeriodEnd,\n   157→            method: price.recurring?.aggregate_usage,\n   158→            dryRun: true,\n   159→            searchBilled: false,\n   160→          });\n   161→          item.quantity = price.transformQuantity(rawQuantity);\n   162→        }\n   163→        return item;\n   164→      })\n   165→    );\n   166→\n   167→    const baseAmount = getSubscriptionCycleAmount(expandedItems, subscription.currency_id);\n   168→    let shouldPayTotal = baseAmount?.total || invoice.total;\n   169→\n   170→    // Apply discount if exists\n   171→    if (baseAmount?.total && invoice.total_discount_amounts && invoice.total_discount_amounts.length > 0) {\n   172→      const totalDiscountAmount = invoice.total_discount_amounts.reduce((sum, discount) => {\n   173→        return new BN(sum).add(new BN(discount.amount.toString())).toString();\n   174→      }, '0');\n   175→\n   176→      shouldPayTotal = new BN(shouldPayTotal).sub(new BN(totalDiscountAmount)).toString();\n   177→\n   178→      // Ensure the final amount doesn't go below zero\n   179→      if (new BN(shouldPayTotal).lt(new BN('0'))) {\n   180→        shouldPayTotal = '0';\n   181→      }\n   182→    }\n   183→\n   184→    return shouldPayTotal;\n   185→  } catch (err) {\n   186→    console.error(`Error in getInvoiceShouldPayTotal for invoice ${invoice.id}:`, err);\n   187→    return invoice.total;\n   188→  }\n   189→}\n   190→\n   191→export async function getReturnStakeInvoices(subscription: Subscription) {\n   192→  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n   193→  const returnStakeInvoice: Invoice[] = [];\n   194→  const refunds = await Refund.findAll({\n   195→    where: { subscription_id: subscription.id, status: 'succeeded', type: 'stake_return' },\n   196→    include: [\n   197→      { model: Invoice, as: 'invoice' },\n   198→      { model: Customer, as: 'customer' },\n   199→      { model: PaymentCurrency, as: 'paymentCurrency' },\n   200→    ],\n   201→  });\n   202→\n   203→  await Promise.all(\n   204→    refunds.map(async (r: any) => {\n   205→      const invoice =\n   206→        r.invoice ||\n   207→        (await Invoice.findOne({\n   208→          where: {\n   209→            subscription_id: subscription.id,\n   210→            currency_id: r.currency_id,\n   211→          },\n   212→          order: [['created_at', 'ASC']],\n   213→        }));\n   214→      returnStakeInvoice.push({\n   215→        id: r.id,\n   216→        status: 'paid',\n   217→        billing_reason: 'return_stake',\n   218→        description: 'Return Subscription staking',\n   219→        total: r.amount,\n   220→        amount_due: '0',\n   221→        amount_paid: r.amount,\n   222→        amount_remaining: '0',\n   223→        subscription_id: subscription.id,\n   224→        paid: true,\n   225→        ...pick(invoice, ['number', 'auto_advance', 'period_start', 'period_end']),\n   226→        ...pick(r, ['created_at', 'updated_at', 'currency_id', 'customer_id']),\n   227→        // @ts-ignore\n   228→        paymentCurrency: r.paymentCurrency,\n   229→        paymentMethod: method,\n   230→        customer: r.customer,\n   231→        metadata: {\n   232→          payment_details: {\n   233→            arcblock: {\n   234→              tx_hash: r?.payment_details?.arcblock?.tx_hash,\n   235→              payer: r?.payment_details?.arcblock?.payer,\n   236→            },\n   237→          },\n   238→        },\n   239→      });\n   240→    })\n   241→  );\n   242→  return returnStakeInvoice;\n   243→}\n   244→\n   245→export async function getSetupInvoice(\n   246→  subscription: Subscription,\n   247→  paymentMethod: PaymentMethod,\n   248→  currencyId: string,\n   249→  stakingProps: { tx_hash: string; payer: string; address: string }\n   250→) {\n   251→  const currency = await PaymentCurrency.findByPk(currencyId);\n   252→  if (!currency) {\n   253→    return null;\n   254→  }\n   255→  if (!stakingProps?.tx_hash) {\n   256→    return null;\n   257→  }\n   258→  if (paymentMethod?.type !== 'arcblock') {\n   259→    return null;\n   260→  }\n   261→  const firstInvoice = await Invoice.findOne({\n   262→    where: { subscription_id: subscription.id, currency_id: currency.id },\n   263→    order: [['created_at', 'ASC']],\n   264→    include: [{ model: Customer, as: 'customer' }],\n   265→  });\n   266→  if (!firstInvoice) {\n   267→    return null;\n   268→  }\n   269→  const stakeAmountResult = await getSubscriptionStakeAmountSetup(subscription, paymentMethod, stakingProps.tx_hash);\n   270→  // @ts-ignore\n   271→  const stakeAmount = stakeAmountResult?.[currency?.contract] || '0';\n   272→  return {\n   273→    id: stakingProps.address as string,\n   274→    status: 'paid',\n   275→    description: 'Subscription staking',\n   276→    billing_reason: 'stake',\n   277→    total: stakeAmount,\n   278→    amount_due: '0',\n   279→    amount_paid: stakeAmount,\n   280→    amount_remaining: '0',\n   281→    ...pick(firstInvoice, [\n   282→      'number',\n   283→      'paid',\n   284→      'auto_advance',\n   285→      'currency_id',\n   286→      'customer_id',\n   287→      'subscription_id',\n   288→      'period_start',\n   289→      'period_end',\n   290→      'created_at',\n   291→      'updated_at',\n   292→    ]),\n   293→    // @ts-ignore\n   294→    paymentCurrency: currency,\n   295→    paymentMethod,\n   296→    // @ts-ignore\n   297→    customer: firstInvoice?.customer,\n   298→    metadata: {\n   299→      payment_details: {\n   300→        arcblock: {\n   301→          tx_hash: stakingProps?.tx_hash,\n   302→          payer: stakingProps?.payer,\n   303→        },\n   304→      },\n   305→    },\n   306→  };\n   307→}\n   308→\n   309→export async function getStakingInvoices(subscription: Subscription): Promise<Invoice[]> {\n   310→  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n   311→  if (!method) {\n   312→    return [];\n   313→  }\n   314→  const stakeInvoices = await Invoice.findAll({\n   315→    where: { subscription_id: subscription.id, billing_reason: 'stake', status: 'paid' },\n   316→    include: [\n   317→      { model: Customer, as: 'customer' },\n   318→      { model: PaymentCurrency, as: 'paymentCurrency' },\n   319→      { model: PaymentMethod, as: 'paymentMethod' },\n   320→    ],\n   321→  });\n   322→  const invoices = cloneDeep(stakeInvoices);\n   323→  const setups = await SetupIntent.findAll({\n   324→    where: {\n   325→      customer_id: subscription.customer_id,\n   326→      payment_method_id: method?.id,\n   327→      status: 'succeeded',\n   328→      [Op.and]: [\n   329→        { metadata: { [Op.not]: null } },\n   330→        { 'metadata.subscription_id': subscription.id },\n   331→        { setup_details: { [Op.not]: null } },\n   332→        { 'setup_details.arcblock': { [Op.not]: null } },\n   333→        { 'setup_details.arcblock.staking': { [Op.not]: null } },\n   334→      ] as any,\n   335→    },\n   336→  });\n   337→  if (setups.length === 0) {\n   338→    // No payment change, use the first invoice\n   339→    if (stakeInvoices.length > 0) {\n   340→      return stakeInvoices;\n   341→    }\n   342→    const newInvoice = await getSetupInvoice(subscription, method, subscription.currency_id, {\n   343→      tx_hash: subscription.payment_details?.arcblock?.staking?.tx_hash!,\n   344→      payer: subscription.payment_details?.arcblock?.payer!,\n   345→      address: subscription.payment_details?.arcblock?.staking?.address!,\n   346→    });\n   347→    // @ts-ignore\n   348→    return [newInvoice].filter(Boolean);\n   349→  }\n   350→\n   351→  await Promise.all(\n   352→    setups.map(async (setup: SetupIntent, index: number) => {\n   353→      if (\n   354→        index === 0 &&\n   355→        setup.metadata?.from_currency &&\n   356→        !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.from_currency)\n   357→      ) {\n   358→        const paymentDetails =\n   359→          setup?.metadata?.from_payment_details?.arcblock || subscription.payment_details?.arcblock;\n   360→        const fromMethod = await PaymentMethod.findByPk(setup?.metadata?.from_payment_method_id);\n   361→        const newInvoice = await getSetupInvoice(subscription, fromMethod!, setup.metadata?.from_currency, {\n   362→          tx_hash: paymentDetails?.staking?.tx_hash!,\n   363→          payer: paymentDetails?.payer!,\n   364→          address: paymentDetails?.staking?.address!,\n   365→        });\n   366→        if (newInvoice) {\n   367→          // @ts-ignore\n   368→          invoices.push(newInvoice);\n   369→        }\n   370→      }\n   371→      if (setup.metadata?.to_currency && !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.to_currency)) {\n   372→        const newInvoice = await getSetupInvoice(subscription, method, setup.metadata?.to_currency, {\n   373→          tx_hash: setup.setup_details?.arcblock?.staking?.tx_hash!,\n   374→          payer: setup.setup_details?.arcblock?.payer!,\n   375→          address: setup.setup_details?.arcblock?.staking?.address!,\n   376→        });\n   377→        if (newInvoice) {\n   378→          // @ts-ignore\n   379→          invoices.push(newInvoice);\n   380→        }\n   381→      }\n   382→    })\n   383→  );\n   384→  return invoices;\n   385→}\n   386→\n   387→type BaseInvoiceProps = {\n   388→  customer: Customer;\n   389→  subscription?: Subscription | null;\n   390→  currency_id: string;\n   391→  livemode: boolean;\n   392→  period_start: number;\n   393→  period_end: number;\n   394→  status?: string;\n   395→  billing_reason: string;\n   396→  description: string;\n   397→  statement_descriptor?: string;\n   398→  total: string;\n   399→  subtotal?: string;\n   400→  amount_due?: string;\n   401→  amount_paid?: string;\n   402→  amount_remaining?: string;\n   403→  default_payment_method_id: string;\n   404→  payment_intent_id?: string;\n   405→  checkout_session_id?: string;\n   406→  metadata?: Record<string, any>;\n   407→  // Discount fields\n   408→  discounts?: string[];\n   409→  total_discount_amounts?: DiscountAmount[];\n   410→  items?: Array<{\n   411→    price_id: string;\n   412→    amount: string;\n   413→    quantity: number;\n   414→    description: string;\n   415→    period?: {\n   416→      start: number;\n   417→      end: number;\n   418→    };\n   419→    metadata?: Record<string, any>;\n   420→    subscription_item_id?: string;\n   421→    // Discount fields for InvoiceItem\n   422→    discountable?: boolean;\n   423→    discount_amounts?: DiscountAmount[];\n   424→  }>;\n   425→  auto_advance?: boolean;\n   426→  paid?: boolean;\n   427→  paid_out_of_band?: boolean;\n   428→  payment_settings?: PaymentSettings;\n   429→  footer?: string;\n   430→  custom_fields?: SimpleCustomField[];\n   431→  starting_token_balance?: Record<string, string>;\n   432→  ending_token_balance?: Record<string, string>;\n   433→  subtotal_excluding_tax?: string;\n   434→  collection_method?: 'charge_automatically' | 'send_invoice';\n   435→  id?: string;\n   436→  quote_id?: string;\n   437→};\n   438→\n   439→async function createInvoiceWithItems(props: BaseInvoiceProps): Promise<{\n   440→  invoice: Invoice;\n   441→  items: InvoiceItem[];\n   442→}> {\n   443→  const {\n   444→    customer,\n   445→    subscription,\n   446→    currency_id: currencyId,\n   447→    livemode,\n   448→    period_start: periodStart,\n   449→    period_end: periodEnd,\n   450→    status = 'open',\n   451→    billing_reason: billingReason,\n   452→    description,\n   453→    statement_descriptor: statementDescriptor = '',\n   454→    total,\n   455→    amount_due: amountDue = total,\n   456→    amount_paid: amountPaid = '0',\n   457→    amount_remaining: amountRemaining = total,\n   458→    default_payment_method_id: paymentMethodId,\n   459→    payment_intent_id: paymentIntentId = '',\n   460→    checkout_session_id: checkoutSessionId = '',\n   461→    items: itemsData,\n   462→    metadata = {},\n   463→    paid = false,\n   464→    auto_advance: autoAdvance = true,\n   465→    paid_out_of_band: paidOutOfBand = false,\n   466→    payment_settings: paymentSettings,\n   467→    ...extraProps\n   468→  } = props;\n   469→\n   470→  const invoiceNumber = await customer.getInvoiceNumber();\n   471→  // create invoice\n   472→  const invoice = await Invoice.create({\n   473→    amount_shipping: '0',\n   474→    starting_balance: '0',\n   475→    ending_balance: '0',\n   476→    subtotal_excluding_tax: '0',\n   477→    starting_token_balance: {},\n   478→    ending_token_balance: {},\n   479→    attempt_count: 0,\n   480→    attempted: false,\n   481→    tax: '0',\n   482→    discounts: props.discounts || [],\n   483→    total_discount_amounts: props.total_discount_amounts || [],\n   484→    collection_method: 'charge_automatically',\n   485→    ...extraProps,\n   486→    livemode,\n   487→    number: invoiceNumber,\n   488→    description,\n   489→    statement_descriptor: statementDescriptor,\n   490→    period_start: periodStart,\n   491→    period_end: periodEnd,\n   492→    auto_advance: autoAdvance,\n   493→    paid,\n   494→    paid_out_of_band: paidOutOfBand,\n   495→    status,\n   496→    billing_reason: billingReason,\n   497→    currency_id: currencyId,\n   498→    customer_id: customer.id,\n   499→    default_payment_method_id: paymentMethodId,\n   500→    payment_intent_id: paymentIntentId,\n   501→    subscription_id: subscription?.id,\n   502→    checkout_session_id: checkoutSessionId,\n   503→    total,\n   504→    subtotal: props.subtotal || total,\n   505→    amount_due: amountDue,\n   506→    amount_paid: amountPaid,\n   507→    amount_remaining: amountRemaining,\n   508→\n   509→    customer_address: customer.address,\n   510→    customer_email: customer.email,\n   511→    customer_name: customer.name,\n   512→    customer_phone: customer.phone,\n   513→\n   514→    effective_at: dayjs().unix(),\n   515→    status_transitions: {\n   516→      finalized_at: dayjs().unix(),\n   517→    },\n   518→    payment_settings: paymentSettings || subscription?.payment_settings,\n   519→    metadata,\n   520→  });\n   521→\n   522→  if (!itemsData) {\n   523→    return { invoice, items: [] };\n   524→  }\n   525→\n   526→  // Generate quotes for dynamic pricing items (subscription invoices)\n   527→  const enrichedItemsData = subscription\n   528→    ? await generateQuotesForInvoiceItems({\n   529→        invoiceId: invoice.id,\n   530→        items: itemsData,\n   531→        currencyId,\n   532→      })\n   533→    : itemsData;\n   534→\n   535→  // create invoice items\n   536→  const items = await Promise.all(\n   537→    enrichedItemsData.map(async (item) => {\n   538→      // Match tax rate for this specific item\n   539→      let taxRateId: string | undefined;\n   540→      if (customer.address?.country && item.price_id) {\n   541→        try {\n   542→          const price = await Price.findByPk(item.price_id);\n   543→          if (price?.product_id) {\n   544→            const product = await Product.findByPk(price.product_id);\n   545→            if (product) {\n   546→              const taxRate = await TaxRate.findMatchingRate({\n   547→                country: customer.address.country,\n   548→                state: customer.address.state,\n   549→                postalCode: customer.address.postal_code,\n   550→                taxCode: product.tax_code,\n   551→                livemode,\n   552→              });\n   553→              taxRateId = taxRate?.id;\n   554→            }\n   555→          }\n   556→        } catch (error) {\n   557→          logger.error('Failed to match tax rate for invoice item:', error);\n   558→        }\n   559→      }\n   560→\n   561→      return InvoiceItem.create({\n   562→        livemode,\n   563→        amount: item.amount,\n   564→        quantity: item.quantity,\n   565→        description: item.description,\n   566→        period: item.period,\n   567→        currency_id: currencyId,\n   568→        customer_id: customer.id,\n   569→        price_id: item.price_id,\n   570→        invoice_id: invoice.id,\n   571→        subscription_id: subscription?.id,\n   572→        subscription_item_id: item.subscription_item_id,\n   573→        tax_rate_id: taxRateId,\n   574→        discountable: item.discountable || false,\n   575→        discounts: [], // Keep as empty for now - this is legacy field\n   576→        discount_amounts:\n   577→          item.discount_amounts?.map((d) => ({ amount: new BN(d.amount || '0').toString(), discount: d.discount })) ||\n   578→          [],\n   579→        proration: false,\n   580→        proration_details: {},\n   581→        metadata: {\n   582→          ...(item.metadata || {}),\n   583→          // Include quote_id in metadata if it exists (for dynamic pricing)\n   584→          ...((item as any).quote_id && { quote_id: (item as any).quote_id }),\n   585→        },\n   586→      });\n   587→    })\n   588→  );\n   589→\n   590→  return { invoice, items };\n   591→}\n   592→\n   593→export async function ensureInvoiceAndItems({\n   594→  customer,\n   595→  currency,\n   596→  subscription,\n   597→  subscriptions,\n   598→  props,\n   599→  lineItems,\n   600→  trialing,\n   601→  metered,\n   602→  applyCredit = true,\n   603→}: {\n   604→  customer: Customer;\n   605→  currency: PaymentCurrency;\n   606→  subscription?: Subscription;\n   607→  subscriptions?: Subscription[];\n   608→  props: TInvoice;\n   609→  lineItems: TLineItemExpanded[];\n   610→  trialing: boolean; // do we have trialing\n   611→  metered: boolean; // is the quantity metered\n   612→  applyCredit?: boolean; // should we apply customer credit?\n   613→}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n   614→  // apply possible balance to invoice\n   615→  let remaining = props.total;\n   616→  let result = { starting: {}, ending: {} };\n   617→  if (applyCredit && props.total > '0' && !props.amount_remaining) {\n   618→    const balance = customer.getBalanceToApply(currency.id, props.total);\n   619→    result = await customer.decreaseTokenBalance(currency.id, balance);\n   620→    remaining = new BN(props.total).sub(new BN(balance)).toString();\n   621→    logger.info('Invoice will use customer credit', { result, remaining, total: props.total });\n   622→  }\n   623→\n   624→  // get subscription items\n   625→  let subscriptionItems: SubscriptionItem[] = [];\n   626→  if (subscriptions && subscriptions.length > 0) {\n   627→    subscriptionItems = await SubscriptionItem.findAll({\n   628→      where: { subscription_id: { [Op.in]: subscriptions.map((s) => s.id) } },\n   629→    });\n   630→  } else if (subscription) {\n   631→    subscriptionItems = await SubscriptionItem.findAll({\n   632→      where: { subscription_id: subscription?.id },\n   633→    });\n   634→  }\n   635→\n   636→  function getLineSetup(x: TLineItemExpanded) {\n   637→    const price = getSubscriptionItemPrice(x);\n   638→    if (price.type === 'recurring' && trialing) {\n   639→      return {\n   640→        price,\n   641→        amount: '0',\n   642→        // @ts-ignore\n   643→        description: trialing ? `${price.product.name} (trialing)` : price.product.name,\n   644→        period: {\n   645→          start: props.period_start,\n   646→          end: props.period_end,\n   647→        },\n   648→      };\n   649→    }\n   650→\n   651→    return {\n   652→      price,\n   653→      amount:\n   654→        x.custom_amount ||\n   655→        new BN(getPriceUintAmountByCurrency(price, props.currency_id)).mul(new BN(x.quantity)).toString(),\n   656→      description: price.product.name,\n   657→      period: undefined,\n   658→    };\n   659→  }\n   660→  // process line items\n   661→  const processedItems = lineItems.map((x: TLineItemExpanded) => {\n   662→    const setup = getLineSetup(x);\n   663→    const { price } = setup;\n   664→    let { quantity } = x;\n   665→    if (price.type === 'recurring') {\n   666→      if (price.recurring?.usage_type === 'metered' && !metered) {\n   667→        quantity = 0;\n   668→      }\n   669→      if (trialing) {\n   670→        quantity = 0;\n   671→      }\n   672→    }\n   673→\n   674→    return {\n   675→      price_id: price.id,\n   676→      amount: quantity > 0 ? setup.amount : '0',\n   677→      quantity,\n   678→      description: setup.description,\n   679→      period: setup.period,\n   680→      metadata: x.metadata || {},\n   681→      subscription_item_id: subscriptionItems.find((si) => si.price_id === price.id)?.id,\n   682→      // Discount fields from pre-calculated line items\n   683→      discountable: x.discountable || false,\n   684→      discount_amounts: x.discount_amounts || [],\n   685→    };\n   686→  });\n   687→\n   688→  return createInvoiceWithItems({\n   689→    customer,\n   690→    subscription,\n   691→    items: processedItems,\n   692→    livemode: props.livemode,\n   693→    status: props.status || 'open',\n   694→    billing_reason: props.billing_reason,\n   695→    description: props.description || '',\n   696→    statement_descriptor: props.statement_descriptor,\n   697→\n   698→    currency_id: props.currency_id,\n   699→    payment_intent_id: props.payment_intent_id,\n   700→    checkout_session_id: props.checkout_session_id,\n   701→    default_payment_method_id: props.default_payment_method_id,\n   702→\n   703→    period_start: props.period_start,\n   704→    period_end: props.period_end,\n   705→    auto_advance: props.auto_advance,\n   706→\n   707→    total: props.total,\n   708→    subtotal: props.subtotal || props.total,\n   709→    amount_remaining: props.amount_remaining || remaining,\n   710→    amount_paid: props.amount_paid,\n   711→    amount_due: props.amount_due || remaining,\n   712→    subtotal_excluding_tax: props.subtotal || props.total || '0',\n   713→    starting_token_balance: result.starting,\n   714→    ending_token_balance: result.ending,\n   715→\n   716→    footer: props.footer,\n   717→    custom_fields: props.custom_fields,\n   718→    payment_settings: props.payment_settings || subscription?.payment_settings,\n   719→    discounts: props.discounts,\n   720→    total_discount_amounts: props.total_discount_amounts || [],\n   721→    metadata: {\n   722→      ...props.metadata,\n   723→      starting_token_balance: result.starting,\n   724→      ending_token_balance: result.ending,\n   725→    },\n   726→  });\n   727→}\n   728→\n   729→export async function cleanupInvoiceAndItems(invoiceId: string) {\n   730→  const invoice = await Invoice.findByPk(invoiceId);\n   731→  if (!invoice) {\n   732→    return;\n   733→  }\n   734→  if (invoice.isImmutable()) {\n   735→    return;\n   736→  }\n   737→\n   738→  const removedItem = await InvoiceItem.destroy({ where: { invoice_id: invoiceId } });\n   739→  const removedInvoice = await Invoice.destroy({ where: { id: invoiceId } });\n   740→  logger.info('cleanup invoice and items', { invoiceId, removedItem, removedInvoice });\n   741→}\n   742→\n   743→export async function ensureRechargeInvoice(\n   744→  invoiceProps: {\n   745→    total: string;\n   746→    description?: string;\n   747→    checkout_session_id?: string;\n   748→    currency_id: string;\n   749→    metadata?: any;\n   750→    payment_settings?: any;\n   751→    livemode?: boolean;\n   752→  },\n   753→  subscription: Subscription | null,\n   754→  paymentMethod: PaymentMethod,\n   755→  customer: Customer\n   756→) {\n   757→  try {\n   758→    const { livemode = true } = invoiceProps;\n   759→    const { invoice } = await createInvoiceWithItems({\n   760→      customer,\n   761→      subscription,\n   762→      currency_id: invoiceProps.currency_id,\n   763→      livemode: subscription?.livemode ?? livemode,\n   764→      period_start: dayjs().unix(),\n   765→      period_end: dayjs().unix(),\n   766→      status: 'paid',\n   767→      billing_reason: 'recharge',\n   768→      description: invoiceProps?.description || 'Add funds for subscription',\n   769→      total: invoiceProps.total || '0',\n   770→      amount_due: '0',\n   771→      amount_paid: invoiceProps.total || '0',\n   772→      amount_remaining: '0',\n   773→      default_payment_method_id: paymentMethod.id,\n   774→      checkout_session_id: invoiceProps?.checkout_session_id || '',\n   775→      metadata: invoiceProps.metadata || {},\n   776→      auto_advance: false,\n   777→      paid: true,\n   778→      paid_out_of_band: false,\n   779→      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n   780→    });\n   781→\n   782→    logger.info('create recharge invoice success', {\n   783→      invoice,\n   784→      subscriptionId: subscription?.id,\n   785→      paymentMethod: paymentMethod.id,\n   786→    });\n   787→  } catch (error) {\n   788→    logger.error('ensureRechargeInvoice: create invoice failed', {\n   789→      error,\n   790→      subscriptionId: subscription?.id,\n   791→      paymentMethod: paymentMethod.id,\n   792→    });\n   793→    throw error;\n   794→  }\n   795→}\n   796→\n   797→export async function ensureOverdraftProtectionInvoiceAndItems({\n   798→  customer,\n   799→  subscription,\n   800→  paymentIntent,\n   801→  props,\n   802→}: {\n   803→  customer: Customer;\n   804→  subscription: Subscription;\n   805→  paymentIntent: PaymentIntent;\n   806→  props: Partial<TInvoice> & { period_start: number; period_end: number };\n   807→}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n   808→  const { price, product } = await ensureOverdraftProtectionPrice(subscription.livemode);\n   809→  const invoicePrice = price?.currency_options?.find((x: any) => x.currency_id === paymentIntent?.currency_id);\n   810→\n   811→  if (!subscription.overdraft_protection?.enabled) {\n   812→    throw new Error('Overdraft protection invoice creation skipped: overdraft protection is not enabled');\n   813→  }\n   814→\n   815→  if (!invoicePrice) {\n   816→    throw new Error('Overdraft protection invoice price not found');\n   817→  }\n   818→  const currency = await PaymentCurrency.findByPk(invoicePrice.currency_id);\n   819→  if (!currency) {\n   820→    throw new Error('Overdraft protection invoice currency not found');\n   821→  }\n   822→  const paymentMethod = await PaymentMethod.findByPk(currency?.payment_method_id);\n   823→  if (!paymentMethod) {\n   824→    throw new Error('Overdraft protection invoice payment method not found');\n   825→  }\n   826→\n   827→  if (paymentMethod.type !== 'arcblock') {\n   828→    throw new Error(`Payment method ${paymentMethod.type} not supported for overdraft protection`);\n   829→  }\n   830→\n   831→  const { unused } = await isSubscriptionOverdraftProtectionEnabled(subscription, paymentIntent?.currency_id);\n   832→  if (new BN(unused).lt(new BN(invoicePrice.unit_amount))) {\n   833→    throw new Error('Overdraft protection invoice creation skipped: insufficient overdraft protection funds');\n   834→  }\n   835→\n   836→  const result = await createInvoiceWithItems({\n   837→    customer,\n   838→    subscription,\n   839→    currency_id: invoicePrice.currency_id,\n   840→    livemode: subscription.livemode,\n   841→    period_start: props.period_start || 0,\n   842→    period_end: props.period_end || 0,\n   843→    status: props.status,\n   844→    billing_reason: 'overdraft_protection',\n   845→    description: 'Overdraft protection',\n   846→    collection_method: 'send_invoice',\n   847→    default_payment_method_id: paymentMethod.id,\n   848→    total: invoicePrice.unit_amount || '0',\n   849→    items: [\n   850→      {\n   851→        price_id: price?.id || '',\n   852→        amount: invoicePrice.unit_amount || '0',\n   853→        quantity: 1,\n   854→        description: product?.name || '',\n   855→        period: {\n   856→          start: props.period_start || 0,\n   857→          end: props.period_end || 0,\n   858→        },\n   859→      },\n   860→    ],\n   861→    metadata: {\n   862→      ...(props.metadata || {}),\n   863→      payment_intent_id: paymentIntent.id,\n   864→    },\n   865→  });\n   866→\n   867→  await Price.increment({ quantity_sold: 1 }, { where: { id: price?.id } });\n   868→  return result;\n   869→}\n   870→\n   871→export async function ensureStakeInvoice(\n   872→  invoiceProps: {\n   873→    total: string;\n   874→    description?: string;\n   875→    checkout_session_id?: string;\n   876→    currency_id: string;\n   877→    billing_reason?: string;\n   878→    metadata?: any;\n   879→    payment_settings?: any;\n   880→  },\n   881→  subscription: Subscription,\n   882→  paymentMethod: PaymentMethod,\n   883→  customer: Customer,\n   884→  allSubscriptions?: Subscription[]\n   885→) {\n   886→  if (paymentMethod.type !== 'arcblock') {\n   887→    return;\n   888→  }\n   889→\n   890→  try {\n   891→    const isMultiSubscription = allSubscriptions && allSubscriptions.length > 1;\n   892→    const metadata = {\n   893→      ...(invoiceProps.metadata || {}),\n   894→    };\n   895→\n   896→    if (isMultiSubscription) {\n   897→      metadata.all_subscription_ids = allSubscriptions.map((s) => s.id);\n   898→      metadata.is_shared_stake = true;\n   899→      metadata.primary_subscription_id = subscription.id;\n   900→    }\n   901→\n   902→    const { invoice } = await createInvoiceWithItems({\n   903→      customer,\n   904→      subscription,\n   905→      currency_id: invoiceProps.currency_id,\n   906→      livemode: subscription.livemode,\n   907→      period_start: dayjs().unix(),\n   908→      period_end: subscription.current_period_end,\n   909→      status: 'paid',\n   910→      billing_reason: invoiceProps?.billing_reason || 'stake',\n   911→      description: invoiceProps?.description || 'Stake for subscription',\n   912→      total: invoiceProps.total || '0',\n   913→      amount_due: '0',\n   914→      amount_paid: invoiceProps.total || '0',\n   915→      amount_remaining: '0',\n   916→      default_payment_method_id: paymentMethod.id,\n   917→      checkout_session_id: invoiceProps?.checkout_session_id || '',\n   918→      metadata,\n   919→      auto_advance: false,\n   920→      paid: true,\n   921→      paid_out_of_band: false,\n   922→      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n   923→    });\n   924→\n   925→    logger.info('create staking invoice success', {\n   926→      invoice,\n   927→      subscriptionId: subscription?.id,\n   928→      paymentMethod: paymentMethod.id,\n   929→    });\n   930→  } catch (error) {\n   931→    logger.error('ensureStake: create invoice failed', {\n   932→      error,\n   933→      subscriptionId: subscription?.id,\n   934→      paymentMethod: paymentMethod.id,\n   935→    });\n   936→    throw error;\n   937→  }\n   938→}\n   939→\n   940→export async function getStakeInvoiceForSubscription(subscriptionId: string, currencyId: string) {\n   941→  const where: WhereOptions = {\n   942→    [Op.or]: [\n   943→      { subscription_id: subscriptionId },\n   944→      { 'metadata.all_subscription_ids': { [Op.contains]: [subscriptionId] } },\n   945→    ],\n   946→    billing_reason: 'stake',\n   947→    status: 'paid',\n   948→  };\n   949→\n   950→  if (currencyId) {\n   951→    where.currency_id = currencyId;\n   952→  }\n   953→  try {\n   954→    const invoice = await Invoice.findOne({ where });\n   955→    return invoice;\n   956→  } catch (error) {\n   957→    logger.error('getStakeInvoiceForSubscription: find invoice failed', {\n   958→      error,\n   959→      subscriptionId,\n   960→      currencyId,\n   961→    });\n   962→    return null;\n   963→  }\n   964→}\n   965→\n   966→// mark overdraft protection invoice as void after payment\n   967→export async function handleOverdraftProtectionInvoiceAfterPayment(invoice: Invoice) {\n   968→  try {\n   969→    if (['stake', 'overdraft_protection', 'stake_overdraft_protection'].includes(invoice.billing_reason)) {\n   970→      return;\n   971→    }\n   972→    const subscription = await Subscription.findByPk(invoice.subscription_id);\n   973→    if (!subscription) {\n   974→      logger.info('handle overdraft protection invoice skipped due to subscription not found', {\n   975→        invoiceId: invoice.id,\n   976→      });\n   977→      return;\n   978→    }\n   979→    if (!subscription.overdraft_protection?.enabled) {\n   980→      logger.info('handle overdraft protection invoice skipped due to overdraft protection not enabled', {\n   981→        subscriptionId: subscription.id,\n   982→      });\n   983→      return;\n   984→    }\n   985→    const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n   986→    if (!paymentMethod || paymentMethod?.type !== 'arcblock') {\n   987→      logger.info('handle overdraft protection invoice skipped due to payment method not supported', {\n   988→        invoiceId: invoice.id,\n   989→        paymentMethodId: paymentMethod?.id,\n   990→      });\n   991→      return;\n   992→    }\n   993→    const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n   994→    if (!paymentIntent) {\n   995→      logger.info('handle overdraft protection invoice skipped due to payment intent not found', {\n   996→        invoiceId: invoice.id,\n   997→      });\n   998→      return;\n   999→    }\n  1000→    if (paymentIntent.status !== 'succeeded') {\n  1001→      logger.info('handle overdraft protection invoice skipped due to payment intent not succeeded', {\n  1002→        invoiceId: invoice.id,\n  1003→      });\n  1004→      return;\n  1005→    }\n  1006→    if (paymentIntent.payment_details?.arcblock?.type !== 'transfer') {\n  1007→      logger.info('handle overdraft protection invoice skipped due to payment type not transfer', {\n  1008→        invoiceId: invoice.id,\n  1009→        paymentIntentId: paymentIntent.id,\n  1010→      });\n  1011→      return;\n  1012→    }\n  1013→    const overdraftProtectionInvoice = await Invoice.findOne({\n  1014→      where: {\n  1015→        subscription_id: subscription.id,\n  1016→        billing_reason: 'overdraft_protection',\n  1017→        'metadata.invoice_id': invoice.id,\n  1018→        status: {\n  1019→          [Op.notIn]: ['paid', 'void'],\n  1020→        },\n  1021→      },\n  1022→    });\n  1023→    if (!overdraftProtectionInvoice) {\n  1024→      logger.info('handle overdraft protection invoice skipped due to overdraft protection invoice not found', {\n  1025→        invoiceId: invoice.id,\n  1026→      });\n  1027→      return;\n  1028→    }\n  1029→\n  1030→    if (overdraftProtectionInvoice.payment_intent_id) {\n  1031→      const overdraftProtectionPaymentIntent = await PaymentIntent.findOne({\n  1032→        where: {\n  1033→          id: overdraftProtectionInvoice.payment_intent_id,\n  1034→        },\n  1035→      });\n  1036→      if (overdraftProtectionPaymentIntent) {\n  1037→        await overdraftProtectionPaymentIntent.update({\n  1038→          status: 'canceled',\n  1039→          canceled_at: dayjs().unix(),\n  1040→          cancellation_reason: 'void_invoice',\n  1041→        });\n  1042→      }\n  1043→    }\n  1044→\n  1045→    await overdraftProtectionInvoice.update({\n  1046→      status: 'void',\n  1047→      status_transitions: {\n  1048→        ...(overdraftProtectionInvoice.status_transitions || {}),\n  1049→        voided_at: dayjs().unix(),\n  1050→      },\n  1051→    });\n  1052→  } catch (error) {\n  1053→    logger.error('handle overdraft protection invoice failed', {\n  1054→      error,\n  1055→      invoiceId: invoice.id,\n  1056→    });\n  1057→  }\n  1058→}\n  1059→\n  1060→/**\n  1061→ * retry uncollectible invoices\n  1062→ * @param options\n  1063→ */\n  1064→export async function retryUncollectibleInvoices(options: {\n  1065→  customerId?: string;\n  1066→  subscriptionId?: string;\n  1067→  invoiceId?: string;\n  1068→  invoiceIds?: string[];\n  1069→  currencyId?: string;\n  1070→}) {\n  1071→  const lockKey = `retry-uncollectible-${JSON.stringify(options)}`;\n  1072→\n  1073→  const isLocked = await Lock.isLocked(lockKey);\n  1074→  if (isLocked) {\n  1075→    logger.warn('Retry uncollectible invoices already in progress', {\n  1076→      lockKey,\n  1077→      options,\n  1078→    });\n  1079→    throw new Error('Retry already in progress');\n  1080→  }\n  1081→\n  1082→  try {\n  1083→    await Lock.acquire(lockKey, dayjs().add(5, 'minutes').unix());\n  1084→\n  1085→    const { customerId, subscriptionId, invoiceId, invoiceIds, currencyId } = options;\n  1086→\n  1087→    const where: WhereOptions = {\n  1088→      status: { [Op.in]: ['uncollectible'] },\n  1089→      payment_intent_id: { [Op.ne]: null },\n  1090→    };\n  1091→\n  1092→    if (customerId) {\n  1093→      where.customer_id = customerId;\n  1094→    }\n  1095→\n  1096→    if (subscriptionId) {\n  1097→      where.subscription_id = subscriptionId;\n  1098→    }\n  1099→\n  1100→    if (invoiceId) {\n  1101→      where.id = invoiceId;\n  1102→    }\n  1103→\n  1104→    if (invoiceIds && invoiceIds.length > 0) {\n  1105→      where.id = { [Op.in]: invoiceIds };\n  1106→    }\n  1107→\n  1108→    if (currencyId) {\n  1109→      where.currency_id = currencyId;\n  1110→    }\n  1111→\n  1112→    const overdueInvoices = (await Invoice.findAll({\n  1113→      where,\n  1114→      include: [{ model: PaymentIntent, as: 'paymentIntent' }],\n  1115→      attributes: ['id', 'payment_intent_id', 'subscription_id', 'customer_id', 'created_at', 'status', 'currency_id'],\n  1116→      order: [['created_at', 'ASC']],\n  1117→    })) as (Invoice & { paymentIntent?: PaymentIntent })[];\n  1118→\n  1119→    const startTime = Date.now();\n  1120→    logger.info('Found uncollectible invoices to retry', {\n  1121→      count: overdueInvoices.length,\n  1122→      criteria: options,\n  1123→      invoiceIds: overdueInvoices.map((inv) => inv.id),\n  1124→    });\n  1125→\n  1126→    const results = {\n  1127→      processed: overdueInvoices.length,\n  1128→      successful: [] as string[],\n  1129→      failed: [] as Array<{ id: string; reason: string }>,\n  1130→    };\n  1131→\n  1132→    const settledResults = await Promise.allSettled(\n  1133→      overdueInvoices.map(async (invoice, index) => {\n  1134→        const { paymentIntent } = invoice;\n  1135→        const delay = index * 2;\n  1136→        if (!paymentIntent) {\n  1137→          throw new Error('No payment intent found');\n  1138→        }\n  1139→\n  1140→        await paymentIntent.update({ status: 'requires_capture' });\n  1141→        await emitAsync(\n  1142→          'payment.queued',\n  1143→          paymentIntent.id,\n  1144→          { paymentIntentId: paymentIntent.id, retryOnError: true, ignoreMaxRetryCheck: true },\n  1145→          { sync: false, delay }\n  1146→        );\n  1147→\n  1148→        return invoice;\n  1149→      })\n  1150→    );\n  1151→\n  1152→    settledResults.forEach((result, index) => {\n  1153→      const invoice = overdueInvoices[index];\n  1154→      if (!invoice) {\n  1155→        return;\n  1156→      }\n  1157→      if (result.status === 'fulfilled') {\n  1158→        results.successful.push(invoice.id);\n  1159→        logger.info('Successfully queued uncollectible invoice retry', {\n  1160→          invoiceId: invoice.id,\n  1161→          customerId: invoice.customer_id,\n  1162→          paymentIntentId: invoice.payment_intent_id,\n  1163→        });\n  1164→      } else {\n  1165→        const error = result.reason;\n  1166→        const errorType = error.name || 'Unknown';\n  1167→        const errorCode = error.code || 'UNKNOWN_ERROR';\n  1168→\n  1169→        results.failed.push({\n  1170→          id: invoice.id,\n  1171→          reason: error.message || 'Unknown error',\n  1172→        });\n  1173→\n  1174→        logger.error('Failed to queue uncollectible invoice retry', {\n  1175→          invoiceId: invoice.id,\n  1176→          customerId: invoice.customer_id,\n  1177→          subscriptionId: invoice.subscription_id,\n  1178→          paymentIntentId: invoice.payment_intent_id,\n  1179→          errorType,\n  1180→          errorCode,\n  1181→          error,\n  1182→        });\n  1183→      }\n  1184→    });\n  1185→\n  1186→    const processingTime = Date.now() - startTime;\n  1187→    logger.info('Completed retrying uncollectible invoices', {\n  1188→      totalProcessed: results.processed,\n  1189→      successful: results.successful.length,\n  1190→      failed: results.failed.length,\n  1191→      processingTimeMs: processingTime,\n  1192→    });\n  1193→\n  1194→    return results;\n  1195→  } finally {\n  1196→    await Lock.release(lockKey);\n  1197→    logger.info('Released retry uncollectible lock', { lockKey });\n  1198→  }\n  1199→}\n  1200→\n  1201→/**\n  1202→ * Migrate billing when a subscription's payment method changes.\n  1203→ * Steps:\n  1204→ * 1. Check if all subscription items are prepaid (licensed recurring).\n  1205→ * 2. If so, check if there is an unpaid invoice for the current period with the old payment method.\n  1206→ * 3. If such an invoice exists, void the old invoice and cancel its payment intent if present.\n  1207→ * 4. Create a new invoice for the current period with the new payment method.\n  1208→ * 5. If any step fails, throw an error and log details.\n  1209→ *\n  1210→ * @param subscription Subscription instance\n  1211→ * @param oldCurrencyId Old payment currency ID\n  1212→ * @param newCurrencyId New payment currency ID\n  1213→ * @returns Migration result: { migrated, oldInvoice, newInvoice }\n  1214→ */\n  1215→export const migrateSubscriptionPaymentMethodInvoice = async (\n  1216→  subscription: Subscription,\n  1217→  oldCurrencyId: string,\n  1218→  newCurrencyId: string\n  1219→) => {\n  1220→  // 1. Check if all subscription items are prepaid (licensed recurring)\n  1221→  const subscriptionItems = await SubscriptionItem.findAll({\n  1222→    where: { subscription_id: subscription.id },\n  1223→    include: [{ model: Price, as: 'price' }],\n  1224→  });\n  1225→\n  1226→  const subscriptionItemsExpanded = await Price.expand(subscriptionItems.map((x) => x.toJSON()));\n  1227→  const isPrepaid = subscriptionItemsExpanded.every((item: TLineItemExpanded) => {\n  1228→    const price = getSubscriptionItemPrice(item);\n  1229→    return price.type === 'recurring' && price.recurring?.usage_type === 'licensed';\n  1230→  });\n  1231→\n  1232→  if (!isPrepaid) {\n  1233→    logger.info('Skip billing migration for non-prepaid items', {\n  1234→      subscriptionId: subscription.id,\n  1235→    });\n  1236→    return { migrated: false, reason: 'has_non_prepaid_items' };\n  1237→  }\n  1238→\n  1239→  // 2. Find unpaid invoice for the current period with the old payment method\n  1240→  const currentPeriodInvoice = await Invoice.findOne({\n  1241→    where: {\n  1242→      subscription_id: subscription.id,\n  1243→      billing_reason: 'subscription_cycle',\n  1244→      status: ['open', 'uncollectible'],\n  1245→      currency_id: oldCurrencyId,\n  1246→      period_start: {\n  1247→        [Op.gte]: subscription.current_period_start,\n  1248→        [Op.lt]: subscription.current_period_end,\n  1249→      },\n  1250→    },\n  1251→    order: [['created_at', 'DESC']],\n  1252→  });\n  1253→\n  1254→  let voidedInvoice: Invoice | null = null;\n  1255→\n  1256→  if (!currentPeriodInvoice) {\n  1257→    voidedInvoice = await Invoice.findOne({\n  1258→      where: {\n  1259→        subscription_id: subscription.id,\n  1260→        billing_reason: 'subscription_cycle',\n  1261→        status: 'void',\n  1262→        currency_id: oldCurrencyId,\n  1263→        period_start: {\n  1264→          [Op.gte]: subscription.current_period_start,\n  1265→          [Op.lt]: subscription.current_period_end,\n  1266→        },\n  1267→      },\n  1268→      order: [['created_at', 'DESC']],\n  1269→    });\n  1270→    if (!voidedInvoice) {\n  1271→      logger.info('Skip billing migration for no unpaid invoice', {\n  1272→        subscriptionId: subscription.id,\n  1273→        periodStart: subscription.current_period_start,\n  1274→        periodEnd: subscription.current_period_end,\n  1275→        oldCurrencyId,\n  1276→      });\n  1277→      return { migrated: false, reason: 'no_unpaid_invoice' };\n  1278→    }\n  1279→  }\n  1280→\n  1281→  // 3. Get old and new payment method/currency\n  1282→  const oldPaymentCurrency = await PaymentCurrency.findByPk(oldCurrencyId);\n  1283→  if (!oldPaymentCurrency) {\n  1284→    throw new Error(`Payment currency ${oldCurrencyId} not found`);\n  1285→  }\n  1286→  const oldPaymentMethod = await PaymentMethod.findByPk(oldPaymentCurrency.payment_method_id);\n  1287→  if (!oldPaymentMethod) {\n  1288→    throw new Error(`Payment method for currency ${oldCurrencyId} not found`);\n  1289→  }\n  1290→\n  1291→  const newPaymentCurrency = await PaymentCurrency.findByPk(newCurrencyId);\n  1292→  if (!newPaymentCurrency) {\n  1293→    throw new Error(`Payment currency ${newCurrencyId} not found`);\n  1294→  }\n  1295→  const newPaymentMethod = await PaymentMethod.findByPk(newPaymentCurrency.payment_method_id);\n  1296→  if (!newPaymentMethod) {\n  1297→    throw new Error(`Payment method for currency ${newCurrencyId} not found`);\n  1298→  }\n  1299→\n  1300→  // 4. Stripe payment method is not supported for migration\n  1301→  if (newPaymentMethod.type === 'stripe') {\n  1302→    logger.info('Skip billing migration for stripe payment method', {\n  1303→      subscriptionId: subscription.id,\n  1304→    });\n  1305→    return { migrated: false, reason: 'stripe_payment_method' };\n  1306→  }\n  1307→\n  1308→  try {\n  1309→    const customer = await Customer.findByPk(subscription.customer_id);\n  1310→    if (!customer) {\n  1311→      throw new Error(`Customer ${subscription.customer_id} not found`);\n  1312→    }\n  1313→\n  1314→    const cancelOldInvoice = async (invoice: Invoice) => {\n  1315→      try {\n  1316→        if (invoice.payment_intent_id) {\n  1317→          const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n  1318→          if (paymentIntent && paymentIntent.status !== 'canceled') {\n  1319→            await paymentIntent.update({\n  1320→              status: 'canceled',\n  1321→              canceled_at: dayjs().unix(),\n  1322→              cancellation_reason: 'void_invoice',\n  1323→            });\n  1324→          }\n  1325→        }\n  1326→\n  1327→        if (oldPaymentMethod.type === 'stripe' && invoice.metadata?.stripe_id) {\n  1328→          const client = oldPaymentMethod.getStripeClient();\n  1329→          await client.invoices.voidInvoice(invoice.metadata.stripe_id);\n  1330→        }\n  1331→\n  1332→        await invoice.update({\n  1333→          status: 'void',\n  1334→          status_transitions: {\n  1335→            ...(invoice.status_transitions || {}),\n  1336→            voided_at: dayjs().unix(),\n  1337→          },\n  1338→        });\n  1339→\n  1340→        logger.info('Successfully voided old invoice for payment method change', {\n  1341→          subscriptionId: subscription.id,\n  1342→          oldInvoice: invoice.id,\n  1343→          oldCurrency: oldCurrencyId,\n  1344→          newCurrency: newCurrencyId,\n  1345→        });\n  1346→      } catch (error) {\n  1347→        logger.error('Failed to void old invoice', {\n  1348→          subscription: subscription.id,\n  1349→          invoiceId: invoice.id,\n  1350→          error: error.message,\n  1351→        });\n  1352→        throw error;\n  1353→      }\n  1354→    };\n  1355→\n  1356→    const createNewInvoice = async () => {\n  1357→      const preInvoice = currentPeriodInvoice || voidedInvoice;\n  1358→      if (!preInvoice) {\n  1359→        throw new Error('No unpaid invoice found');\n  1360→      }\n  1361→      const metadata: Record<string, any> = {\n  1362→        prev_invoice_id: preInvoice.id,\n  1363→      };\n  1364→      const amount = getSubscriptionCycleAmount(subscriptionItemsExpanded, newCurrencyId);\n  1365→\n  1366→      const { invoice } = await ensureInvoiceAndItems({\n  1367→        customer,\n  1368→        currency: newPaymentCurrency,\n  1369→        subscription,\n  1370→        trialing: subscription.status === 'trialing',\n  1371→        metered: false,\n  1372→        lineItems: subscriptionItemsExpanded,\n  1373→        applyCredit: false,\n  1374→        props: {\n  1375→          status: 'open',\n  1376→          total: amount.total,\n  1377→          livemode: subscription.livemode,\n  1378→          description: 'Subscription cycle',\n  1379→          statement_descriptor: preInvoice.statement_descriptor,\n  1380→          period_start: preInvoice.period_start,\n  1381→          period_end: preInvoice.period_end,\n  1382→          auto_advance: true,\n  1383→          billing_reason: 'subscription_cycle',\n  1384→          currency_id: newCurrencyId,\n  1385→          default_payment_method_id: newPaymentMethod.id,\n  1386→          custom_fields: preInvoice.custom_fields || [],\n  1387→          footer: preInvoice.footer || '',\n  1388→          payment_settings: subscription.payment_settings,\n  1389→          metadata,\n  1390→        } as Invoice,\n  1391→      });\n  1392→      return invoice;\n  1393→    };\n  1394→\n  1395→    // 5. Cancel old invoice, then create new invoice\n  1396→    if (currentPeriodInvoice) {\n  1397→      await cancelOldInvoice(currentPeriodInvoice);\n  1398→    }\n  1399→\n  1400→    const invoice = await createNewInvoice();\n  1401→    if (invoice) {\n  1402→      await emitAsync('invoice.queued', invoice.id, { invoiceId: invoice.id, retryOnError: true }, { sync: false });\n  1403→      logger.info('Successfully queued new invoice for payment method change', {\n  1404→        subscriptionId: subscription.id,\n  1405→        invoiceId: invoice.id,\n  1406→      });\n  1407→    }\n  1408→\n  1409→    logger.info('Successfully migrated invoice for payment method change', {\n  1410→      subscriptionId: subscription.id,\n  1411→      oldInvoiceId: currentPeriodInvoice?.id || voidedInvoice?.id,\n  1412→      oldCurrency: oldCurrencyId,\n  1413→      newCurrency: newCurrencyId,\n  1414→      newInvoiceId: invoice.id,\n  1415→    });\n  1416→    return {\n  1417→      migrated: true,\n  1418→      oldInvoice: currentPeriodInvoice,\n  1419→      newInvoice: invoice,\n  1420→    };\n  1421→  } catch (error) {\n  1422→    logger.error('Failed to migrate invoice for payment method change', {\n  1423→      subscriptionId: subscription.id,\n  1424→      oldCurrencyId,\n  1425→      newCurrencyId,\n  1426→      error: error.message,\n  1427→    });\n  1428→    throw error;\n  1429→  }\n  1430→};\n  1431→\n  1432→export async function destroyExistingInvoice(invoice: Invoice) {\n  1433→  const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n  1434→  try {\n  1435→    if (paymentMethod?.type === 'stripe' && invoice.metadata?.stripe_id) {\n  1436→      const client = paymentMethod.getStripeClient();\n  1437→      await client.invoices.del(invoice.metadata.stripe_id);\n  1438→    }\n  1439→  } catch (error) {\n  1440→    logger.error('Failed to destroy invoice on stripe', {\n  1441→      error: error.message,\n  1442→      invoiceId: invoice.id,\n  1443→    });\n  1444→  }\n  1445→  await InvoiceItem.destroy({ where: { invoice_id: invoice.id } });\n  1446→  await invoice.destroy();\n  1447→}\n  1448→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d4e90782-d9a2-4199-834e-8917c481831e","timestamp":"2026-01-06T14:31:08.830Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts","content":"import { component } from '@blocklet/sdk';\nimport type { LiteralUnion } from 'type-fest';\nimport { withQuery } from 'ufo';\n\nimport { BN, fromUnitToToken } from '@ocap/util';\nimport { Op, type WhereOptions } from 'sequelize';\nimport { cloneDeep, pick } from 'lodash';\nimport {\n  Customer,\n  Invoice,\n  InvoiceItem,\n  PaymentCurrency,\n  PaymentIntent,\n  PaymentMethod,\n  PaymentSettings,\n  Price,\n  Product,\n  Refund,\n  SetupIntent,\n  SimpleCustomField,\n  Subscription,\n  SubscriptionItem,\n  TaxRate,\n  TInvoice,\n  TLineItemExpanded,\n  UsageRecord,\n  Lock,\n  DiscountAmount,\n} from '../store/models';\nimport { getConnectQueryParam } from './util';\nimport { expandLineItems } from './session';\nimport dayjs from './dayjs';\nimport {\n  getSubscriptionCycleAmount,\n  getSubscriptionCycleSetup,\n  getSubscriptionItemPrice,\n  getSubscriptionStakeAmountSetup,\n  isSubscriptionOverdraftProtectionEnabled,\n} from './subscription';\nimport logger from './logger';\nimport { ensureOverdraftProtectionPrice } from './overdraft-protection';\nimport { CHARGE_SUPPORTED_CHAIN_TYPES } from './constants';\nimport { emitAsync } from './event';\nimport { getPriceUintAmountByCurrency } from './price';\nimport { generateQuotesForInvoiceItems } from './invoice-quote';\n\nexport function getCustomerInvoicePageUrl({\n  invoiceId,\n  userDid,\n  locale = 'en',\n  action = '',\n}: {\n  userDid: string;\n  invoiceId: string;\n  locale: LiteralUnion<'en' | 'zh', string>;\n  action?: LiteralUnion<'pay', string>;\n}) {\n  return component.getUrl(\n    withQuery(`customer/invoice/${invoiceId}`, {\n      locale,\n      action,\n      ...getConnectQueryParam({ userDid }),\n    })\n  );\n}\n\nexport async function getOneTimeProductInfo(invoiceId: string, paymentCurrency: PaymentCurrency) {\n  try {\n    const doc = await Invoice.findOne({\n      where: { id: invoiceId },\n      include: [{ model: InvoiceItem, as: 'lines' }],\n    });\n    if (!doc) {\n      throw new Error(`Invoice not found: ${invoiceId}`);\n    }\n    const json = doc.toJSON();\n    const products = (await Product.findAll()).map((x) => x.toJSON());\n    const prices = (await Price.findAll()).map((x) => x.toJSON());\n    // @ts-ignore\n    expandLineItems(json.lines, products, prices);\n    const oneTimePaymentInfo: Array<{\n      productName: string;\n      paymentInfo: string;\n      quantity: number;\n    }> = [];\n    // @ts-ignore\n    (json.lines || []).forEach((x) => {\n      const { recurring, product } = x.price;\n      if (!recurring) {\n        // it's one-time product\n        oneTimePaymentInfo.push({\n          productName: product?.name,\n          paymentInfo: `${fromUnitToToken(x.amount, paymentCurrency.decimal)} ${paymentCurrency.symbol}`,\n          quantity: x.quantity,\n        });\n      }\n    });\n    return oneTimePaymentInfo;\n  } catch (err) {\n    console.error(`Error in getOneTimeProductInfo for invoice ${invoiceId}:`, err);\n    return [];\n  }\n}\n\nexport async function getInvoiceShouldPayTotal(invoice: Invoice) {\n  try {\n    const subscription = await Subscription.findByPk(invoice.subscription_id);\n    if (!subscription) {\n      throw new Error(`Subscription not found: ${invoice.subscription_id}`);\n    }\n\n    const paymentCurrency = await PaymentCurrency.findByPk(invoice.currency_id);\n    if (!paymentCurrency) {\n      throw new Error(`Payment currency not found: ${invoice.currency_id}`);\n    }\n\n    const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n    if (!paymentMethod) {\n      throw new Error(`Payment method not found: ${paymentCurrency.payment_method_id}`);\n    }\n\n    const subscriptionItems = await SubscriptionItem.findAll({\n      where: { subscription_id: subscription.id },\n    });\n\n    let expandedItems = await Price.expand(\n      subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n      { product: true }\n    );\n\n    const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, invoice.period_start);\n    let offset = 0;\n    let filterFunc = (item: any) => item;\n    if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type)) {\n      switch (invoice.billing_reason) {\n        case 'subscription_cancel':\n          filterFunc = (item: any) => item.price?.recurring?.usage_type === 'metered';\n          break;\n        case 'subscription_cycle':\n          filterFunc = (item: any) => item.price?.type === 'recurring';\n          offset = setup.cycle / 1000;\n          break;\n        default:\n          filterFunc = () => true;\n      }\n    }\n    const previousPeriodStart = setup.period.start - offset;\n    const previousPeriodEnd = setup.period.end - offset;\n    expandedItems = await Promise.all(\n      expandedItems.filter(filterFunc).map(async (item: any) => {\n        const { price } = item;\n        if (price?.recurring?.usage_type === 'metered') {\n          const rawQuantity = await UsageRecord.getSummary({\n            id: item.id,\n            start: previousPeriodStart,\n            end: previousPeriodEnd,\n            method: price.recurring?.aggregate_usage,\n            dryRun: true,\n            searchBilled: false,\n          });\n          item.quantity = price.transformQuantity(rawQuantity);\n        }\n        return item;\n      })\n    );\n\n    const baseAmount = getSubscriptionCycleAmount(expandedItems, subscription.currency_id);\n    let shouldPayTotal = baseAmount?.total || invoice.total;\n\n    // Apply discount if exists\n    if (baseAmount?.total && invoice.total_discount_amounts && invoice.total_discount_amounts.length > 0) {\n      const totalDiscountAmount = invoice.total_discount_amounts.reduce((sum, discount) => {\n        return new BN(sum).add(new BN(discount.amount.toString())).toString();\n      }, '0');\n\n      shouldPayTotal = new BN(shouldPayTotal).sub(new BN(totalDiscountAmount)).toString();\n\n      // Ensure the final amount doesn't go below zero\n      if (new BN(shouldPayTotal).lt(new BN('0'))) {\n        shouldPayTotal = '0';\n      }\n    }\n\n    return shouldPayTotal;\n  } catch (err) {\n    console.error(`Error in getInvoiceShouldPayTotal for invoice ${invoice.id}:`, err);\n    return invoice.total;\n  }\n}\n\nexport async function getReturnStakeInvoices(subscription: Subscription) {\n  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n  const returnStakeInvoice: Invoice[] = [];\n  const refunds = await Refund.findAll({\n    where: { subscription_id: subscription.id, status: 'succeeded', type: 'stake_return' },\n    include: [\n      { model: Invoice, as: 'invoice' },\n      { model: Customer, as: 'customer' },\n      { model: PaymentCurrency, as: 'paymentCurrency' },\n    ],\n  });\n\n  await Promise.all(\n    refunds.map(async (r: any) => {\n      const invoice =\n        r.invoice ||\n        (await Invoice.findOne({\n          where: {\n            subscription_id: subscription.id,\n            currency_id: r.currency_id,\n          },\n          order: [['created_at', 'ASC']],\n        }));\n      returnStakeInvoice.push({\n        id: r.id,\n        status: 'paid',\n        billing_reason: 'return_stake',\n        description: 'Return Subscription staking',\n        total: r.amount,\n        amount_due: '0',\n        amount_paid: r.amount,\n        amount_remaining: '0',\n        subscription_id: subscription.id,\n        paid: true,\n        ...pick(invoice, ['number', 'auto_advance', 'period_start', 'period_end']),\n        ...pick(r, ['created_at', 'updated_at', 'currency_id', 'customer_id']),\n        // @ts-ignore\n        paymentCurrency: r.paymentCurrency,\n        paymentMethod: method,\n        customer: r.customer,\n        metadata: {\n          payment_details: {\n            arcblock: {\n              tx_hash: r?.payment_details?.arcblock?.tx_hash,\n              payer: r?.payment_details?.arcblock?.payer,\n            },\n          },\n        },\n      });\n    })\n  );\n  return returnStakeInvoice;\n}\n\nexport async function getSetupInvoice(\n  subscription: Subscription,\n  paymentMethod: PaymentMethod,\n  currencyId: string,\n  stakingProps: { tx_hash: string; payer: string; address: string }\n) {\n  const currency = await PaymentCurrency.findByPk(currencyId);\n  if (!currency) {\n    return null;\n  }\n  if (!stakingProps?.tx_hash) {\n    return null;\n  }\n  if (paymentMethod?.type !== 'arcblock') {\n    return null;\n  }\n  const firstInvoice = await Invoice.findOne({\n    where: { subscription_id: subscription.id, currency_id: currency.id },\n    order: [['created_at', 'ASC']],\n    include: [{ model: Customer, as: 'customer' }],\n  });\n  if (!firstInvoice) {\n    return null;\n  }\n  const stakeAmountResult = await getSubscriptionStakeAmountSetup(subscription, paymentMethod, stakingProps.tx_hash);\n  // @ts-ignore\n  const stakeAmount = stakeAmountResult?.[currency?.contract] || '0';\n  return {\n    id: stakingProps.address as string,\n    status: 'paid',\n    description: 'Subscription staking',\n    billing_reason: 'stake',\n    total: stakeAmount,\n    amount_due: '0',\n    amount_paid: stakeAmount,\n    amount_remaining: '0',\n    ...pick(firstInvoice, [\n      'number',\n      'paid',\n      'auto_advance',\n      'currency_id',\n      'customer_id',\n      'subscription_id',\n      'period_start',\n      'period_end',\n      'created_at',\n      'updated_at',\n    ]),\n    // @ts-ignore\n    paymentCurrency: currency,\n    paymentMethod,\n    // @ts-ignore\n    customer: firstInvoice?.customer,\n    metadata: {\n      payment_details: {\n        arcblock: {\n          tx_hash: stakingProps?.tx_hash,\n          payer: stakingProps?.payer,\n        },\n      },\n    },\n  };\n}\n\nexport async function getStakingInvoices(subscription: Subscription): Promise<Invoice[]> {\n  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n  if (!method) {\n    return [];\n  }\n  const stakeInvoices = await Invoice.findAll({\n    where: { subscription_id: subscription.id, billing_reason: 'stake', status: 'paid' },\n    include: [\n      { model: Customer, as: 'customer' },\n      { model: PaymentCurrency, as: 'paymentCurrency' },\n      { model: PaymentMethod, as: 'paymentMethod' },\n    ],\n  });\n  const invoices = cloneDeep(stakeInvoices);\n  const setups = await SetupIntent.findAll({\n    where: {\n      customer_id: subscription.customer_id,\n      payment_method_id: method?.id,\n      status: 'succeeded',\n      [Op.and]: [\n        { metadata: { [Op.not]: null } },\n        { 'metadata.subscription_id': subscription.id },\n        { setup_details: { [Op.not]: null } },\n        { 'setup_details.arcblock': { [Op.not]: null } },\n        { 'setup_details.arcblock.staking': { [Op.not]: null } },\n      ] as any,\n    },\n  });\n  if (setups.length === 0) {\n    // No payment change, use the first invoice\n    if (stakeInvoices.length > 0) {\n      return stakeInvoices;\n    }\n    const newInvoice = await getSetupInvoice(subscription, method, subscription.currency_id, {\n      tx_hash: subscription.payment_details?.arcblock?.staking?.tx_hash!,\n      payer: subscription.payment_details?.arcblock?.payer!,\n      address: subscription.payment_details?.arcblock?.staking?.address!,\n    });\n    // @ts-ignore\n    return [newInvoice].filter(Boolean);\n  }\n\n  await Promise.all(\n    setups.map(async (setup: SetupIntent, index: number) => {\n      if (\n        index === 0 &&\n        setup.metadata?.from_currency &&\n        !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.from_currency)\n      ) {\n        const paymentDetails =\n          setup?.metadata?.from_payment_details?.arcblock || subscription.payment_details?.arcblock;\n        const fromMethod = await PaymentMethod.findByPk(setup?.metadata?.from_payment_method_id);\n        const newInvoice = await getSetupInvoice(subscription, fromMethod!, setup.metadata?.from_currency, {\n          tx_hash: paymentDetails?.staking?.tx_hash!,\n          payer: paymentDetails?.payer!,\n          address: paymentDetails?.staking?.address!,\n        });\n        if (newInvoice) {\n          // @ts-ignore\n          invoices.push(newInvoice);\n        }\n      }\n      if (setup.metadata?.to_currency && !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.to_currency)) {\n        const newInvoice = await getSetupInvoice(subscription, method, setup.metadata?.to_currency, {\n          tx_hash: setup.setup_details?.arcblock?.staking?.tx_hash!,\n          payer: setup.setup_details?.arcblock?.payer!,\n          address: setup.setup_details?.arcblock?.staking?.address!,\n        });\n        if (newInvoice) {\n          // @ts-ignore\n          invoices.push(newInvoice);\n        }\n      }\n    })\n  );\n  return invoices;\n}\n\ntype BaseInvoiceProps = {\n  customer: Customer;\n  subscription?: Subscription | null;\n  currency_id: string;\n  livemode: boolean;\n  period_start: number;\n  period_end: number;\n  status?: string;\n  billing_reason: string;\n  description: string;\n  statement_descriptor?: string;\n  total: string;\n  subtotal?: string;\n  amount_due?: string;\n  amount_paid?: string;\n  amount_remaining?: string;\n  default_payment_method_id: string;\n  payment_intent_id?: string;\n  checkout_session_id?: string;\n  metadata?: Record<string, any>;\n  // Discount fields\n  discounts?: string[];\n  total_discount_amounts?: DiscountAmount[];\n  items?: Array<{\n    price_id: string;\n    amount: string;\n    quantity: number;\n    description: string;\n    period?: {\n      start: number;\n      end: number;\n    };\n    metadata?: Record<string, any>;\n    subscription_item_id?: string;\n    // Discount fields for InvoiceItem\n    discountable?: boolean;\n    discount_amounts?: DiscountAmount[];\n  }>;\n  auto_advance?: boolean;\n  paid?: boolean;\n  paid_out_of_band?: boolean;\n  payment_settings?: PaymentSettings;\n  footer?: string;\n  custom_fields?: SimpleCustomField[];\n  starting_token_balance?: Record<string, string>;\n  ending_token_balance?: Record<string, string>;\n  subtotal_excluding_tax?: string;\n  collection_method?: 'charge_automatically' | 'send_invoice';\n  id?: string;\n  quote_id?: string;\n};\n\nasync function createInvoiceWithItems(props: BaseInvoiceProps): Promise<{\n  invoice: Invoice;\n  items: InvoiceItem[];\n}> {\n  const {\n    customer,\n    subscription,\n    currency_id: currencyId,\n    livemode,\n    period_start: periodStart,\n    period_end: periodEnd,\n    status = 'open',\n    billing_reason: billingReason,\n    description,\n    statement_descriptor: statementDescriptor = '',\n    total,\n    amount_due: amountDue = total,\n    amount_paid: amountPaid = '0',\n    amount_remaining: amountRemaining = total,\n    default_payment_method_id: paymentMethodId,\n    payment_intent_id: paymentIntentId = '',\n    checkout_session_id: checkoutSessionId = '',\n    items: itemsData,\n    metadata = {},\n    paid = false,\n    auto_advance: autoAdvance = true,\n    paid_out_of_band: paidOutOfBand = false,\n    payment_settings: paymentSettings,\n    ...extraProps\n  } = props;\n\n  const invoiceNumber = await customer.getInvoiceNumber();\n  // create invoice\n  const invoice = await Invoice.create({\n    amount_shipping: '0',\n    starting_balance: '0',\n    ending_balance: '0',\n    subtotal_excluding_tax: '0',\n    starting_token_balance: {},\n    ending_token_balance: {},\n    attempt_count: 0,\n    attempted: false,\n    tax: '0',\n    discounts: props.discounts || [],\n    total_discount_amounts: props.total_discount_amounts || [],\n    collection_method: 'charge_automatically',\n    ...extraProps,\n    livemode,\n    number: invoiceNumber,\n    description,\n    statement_descriptor: statementDescriptor,\n    period_start: periodStart,\n    period_end: periodEnd,\n    auto_advance: autoAdvance,\n    paid,\n    paid_out_of_band: paidOutOfBand,\n    status,\n    billing_reason: billingReason,\n    currency_id: currencyId,\n    customer_id: customer.id,\n    default_payment_method_id: paymentMethodId,\n    payment_intent_id: paymentIntentId,\n    subscription_id: subscription?.id,\n    checkout_session_id: checkoutSessionId,\n    total,\n    subtotal: props.subtotal || total,\n    amount_due: amountDue,\n    amount_paid: amountPaid,\n    amount_remaining: amountRemaining,\n\n    customer_address: customer.address,\n    customer_email: customer.email,\n    customer_name: customer.name,\n    customer_phone: customer.phone,\n\n    effective_at: dayjs().unix(),\n    status_transitions: {\n      finalized_at: dayjs().unix(),\n    },\n    payment_settings: paymentSettings || subscription?.payment_settings,\n    metadata,\n  });\n\n  if (!itemsData) {\n    return { invoice, items: [] };\n  }\n\n  // Generate quotes for dynamic pricing items (subscription invoices)\n  const enrichedItemsData = subscription\n    ? await generateQuotesForInvoiceItems({\n        invoiceId: invoice.id,\n        items: itemsData,\n        currencyId,\n      })\n    : itemsData;\n\n  // create invoice items\n  const items = await Promise.all(\n    enrichedItemsData.map(async (item) => {\n      // Match tax rate for this specific item\n      let taxRateId: string | undefined;\n      if (customer.address?.country && item.price_id) {\n        try {\n          const price = await Price.findByPk(item.price_id);\n          if (price?.product_id) {\n            const product = await Product.findByPk(price.product_id);\n            if (product) {\n              const taxRate = await TaxRate.findMatchingRate({\n                country: customer.address.country,\n                state: customer.address.state,\n                postalCode: customer.address.postal_code,\n                taxCode: product.tax_code,\n                livemode,\n              });\n              taxRateId = taxRate?.id;\n            }\n          }\n        } catch (error) {\n          logger.error('Failed to match tax rate for invoice item:', error);\n        }\n      }\n\n      return InvoiceItem.create({\n        livemode,\n        amount: item.amount,\n        quantity: item.quantity,\n        description: item.description,\n        period: item.period,\n        currency_id: currencyId,\n        customer_id: customer.id,\n        price_id: item.price_id,\n        invoice_id: invoice.id,\n        subscription_id: subscription?.id,\n        subscription_item_id: item.subscription_item_id,\n        tax_rate_id: taxRateId,\n        discountable: item.discountable || false,\n        discounts: [], // Keep as empty for now - this is legacy field\n        discount_amounts:\n          item.discount_amounts?.map((d) => ({ amount: new BN(d.amount || '0').toString(), discount: d.discount })) ||\n          [],\n        proration: false,\n        proration_details: {},\n        metadata: {\n          ...(item.metadata || {}),\n          // Include quote_id in metadata if it exists (for dynamic pricing)\n          ...((item as any).quote_id && { quote_id: (item as any).quote_id }),\n        },\n      });\n    })\n  );\n\n  return { invoice, items };\n}\n\nexport async function ensureInvoiceAndItems({\n  customer,\n  currency,\n  subscription,\n  subscriptions,\n  props,\n  lineItems,\n  trialing,\n  metered,\n  applyCredit = true,\n}: {\n  customer: Customer;\n  currency: PaymentCurrency;\n  subscription?: Subscription;\n  subscriptions?: Subscription[];\n  props: TInvoice;\n  lineItems: TLineItemExpanded[];\n  trialing: boolean; // do we have trialing\n  metered: boolean; // is the quantity metered\n  applyCredit?: boolean; // should we apply customer credit?\n}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n  // apply possible balance to invoice\n  let remaining = props.total;\n  let result = { starting: {}, ending: {} };\n  if (applyCredit && props.total > '0' && !props.amount_remaining) {\n    const balance = customer.getBalanceToApply(currency.id, props.total);\n    result = await customer.decreaseTokenBalance(currency.id, balance);\n    remaining = new BN(props.total).sub(new BN(balance)).toString();\n    logger.info('Invoice will use customer credit', { result, remaining, total: props.total });\n  }\n\n  // get subscription items\n  let subscriptionItems: SubscriptionItem[] = [];\n  if (subscriptions && subscriptions.length > 0) {\n    subscriptionItems = await SubscriptionItem.findAll({\n      where: { subscription_id: { [Op.in]: subscriptions.map((s) => s.id) } },\n    });\n  } else if (subscription) {\n    subscriptionItems = await SubscriptionItem.findAll({\n      where: { subscription_id: subscription?.id },\n    });\n  }\n\n  function getLineSetup(x: TLineItemExpanded) {\n    const price = getSubscriptionItemPrice(x);\n    if (price.type === 'recurring' && trialing) {\n      return {\n        price,\n        amount: '0',\n        // @ts-ignore\n        description: trialing ? `${price.product.name} (trialing)` : price.product.name,\n        period: {\n          start: props.period_start,\n          end: props.period_end,\n        },\n      };\n    }\n\n    return {\n      price,\n      amount:\n        x.custom_amount ||\n        new BN(getPriceUintAmountByCurrency(price, props.currency_id)).mul(new BN(x.quantity)).toString(),\n      description: price.product.name,\n      period: undefined,\n    };\n  }\n  // process line items\n  const processedItems = lineItems.map((x: TLineItemExpanded) => {\n    const setup = getLineSetup(x);\n    const { price } = setup;\n    let { quantity } = x;\n    if (price.type === 'recurring') {\n      if (price.recurring?.usage_type === 'metered' && !metered) {\n        quantity = 0;\n      }\n      if (trialing) {\n        quantity = 0;\n      }\n    }\n\n    return {\n      price_id: price.id,\n      amount: quantity > 0 ? setup.amount : '0',\n      quantity,\n      description: setup.description,\n      period: setup.period,\n      metadata: x.metadata || {},\n      subscription_item_id: subscriptionItems.find((si) => si.price_id === price.id)?.id,\n      // Discount fields from pre-calculated line items\n      discountable: x.discountable || false,\n      discount_amounts: x.discount_amounts || [],\n    };\n  });\n\n  return createInvoiceWithItems({\n    customer,\n    subscription,\n    items: processedItems,\n    livemode: props.livemode,\n    status: props.status || 'open',\n    billing_reason: props.billing_reason,\n    description: props.description || '',\n    statement_descriptor: props.statement_descriptor,\n\n    currency_id: props.currency_id,\n    payment_intent_id: props.payment_intent_id,\n    checkout_session_id: props.checkout_session_id,\n    default_payment_method_id: props.default_payment_method_id,\n\n    period_start: props.period_start,\n    period_end: props.period_end,\n    auto_advance: props.auto_advance,\n\n    total: props.total,\n    subtotal: props.subtotal || props.total,\n    amount_remaining: props.amount_remaining || remaining,\n    amount_paid: props.amount_paid,\n    amount_due: props.amount_due || remaining,\n    subtotal_excluding_tax: props.subtotal || props.total || '0',\n    starting_token_balance: result.starting,\n    ending_token_balance: result.ending,\n\n    footer: props.footer,\n    custom_fields: props.custom_fields,\n    payment_settings: props.payment_settings || subscription?.payment_settings,\n    discounts: props.discounts,\n    total_discount_amounts: props.total_discount_amounts || [],\n    metadata: {\n      ...props.metadata,\n      starting_token_balance: result.starting,\n      ending_token_balance: result.ending,\n    },\n  });\n}\n\nexport async function cleanupInvoiceAndItems(invoiceId: string) {\n  const invoice = await Invoice.findByPk(invoiceId);\n  if (!invoice) {\n    return;\n  }\n  if (invoice.isImmutable()) {\n    return;\n  }\n\n  const removedItem = await InvoiceItem.destroy({ where: { invoice_id: invoiceId } });\n  const removedInvoice = await Invoice.destroy({ where: { id: invoiceId } });\n  logger.info('cleanup invoice and items', { invoiceId, removedItem, removedInvoice });\n}\n\nexport async function ensureRechargeInvoice(\n  invoiceProps: {\n    total: string;\n    description?: string;\n    checkout_session_id?: string;\n    currency_id: string;\n    metadata?: any;\n    payment_settings?: any;\n    livemode?: boolean;\n  },\n  subscription: Subscription | null,\n  paymentMethod: PaymentMethod,\n  customer: Customer\n) {\n  try {\n    const { livemode = true } = invoiceProps;\n    const { invoice } = await createInvoiceWithItems({\n      customer,\n      subscription,\n      currency_id: invoiceProps.currency_id,\n      livemode: subscription?.livemode ?? livemode,\n      period_start: dayjs().unix(),\n      period_end: dayjs().unix(),\n      status: 'paid',\n      billing_reason: 'recharge',\n      description: invoiceProps?.description || 'Add funds for subscription',\n      total: invoiceProps.total || '0',\n      amount_due: '0',\n      amount_paid: invoiceProps.total || '0',\n      amount_remaining: '0',\n      default_payment_method_id: paymentMethod.id,\n      checkout_session_id: invoiceProps?.checkout_session_id || '',\n      metadata: invoiceProps.metadata || {},\n      auto_advance: false,\n      paid: true,\n      paid_out_of_band: false,\n      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n    });\n\n    logger.info('create recharge invoice success', {\n      invoice,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n  } catch (error) {\n    logger.error('ensureRechargeInvoice: create invoice failed', {\n      error,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n    throw error;\n  }\n}\n\nexport async function ensureOverdraftProtectionInvoiceAndItems({\n  customer,\n  subscription,\n  paymentIntent,\n  props,\n}: {\n  customer: Customer;\n  subscription: Subscription;\n  paymentIntent: PaymentIntent;\n  props: Partial<TInvoice> & { period_start: number; period_end: number };\n}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n  const { price, product } = await ensureOverdraftProtectionPrice(subscription.livemode);\n  const invoicePrice = price?.currency_options?.find((x: any) => x.currency_id === paymentIntent?.currency_id);\n\n  if (!subscription.overdraft_protection?.enabled) {\n    throw new Error('Overdraft protection invoice creation skipped: overdraft protection is not enabled');\n  }\n\n  if (!invoicePrice) {\n    throw new Error('Overdraft protection invoice price not found');\n  }\n  const currency = await PaymentCurrency.findByPk(invoicePrice.currency_id);\n  if (!currency) {\n    throw new Error('Overdraft protection invoice currency not found');\n  }\n  const paymentMethod = await PaymentMethod.findByPk(currency?.payment_method_id);\n  if (!paymentMethod) {\n    throw new Error('Overdraft protection invoice payment method not found');\n  }\n\n  if (paymentMethod.type !== 'arcblock') {\n    throw new Error(`Payment method ${paymentMethod.type} not supported for overdraft protection`);\n  }\n\n  const { unused } = await isSubscriptionOverdraftProtectionEnabled(subscription, paymentIntent?.currency_id);\n  if (new BN(unused).lt(new BN(invoicePrice.unit_amount))) {\n    throw new Error('Overdraft protection invoice creation skipped: insufficient overdraft protection funds');\n  }\n\n  const result = await createInvoiceWithItems({\n    customer,\n    subscription,\n    currency_id: invoicePrice.currency_id,\n    livemode: subscription.livemode,\n    period_start: props.period_start || 0,\n    period_end: props.period_end || 0,\n    status: props.status,\n    billing_reason: 'overdraft_protection',\n    description: 'Overdraft protection',\n    collection_method: 'send_invoice',\n    default_payment_method_id: paymentMethod.id,\n    total: invoicePrice.unit_amount || '0',\n    items: [\n      {\n        price_id: price?.id || '',\n        amount: invoicePrice.unit_amount || '0',\n        quantity: 1,\n        description: product?.name || '',\n        period: {\n          start: props.period_start || 0,\n          end: props.period_end || 0,\n        },\n      },\n    ],\n    metadata: {\n      ...(props.metadata || {}),\n      payment_intent_id: paymentIntent.id,\n    },\n  });\n\n  await Price.increment({ quantity_sold: 1 }, { where: { id: price?.id } });\n  return result;\n}\n\nexport async function ensureStakeInvoice(\n  invoiceProps: {\n    total: string;\n    description?: string;\n    checkout_session_id?: string;\n    currency_id: string;\n    billing_reason?: string;\n    metadata?: any;\n    payment_settings?: any;\n  },\n  subscription: Subscription,\n  paymentMethod: PaymentMethod,\n  customer: Customer,\n  allSubscriptions?: Subscription[]\n) {\n  if (paymentMethod.type !== 'arcblock') {\n    return;\n  }\n\n  try {\n    const isMultiSubscription = allSubscriptions && allSubscriptions.length > 1;\n    const metadata = {\n      ...(invoiceProps.metadata || {}),\n    };\n\n    if (isMultiSubscription) {\n      metadata.all_subscription_ids = allSubscriptions.map((s) => s.id);\n      metadata.is_shared_stake = true;\n      metadata.primary_subscription_id = subscription.id;\n    }\n\n    const { invoice } = await createInvoiceWithItems({\n      customer,\n      subscription,\n      currency_id: invoiceProps.currency_id,\n      livemode: subscription.livemode,\n      period_start: dayjs().unix(),\n      period_end: subscription.current_period_end,\n      status: 'paid',\n      billing_reason: invoiceProps?.billing_reason || 'stake',\n      description: invoiceProps?.description || 'Stake for subscription',\n      total: invoiceProps.total || '0',\n      amount_due: '0',\n      amount_paid: invoiceProps.total || '0',\n      amount_remaining: '0',\n      default_payment_method_id: paymentMethod.id,\n      checkout_session_id: invoiceProps?.checkout_session_id || '',\n      metadata,\n      auto_advance: false,\n      paid: true,\n      paid_out_of_band: false,\n      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n    });\n\n    logger.info('create staking invoice success', {\n      invoice,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n  } catch (error) {\n    logger.error('ensureStake: create invoice failed', {\n      error,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n    throw error;\n  }\n}\n\nexport async function getStakeInvoiceForSubscription(subscriptionId: string, currencyId: string) {\n  const where: WhereOptions = {\n    [Op.or]: [\n      { subscription_id: subscriptionId },\n      { 'metadata.all_subscription_ids': { [Op.contains]: [subscriptionId] } },\n    ],\n    billing_reason: 'stake',\n    status: 'paid',\n  };\n\n  if (currencyId) {\n    where.currency_id = currencyId;\n  }\n  try {\n    const invoice = await Invoice.findOne({ where });\n    return invoice;\n  } catch (error) {\n    logger.error('getStakeInvoiceForSubscription: find invoice failed', {\n      error,\n      subscriptionId,\n      currencyId,\n    });\n    return null;\n  }\n}\n\n// mark overdraft protection invoice as void after payment\nexport async function handleOverdraftProtectionInvoiceAfterPayment(invoice: Invoice) {\n  try {\n    if (['stake', 'overdraft_protection', 'stake_overdraft_protection'].includes(invoice.billing_reason)) {\n      return;\n    }\n    const subscription = await Subscription.findByPk(invoice.subscription_id);\n    if (!subscription) {\n      logger.info('handle overdraft protection invoice skipped due to subscription not found', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n    if (!subscription.overdraft_protection?.enabled) {\n      logger.info('handle overdraft protection invoice skipped due to overdraft protection not enabled', {\n        subscriptionId: subscription.id,\n      });\n      return;\n    }\n    const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n    if (!paymentMethod || paymentMethod?.type !== 'arcblock') {\n      logger.info('handle overdraft protection invoice skipped due to payment method not supported', {\n        invoiceId: invoice.id,\n        paymentMethodId: paymentMethod?.id,\n      });\n      return;\n    }\n    const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n    if (!paymentIntent) {\n      logger.info('handle overdraft protection invoice skipped due to payment intent not found', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n    if (paymentIntent.status !== 'succeeded') {\n      logger.info('handle overdraft protection invoice skipped due to payment intent not succeeded', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n    if (paymentIntent.payment_details?.arcblock?.type !== 'transfer') {\n      logger.info('handle overdraft protection invoice skipped due to payment type not transfer', {\n        invoiceId: invoice.id,\n        paymentIntentId: paymentIntent.id,\n      });\n      return;\n    }\n    const overdraftProtectionInvoice = await Invoice.findOne({\n      where: {\n        subscription_id: subscription.id,\n        billing_reason: 'overdraft_protection',\n        'metadata.invoice_id': invoice.id,\n        status: {\n          [Op.notIn]: ['paid', 'void'],\n        },\n      },\n    });\n    if (!overdraftProtectionInvoice) {\n      logger.info('handle overdraft protection invoice skipped due to overdraft protection invoice not found', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n\n    if (overdraftProtectionInvoice.payment_intent_id) {\n      const overdraftProtectionPaymentIntent = await PaymentIntent.findOne({\n        where: {\n          id: overdraftProtectionInvoice.payment_intent_id,\n        },\n      });\n      if (overdraftProtectionPaymentIntent) {\n        await overdraftProtectionPaymentIntent.update({\n          status: 'canceled',\n          canceled_at: dayjs().unix(),\n          cancellation_reason: 'void_invoice',\n        });\n      }\n    }\n\n    await overdraftProtectionInvoice.update({\n      status: 'void',\n      status_transitions: {\n        ...(overdraftProtectionInvoice.status_transitions || {}),\n        voided_at: dayjs().unix(),\n      },\n    });\n  } catch (error) {\n    logger.error('handle overdraft protection invoice failed', {\n      error,\n      invoiceId: invoice.id,\n    });\n  }\n}\n\n/**\n * retry uncollectible invoices\n * @param options\n */\nexport async function retryUncollectibleInvoices(options: {\n  customerId?: string;\n  subscriptionId?: string;\n  invoiceId?: string;\n  invoiceIds?: string[];\n  currencyId?: string;\n}) {\n  const lockKey = `retry-uncollectible-${JSON.stringify(options)}`;\n\n  const isLocked = await Lock.isLocked(lockKey);\n  if (isLocked) {\n    logger.warn('Retry uncollectible invoices already in progress', {\n      lockKey,\n      options,\n    });\n    throw new Error('Retry already in progress');\n  }\n\n  try {\n    await Lock.acquire(lockKey, dayjs().add(5, 'minutes').unix());\n\n    const { customerId, subscriptionId, invoiceId, invoiceIds, currencyId } = options;\n\n    const where: WhereOptions = {\n      status: { [Op.in]: ['uncollectible'] },\n      payment_intent_id: { [Op.ne]: null },\n    };\n\n    if (customerId) {\n      where.customer_id = customerId;\n    }\n\n    if (subscriptionId) {\n      where.subscription_id = subscriptionId;\n    }\n\n    if (invoiceId) {\n      where.id = invoiceId;\n    }\n\n    if (invoiceIds && invoiceIds.length > 0) {\n      where.id = { [Op.in]: invoiceIds };\n    }\n\n    if (currencyId) {\n      where.currency_id = currencyId;\n    }\n\n    const overdueInvoices = (await Invoice.findAll({\n      where,\n      include: [{ model: PaymentIntent, as: 'paymentIntent' }],\n      attributes: ['id', 'payment_intent_id', 'subscription_id', 'customer_id', 'created_at', 'status', 'currency_id'],\n      order: [['created_at', 'ASC']],\n    })) as (Invoice & { paymentIntent?: PaymentIntent })[];\n\n    const startTime = Date.now();\n    logger.info('Found uncollectible invoices to retry', {\n      count: overdueInvoices.length,\n      criteria: options,\n      invoiceIds: overdueInvoices.map((inv) => inv.id),\n    });\n\n    const results = {\n      processed: overdueInvoices.length,\n      successful: [] as string[],\n      failed: [] as Array<{ id: string; reason: string }>,\n    };\n\n    const settledResults = await Promise.allSettled(\n      overdueInvoices.map(async (invoice, index) => {\n        const { paymentIntent } = invoice;\n        const delay = index * 2;\n        if (!paymentIntent) {\n          throw new Error('No payment intent found');\n        }\n\n        await paymentIntent.update({ status: 'requires_capture' });\n        await emitAsync(\n          'payment.queued',\n          paymentIntent.id,\n          { paymentIntentId: paymentIntent.id, retryOnError: true, ignoreMaxRetryCheck: true },\n          { sync: false, delay }\n        );\n\n        return invoice;\n      })\n    );\n\n    settledResults.forEach((result, index) => {\n      const invoice = overdueInvoices[index];\n      if (!invoice) {\n        return;\n      }\n      if (result.status === 'fulfilled') {\n        results.successful.push(invoice.id);\n        logger.info('Successfully queued uncollectible invoice retry', {\n          invoiceId: invoice.id,\n          customerId: invoice.customer_id,\n          paymentIntentId: invoice.payment_intent_id,\n        });\n      } else {\n        const error = result.reason;\n        const errorType = error.name || 'Unknown';\n        const errorCode = error.code || 'UNKNOWN_ERROR';\n\n        results.failed.push({\n          id: invoice.id,\n          reason: error.message || 'Unknown error',\n        });\n\n        logger.error('Failed to queue uncollectible invoice retry', {\n          invoiceId: invoice.id,\n          customerId: invoice.customer_id,\n          subscriptionId: invoice.subscription_id,\n          paymentIntentId: invoice.payment_intent_id,\n          errorType,\n          errorCode,\n          error,\n        });\n      }\n    });\n\n    const processingTime = Date.now() - startTime;\n    logger.info('Completed retrying uncollectible invoices', {\n      totalProcessed: results.processed,\n      successful: results.successful.length,\n      failed: results.failed.length,\n      processingTimeMs: processingTime,\n    });\n\n    return results;\n  } finally {\n    await Lock.release(lockKey);\n    logger.info('Released retry uncollectible lock', { lockKey });\n  }\n}\n\n/**\n * Migrate billing when a subscription's payment method changes.\n * Steps:\n * 1. Check if all subscription items are prepaid (licensed recurring).\n * 2. If so, check if there is an unpaid invoice for the current period with the old payment method.\n * 3. If such an invoice exists, void the old invoice and cancel its payment intent if present.\n * 4. Create a new invoice for the current period with the new payment method.\n * 5. If any step fails, throw an error and log details.\n *\n * @param subscription Subscription instance\n * @param oldCurrencyId Old payment currency ID\n * @param newCurrencyId New payment currency ID\n * @returns Migration result: { migrated, oldInvoice, newInvoice }\n */\nexport const migrateSubscriptionPaymentMethodInvoice = async (\n  subscription: Subscription,\n  oldCurrencyId: string,\n  newCurrencyId: string\n) => {\n  // 1. Check if all subscription items are prepaid (licensed recurring)\n  const subscriptionItems = await SubscriptionItem.findAll({\n    where: { subscription_id: subscription.id },\n    include: [{ model: Price, as: 'price' }],\n  });\n\n  const subscriptionItemsExpanded = await Price.expand(subscriptionItems.map((x) => x.toJSON()));\n  const isPrepaid = subscriptionItemsExpanded.every((item: TLineItemExpanded) => {\n    const price = getSubscriptionItemPrice(item);\n    return price.type === 'recurring' && price.recurring?.usage_type === 'licensed';\n  });\n\n  if (!isPrepaid) {\n    logger.info('Skip billing migration for non-prepaid items', {\n      subscriptionId: subscription.id,\n    });\n    return { migrated: false, reason: 'has_non_prepaid_items' };\n  }\n\n  // 2. Find unpaid invoice for the current period with the old payment method\n  const currentPeriodInvoice = await Invoice.findOne({\n    where: {\n      subscription_id: subscription.id,\n      billing_reason: 'subscription_cycle',\n      status: ['open', 'uncollectible'],\n      currency_id: oldCurrencyId,\n      period_start: {\n        [Op.gte]: subscription.current_period_start,\n        [Op.lt]: subscription.current_period_end,\n      },\n    },\n    order: [['created_at', 'DESC']],\n  });\n\n  let voidedInvoice: Invoice | null = null;\n\n  if (!currentPeriodInvoice) {\n    voidedInvoice = await Invoice.findOne({\n      where: {\n        subscription_id: subscription.id,\n        billing_reason: 'subscription_cycle',\n        status: 'void',\n        currency_id: oldCurrencyId,\n        period_start: {\n          [Op.gte]: subscription.current_period_start,\n          [Op.lt]: subscription.current_period_end,\n        },\n      },\n      order: [['created_at', 'DESC']],\n    });\n    if (!voidedInvoice) {\n      logger.info('Skip billing migration for no unpaid invoice', {\n        subscriptionId: subscription.id,\n        periodStart: subscription.current_period_start,\n        periodEnd: subscription.current_period_end,\n        oldCurrencyId,\n      });\n      return { migrated: false, reason: 'no_unpaid_invoice' };\n    }\n  }\n\n  // 3. Get old and new payment method/currency\n  const oldPaymentCurrency = await PaymentCurrency.findByPk(oldCurrencyId);\n  if (!oldPaymentCurrency) {\n    throw new Error(`Payment currency ${oldCurrencyId} not found`);\n  }\n  const oldPaymentMethod = await PaymentMethod.findByPk(oldPaymentCurrency.payment_method_id);\n  if (!oldPaymentMethod) {\n    throw new Error(`Payment method for currency ${oldCurrencyId} not found`);\n  }\n\n  const newPaymentCurrency = await PaymentCurrency.findByPk(newCurrencyId);\n  if (!newPaymentCurrency) {\n    throw new Error(`Payment currency ${newCurrencyId} not found`);\n  }\n  const newPaymentMethod = await PaymentMethod.findByPk(newPaymentCurrency.payment_method_id);\n  if (!newPaymentMethod) {\n    throw new Error(`Payment method for currency ${newCurrencyId} not found`);\n  }\n\n  // 4. Stripe payment method is not supported for migration\n  if (newPaymentMethod.type === 'stripe') {\n    logger.info('Skip billing migration for stripe payment method', {\n      subscriptionId: subscription.id,\n    });\n    return { migrated: false, reason: 'stripe_payment_method' };\n  }\n\n  try {\n    const customer = await Customer.findByPk(subscription.customer_id);\n    if (!customer) {\n      throw new Error(`Customer ${subscription.customer_id} not found`);\n    }\n\n    const cancelOldInvoice = async (invoice: Invoice) => {\n      try {\n        if (invoice.payment_intent_id) {\n          const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n          if (paymentIntent && paymentIntent.status !== 'canceled') {\n            await paymentIntent.update({\n              status: 'canceled',\n              canceled_at: dayjs().unix(),\n              cancellation_reason: 'void_invoice',\n            });\n          }\n        }\n\n        if (oldPaymentMethod.type === 'stripe' && invoice.metadata?.stripe_id) {\n          const client = oldPaymentMethod.getStripeClient();\n          await client.invoices.voidInvoice(invoice.metadata.stripe_id);\n        }\n\n        await invoice.update({\n          status: 'void',\n          status_transitions: {\n            ...(invoice.status_transitions || {}),\n            voided_at: dayjs().unix(),\n          },\n        });\n\n        logger.info('Successfully voided old invoice for payment method change', {\n          subscriptionId: subscription.id,\n          oldInvoice: invoice.id,\n          oldCurrency: oldCurrencyId,\n          newCurrency: newCurrencyId,\n        });\n      } catch (error) {\n        logger.error('Failed to void old invoice', {\n          subscription: subscription.id,\n          invoiceId: invoice.id,\n          error: error.message,\n        });\n        throw error;\n      }\n    };\n\n    const createNewInvoice = async () => {\n      const preInvoice = currentPeriodInvoice || voidedInvoice;\n      if (!preInvoice) {\n        throw new Error('No unpaid invoice found');\n      }\n      const metadata: Record<string, any> = {\n        prev_invoice_id: preInvoice.id,\n      };\n      const amount = getSubscriptionCycleAmount(subscriptionItemsExpanded, newCurrencyId);\n\n      const { invoice } = await ensureInvoiceAndItems({\n        customer,\n        currency: newPaymentCurrency,\n        subscription,\n        trialing: subscription.status === 'trialing',\n        metered: false,\n        lineItems: subscriptionItemsExpanded,\n        applyCredit: false,\n        props: {\n          status: 'open',\n          total: amount.total,\n          livemode: subscription.livemode,\n          description: 'Subscription cycle',\n          statement_descriptor: preInvoice.statement_descriptor,\n          period_start: preInvoice.period_start,\n          period_end: preInvoice.period_end,\n          auto_advance: true,\n          billing_reason: 'subscription_cycle',\n          currency_id: newCurrencyId,\n          default_payment_method_id: newPaymentMethod.id,\n          custom_fields: preInvoice.custom_fields || [],\n          footer: preInvoice.footer || '',\n          payment_settings: subscription.payment_settings,\n          metadata,\n        } as Invoice,\n      });\n      return invoice;\n    };\n\n    // 5. Cancel old invoice, then create new invoice\n    if (currentPeriodInvoice) {\n      await cancelOldInvoice(currentPeriodInvoice);\n    }\n\n    const invoice = await createNewInvoice();\n    if (invoice) {\n      await emitAsync('invoice.queued', invoice.id, { invoiceId: invoice.id, retryOnError: true }, { sync: false });\n      logger.info('Successfully queued new invoice for payment method change', {\n        subscriptionId: subscription.id,\n        invoiceId: invoice.id,\n      });\n    }\n\n    logger.info('Successfully migrated invoice for payment method change', {\n      subscriptionId: subscription.id,\n      oldInvoiceId: currentPeriodInvoice?.id || voidedInvoice?.id,\n      oldCurrency: oldCurrencyId,\n      newCurrency: newCurrencyId,\n      newInvoiceId: invoice.id,\n    });\n    return {\n      migrated: true,\n      oldInvoice: currentPeriodInvoice,\n      newInvoice: invoice,\n    };\n  } catch (error) {\n    logger.error('Failed to migrate invoice for payment method change', {\n      subscriptionId: subscription.id,\n      oldCurrencyId,\n      newCurrencyId,\n      error: error.message,\n    });\n    throw error;\n  }\n};\n\nexport async function destroyExistingInvoice(invoice: Invoice) {\n  const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n  try {\n    if (paymentMethod?.type === 'stripe' && invoice.metadata?.stripe_id) {\n      const client = paymentMethod.getStripeClient();\n      await client.invoices.del(invoice.metadata.stripe_id);\n    }\n  } catch (error) {\n    logger.error('Failed to destroy invoice on stripe', {\n      error: error.message,\n      invoiceId: invoice.id,\n    });\n  }\n  await InvoiceItem.destroy({ where: { invoice_id: invoice.id } });\n  await invoice.destroy();\n}\n","numLines":1448,"startLine":1,"totalLines":1448}}}
{"parentUuid":"28e4d419-715f-4491-b913-c3106c0f6d2a","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013p4wJwuYSJtWHetbHXrC5W","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我继续查看关键部分："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":35306,"cache_read_input_tokens":14736,"cache_creation":{"ephemeral_5m_input_tokens":35306,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrHXmUDJNC58en5JStRQ","type":"assistant","uuid":"7278c039-9124-4002-b07a-04b944087b5b","timestamp":"2026-01-06T14:31:13.146Z"}
{"parentUuid":"7278c039-9124-4002-b07a-04b944087b5b","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013p4wJwuYSJtWHetbHXrC5W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LnmGhtSR8VGDiW7uGeULAE","name":"Grep","input":{"pattern":"generateQuotesForInvoiceItems","output_mode":"files_with_matches","path":"~/Arcblock/payment-kit-master/blocklets/core/api/src"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":35306,"cache_read_input_tokens":14736,"cache_creation":{"ephemeral_5m_input_tokens":35306,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrHXmUDJNC58en5JStRQ","type":"assistant","uuid":"bf484c96-3d2f-4761-800b-7b355d7961c4","timestamp":"2026-01-06T14:31:15.346Z"}
{"parentUuid":"bf484c96-3d2f-4761-800b-7b355d7961c4","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013p4wJwuYSJtWHetbHXrC5W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UidmQApGGzwqB7qXjdnkAS","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","offset":1,"limit":200}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":35306,"cache_read_input_tokens":14736,"cache_creation":{"ephemeral_5m_input_tokens":35306,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrHXmUDJNC58en5JStRQ","type":"assistant","uuid":"23bb8bf5-7ba6-46f4-bac4-f06203e3c466","timestamp":"2026-01-06T14:31:16.344Z"}
{"parentUuid":"23bb8bf5-7ba6-46f4-bac4-f06203e3c466","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013p4wJwuYSJtWHetbHXrC5W","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QfSNbeH7c9r339GcghqJA5","name":"Grep","input":{"pattern":"createInvoiceWithItems","output_mode":"content","path":"~/Arcblock/payment-kit-master/blocklets/core/api/src"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":35306,"cache_read_input_tokens":14736,"cache_creation":{"ephemeral_5m_input_tokens":35306,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrHXmUDJNC58en5JStRQ","type":"assistant","uuid":"28ff7387-6a0c-4326-b0e2-d256488b47af","timestamp":"2026-01-06T14:31:17.285Z"}
{"parentUuid":"28ff7387-6a0c-4326-b0e2-d256488b47af","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UidmQApGGzwqB7qXjdnkAS","type":"tool_result","content":"     1→/* eslint-disable consistent-return */\n     2→import { isValid } from '@arcblock/did';\n     3→import { getUrl } from '@blocklet/sdk/lib/component';\n     4→import { sessionMiddleware } from '@blocklet/sdk/lib/middlewares/session';\n     5→import { BN, fromTokenToUnit, fromUnitToToken } from '@ocap/util';\n     6→import { NextFunction, Request, Response, Router } from 'express';\n     7→import Joi from 'joi';\n     8→import cloneDeep from 'lodash/cloneDeep';\n     9→import merge from 'lodash/merge';\n    10→import omit from 'lodash/omit';\n    11→import pick from 'lodash/pick';\n    12→import sortBy from 'lodash/sortBy';\n    13→import uniq from 'lodash/uniq';\n    14→import type { WhereOptions } from 'sequelize';\n    15→import { Op } from 'sequelize';\n    16→\n    17→import { CustomError, formatError, getStatusFromError } from '@blocklet/error';\n    18→import pAll from 'p-all';\n    19→import { withQuery } from 'ufo';\n    20→import { MetadataSchema } from '../libs/api';\n    21→import { checkPassportForPaymentLink } from '../integrations/blocklet/passport';\n    22→import dayjs from '../libs/dayjs';\n    23→import logger from '../libs/logger';\n    24→import { trimDecimals } from '../libs/math-utils';\n    25→import { authenticate } from '../libs/security';\n    26→import {\n    27→  canPayWithDelegation,\n    28→  canUpsell,\n    29→  createPaymentBeneficiaries,\n    30→  expandLineItems,\n    31→  getBillingThreshold,\n    32→  getCheckoutAmount,\n    33→  getCheckoutMode,\n    34→  getFastCheckoutAmount,\n    35→  getMinStakeAmount,\n    36→  getStatementDescriptor,\n    37→  getSupportedPaymentCurrencies,\n    38→  getSupportedPaymentMethods,\n    39→  isLineItemAligned,\n    40→  isDonationCheckoutSession,\n    41→  createGroupSubscriptions,\n    42→  formatSubscriptionProduct,\n    43→  getOneTimeLineItems,\n    44→  getCheckoutSessionSubscriptionIds,\n    45→  getSubscriptionLineItems,\n    46→  isCreditMeteredLineItems,\n    47→  validatePaymentAmounts,\n    48→  processCheckoutSessionDiscounts,\n    49→  getCheckoutSessionAmounts,\n    50→  enrichCheckoutSessionWithQuotes,\n    51→} from '../libs/session';\n    52→import { getDaysUntilCancel, getDaysUntilDue, getSubscriptionTrialSetup } from '../libs/subscription';\n    53→import {\n    54→  CHECKOUT_SESSION_TTL,\n    55→  formatAmountPrecisionLimit,\n    56→  formatMetadata,\n    57→  getConnectQueryParam,\n    58→  getDataObjectFromQuery,\n    59→  getUserOrAppInfo,\n    60→  hasObjectChanged,\n    61→  isUserInBlocklist,\n    62→} from '../libs/util';\n    63→import {\n    64→  PaymentBeneficiary,\n    65→  SetupIntent,\n    66→  Subscription,\n    67→  SubscriptionItem,\n    68→  type LineItem,\n    69→  type SubscriptionData,\n    70→  type TPriceExpanded,\n    71→  type TProductExpanded,\n    72→  type TLineItemExpanded,\n    73→  Invoice,\n    74→  Coupon,\n    75→  PromotionCode,\n    76→} from '../store/models';\n    77→import { CheckoutSession } from '../store/models/checkout-session';\n    78→import { Customer } from '../store/models/customer';\n    79→import { PaymentCurrency } from '../store/models/payment-currency';\n    80→import { PaymentIntent } from '../store/models/payment-intent';\n    81→import { PaymentLink } from '../store/models/payment-link';\n    82→import { PaymentMethod } from '../store/models/payment-method';\n    83→import { Price } from '../store/models/price';\n    84→import { Product } from '../store/models/product';\n    85→import {\n    86→  ensureStripePaymentIntent,\n    87→  ensureStripeSetupIntentForCheckoutSession,\n    88→  ensureStripeSubscription,\n    89→} from '../integrations/stripe/resource';\n    90→import { handleStripePaymentSucceed } from '../integrations/stripe/handlers/payment-intent';\n    91→import { paymentQueue } from '../queues/payment';\n    92→import { invoiceQueue } from '../queues/invoice';\n    93→import { ensureInvoiceForCheckout, ensureInvoicesForSubscriptions } from './connect/shared';\n    94→import {\n    95→  isCreditGrantSufficientForPayment,\n    96→  isCreditSufficientForPayment,\n    97→  isDelegationSufficientForPayment,\n    98→  SufficientForPaymentResult,\n    99→} from '../libs/payment';\n   100→import { handleStripeSubscriptionSucceed } from '../integrations/stripe/handlers/subscription';\n   101→import { CHARGE_SUPPORTED_CHAIN_TYPES } from '../libs/constants';\n   102→import { blocklet } from '../libs/auth';\n   103→import { addSubscriptionJob } from '../queues/subscription';\n   104→import { updateDataConcurrency } from '../libs/env';\n   105→import {\n   106→  expandLineItemsWithCouponInfo,\n   107→  expandDiscountsWithDetails,\n   108→  checkPromotionCodeEligibility,\n   109→  createDiscountRecordsForCheckout,\n   110→  updateSubscriptionDiscountReferences,\n   111→} from '../libs/discount/coupon';\n   112→import { rollbackDiscountUsageForCheckoutSession, applyDiscountsToLineItems } from '../libs/discount/discount';\n   113→import { formatToShortUrl } from '../libs/url';\n   114→import { destroyExistingInvoice } from '../libs/invoice';\n   115→import { getApproveFunction } from '../integrations/ethereum/contract';\n   116→import { getQuoteService } from '../libs/quote-service';\n   117→import { PriceQuote } from '../store/models/price-quote';\n   118→import { sequelize } from '../store/sequelize';\n   119→\n   120→const router = Router();\n   121→\n   122→const user = sessionMiddleware({ accessKey: true });\n   123→const auth = authenticate<CheckoutSession>({ component: true, roles: ['owner', 'admin'] });\n   124→\n   125→const authLogin = authenticate<CheckoutSession>({ component: true, roles: ['owner', 'admin'], ensureLogin: true });\n   126→\n   127→const getPaymentMethods = async (doc: CheckoutSession) => {\n   128→  const paymentMethods = await PaymentMethod.expand(doc.livemode, { type: doc.payment_method_types });\n   129→  const supportedCurrencies = getSupportedPaymentCurrencies(doc.line_items as any[]);\n   130→  const methods = getSupportedPaymentMethods(paymentMethods as any[], (x) => supportedCurrencies.includes(x.id));\n   131→\n   132→  const needsApprove = ['subscription', 'setup'].includes(doc.mode);\n   133→  if (!needsApprove) {\n   134→    return sortBy(methods, (m) => (m.payment_currencies.some((c) => c.is_base_currency) ? 0 : 1));\n   135→  }\n   136→\n   137→  const filteredMethods = await Promise.all(\n   138→    methods.map(async (method) => {\n   139→      if (!['ethereum', 'base'].includes(method.type)) {\n   140→        return method;\n   141→      }\n   142→\n   143→      const filteredCurrencies = await Promise.all(\n   144→        method.payment_currencies.map(async (currency) => {\n   145→          if (!currency.contract) {\n   146→            return currency;\n   147→          }\n   148→\n   149→          try {\n   150→            const paymentMethodInstance = await PaymentMethod.findByPk(method.id);\n   151→            if (!paymentMethodInstance) {\n   152→              return null;\n   153→            }\n   154→            const provider = paymentMethodInstance.getEvmClient();\n   155→            await getApproveFunction(provider, currency.contract);\n   156→            return currency;\n   157→          } catch (err: any) {\n   158→            logger.warn(`Currency ${currency.id} (${currency.symbol}) does not support approve function`, {\n   159→              contract: currency.contract,\n   160→              error: err.message,\n   161→            });\n   162→            return null;\n   163→          }\n   164→        })\n   165→      );\n   166→\n   167→      return {\n   168→        ...method,\n   169→        payment_currencies: filteredCurrencies.filter((c) => c !== null),\n   170→      };\n   171→    })\n   172→  );\n   173→\n   174→  const validMethods = filteredMethods.filter((m) => m.payment_currencies.length > 0);\n   175→  return sortBy(validMethods, (m) => (m.payment_currencies.some((c) => c.is_base_currency) ? 0 : 1));\n   176→};\n   177→\n   178→const getPaymentTypes = async (items: any[]) => {\n   179→  const supportedCurrencies = getSupportedPaymentCurrencies(items);\n   180→  const currencies = await PaymentCurrency.findAll({ where: { id: supportedCurrencies } });\n   181→  const methods = await PaymentMethod.findAll({ where: { id: uniq(currencies.map((x) => x.payment_method_id)) } });\n   182→  return methods.map((x) => x.type);\n   183→};\n   184→\n   185→export async function validateInventory(line_items: LineItem[], includePendingQuantity = false) {\n   186→  const checks = line_items.map((item) => async () => {\n   187→    const priceId = item.price_id;\n   188→    const quantity = Number(item.quantity || 0);\n   189→\n   190→    if (quantity < 1) {\n   191→      throw new Error(`Quantity should be greater or equal to 1 for price: ${priceId}`);\n   192→    }\n   193→\n   194→    const price = await Price.findOne({ where: { id: priceId } });\n   195→\n   196→    let delta = quantity;\n   197→\n   198→    if (!price) {\n   199→      throw new Error(`Price not found for priceId: ${priceId}`);\n   200→    }\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"34210bc0-f54b-4071-b8f2-c1d04aa26b97","timestamp":"2026-01-06T14:31:17.376Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","content":"/* eslint-disable consistent-return */\nimport { isValid } from '@arcblock/did';\nimport { getUrl } from '@blocklet/sdk/lib/component';\nimport { sessionMiddleware } from '@blocklet/sdk/lib/middlewares/session';\nimport { BN, fromTokenToUnit, fromUnitToToken } from '@ocap/util';\nimport { NextFunction, Request, Response, Router } from 'express';\nimport Joi from 'joi';\nimport cloneDeep from 'lodash/cloneDeep';\nimport merge from 'lodash/merge';\nimport omit from 'lodash/omit';\nimport pick from 'lodash/pick';\nimport sortBy from 'lodash/sortBy';\nimport uniq from 'lodash/uniq';\nimport type { WhereOptions } from 'sequelize';\nimport { Op } from 'sequelize';\n\nimport { CustomError, formatError, getStatusFromError } from '@blocklet/error';\nimport pAll from 'p-all';\nimport { withQuery } from 'ufo';\nimport { MetadataSchema } from '../libs/api';\nimport { checkPassportForPaymentLink } from '../integrations/blocklet/passport';\nimport dayjs from '../libs/dayjs';\nimport logger from '../libs/logger';\nimport { trimDecimals } from '../libs/math-utils';\nimport { authenticate } from '../libs/security';\nimport {\n  canPayWithDelegation,\n  canUpsell,\n  createPaymentBeneficiaries,\n  expandLineItems,\n  getBillingThreshold,\n  getCheckoutAmount,\n  getCheckoutMode,\n  getFastCheckoutAmount,\n  getMinStakeAmount,\n  getStatementDescriptor,\n  getSupportedPaymentCurrencies,\n  getSupportedPaymentMethods,\n  isLineItemAligned,\n  isDonationCheckoutSession,\n  createGroupSubscriptions,\n  formatSubscriptionProduct,\n  getOneTimeLineItems,\n  getCheckoutSessionSubscriptionIds,\n  getSubscriptionLineItems,\n  isCreditMeteredLineItems,\n  validatePaymentAmounts,\n  processCheckoutSessionDiscounts,\n  getCheckoutSessionAmounts,\n  enrichCheckoutSessionWithQuotes,\n} from '../libs/session';\nimport { getDaysUntilCancel, getDaysUntilDue, getSubscriptionTrialSetup } from '../libs/subscription';\nimport {\n  CHECKOUT_SESSION_TTL,\n  formatAmountPrecisionLimit,\n  formatMetadata,\n  getConnectQueryParam,\n  getDataObjectFromQuery,\n  getUserOrAppInfo,\n  hasObjectChanged,\n  isUserInBlocklist,\n} from '../libs/util';\nimport {\n  PaymentBeneficiary,\n  SetupIntent,\n  Subscription,\n  SubscriptionItem,\n  type LineItem,\n  type SubscriptionData,\n  type TPriceExpanded,\n  type TProductExpanded,\n  type TLineItemExpanded,\n  Invoice,\n  Coupon,\n  PromotionCode,\n} from '../store/models';\nimport { CheckoutSession } from '../store/models/checkout-session';\nimport { Customer } from '../store/models/customer';\nimport { PaymentCurrency } from '../store/models/payment-currency';\nimport { PaymentIntent } from '../store/models/payment-intent';\nimport { PaymentLink } from '../store/models/payment-link';\nimport { PaymentMethod } from '../store/models/payment-method';\nimport { Price } from '../store/models/price';\nimport { Product } from '../store/models/product';\nimport {\n  ensureStripePaymentIntent,\n  ensureStripeSetupIntentForCheckoutSession,\n  ensureStripeSubscription,\n} from '../integrations/stripe/resource';\nimport { handleStripePaymentSucceed } from '../integrations/stripe/handlers/payment-intent';\nimport { paymentQueue } from '../queues/payment';\nimport { invoiceQueue } from '../queues/invoice';\nimport { ensureInvoiceForCheckout, ensureInvoicesForSubscriptions } from './connect/shared';\nimport {\n  isCreditGrantSufficientForPayment,\n  isCreditSufficientForPayment,\n  isDelegationSufficientForPayment,\n  SufficientForPaymentResult,\n} from '../libs/payment';\nimport { handleStripeSubscriptionSucceed } from '../integrations/stripe/handlers/subscription';\nimport { CHARGE_SUPPORTED_CHAIN_TYPES } from '../libs/constants';\nimport { blocklet } from '../libs/auth';\nimport { addSubscriptionJob } from '../queues/subscription';\nimport { updateDataConcurrency } from '../libs/env';\nimport {\n  expandLineItemsWithCouponInfo,\n  expandDiscountsWithDetails,\n  checkPromotionCodeEligibility,\n  createDiscountRecordsForCheckout,\n  updateSubscriptionDiscountReferences,\n} from '../libs/discount/coupon';\nimport { rollbackDiscountUsageForCheckoutSession, applyDiscountsToLineItems } from '../libs/discount/discount';\nimport { formatToShortUrl } from '../libs/url';\nimport { destroyExistingInvoice } from '../libs/invoice';\nimport { getApproveFunction } from '../integrations/ethereum/contract';\nimport { getQuoteService } from '../libs/quote-service';\nimport { PriceQuote } from '../store/models/price-quote';\nimport { sequelize } from '../store/sequelize';\n\nconst router = Router();\n\nconst user = sessionMiddleware({ accessKey: true });\nconst auth = authenticate<CheckoutSession>({ component: true, roles: ['owner', 'admin'] });\n\nconst authLogin = authenticate<CheckoutSession>({ component: true, roles: ['owner', 'admin'], ensureLogin: true });\n\nconst getPaymentMethods = async (doc: CheckoutSession) => {\n  const paymentMethods = await PaymentMethod.expand(doc.livemode, { type: doc.payment_method_types });\n  const supportedCurrencies = getSupportedPaymentCurrencies(doc.line_items as any[]);\n  const methods = getSupportedPaymentMethods(paymentMethods as any[], (x) => supportedCurrencies.includes(x.id));\n\n  const needsApprove = ['subscription', 'setup'].includes(doc.mode);\n  if (!needsApprove) {\n    return sortBy(methods, (m) => (m.payment_currencies.some((c) => c.is_base_currency) ? 0 : 1));\n  }\n\n  const filteredMethods = await Promise.all(\n    methods.map(async (method) => {\n      if (!['ethereum', 'base'].includes(method.type)) {\n        return method;\n      }\n\n      const filteredCurrencies = await Promise.all(\n        method.payment_currencies.map(async (currency) => {\n          if (!currency.contract) {\n            return currency;\n          }\n\n          try {\n            const paymentMethodInstance = await PaymentMethod.findByPk(method.id);\n            if (!paymentMethodInstance) {\n              return null;\n            }\n            const provider = paymentMethodInstance.getEvmClient();\n            await getApproveFunction(provider, currency.contract);\n            return currency;\n          } catch (err: any) {\n            logger.warn(`Currency ${currency.id} (${currency.symbol}) does not support approve function`, {\n              contract: currency.contract,\n              error: err.message,\n            });\n            return null;\n          }\n        })\n      );\n\n      return {\n        ...method,\n        payment_currencies: filteredCurrencies.filter((c) => c !== null),\n      };\n    })\n  );\n\n  const validMethods = filteredMethods.filter((m) => m.payment_currencies.length > 0);\n  return sortBy(validMethods, (m) => (m.payment_currencies.some((c) => c.is_base_currency) ? 0 : 1));\n};\n\nconst getPaymentTypes = async (items: any[]) => {\n  const supportedCurrencies = getSupportedPaymentCurrencies(items);\n  const currencies = await PaymentCurrency.findAll({ where: { id: supportedCurrencies } });\n  const methods = await PaymentMethod.findAll({ where: { id: uniq(currencies.map((x) => x.payment_method_id)) } });\n  return methods.map((x) => x.type);\n};\n\nexport async function validateInventory(line_items: LineItem[], includePendingQuantity = false) {\n  const checks = line_items.map((item) => async () => {\n    const priceId = item.price_id;\n    const quantity = Number(item.quantity || 0);\n\n    if (quantity < 1) {\n      throw new Error(`Quantity should be greater or equal to 1 for price: ${priceId}`);\n    }\n\n    const price = await Price.findOne({ where: { id: priceId } });\n\n    let delta = quantity;\n\n    if (!price) {\n      throw new Error(`Price not found for priceId: ${priceId}`);\n    }","numLines":200,"startLine":1,"totalLines":3727}}}
{"parentUuid":"34210bc0-f54b-4071-b8f2-c1d04aa26b97","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LnmGhtSR8VGDiW7uGeULAE","type":"tool_result","content":"Found 2 files\napi/src/libs/invoice-quote.ts\napi/src/libs/invoice.ts"}]},"uuid":"6f323d24-47ac-49a9-918a-fefa8f908182","timestamp":"2026-01-06T14:31:17.392Z","toolUseResult":{"mode":"files_with_matches","filenames":["api/src/libs/invoice-quote.ts","api/src/libs/invoice.ts"],"numFiles":2}}
{"parentUuid":"6f323d24-47ac-49a9-918a-fefa8f908182","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QfSNbeH7c9r339GcghqJA5","type":"tool_result","content":"api/src/libs/invoice.ts:439:async function createInvoiceWithItems(props: BaseInvoiceProps): Promise<{\napi/src/libs/invoice.ts:688:  return createInvoiceWithItems({\napi/src/libs/invoice.ts:759:    const { invoice } = await createInvoiceWithItems({\napi/src/libs/invoice.ts:836:  const result = await createInvoiceWithItems({\napi/src/libs/invoice.ts:902:    const { invoice } = await createInvoiceWithItems({"}]},"uuid":"0defd138-3eb2-4034-88e3-771d90302bb1","timestamp":"2026-01-06T14:31:17.387Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"api/src/libs/invoice.ts:439:async function createInvoiceWithItems(props: BaseInvoiceProps): Promise<{\napi/src/libs/invoice.ts:688:  return createInvoiceWithItems({\napi/src/libs/invoice.ts:759:    const { invoice } = await createInvoiceWithItems({\napi/src/libs/invoice.ts:836:  const result = await createInvoiceWithItems({\napi/src/libs/invoice.ts:902:    const { invoice } = await createInvoiceWithItems({","numLines":5}}
{"parentUuid":"0defd138-3eb2-4034-88e3-771d90302bb1","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CwzT6GSuqS66fWcrAWH4YN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AWFtrpYo7hjbAw5GAAk92Y","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3682,"cache_read_input_tokens":50042,"cache_creation":{"ephemeral_5m_input_tokens":3682,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CWrHYQ2ebhGwR3zYDTxVz","type":"assistant","uuid":"3e1a9d05-b9a5-4528-9123-a92c57298795","timestamp":"2026-01-06T14:31:22.260Z"}
{"parentUuid":"3e1a9d05-b9a5-4528-9123-a92c57298795","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CwzT6GSuqS66fWcrAWH4YN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01X7p1cAuQzmV2szp9bjC7xA","name":"Grep","input":{"pattern":"ensureInvoiceForCheckout","output_mode":"content","path":"~/Arcblock/payment-kit-master/blocklets/core/api/src","-B":2,"-A":10}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":3682,"cache_read_input_tokens":50042,"cache_creation":{"ephemeral_5m_input_tokens":3682,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"}},"requestId":"req_011CWrHYQ2ebhGwR3zYDTxVz","type":"assistant","uuid":"354fc029-389d-44e8-818c-0365f6f5b9b2","timestamp":"2026-01-06T14:31:23.456Z"}
{"parentUuid":"354fc029-389d-44e8-818c-0365f6f5b9b2","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X7p1cAuQzmV2szp9bjC7xA","type":"tool_result","content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-4-import { mintNftForCheckoutSession } from '../integrations/arcblock/nft';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-5-import { ensurePassportIssued } from '../integrations/blocklet/passport';\napi/src/queues/checkout-session.ts:6:import { ensureInvoiceForCheckout } from '../routes/connect/shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-7-import dayjs from '../libs/dayjs';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-8-import { events } from '../libs/event';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-9-import logger from '../libs/logger';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-10-import createQueue from '../libs/queue';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-11-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-12-  CheckoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-13-  Customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-14-  Invoice,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-15-  InvoiceItem,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-16-  PaymentIntent,\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-304-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-305-\napi/src/queues/checkout-session.ts:306:    await ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-307-      checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-308-      paymentIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-309-      customer,\napi/src/queues/checkout-session.ts-310-      props: {\napi/src/queues/checkout-session.ts-311-        status: 'paid',\napi/src/queues/checkout-session.ts-312-        amount_due: '0',\napi/src/queues/checkout-session.ts-313-        amount_paid: checkoutSession.amount_total,\napi/src/queues/checkout-session.ts-314-        amount_remaining: '0',\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-315-      },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-316-    });\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-385-};\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-386-\napi/src/routes/connect/shared.ts:387:export async function ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-388-  checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-389-  customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-390-  paymentIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-391-  subscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-392-  props,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-393-  subscriptions,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-394-  lineItems,\napi/src/routes/connect/shared.ts-395-}: Args): Promise<{ invoice: Invoice | null; items: InvoiceItem[] }> {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-396-  const isGroupInvoice = subscriptions && subscriptions.length > 1;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-397-  // invoices are optional when checkout session is in payment mode\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-622-    subscriptions.map(async (subscription) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-623-      const subItems = await getSubscriptionLineItems(subscription, lineItems, primarySubscription);\napi/src/routes/connect/shared.ts:624:      const { invoice } = await ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-625-        checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-626-        customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-627-        subscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-628-        subscriptions,\napi/src/routes/connect/shared.ts-629-        lineItems: subItems,\napi/src/routes/connect/shared.ts-630-        props: invoiceProps,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-631-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-632-      return invoice;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-633-    })\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-634-  );\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-11-import { getTxMetadata } from '../../libs/util';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-12-import { handlePaymentSucceed } from '../../queues/payment';\napi/src/routes/connect/pay.ts:13:import { ensureInvoiceForCheckout, ensurePaymentIntent, getAuthPrincipalClaim } from './shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-14-import { EVMChainType } from '../../store/models';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-15-import { EVM_CHAIN_TYPES } from '../../libs/constants';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-16-import { validateQuoteForPayment, handleExpiredQuotePayment } from '../../libs/quote-validation';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-17-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-18-export default {\napi/src/routes/connect/pay.ts-19-  action: 'payment',\napi/src/routes/connect/pay.ts-20-  authPrincipal: false,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-21-\napi/src/routes/connect/pay.ts-22-  claims: {\napi/src/routes/connect/pay.ts-23-    authPrincipal: async ({ extraParams }: CallbackArgs) => {\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-98-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-99-\napi/src/routes/connect/pay.ts:100:    await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-101-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-102-    if (paymentMethod.type === 'arcblock') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-103-      try {\napi/src/routes/connect/pay.ts-104-        await paymentIntent.update({ status: 'processing' });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-105-        const client = paymentMethod.getOcapClient();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-106-        const claim = claims.find((x) => x.type === 'prepareTx');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-107-\napi/src/routes/connect/pay.ts-108-        const tx: Partial<Transaction> = client.decodeTx(claim.finalTx);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-109-        if (claim.delegator && claim.from) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-110-          tx.delegator = claim.delegator;\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-91-import { paymentQueue } from '../queues/payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-92-import { invoiceQueue } from '../queues/invoice';\napi/src/routes/checkout-sessions.ts:93:import { ensureInvoiceForCheckout, ensureInvoicesForSubscriptions } from './connect/shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-94-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-95-  isCreditGrantSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-96-  isCreditSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-97-  isDelegationSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-98-  SufficientForPaymentResult,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-99-} from '../libs/payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-100-import { handleStripeSubscriptionSucceed } from '../integrations/stripe/handlers/subscription';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-101-import { CHARGE_SUPPORTED_CHAIN_TYPES } from '../libs/constants';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-102-import { blocklet } from '../libs/auth';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-103-import { addSubscriptionJob } from '../queues/subscription';\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2758-        fastPaid = true;\napi/src/routes/checkout-sessions.ts-2759-        await paymentIntent.update({ status: 'requires_capture' });\napi/src/routes/checkout-sessions.ts:2760:        const { invoice } = await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2761-        if (invoice) {\napi/src/routes/checkout-sessions.ts-2762-          await invoice.update({ auto_advance: true, payment_settings: paymentSettings });\napi/src/routes/checkout-sessions.ts-2763-          invoiceQueue.push({ id: invoice.id, job: { invoiceId: invoice.id, retryOnError: false } });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2764-        } else {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2765-          paymentQueue.push({\napi/src/routes/checkout-sessions.ts-2766-            id: paymentIntent.id,\napi/src/routes/checkout-sessions.ts-2767-            job: { paymentIntentId: paymentIntent.id, paymentSettings, retryOnError: false },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2768-          });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2769-        }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2770-      }"}]},"uuid":"9add4146-b67d-4261-b553-9f353b99a19a","timestamp":"2026-01-06T14:31:23.671Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-4-import { mintNftForCheckoutSession } from '../integrations/arcblock/nft';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-5-import { ensurePassportIssued } from '../integrations/blocklet/passport';\napi/src/queues/checkout-session.ts:6:import { ensureInvoiceForCheckout } from '../routes/connect/shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-7-import dayjs from '../libs/dayjs';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-8-import { events } from '../libs/event';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-9-import logger from '../libs/logger';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-10-import createQueue from '../libs/queue';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-11-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-12-  CheckoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-13-  Customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-14-  Invoice,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-15-  InvoiceItem,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-16-  PaymentIntent,\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-304-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-305-\napi/src/queues/checkout-session.ts:306:    await ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-307-      checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-308-      paymentIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-309-      customer,\napi/src/queues/checkout-session.ts-310-      props: {\napi/src/queues/checkout-session.ts-311-        status: 'paid',\napi/src/queues/checkout-session.ts-312-        amount_due: '0',\napi/src/queues/checkout-session.ts-313-        amount_paid: checkoutSession.amount_total,\napi/src/queues/checkout-session.ts-314-        amount_remaining: '0',\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-315-      },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/checkout-session.ts-316-    });\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-385-};\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-386-\napi/src/routes/connect/shared.ts:387:export async function ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-388-  checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-389-  customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-390-  paymentIntent,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-391-  subscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-392-  props,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-393-  subscriptions,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-394-  lineItems,\napi/src/routes/connect/shared.ts-395-}: Args): Promise<{ invoice: Invoice | null; items: InvoiceItem[] }> {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-396-  const isGroupInvoice = subscriptions && subscriptions.length > 1;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-397-  // invoices are optional when checkout session is in payment mode\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-622-    subscriptions.map(async (subscription) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-623-      const subItems = await getSubscriptionLineItems(subscription, lineItems, primarySubscription);\napi/src/routes/connect/shared.ts:624:      const { invoice } = await ensureInvoiceForCheckout({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-625-        checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-626-        customer,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-627-        subscription,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-628-        subscriptions,\napi/src/routes/connect/shared.ts-629-        lineItems: subItems,\napi/src/routes/connect/shared.ts-630-        props: invoiceProps,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-631-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-632-      return invoice;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-633-    })\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-634-  );\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-11-import { getTxMetadata } from '../../libs/util';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-12-import { handlePaymentSucceed } from '../../queues/payment';\napi/src/routes/connect/pay.ts:13:import { ensureInvoiceForCheckout, ensurePaymentIntent, getAuthPrincipalClaim } from './shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-14-import { EVMChainType } from '../../store/models';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-15-import { EVM_CHAIN_TYPES } from '../../libs/constants';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-16-import { validateQuoteForPayment, handleExpiredQuotePayment } from '../../libs/quote-validation';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-17-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-18-export default {\napi/src/routes/connect/pay.ts-19-  action: 'payment',\napi/src/routes/connect/pay.ts-20-  authPrincipal: false,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-21-\napi/src/routes/connect/pay.ts-22-  claims: {\napi/src/routes/connect/pay.ts-23-    authPrincipal: async ({ extraParams }: CallbackArgs) => {\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-98-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-99-\napi/src/routes/connect/pay.ts:100:    await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-101-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-102-    if (paymentMethod.type === 'arcblock') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-103-      try {\napi/src/routes/connect/pay.ts-104-        await paymentIntent.update({ status: 'processing' });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-105-        const client = paymentMethod.getOcapClient();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-106-        const claim = claims.find((x) => x.type === 'prepareTx');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-107-\napi/src/routes/connect/pay.ts-108-        const tx: Partial<Transaction> = client.decodeTx(claim.finalTx);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-109-        if (claim.delegator && claim.from) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts-110-          tx.delegator = claim.delegator;\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-91-import { paymentQueue } from '../queues/payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-92-import { invoiceQueue } from '../queues/invoice';\napi/src/routes/checkout-sessions.ts:93:import { ensureInvoiceForCheckout, ensureInvoicesForSubscriptions } from './connect/shared';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-94-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-95-  isCreditGrantSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-96-  isCreditSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-97-  isDelegationSufficientForPayment,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-98-  SufficientForPaymentResult,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-99-} from '../libs/payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-100-import { handleStripeSubscriptionSucceed } from '../integrations/stripe/handlers/subscription';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-101-import { CHARGE_SUPPORTED_CHAIN_TYPES } from '../libs/constants';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-102-import { blocklet } from '../libs/auth';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-103-import { addSubscriptionJob } from '../queues/subscription';\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2758-        fastPaid = true;\napi/src/routes/checkout-sessions.ts-2759-        await paymentIntent.update({ status: 'requires_capture' });\napi/src/routes/checkout-sessions.ts:2760:        const { invoice } = await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2761-        if (invoice) {\napi/src/routes/checkout-sessions.ts-2762-          await invoice.update({ auto_advance: true, payment_settings: paymentSettings });\napi/src/routes/checkout-sessions.ts-2763-          invoiceQueue.push({ id: invoice.id, job: { invoiceId: invoice.id, retryOnError: false } });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2764-        } else {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2765-          paymentQueue.push({\napi/src/routes/checkout-sessions.ts-2766-            id: paymentIntent.id,\napi/src/routes/checkout-sessions.ts-2767-            job: { paymentIntentId: paymentIntent.id, paymentSettings, retryOnError: false },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2768-          });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2769-        }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2770-      }","numLines":111}}
{"parentUuid":"9add4146-b67d-4261-b553-9f353b99a19a","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AWFtrpYo7hjbAw5GAAk92Y","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/indent */\n     2→/* eslint-disable prettier/prettier */\n     3→import { toTypeInfo } from '@arcblock/did';\n     4→import { toDelegateAddress } from '@arcblock/did-util';\n     5→import type { Transaction } from '@ocap/client';\n     6→import { BN, fromTokenToUnit, toBase58 } from '@ocap/util';\n     7→import { fromPublicKey } from '@ocap/wallet';\n     8→import type { Request } from 'express';\n     9→import { isEmpty } from 'lodash';\n    10→import { Op } from 'sequelize';\n    11→import dayjs from '../../libs/dayjs';\n    12→import { estimateMaxGasForTx, hasStakedForGas } from '../../integrations/arcblock/stake';\n    13→import { encodeApproveItx } from '../../integrations/ethereum/token';\n    14→import { blocklet, ethWallet, wallet } from '../../libs/auth';\n    15→import logger from '../../libs/logger';\n    16→import { getGasPayerExtra, getTokenLimitsForDelegation } from '../../libs/payment';\n    17→import {\n    18→  getCheckoutAmount,\n    19→  getCheckoutSessionSubscriptionIds,\n    20→  getFastCheckoutAmount,\n    21→  getStatementDescriptor,\n    22→  getSubscriptionCreateSetup,\n    23→  isDonationCheckoutSession,\n    24→  getSubscriptionLineItems,\n    25→} from '../../libs/session';\n    26→import { getDiscountRecordsForCheckout } from '../../libs/discount/coupon';\n    27→import {\n    28→  expandSubscriptionItems,\n    29→  getSubscriptionPaymentAddress,\n    30→  getSubscriptionStakeSetup,\n    31→} from '../../libs/subscription';\n    32→import { getCustomerStakeAddress, OCAP_PAYMENT_TX_TYPE } from '../../libs/util';\n    33→\n    34→import { invoiceQueue } from '../../queues/invoice';\n    35→import { AutoRechargeConfig, type TLineItemExpanded } from '../../store/models';\n    36→import { CheckoutSession } from '../../store/models/checkout-session';\n    37→import { Customer } from '../../store/models/customer';\n    38→import { Invoice, TInvoice } from '../../store/models/invoice';\n    39→import { InvoiceItem } from '../../store/models/invoice-item';\n    40→import { PaymentCurrency } from '../../store/models/payment-currency';\n    41→import { PaymentIntent } from '../../store/models/payment-intent';\n    42→import { PaymentMethod } from '../../store/models/payment-method';\n    43→import { Price } from '../../store/models/price';\n    44→import { PriceQuote } from '../../store/models/price-quote';\n    45→import { SetupIntent } from '../../store/models/setup-intent';\n    46→import { Subscription } from '../../store/models/subscription';\n    47→import { ensureInvoiceAndItems } from '../../libs/invoice';\n    48→import { CHARGE_SUPPORTED_CHAIN_TYPES, EVM_CHAIN_TYPES } from '../../libs/constants';\n    49→import { returnStakeQueue } from '../../queues/subscription';\n    50→\n    51→type Result = {\n    52→  checkoutSession: CheckoutSession;\n    53→  customer: Customer;\n    54→  paymentIntent?: PaymentIntent;\n    55→  subscription?: Subscription;\n    56→  subscriptions?: Subscription[];\n    57→  paymentCurrency: PaymentCurrency;\n    58→  paymentMethod: PaymentMethod;\n    59→  invoice?: Invoice;\n    60→};\n    61→\n    62→export async function ensureCheckoutSession(checkoutSessionId: string) {\n    63→  const checkoutSession = await CheckoutSession.findByPk(checkoutSessionId);\n    64→  if (!checkoutSession) {\n    65→    throw new Error('Checkout session not found');\n    66→  }\n    67→  if (checkoutSession.isImmutable()) {\n    68→    throw new Error('Checkout session is immutable');\n    69→  }\n    70→\n    71→  return checkoutSession;\n    72→}\n    73→\n    74→export async function ensurePaymentIntent(\n    75→  checkoutSessionId: string,\n    76→  userDid?: string,\n    77→  skipCustomer?: boolean\n    78→): Promise<Result> {\n    79→  const checkoutSession = await ensureCheckoutSession(checkoutSessionId);\n    80→\n    81→  let paymentCurrencyId;\n    82→  let paymentMethodId;\n    83→\n    84→  let paymentIntent;\n    85→  if (checkoutSession.payment_intent_id) {\n    86→    paymentIntent = await PaymentIntent.findByPk(checkoutSession.payment_intent_id);\n    87→    if (!paymentIntent) {\n    88→      throw new Error('Payment intent not found');\n    89→    }\n    90→    if (paymentIntent.status === 'succeeded') {\n    91→      throw new Error('Payment intent completed');\n    92→    }\n    93→    if (paymentIntent.status === 'canceled') {\n    94→      throw new Error('Payment intent canceled');\n    95→    }\n    96→    if (paymentIntent.status === 'processing') {\n    97→      throw new Error('Payment intent processing');\n    98→    }\n    99→\n   100→    paymentCurrencyId = paymentIntent.currency_id;\n   101→    paymentMethodId = paymentIntent.payment_method_id;\n   102→  }\n   103→\n   104→  const subscriptionIds = getCheckoutSessionSubscriptionIds(checkoutSession);\n   105→\n   106→  let subscriptions: Subscription[] = [];\n   107→  let primarySubscription: Subscription | null = null;\n   108→  if (subscriptionIds.length > 0) {\n   109→    // @ts-ignore\n   110→    subscriptions = await Promise.all(subscriptionIds.filter(Boolean).map((id) => Subscription.findByPk(id)));\n   111→\n   112→    subscriptions = subscriptions.filter(Boolean);\n   113→    for (const subscription of subscriptions) {\n   114→      if (subscription && subscription.status !== 'incomplete') {\n   115→        throw new Error(`Subscription ${subscription.id} is not in incomplete status: ${subscription.status}`);\n   116→      }\n   117→    }\n   118→    if (subscriptions.length > 0) {\n   119→      // @ts-ignore\n   120→      primarySubscription = subscriptions.find((sub) => sub.metadata?.is_primary_subscription) || subscriptions[0];\n   121→      paymentCurrencyId = primarySubscription?.currency_id;\n   122→      paymentMethodId = primarySubscription?.default_payment_method_id;\n   123→    }\n   124→  }\n   125→  let customer = null;\n   126→\n   127→  if (!skipCustomer) {\n   128→    // 检查是否为打赏场景\n   129→    const isDonation = isDonationCheckoutSession(checkoutSession);\n   130→\n   131→    // if donation, create customer if not exists\n   132→    if (isDonation && !checkoutSession.customer_id && userDid) {\n   133→      customer = await Customer.findByPkOrDid(userDid);\n   134→      if (!customer) {\n   135→        const { user } = await blocklet.getUser(userDid);\n   136→        if (user) {\n   137→          customer = await Customer.create({\n   138→            did: userDid,\n   139→            email: user.email,\n   140→            name: user.fullName || userDid,\n   141→            description: user.remark,\n   142→            metadata: { fromDonation: true },\n   143→            livemode: checkoutSession.livemode,\n   144→            phone: user.phone,\n   145→            address: Customer.formatAddressFromUser(user),\n   146→            delinquent: false,\n   147→            balance: '0',\n   148→            next_invoice_sequence: 1,\n   149→            invoice_prefix: Customer.getInvoicePrefix(),\n   150→          });\n   151→          logger.info('Customer created for donation', { userDid, customerId: customer.id });\n   152→        } else {\n   153→          customer = await Customer.create({\n   154→            did: userDid,\n   155→            email: '',\n   156→            name: 'anonymous',\n   157→            description: 'Anonymous customer',\n   158→            metadata: { fromDonation: true, anonymous: true },\n   159→            livemode: checkoutSession.livemode,\n   160→            phone: '',\n   161→            delinquent: false,\n   162→            balance: '0',\n   163→            next_invoice_sequence: 1,\n   164→            invoice_prefix: Customer.getInvoicePrefix(),\n   165→          });\n   166→        }\n   167→      }\n   168→\n   169→      if (customer) {\n   170→        await checkoutSession.update({ customer_id: customer.id, customer_did: customer.did });\n   171→        if (paymentIntent) {\n   172→          await paymentIntent.update({ customer_id: customer.id });\n   173→        }\n   174→        logger.info('Customer associated with donation', {\n   175→          userDid,\n   176→          customerId: customer.id,\n   177→          checkoutSessionId: checkoutSession.id,\n   178→          paymentIntentId: paymentIntent?.id,\n   179→        });\n   180→      }\n   181→    } else {\n   182→      // 非打赏场景或已有客户ID的情况\n   183→      customer = await Customer.findByPk(checkoutSession.customer_id);\n   184→    }\n   185→    if (!customer) {\n   186→      throw new Error('Customer not found');\n   187→    }\n   188→  }\n   189→\n   190→  const [paymentMethod, paymentCurrency] = await Promise.all([\n   191→    PaymentMethod.findByPk(paymentMethodId),\n   192→    PaymentCurrency.findByPk(paymentCurrencyId),\n   193→  ]);\n   194→  if (!paymentMethod) {\n   195→    throw new Error('Payment method not found');\n   196→  }\n   197→  if (!paymentCurrency) {\n   198→    throw new Error('Payment currency not found');\n   199→  }\n   200→\n   201→  if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type) === false) {\n   202→    throw new Error(`Payment method ${paymentMethod.type} should not be here`);\n   203→  }\n   204→\n   205→  checkoutSession.line_items = await Price.expand(checkoutSession.line_items);\n   206→\n   207→  return {\n   208→    checkoutSession,\n   209→    paymentIntent,\n   210→    customer: customer as Customer,\n   211→    subscription: primarySubscription as Subscription,\n   212→    subscriptions,\n   213→    paymentMethod,\n   214→    paymentCurrency,\n   215→  };\n   216→}\n   217→\n   218→export async function ensureSetupIntent(checkoutSessionId: string, skipInvoice?: boolean) {\n   219→  const checkoutSession = await ensureCheckoutSession(checkoutSessionId);\n   220→\n   221→  if (!checkoutSession.setup_intent_id) {\n   222→    throw new Error('SetupIntent for checkoutSession not found');\n   223→  }\n   224→  if (!checkoutSession.subscription_id) {\n   225→    throw new Error('Subscription for checkoutSession not found');\n   226→  }\n   227→\n   228→  const setupIntent = await SetupIntent.findByPk(checkoutSession.setup_intent_id);\n   229→  if (!setupIntent) {\n   230→    throw new Error('SetupIntent not found for checkoutSession');\n   231→  }\n   232→  if (setupIntent.isImmutable()) {\n   233→    throw new Error('SetupIntent completed or canceled for checkoutSession');\n   234→  }\n   235→  if (setupIntent.status === 'processing') {\n   236→    throw new Error('SetupIntent processing for checkoutSession');\n   237→  }\n   238→\n   239→  const subscription = await Subscription.findByPk(checkoutSession.subscription_id);\n   240→  if (!subscription) {\n   241→    throw new Error('Subscription not found for checkoutSession');\n   242→  }\n   243→  if (subscription.status !== 'incomplete') {\n   244→    throw new Error('Subscription is not in incomplete status for checkoutSession');\n   245→  }\n   246→\n   247→  const customer = await Customer.findByPk(subscription.customer_id);\n   248→  if (!customer) {\n   249→    throw new Error('Customer not found for checkoutSession');\n   250→  }\n   251→\n   252→  const [paymentMethod, paymentCurrency] = await Promise.all([\n   253→    PaymentMethod.findByPk(subscription.default_payment_method_id),\n   254→    PaymentCurrency.findByPk(subscription.currency_id),\n   255→  ]);\n   256→  if (!paymentMethod) {\n   257→    throw new Error('Payment method not found for checkoutSession');\n   258→  }\n   259→  if (!paymentCurrency) {\n   260→    throw new Error('Payment currency not found for checkoutSession');\n   261→  }\n   262→\n   263→  if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type) === false) {\n   264→    throw new Error(`Payment method ${paymentMethod.type} should not be here`);\n   265→  }\n   266→\n   267→  checkoutSession.line_items = await Price.expand(checkoutSession.line_items);\n   268→\n   269→  let invoice;\n   270→  if (subscription && !skipInvoice) {\n   271→    if (checkoutSession.invoice_id) {\n   272→      invoice = await Invoice.findByPk(checkoutSession.invoice_id);\n   273→    } else {\n   274→      // Get discount information for this checkout session\n   275→      let discountInfo: { appliedDiscounts: string[]; discountBreakdown: Array<{ amount: string; discount: string }> } =\n   276→        {\n   277→          appliedDiscounts: [],\n   278→          discountBreakdown: [],\n   279→        };\n   280→\n   281→      try {\n   282→        discountInfo = await getDiscountRecordsForCheckout({\n   283→          checkoutSessionId: checkoutSession.id,\n   284→          customerId: customer.id,\n   285→        });\n   286→      } catch (error) {\n   287→        logger.warn('Failed to get discount records for setup intent checkout session', {\n   288→          checkoutSessionId: checkoutSession.id,\n   289→          customerId: customer.id,\n   290→          error: error.message,\n   291→        });\n   292→      }\n   293→\n   294→      // generate empty invoice here with discount information\n   295→      const result = await ensureInvoiceAndItems({\n   296→        customer,\n   297→        currency: paymentCurrency,\n   298→        subscription,\n   299→        lineItems: [],\n   300→        trialing: !!checkoutSession.subscription_data?.trial_period_days,\n   301→        metered: false,\n   302→        props: {\n   303→          livemode: checkoutSession.livemode,\n   304→          description: checkoutSession.invoice_creation?.invoice_data?.description || 'Subscription creation',\n   305→          statement_descriptor: getStatementDescriptor(checkoutSession.line_items),\n   306→          period_start: subscription.current_period_start,\n   307→          period_end: subscription.current_period_end,\n   308→\n   309→          auto_advance: true,\n   310→          billing_reason: 'subscription_create',\n   311→\n   312→          currency_id: checkoutSession.currency_id,\n   313→          payment_intent_id: '',\n   314→          checkout_session_id: checkoutSession.id,\n   315→\n   316→          total: '0',\n   317→\n   318→          default_payment_method_id: subscription.default_payment_method_id as string,\n   319→\n   320→          discounts: discountInfo.appliedDiscounts,\n   321→          total_discount_amounts: discountInfo.discountBreakdown,\n   322→\n   323→          custom_fields: checkoutSession.invoice_creation?.invoice_data?.custom_fields || [],\n   324→          footer: checkoutSession.invoice_creation?.invoice_data?.footer || '',\n   325→          metadata: checkoutSession.invoice_creation?.invoice_data?.metadata || {},\n   326→        } as unknown as Invoice,\n   327→      });\n   328→      invoice = result.invoice;\n   329→\n   330→      logger.info(`Invoice created for checkoutSession ${checkoutSession.id} in setup mode: ${invoice.id}`, {\n   331→        hasDiscounts: discountInfo.appliedDiscounts.length > 0,\n   332→        discountCount: discountInfo.appliedDiscounts.length,\n   333→      });\n   334→\n   335→      // persist invoice id\n   336→      await checkoutSession.update({ invoice_id: invoice.id });\n   337→      await subscription.update({ latest_invoice_id: invoice.id });\n   338→    }\n   339→  }\n   340→\n   341→  return {\n   342→    checkoutSession,\n   343→    setupIntent,\n   344→    customer,\n   345→    subscription,\n   346→    paymentMethod,\n   347→    paymentCurrency,\n   348→    invoice,\n   349→  };\n   350→}\n   351→\n   352→export async function ensureSubscriptionDelegation(subscriptionId: string) {\n   353→  const subscription = (await Subscription.findOne({\n   354→    where: { id: subscriptionId },\n   355→    include: [\n   356→      { model: PaymentCurrency, as: 'paymentCurrency' },\n   357→      { model: PaymentMethod, as: 'paymentMethod' },\n   358→    ],\n   359→  })) as\n   360→    | (Subscription & { paymentCurrency: PaymentCurrency; paymentMethod: PaymentMethod; items?: TLineItemExpanded[] })\n   361→    | null;\n   362→  if (!subscription) {\n   363→    throw new Error('Subscription not found');\n   364→  }\n   365→  if (!CHARGE_SUPPORTED_CHAIN_TYPES.includes(subscription.paymentMethod?.type)) {\n   366→    throw new Error(`Payment method ${subscription.paymentMethod?.type} not supported for delegation`);\n   367→  }\n   368→  subscription.items = await expandSubscriptionItems(subscription.id);\n   369→  return {\n   370→    paymentCurrency: subscription.paymentCurrency!,\n   371→    paymentMethod: subscription.paymentMethod!,\n   372→    subscription,\n   373→    payerAddress: getSubscriptionPaymentAddress(subscription, subscription.paymentMethod?.type),\n   374→  };\n   375→}\n   376→\n   377→type Args = {\n   378→  checkoutSession: CheckoutSession;\n   379→  customer: Customer;\n   380→  paymentIntent?: PaymentIntent;\n   381→  subscription?: Subscription;\n   382→  props?: Partial<TInvoice>;\n   383→  subscriptions?: Subscription[];\n   384→  lineItems?: TLineItemExpanded[];\n   385→};\n   386→\n   387→export async function ensureInvoiceForCheckout({\n   388→  checkoutSession,\n   389→  customer,\n   390→  paymentIntent,\n   391→  subscription,\n   392→  props,\n   393→  subscriptions,\n   394→  lineItems,\n   395→}: Args): Promise<{ invoice: Invoice | null; items: InvoiceItem[] }> {\n   396→  const isGroupInvoice = subscriptions && subscriptions.length > 1;\n   397→  // invoices are optional when checkout session is in payment mode\n   398→  if (checkoutSession.mode === 'payment' && !checkoutSession.invoice_creation?.enabled) {\n   399→    logger.warn('Invoice creation disabled for payment mode');\n   400→    return { invoice: null, items: [] };\n   401→  }\n   402→\n   403→  const existingInvoice = checkoutSession.invoice_id || (isGroupInvoice && subscription?.latest_invoice_id);\n   404→  // Do not create invoice if it's already created\n   405→  if (existingInvoice) {\n   406→    logger.info(`Invoice already created for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n   407→    const invoice = await Invoice.findByPk(existingInvoice);\n   408→    if (invoice) {\n   409→      if (invoice.status === 'paid') {\n   410→        logger.info(`Invoice already paid for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n   411→        throw new Error('Invoice already paid');\n   412→      }\n   413→\n   414→      // invoice currency is aligned\n   415→      if (invoice.currency_id === checkoutSession.currency_id && invoice.status !== 'draft') {\n   416→        await invoice.update({ status: 'open' });\n   417→        logger.info(`Invoice status reset for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n   418→\n   419→        if (invoice.payment_intent_id) {\n   420→          await PaymentIntent.update({ status: 'requires_capture' }, { where: { id: invoice.payment_intent_id } });\n   421→          logger.info(\n   422→            `PaymentIntent status reset for checkout session ${checkoutSession.id}: ${invoice.payment_intent_id}`\n   423→          );\n   424→        }\n   425→\n   426→        // Reset related quotes to allow retry payment\n   427→        // Find quotes associated with this invoice and checkout session\n   428→        const relatedQuotes = await PriceQuote.findAll({\n   429→          where: {\n   430→            [Op.or]: [\n   431→              { session_id: checkoutSession.id },\n   432→              { invoice_id: existingInvoice }\n   433→            ],\n   434→            status: { [Op.in]: ['used', 'paid'] }\n   435→          }\n   436→        });\n   437→\n   438→        // Reset non-expired quotes to 'active' status, mark expired ones as 'expired'\n   439→        const now = Math.floor(Date.now() / 1000);\n   440→        const resetToActivePromises = relatedQuotes\n   441→          .filter((quote) => quote.expires_at > now)\n   442→          .map((quote) => quote.update({ status: 'active' }));\n   443→\n   444→        const markExpiredPromises = relatedQuotes\n   445→          .filter((quote) => quote.expires_at <= now)\n   446→          .map((quote) => quote.update({ status: 'expired' }));\n   447→\n   448→        const allPromises = [...resetToActivePromises, ...markExpiredPromises];\n   449→        if (allPromises.length > 0) {\n   450→          await Promise.all(allPromises);\n   451→          logger.info('Reset quotes for retry payment', {\n   452→            checkoutSessionId: checkoutSession.id,\n   453→            invoiceId: existingInvoice,\n   454→            resetToActive: resetToActivePromises.length,\n   455→            markedExpired: markExpiredPromises.length,\n   456→            quoteIds: relatedQuotes.map((q) => q.id),\n   457→          });\n   458→        }\n   459→\n   460→        return {\n   461→          invoice,\n   462→          items: await InvoiceItem.findAll({ where: { invoice_id: existingInvoice } }),\n   463→        };\n   464→      }\n   465→\n   466→      // invalid currency not aligned: we should generate new invoice\n   467→      await invoice.update({ status: 'void' });\n   468→      logger.info(`Invoice marked void for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n   469→      const method = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n   470→      if (method?.type === 'stripe' && invoice.metadata?.stripe_id) {\n   471→        const client = method.getStripeClient();\n   472→        client.invoices\n   473→          .voidInvoice(invoice.metadata.stripe_id)\n   474→          .then(() => {\n   475→            logger.info(`Invoice marked void on stripe for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n   476→          })\n   477→          .catch((err) => {\n   478→            logger.error(\n   479→              `Invoice marked void on stripe failed for checkout session ${checkoutSession.id}: ${existingInvoice}`,\n   480→              err\n   481→            );\n   482→          });\n   483→      }\n   484→    }\n   485→  }\n   486→\n   487→  const currency = await PaymentCurrency.findByPk(checkoutSession.currency_id);\n   488→\n   489→  const metadata = {\n   490→    ...(checkoutSession.invoice_creation?.invoice_data?.metadata || {}),\n   491→  };\n   492→\n   493→  if (isGroupInvoice) {\n   494→    metadata.subscription_ids = subscriptions.map((sub) => sub.id);\n   495→    metadata.is_group_invoice = true;\n   496→  }\n   497→\n   498→  const trialInDays = Number(checkoutSession.subscription_data?.trial_period_days || 0);\n   499→  const trialEnd = Number(checkoutSession.subscription_data?.trial_end || 0);\n   500→  const now = dayjs().unix();\n   501→  const invoiceItems = lineItems || (await Price.expand(checkoutSession.line_items, { product: true }));\n   502→\n   503→  // Get discount records for this checkout session\n   504→  let discountInfo: { appliedDiscounts: string[]; discountBreakdown: Array<{ amount: string; discount: string }> } = {\n   505→    appliedDiscounts: [],\n   506→    discountBreakdown: [],\n   507→  };\n   508→\n   509→  // Prepare discount configuration for getCheckoutAmount\n   510→  let discountConfig;\n   511→  try {\n   512→    discountInfo = await getDiscountRecordsForCheckout({\n   513→      checkoutSessionId: checkoutSession.id,\n   514→      customerId: customer.id,\n   515→    });\n   516→\n   517→    // Apply discount if we have discount records\n   518→    if (discountInfo.appliedDiscounts.length > 0 && checkoutSession.discounts?.length) {\n   519→      const firstDiscount = checkoutSession.discounts[0];\n   520→      if (firstDiscount?.coupon && firstDiscount?.promotion_code) {\n   521→        discountConfig = {\n   522→          promotionCodeId: firstDiscount.promotion_code,\n   523→          couponId: firstDiscount.coupon,\n   524→          customerId: customer.id,\n   525→        };\n   526→      }\n   527→    }\n   528→  } catch (error) {\n   529→    logger.warn('Failed to get discount records for checkout session', {\n   530→      checkoutSessionId: checkoutSession.id,\n   531→      customerId: customer.id,\n   532→      error: error.message,\n   533→    });\n   534→  }\n   535→\n   536→  const totalAmount = await getCheckoutAmount(\n   537→    invoiceItems,\n   538→    checkoutSession.currency_id,\n   539→    trialInDays > 0 || trialEnd > now,\n   540→    discountConfig\n   541→  );\n   542→  const { invoice, items } = await ensureInvoiceAndItems({\n   543→    customer,\n   544→    currency: currency as PaymentCurrency,\n   545→    subscription,\n   546→    lineItems: invoiceItems,\n   547→    trialing: !!checkoutSession.subscription_data?.trial_period_days,\n   548→    metered: false,\n   549→    props: {\n   550→      livemode: checkoutSession.livemode,\n   551→      description:\n   552→        checkoutSession.invoice_creation?.invoice_data?.description ||\n   553→        paymentIntent?.description ||\n   554→        'Subscription creation',\n   555→      statement_descriptor: paymentIntent?.statement_descriptor || getStatementDescriptor(checkoutSession.line_items),\n   556→      period_start: subscription?.current_period_start ?? 0,\n   557→      period_end: subscription?.current_period_end ?? 0,\n   558→\n   559→      auto_advance: !paymentIntent,\n   560→      billing_reason: subscription ? 'subscription_create' : 'manual',\n   561→\n   562→      currency_id: checkoutSession.currency_id,\n   563→      payment_intent_id: paymentIntent?.id,\n   564→      checkout_session_id: checkoutSession.id,\n   565→\n   566→      total: totalAmount.total,\n   567→      subtotal: totalAmount.subtotal,\n   568→\n   569→      default_payment_method_id: (subscription?.default_payment_method_id ||\n   570→        paymentIntent?.payment_method_id) as string,\n   571→\n   572→      custom_fields: checkoutSession.invoice_creation?.invoice_data?.custom_fields || [],\n   573→      footer: checkoutSession.invoice_creation?.invoice_data?.footer || '',\n   574→      metadata,\n   575→\n   576→      discounts: discountInfo.appliedDiscounts,\n   577→      total_discount_amounts: discountInfo.discountBreakdown,\n   578→\n   579→      ...(props || {}),\n   580→    } as unknown as Invoice,\n   581→  });\n   582→\n   583→  logger.info('Invoice created for checkoutSession', {\n   584→    checkoutSessionId: checkoutSession.id,\n   585→    invoiceId: invoice.id,\n   586→    hasDiscounts: discountInfo.appliedDiscounts.length > 0,\n   587→    discountCount: discountInfo.appliedDiscounts.length,\n   588→  });\n   589→\n   590→  // only update invoice_id for single invoice\n   591→  if (!isGroupInvoice) {\n   592→    await checkoutSession.update({ invoice_id: invoice.id });\n   593→  }\n   594→  if (paymentIntent) {\n   595→    await paymentIntent.update({ invoice_id: invoice.id });\n   596→  }\n   597→  if (subscription) {\n   598→    await subscription.update({ latest_invoice_id: invoice.id });\n   599→  }\n   600→\n   601→  return { invoice, items };\n   602→}\n   603→\n   604→export async function ensureInvoicesForSubscriptions({\n   605→  checkoutSession,\n   606→  customer,\n   607→  subscriptions,\n   608→  invoiceProps,\n   609→}: Omit<Args, 'subscription'> & { subscriptions: Subscription[]; invoiceProps?: Partial<TInvoice> }): Promise<{\n   610→  invoices: Invoice[];\n   611→}> {\n   612→  if (!subscriptions?.length) {\n   613→    logger.warn('No subscriptions provided for invoice creation');\n   614→    return { invoices: [] };\n   615→  }\n   616→\n   617→  const lineItems = await Price.expand(checkoutSession.line_items, { product: true });\n   618→\n   619→  const primarySubscription = (subscriptions.find((x) => x.metadata.is_primary_subscription) ||\n   620→    subscriptions[0]) as Subscription;\n   621→  const invoices = await Promise.all(\n   622→    subscriptions.map(async (subscription) => {\n   623→      const subItems = await getSubscriptionLineItems(subscription, lineItems, primarySubscription);\n   624→      const { invoice } = await ensureInvoiceForCheckout({\n   625→        checkoutSession,\n   626→        customer,\n   627→        subscription,\n   628→        subscriptions,\n   629→        lineItems: subItems,\n   630→        props: invoiceProps,\n   631→      });\n   632→      return invoice;\n   633→    })\n   634→  );\n   635→\n   636→  const createdInvoices = invoices.filter(Boolean);\n   637→\n   638→  logger.info(`Created ${createdInvoices.length} invoices for subscriptions`, {\n   639→    checkoutSessionId: checkoutSession.id,\n   640→    invoiceIds: createdInvoices.map((inv) => inv?.id),\n   641→  });\n   642→\n   643→  return { invoices: createdInvoices as Invoice[] };\n   644→}\n   645→\n   646→export async function ensureInvoiceForCollect(invoiceId: string) {\n   647→  const invoice = await Invoice.findByPk(invoiceId);\n   648→  if (!invoice) {\n   649→    throw new Error(`Invoice ${invoiceId} not found`);\n   650→  }\n   651→  if (invoice.status === 'paid') {\n   652→    throw new Error(`Invoice ${invoiceId} already paid`);\n   653→  }\n   654→  if (invoice.status === 'void') {\n   655→    throw new Error(`Invoice ${invoiceId} already void`);\n   656→  }\n   657→  if (invoice.status === 'draft') {\n   658→    throw new Error(`Invoice ${invoiceId} is draft`);\n   659→  }\n   660→\n   661→  if (!invoice.payment_intent_id) {\n   662→    await invoiceQueue.pushAndWait({\n   663→      id: invoice.id,\n   664→      job: { invoiceId: invoice.id, retryOnError: false, justCreate: true },\n   665→    });\n   666→    await invoice.reload();\n   667→  }\n   668→\n   669→  const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n   670→  if (!paymentIntent) {\n   671→    throw new Error(`Payment intent not found for invoice ${invoiceId}`);\n   672→  }\n   673→  if (paymentIntent.status === 'canceled') {\n   674→    throw new Error(`Payment intent already canceled for invoice ${invoiceId}`);\n   675→  }\n   676→  if (paymentIntent.status === 'succeeded') {\n   677→    await invoice.update({ status: 'paid' });\n   678→    throw new Error(`Payment intent already succeeded for invoice ${invoiceId}`);\n   679→  }\n   680→\n   681→  await paymentIntent.update({ status: 'requires_capture' });\n   682→\n   683→  const paymentCurrency = await PaymentCurrency.findByPk(paymentIntent.currency_id);\n   684→  const paymentMethod = await PaymentMethod.findByPk(paymentIntent.payment_method_id);\n   685→\n   686→  return {\n   687→    invoice,\n   688→    paymentIntent,\n   689→    paymentCurrency: paymentCurrency as PaymentCurrency,\n   690→    paymentMethod: paymentMethod as PaymentMethod,\n   691→  };\n   692→}\n   693→\n   694→export async function ensureSubscriptionRecharge(subscriptionId: string) {\n   695→  const subscription = await Subscription.findByPk(subscriptionId);\n   696→  if (!subscription) {\n   697→    throw new Error(`Subscription ${subscriptionId} not found`);\n   698→  }\n   699→  const paymentCurrency = await PaymentCurrency.findByPk(subscription.currency_id);\n   700→  if (!paymentCurrency) {\n   701→    throw new Error(`Currency ${subscription.currency_id} not found`);\n   702→  }\n   703→  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n   704→  if (!paymentMethod) {\n   705→    throw new Error(`Payment method ${paymentCurrency.payment_method_id} not found`);\n   706→  }\n   707→  // @ts-ignore\n   708→  const receiverAddress = getSubscriptionPaymentAddress(subscription, paymentMethod.type);\n   709→  if (!receiverAddress) {\n   710→    throw new Error(`Receiver address not found for subscription ${subscriptionId}`);\n   711→  }\n   712→\n   713→  const customer = await Customer.findByPk(subscription.customer_id);\n   714→  if (!customer) {\n   715→    throw new Error(`Customer ${subscription.customer_id} not found`);\n   716→  }\n   717→  return {\n   718→    paymentCurrency: paymentCurrency as PaymentCurrency,\n   719→    paymentMethod: paymentMethod as PaymentMethod,\n   720→    receiverAddress,\n   721→    subscription,\n   722→    customer,\n   723→  };\n   724→}\n   725→\n   726→export async function ensureAccountRecharge(customerId: string, currencyId: string, rechargeAddress?: string) {\n   727→  const customer = await Customer.findByPkOrDid(customerId);\n   728→  if (!customer) {\n   729→    throw new Error(`Customer ${customerId} not found`);\n   730→  }\n   731→  const paymentCurrency = await PaymentCurrency.findByPk(currencyId);\n   732→  if (!paymentCurrency) {\n   733→    throw new Error(`Currency ${currencyId} not found`);\n   734→  }\n   735→  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n   736→  if (!paymentMethod) {\n   737→    throw new Error(`Payment method ${paymentCurrency.payment_method_id} not found`);\n   738→  }\n   739→\n   740→  const receiverAddress = rechargeAddress || customer.did;\n   741→\n   742→  return {\n   743→    paymentCurrency: paymentCurrency as PaymentCurrency,\n   744→    paymentMethod: paymentMethod as PaymentMethod,\n   745→    customer,\n   746→    receiverAddress,\n   747→  };\n   748→}\n   749→export function getAuthPrincipalClaim(method: PaymentMethod, action: string) {\n   750→  let chainInfo = { type: 'none', id: 'none', host: 'none' };\n   751→  if (method.type === 'arcblock') {\n   752→    chainInfo = {\n   753→      type: 'arcblock',\n   754→      id: method.settings?.arcblock?.chain_id as string,\n   755→      host: method.settings?.arcblock?.api_host as string,\n   756→    };\n   757→  }\n   758→  if (method.type === 'ethereum') {\n   759→    chainInfo = {\n   760→      type: 'ethereum',\n   761→      // @ts-ignore\n   762→      id: method.settings?.ethereum?.chain_id as number,\n   763→      host: method.settings?.ethereum?.api_host as string,\n   764→    };\n   765→  }\n   766→  if (method.type === 'base') {\n   767→    chainInfo = {\n   768→      type: 'ethereum',\n   769→      // @ts-ignore\n   770→      id: method.settings?.base?.chain_id as number,\n   771→      host: method.settings?.base?.api_host as string,\n   772→    };\n   773→  }\n   774→\n   775→  return {\n   776→    description: `Select account to ${action}`,\n   777→    chainInfo,\n   778→  };\n   779→}\n   780→\n   781→export async function getDelegationTxClaim({\n   782→  userDid,\n   783→  userPk,\n   784→  nonce,\n   785→  mode,\n   786→  data,\n   787→  items,\n   788→  paymentCurrency,\n   789→  paymentMethod,\n   790→  trialing = false,\n   791→  billingThreshold = 0,\n   792→  requiredStake = true,\n   793→}: {\n   794→  userDid: string;\n   795→  userPk: string;\n   796→  nonce: string;\n   797→  mode: string;\n   798→  data: any;\n   799→  items: TLineItemExpanded[];\n   800→  paymentCurrency: PaymentCurrency;\n   801→  paymentMethod: PaymentMethod;\n   802→  trialing: boolean;\n   803→  billingThreshold?: number;\n   804→  requiredStake?: boolean;\n   805→  requiredAmount?: string;\n   806→}) {\n   807→  const amount = await getFastCheckoutAmount({ items, mode, currencyId: paymentCurrency.id });\n   808→  const address = toDelegateAddress(userDid, wallet.address);\n   809→  const tokenLimits = await getTokenLimitsForDelegation(items, paymentMethod, paymentCurrency, address, amount);\n   810→  let tokenRequirements = await getTokenRequirements({\n   811→    items,\n   812→    mode,\n   813→    trialing,\n   814→    billingThreshold,\n   815→    paymentMethod,\n   816→    paymentCurrency,\n   817→    requiredStake,\n   818→  });\n   819→\n   820→  if (mode === 'delegation') {\n   821→    tokenRequirements = [];\n   822→  }\n   823→  if (paymentMethod.type === 'arcblock') {\n   824→    return {\n   825→      type: 'DelegateTx',\n   826→      description: 'Sign the delegation to continue',\n   827→      wallet: fromPublicKey(userPk, toTypeInfo(userDid)),\n   828→      data: {\n   829→        itx: {\n   830→          address,\n   831→          to: wallet.address,\n   832→          ops: [{ typeUrl: OCAP_PAYMENT_TX_TYPE, limit: { tokens: tokenLimits, assets: [] } }],\n   833→          data,\n   834→        },\n   835→      },\n   836→      nonce,\n   837→      requirement: {\n   838→        tokens: tokenRequirements,\n   839→      },\n   840→      meta: {\n   841→        purpose: 'delegation',\n   842→        address,\n   843→      },\n   844→      chainInfo: {\n   845→        host: paymentMethod.settings?.arcblock?.api_host as string,\n   846→        id: paymentMethod.settings?.arcblock?.chain_id as string,\n   847→      },\n   848→    };\n   849→  }\n   850→\n   851→  if (EVM_CHAIN_TYPES.includes(paymentMethod.type) && paymentCurrency.contract) {\n   852→    const requirement = tokenRequirements.find((x) => x.address === paymentCurrency.contract);\n   853→    const limit = tokenLimits.find((x) => x.address === paymentCurrency.contract);\n   854→    // logger.info('getDelegationTxClaim base', {\n   855→    //   address: ethWallet.address,\n   856→    //   amount: mode === 'setup' ? requirement!.value : limit!.totalAllowance,\n   857→    //   contract: paymentCurrency.contract,\n   858→    //   mode,\n   859→    //   requirement,\n   860→    //   limit,\n   861→    // });\n   862→    return {\n   863→      type: 'eth:transaction',\n   864→      description: 'Sign the approval to continue',\n   865→      data: toBase58(\n   866→        Buffer.from(\n   867→          JSON.stringify({\n   868→            // @ts-ignore\n   869→            network: paymentMethod.settings?.[paymentMethod.type]?.chain_id,\n   870→            tx: await encodeApproveItx(\n   871→              paymentMethod.getEvmClient(),\n   872→              ethWallet.address,\n   873→              mode === 'setup' ? requirement!.value : limit!.totalAllowance,\n   874→              paymentCurrency.contract\n   875→            ),\n   876→          }),\n   877→          'utf-8'\n   878→        )\n   879→      ),\n   880→      nonce,\n   881→      meta: {\n   882→        purpose: 'delegation',\n   883→        address,\n   884→      },\n   885→    };\n   886→  }\n   887→\n   888→  throw new Error(`getDelegationTxClaim: Payment method ${paymentMethod.type} not supported`);\n   889→}\n   890→\n   891→export function getStakeAmount(\n   892→  subscription: Subscription,\n   893→  paymentCurrency: PaymentCurrency,\n   894→  items: TLineItemExpanded[]\n   895→) {\n   896→  const billingThreshold = Number(subscription.billing_thresholds?.amount_gte || 0);\n   897→  const minStakeAmount = Number(subscription.billing_thresholds?.stake_gte || 0);\n   898→  const threshold = fromTokenToUnit(Math.max(billingThreshold, minStakeAmount), paymentCurrency.decimal);\n   899→  const staking = getSubscriptionStakeSetup(items, paymentCurrency.id, threshold.toString());\n   900→  const amount = staking.licensed.add(staking.metered).toString();\n   901→  return amount;\n   902→}\n   903→\n   904→export async function getStakeTxClaim({\n   905→  userDid,\n   906→  userPk,\n   907→  subscription,\n   908→  items,\n   909→  paymentCurrency,\n   910→  paymentMethod,\n   911→  subscriptions,\n   912→}: {\n   913→  userDid: string;\n   914→  userPk: string;\n   915→  subscription: Subscription;\n   916→  items: TLineItemExpanded[];\n   917→  paymentCurrency: PaymentCurrency;\n   918→  paymentMethod: PaymentMethod;\n   919→  subscriptions?: Subscription[];\n   920→}) {\n   921→  let billingThreshold = Number(subscription.billing_thresholds?.amount_gte || 0);\n   922→  let minStakeAmount = Number(subscription.billing_thresholds?.stake_gte || 0);\n   923→\n   924→  const hasGrouping = subscriptions && subscriptions.length > 1;\n   925→  if (hasGrouping) {\n   926→    const primarySubscription = subscriptions[0] as Subscription;\n   927→    // use the settings of the primary subscription, not the scattered staking\n   928→    billingThreshold = Number(primarySubscription.billing_thresholds?.amount_gte || 0);\n   929→    minStakeAmount = Number(primarySubscription.billing_thresholds?.stake_gte || 0);\n   930→\n   931→    logger.info('Using primary subscription for staking', {\n   932→      primarySubscriptionId: primarySubscription.id,\n   933→      billingThreshold,\n   934→      minStakeAmount,\n   935→      allSubscriptionIds: subscriptions.map((s) => s.id),\n   936→    });\n   937→  }\n   938→\n   939→  const threshold = fromTokenToUnit(Math.max(billingThreshold, minStakeAmount), paymentCurrency.decimal);\n   940→  const staking = getSubscriptionStakeSetup(items, paymentCurrency.id, threshold.toString());\n   941→  const amount = staking.licensed.add(staking.metered).toString();\n   942→\n   943→  logger.info('getStakeTxClaim', {\n   944→    subscriptionId: subscription.id,\n   945→    allSubscriptions: subscriptions?.map((s) => s.id) || [],\n   946→    billingThreshold,\n   947→    minStakeAmount,\n   948→    threshold: threshold.toString(),\n   949→    staking,\n   950→    amount: amount.toString(),\n   951→  });\n   952→\n   953→  if (paymentMethod.type === 'arcblock') {\n   954→    // create staking data\n   955→    const client = paymentMethod.getOcapClient();\n   956→\n   957→    const stakeId = hasGrouping ? `stake-group-${subscription.id}` : subscription.id;\n   958→\n   959→    const address = await getCustomerStakeAddress(userDid, stakeId);\n   960→    const { state } = await client.getStakeState({ address });\n   961→    const data = {\n   962→      type: 'json',\n   963→      value: Object.assign(\n   964→        {\n   965→          appId: wallet.address,\n   966→          subscriptionId: subscription.id,\n   967→          ...(hasGrouping\n   968→            ? {\n   969→                subscriptionGroup: true,\n   970→                subscriptionIds: subscriptions.map((s) => s.id),\n   971→              }\n   972→            : {}),\n   973→        },\n   974→        JSON.parse(state?.data?.value || '{}')\n   975→      ),\n   976→    };\n   977→\n   978→    const setup = getSubscriptionCreateSetup(items, paymentCurrency.id, 0, 0);\n   979→\n   980→    return {\n   981→      type: 'StakeTx',\n   982→      description: hasGrouping\n   983→        ? `Stake for ${subscriptions.length} subscriptions`\n   984→        : `Stake for subscription ${subscription.id}`,\n   985→      partialTx: {\n   986→        from: userDid,\n   987→        pk: userPk,\n   988→        itx: {\n   989→          address,\n   990→          receiver: wallet.address,\n   991→          slashers: [wallet.address],\n   992→          revokeWaitingPeriod: setup.cycle.duration / 1000, // wait for at least 1 billing cycle\n   993→          message: hasGrouping\n   994→            ? `Stake for ${subscriptions.length} subscriptions`\n   995→            : `Stake for subscription ${subscription.id}`,\n   996→          nonce: stakeId,\n   997→          inputs: [],\n   998→          data,\n   999→        },\n  1000→        signatures: [],\n  1001→      },\n  1002→      requirement: {\n  1003→        tokens: [{ address: paymentCurrency.contract as string, value: amount }],\n  1004→      },\n  1005→      nonce: `stake-${stakeId}`,\n  1006→      meta: {\n  1007→        purpose: 'staking',\n  1008→        address,\n  1009→        ...(hasGrouping\n  1010→          ? {\n  1011→              subscriptionGroup: true,\n  1012→              primarySubscriptionId: subscription.id,\n  1013→              allSubscriptionIds: subscriptions.map((s) => s.id),\n  1014→            }\n  1015→          : {}),\n  1016→      },\n  1017→      chainInfo: {\n  1018→        host: paymentMethod.settings?.arcblock?.api_host as string,\n  1019→        id: paymentMethod.settings?.arcblock?.chain_id as string,\n  1020→      },\n  1021→    };\n  1022→  }\n  1023→\n  1024→  throw new Error(`getStakeTxClaim: Payment method ${paymentMethod.type} not supported`);\n  1025→}\n  1026→\n  1027→export async function getOverdraftProtectionStakeTxClaim({\n  1028→  userDid,\n  1029→  userPk,\n  1030→  subscription,\n  1031→  paymentCurrency,\n  1032→  paymentMethod,\n  1033→  stakeAmount,\n  1034→  items,\n  1035→}: {\n  1036→  userDid: string;\n  1037→  userPk: string;\n  1038→  subscription: Subscription;\n  1039→  paymentCurrency: PaymentCurrency;\n  1040→  paymentMethod: PaymentMethod;\n  1041→  stakeAmount: string;\n  1042→  items: TLineItemExpanded[];\n  1043→}) {\n  1044→  // create staking amount\n  1045→  logger.info('getStakeTxClaim', {\n  1046→    subscriptionId: subscription.id,\n  1047→    paymentCurrencyId: paymentCurrency.id,\n  1048→    paymentMethodId: paymentMethod.id,\n  1049→    stakeAmount,\n  1050→  });\n  1051→\n  1052→  if (paymentMethod.type === 'arcblock') {\n  1053→    // create staking data\n  1054→    const client = paymentMethod.getOcapClient();\n  1055→    const nonce = `overdraft-protection-${subscription.id}`;\n  1056→    const address = await getCustomerStakeAddress(userDid, nonce);\n  1057→    const { state } = await client.getStakeState({ address });\n  1058→    const data = {\n  1059→      type: 'json',\n  1060→      value: Object.assign(\n  1061→        {\n  1062→          appId: wallet.address,\n  1063→          subscriptionId: subscription.id,\n  1064→        },\n  1065→        JSON.parse(state?.data?.value || '{}')\n  1066→      ),\n  1067→    };\n  1068→\n  1069→    const setup = getSubscriptionCreateSetup(items, paymentCurrency.id, 0, 0);\n  1070→\n  1071→    return {\n  1072→      type: 'StakeTx',\n  1073→      description: `Stake to complete subscription ${subscription.id} SubGuard`,\n  1074→      partialTx: {\n  1075→        from: userDid,\n  1076→        pk: userPk,\n  1077→        itx: {\n  1078→          address,\n  1079→          receiver: wallet.address,\n  1080→          slashers: [wallet.address],\n  1081→          revokeWaitingPeriod: setup.cycle.duration / 1000, // wait for at least 1 billing cycle\n  1082→          message: `Stake for subscription ${subscription.id} SubGuard`,\n  1083→          nonce,\n  1084→          inputs: [],\n  1085→          data,\n  1086→        },\n  1087→        signatures: [],\n  1088→      },\n  1089→      requirement: {\n  1090→        tokens: [{ address: paymentCurrency.contract as string, value: stakeAmount }],\n  1091→      },\n  1092→      nonce: `stake-${subscription.id}`,\n  1093→      meta: {\n  1094→        purpose: 'staking',\n  1095→        address,\n  1096→      },\n  1097→      chainInfo: {\n  1098→        host: paymentMethod.settings?.arcblock?.api_host as string,\n  1099→        id: paymentMethod.settings?.arcblock?.chain_id as string,\n  1100→      },\n  1101→    };\n  1102→  }\n  1103→\n  1104→  throw new Error(`getStakeTxClaim: Payment method ${paymentMethod.type} not supported`);\n  1105→}\n  1106→\n  1107→export type TokenRequirementArgs = {\n  1108→  items: TLineItemExpanded[];\n  1109→  mode: string;\n  1110→  paymentMethod: PaymentMethod;\n  1111→  paymentCurrency: PaymentCurrency;\n  1112→  trialing: boolean;\n  1113→  billingThreshold: number;\n  1114→  requiredStake?: boolean;\n  1115→};\n  1116→\n  1117→export async function getTokenRequirements({\n  1118→  items,\n  1119→  mode,\n  1120→  paymentMethod,\n  1121→  paymentCurrency,\n  1122→  trialing = false,\n  1123→  billingThreshold = 0,\n  1124→  requiredStake,\n  1125→}: TokenRequirementArgs) {\n  1126→  const tokenRequirements: { address: string; value: string }[] = [];\n  1127→  let amount = await getFastCheckoutAmount({ items, mode, currencyId: paymentCurrency.id, trialing: !!trialing });\n  1128→\n  1129→  const addStakeRequired =\n  1130→    requiredStake && ((paymentMethod.type === 'arcblock' && mode !== 'delegation') || mode === 'setup');\n  1131→\n  1132→  if (!addStakeRequired && amount === '0') {\n  1133→    return tokenRequirements;\n  1134→  }\n  1135→\n  1136→  // If the app has not staked, we need to add the gas fee to the amount\n  1137→  if ((await hasStakedForGas(paymentMethod)) === false) {\n  1138→    const maxGas = await estimateMaxGasForTx(paymentMethod);\n  1139→    // pay with the base currency? just add gas to it\n  1140→    if (paymentCurrency.is_base_currency) {\n  1141→      amount = new BN(amount).add(new BN(maxGas)).toString();\n  1142→      tokenRequirements.push({ address: paymentCurrency.contract as string, value: amount });\n  1143→    } else {\n  1144→      tokenRequirements.push({ address: paymentCurrency.contract as string, value: amount });\n  1145→      const baseCurrency = await PaymentCurrency.findOne({\n  1146→        where: { active: true, is_base_currency: true, payment_method_id: paymentMethod.id },\n  1147→      });\n  1148→      if (baseCurrency) {\n  1149→        tokenRequirements.push({ address: baseCurrency.contract as string, value: maxGas });\n  1150→      } else {\n  1151→        throw new Error('Base currency not found since app has not staked for gas');\n  1152→      }\n  1153→    }\n  1154→  } else {\n  1155→    tokenRequirements.push({ address: paymentCurrency.contract as string, value: amount });\n  1156→  }\n  1157→\n  1158→  // Add stake requirement to token requirement\n  1159→  if (addStakeRequired) {\n  1160→    const staking = getSubscriptionStakeSetup(\n  1161→      items,\n  1162→      paymentCurrency.id,\n  1163→      fromTokenToUnit(billingThreshold, paymentCurrency.decimal).toString()\n  1164→    );\n  1165→    const exist = tokenRequirements.find((x) => x.address === paymentCurrency.contract);\n  1166→    if (exist) {\n  1167→      exist.value = new BN(exist.value).add(staking.licensed).add(staking.metered).toString();\n  1168→    } else {\n  1169→      tokenRequirements.push({\n  1170→        address: paymentCurrency.contract as string,\n  1171→        value: staking.licensed.add(staking.metered).toString(),\n  1172→      });\n  1173→    }\n  1174→  }\n  1175→\n  1176→  return tokenRequirements;\n  1177→}\n  1178→\n  1179→export async function ensureSubscription(subscriptionId: string): Promise<Result & { customer: Customer }> {\n  1180→  const subscription = await Subscription.findByPk(subscriptionId);\n  1181→  if (!subscription) {\n  1182→    throw new Error(`Subscription not found: ${subscriptionId}`);\n  1183→  }\n  1184→\n  1185→  if (subscription.isActive() === false) {\n  1186→    throw new Error(`Subscription ${subscriptionId} is not active`);\n  1187→  }\n  1188→\n  1189→  const paymentCurrencyId = subscription.currency_id;\n  1190→  const paymentMethodId = subscription.default_payment_method_id;\n  1191→\n  1192→  const [paymentMethod, paymentCurrency, invoice] = await Promise.all([\n  1193→    PaymentMethod.findByPk(paymentMethodId),\n  1194→    PaymentCurrency.findByPk(paymentCurrencyId),\n  1195→    Invoice.findByPk(subscription.latest_invoice_id),\n  1196→  ]);\n  1197→  if (!paymentMethod) {\n  1198→    throw new Error(`Payment method not found for subscription ${subscriptionId}`);\n  1199→  }\n  1200→  if (!paymentCurrency) {\n  1201→    throw new Error(`Payment currency not found for subscription ${subscriptionId}`);\n  1202→  }\n  1203→\n  1204→  if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type) === false) {\n  1205→    throw new Error(`Payment method ${paymentMethod.type} should not be here`);\n  1206→  }\n  1207→\n  1208→  // @ts-ignore\n  1209→  subscription.items = await expandSubscriptionItems(subscription.id);\n  1210→\n  1211→  return {\n  1212→    // @ts-ignore\n  1213→    checkoutSession: null,\n  1214→    subscription,\n  1215→    paymentMethod,\n  1216→    paymentCurrency,\n  1217→    // @ts-ignore\n  1218→    invoice,\n  1219→    // @ts-ignore\n  1220→    customer: await Customer.findByPk(subscription.customer_id),\n  1221→  };\n  1222→}\n  1223→\n  1224→export async function ensureChangePaymentContext(subscriptionId: string) {\n  1225→  const subscription = await Subscription.findByPk(subscriptionId);\n  1226→  if (!subscription) {\n  1227→    throw new Error(`Subscription not found: ${subscriptionId}`);\n  1228→  }\n  1229→\n  1230→  const context = subscription.metadata?.changePayment || {};\n  1231→  if (!context || !context.setup_intent_id) {\n  1232→    throw new Error(`Change payment context not found: ${subscriptionId}`);\n  1233→  }\n  1234→\n  1235→  const setupIntent = await SetupIntent.findByPk(context.setup_intent_id);\n  1236→  if (!setupIntent) {\n  1237→    throw new Error(`SetupIntent not found for subscription payment change ${subscriptionId}`);\n  1238→  }\n  1239→  if (setupIntent.status === 'succeeded') {\n  1240→    throw new Error(`SetupIntent completed for subscription payment change ${subscriptionId}`);\n  1241→  }\n  1242→\n  1243→  const paymentCurrencyId = setupIntent.currency_id;\n  1244→  const paymentMethodId = setupIntent.payment_method_id;\n  1245→\n  1246→  const [paymentMethod, paymentCurrency] = await Promise.all([\n  1247→    PaymentMethod.findByPk(paymentMethodId),\n  1248→    PaymentCurrency.findByPk(paymentCurrencyId),\n  1249→  ]);\n  1250→  if (!paymentMethod) {\n  1251→    throw new Error(`Payment method not found for SetupIntent ${setupIntent.id}`);\n  1252→  }\n  1253→  if (!paymentCurrency) {\n  1254→    throw new Error(`Payment currency not found for SetupIntent ${setupIntent.id}`);\n  1255→  }\n  1256→\n  1257→  if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type) === false) {\n  1258→    throw new Error(`Payment method ${paymentMethod.type} should not be here`);\n  1259→  }\n  1260→\n  1261→  // @ts-ignore\n  1262→  subscription.items = await expandSubscriptionItems(subscription.id);\n  1263→\n  1264→  return {\n  1265→    subscription,\n  1266→    setupIntent,\n  1267→    paymentMethod,\n  1268→    paymentCurrency,\n  1269→    customer: await Customer.findByPk(subscription.customer_id),\n  1270→  };\n  1271→}\n  1272→\n  1273→export async function ensurePayerChangeContext(subscriptionId: string) {\n  1274→  const subscription = await Subscription.findByPk(subscriptionId);\n  1275→  if (!subscription) {\n  1276→    throw new Error(`Subscription not found: ${subscriptionId}`);\n  1277→  }\n  1278→  if (!['active', 'trialing', 'past_due'].includes(subscription.status)) {\n  1279→    throw new Error(`Subscription ${subscriptionId} is not in a valid status to change payer`);\n  1280→  }\n  1281→  const paymentMethod = await PaymentMethod.findByPk(subscription.default_payment_method_id);\n  1282→  if (!paymentMethod) {\n  1283→    throw new Error(`Payment method not found for subscription ${subscriptionId}`);\n  1284→  }\n  1285→  const payerAddress = getSubscriptionPaymentAddress(subscription, paymentMethod?.type);\n  1286→  const paymentCurrency = await PaymentCurrency.findByPk(subscription.currency_id);\n  1287→  if (!paymentCurrency) {\n  1288→    throw new Error(`PaymentCurrency ${subscription.currency_id} not found for subscription ${subscriptionId}`);\n  1289→  }\n  1290→\n  1291→  // @ts-ignore\n  1292→  subscription.items = await expandSubscriptionItems(subscription.id);\n  1293→\n  1294→  return {\n  1295→    subscription,\n  1296→    paymentCurrency,\n  1297→    paymentMethod,\n  1298→    customer: await Customer.findByPk(subscription.customer_id),\n  1299→    payerAddress,\n  1300→  };\n  1301→}\n  1302→\n  1303→export async function ensureReStakeContext(subscriptionId: string) {\n  1304→  const subscription = await Subscription.findByPk(subscriptionId);\n  1305→  if (!subscription) {\n  1306→    throw new Error(`Subscription not found: ${subscriptionId}`);\n  1307→  }\n  1308→  if (subscription.status === 'canceled') {\n  1309→    throw new Error(`Subscription ${subscriptionId} not recoverable from cancellation`);\n  1310→  }\n  1311→  if (!subscription.cancel_at_period_end) {\n  1312→    throw new Error(`Subscription ${subscriptionId} not recoverable from cancellation config`);\n  1313→  }\n  1314→  if (subscription.cancelation_details?.reason === 'payment_failed') {\n  1315→    throw new Error(`Subscription ${subscriptionId} not recoverable from payment failed`);\n  1316→  }\n  1317→\n  1318→  const paymentCurrency = await PaymentCurrency.findByPk(subscription.currency_id);\n  1319→  if (!paymentCurrency) {\n  1320→    throw new Error(`PaymentCurrency ${subscription.currency_id} not found for subscription ${subscriptionId}`);\n  1321→  }\n  1322→  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  1323→  if (!paymentMethod) {\n  1324→    throw new Error(`Payment method not found for subscription ${subscriptionId}`);\n  1325→  }\n  1326→\n  1327→  if (paymentMethod.type !== 'arcblock') {\n  1328→    throw new Error(`Payment method ${paymentMethod.type} not supported for subscription ${subscriptionId}`);\n  1329→  }\n  1330→\n  1331→  const customer = await Customer.findByPk(subscription.customer_id);\n  1332→  if (!customer) {\n  1333→    throw new Error(`Customer not found for subscription ${subscriptionId}`);\n  1334→  }\n  1335→\n  1336→  // @ts-ignore\n  1337→  subscription.items = await expandSubscriptionItems(subscription.id);\n  1338→\n  1339→  return {\n  1340→    subscription,\n  1341→    paymentCurrency,\n  1342→    paymentMethod,\n  1343→    customer,\n  1344→    payerAddress: getSubscriptionPaymentAddress(subscription, paymentMethod?.type),\n  1345→  };\n  1346→}\n  1347→export async function ensureSubscriptionForCollectBatch(\n  1348→  subscriptionId?: string,\n  1349→  currencyId?: string,\n  1350→  customerId?: string\n  1351→) {\n  1352→  if (!currencyId) {\n  1353→    throw new Error('Currency ID must be provided');\n  1354→  }\n  1355→  if (!subscriptionId && !customerId) {\n  1356→    throw new Error('Either subscriptionId or customerId must be provided');\n  1357→  }\n  1358→\n  1359→  const paymentCurrency = await PaymentCurrency.findByPk(currencyId);\n  1360→  if (!paymentCurrency) {\n  1361→    throw new Error(`PaymentCurrency ${currencyId} not found when prepare batch collect`);\n  1362→  }\n  1363→\n  1364→  let subscription;\n  1365→  let searchCustomerId = customerId;\n  1366→\n  1367→  if (subscriptionId) {\n  1368→    subscription = await Subscription.findByPk(subscriptionId);\n  1369→    if (!subscription) {\n  1370→      throw new Error(`Subscription ${subscriptionId} not found when prepare batch collect`);\n  1371→    }\n  1372→    searchCustomerId = subscription.customer_id;\n  1373→  } else if (customerId) {\n  1374→    const customer = await Customer.findByPkOrDid(customerId);\n  1375→    if (!customer) {\n  1376→      throw new Error(`Customer ${customerId} not found when prepare batch collect`);\n  1377→    }\n  1378→    searchCustomerId = customer.id;\n  1379→  }\n  1380→\n  1381→  const [summary, detail] = await Invoice.getUncollectibleAmount({\n  1382→    ...(subscriptionId ? { subscriptionId } : {}),\n  1383→    customerId: searchCustomerId,\n  1384→    currencyId,\n  1385→  });\n  1386→  if (isEmpty(summary) || !summary[currencyId] || summary[currencyId] === '0') {\n  1387→    throw new Error('No uncollectible invoice found to batch collect');\n  1388→  }\n  1389→\n  1390→  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  1391→  if (!paymentMethod) {\n  1392→    throw new Error(`Payment method not found for currency ${currencyId}`);\n  1393→  }\n  1394→\n  1395→  return {\n  1396→    subscription,\n  1397→    paymentCurrency: paymentCurrency as PaymentCurrency,\n  1398→    paymentMethod: paymentMethod as PaymentMethod,\n  1399→    amount: summary[currencyId],\n  1400→    invoices: detail[currencyId],\n  1401→  };\n  1402→}\n  1403→\n  1404→export async function ensureSubscriptionForOverdraftProtection(subscriptionId: string, amount: string) {\n  1405→  const subscription = await Subscription.findByPk(subscriptionId);\n  1406→  if (!subscription) {\n  1407→    throw new Error(`Subscription ${subscriptionId} not found when prepare SubGuard`);\n  1408→  }\n  1409→  // @ts-ignore\n  1410→  subscription.items = await expandSubscriptionItems(subscription.id);\n  1411→  const paymentCurrency = await PaymentCurrency.findByPk(subscription.currency_id);\n  1412→  if (!paymentCurrency) {\n  1413→    throw new Error(`PaymentCurrency ${subscription.currency_id} not found when prepare SubGuard`);\n  1414→  }\n  1415→\n  1416→  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  1417→\n  1418→  if (!paymentMethod) {\n  1419→    throw new Error(`Payment method not found for subscription ${subscriptionId}`);\n  1420→  }\n  1421→  if (paymentMethod.type !== 'arcblock') {\n  1422→    throw new Error(`Payment method ${paymentMethod.type} not supported for SubGuard`);\n  1423→  }\n  1424→\n  1425→  const customer = await Customer.findByPk(subscription.customer_id);\n  1426→  if (!customer) {\n  1427→    throw new Error(`Customer not found for subscription ${subscriptionId}`);\n  1428→  }\n  1429→\n  1430→  return {\n  1431→    subscription,\n  1432→    paymentCurrency: paymentCurrency as PaymentCurrency,\n  1433→    paymentMethod: paymentMethod as PaymentMethod,\n  1434→    customer,\n  1435→    stakeAmount: fromTokenToUnit(amount, paymentCurrency.decimal).toString(),\n  1436→  };\n  1437→}\n  1438→\n  1439→async function executeSingleTransaction(\n  1440→  client: any,\n  1441→  claim: any,\n  1442→  type: 'Delegate' | 'Stake',\n  1443→  userDid: string,\n  1444→  userPk: string,\n  1445→  gasPayerHeaders: Record<string, string>\n  1446→): Promise<string> {\n  1447→  if (!claim) return '';\n  1448→\n  1449→  const tx: Partial<Transaction> = client.decodeTx(claim.finalTx || claim.origin);\n  1450→  if (claim.sig) {\n  1451→    tx.signature = claim.sig;\n  1452→  }\n  1453→\n  1454→  const { buffer } = await client[`encode${type}Tx`]({ tx });\n  1455→  return client[`send${type}Tx`](\n  1456→    { tx, wallet: fromPublicKey(userPk, toTypeInfo(userDid)) },\n  1457→    await getGasPayerExtra(buffer, gasPayerHeaders)\n  1458→  );\n  1459→}\n  1460→\n  1461→export async function executeOcapTransactions(\n  1462→  userDid: string,\n  1463→  userPk: string,\n  1464→  claims: any[],\n  1465→  paymentMethod: PaymentMethod,\n  1466→  requestSource: Request | Request[] | any[],\n  1467→  subscriptionId?: string,\n  1468→  paymentCurrencyContract?: string,\n  1469→  nonce?: string\n  1470→) {\n  1471→  const client = paymentMethod.getOcapClient();\n  1472→  logger.info('start executeOcapTransactions', { userDid, claims });\n  1473→\n  1474→  const delegation = claims.find((x) => x.type === 'signature' && x.meta?.purpose === 'delegation');\n  1475→  const staking = claims.find((x) => x.type === 'prepareTx' && x.meta?.purpose === 'staking');\n  1476→\n  1477→  const stakingAmount =\n  1478→    staking?.requirement?.tokens?.find((x: any) => x?.address === paymentCurrencyContract)?.value || '0';\n  1479→\n  1480→  try {\n  1481→    const getHeaders = (index: number): Record<string, string> => {\n  1482→      if (Array.isArray(requestSource)) {\n  1483→        if (requestSource.length === 0) {\n  1484→          return {};\n  1485→        }\n  1486→        const headerIndex = index < requestSource.length ? index : 0;\n  1487→        const req = requestSource[headerIndex];\n  1488→        return req ? client.pickGasPayerHeaders(req) : {};\n  1489→      }\n  1490→\n  1491→      if (requestSource && typeof requestSource === 'object') {\n  1492→        return client.pickGasPayerHeaders(requestSource);\n  1493→      }\n  1494→\n  1495→      return {};\n  1496→    };\n  1497→\n  1498→    const transactions = [\n  1499→      { claim: delegation, type: 'Delegate' },\n  1500→      { claim: staking, type: 'Stake' },\n  1501→    ];\n  1502→\n  1503→    const txHashes = [];\n  1504→    for (let i = 0; i < transactions.length; i++) {\n  1505→      const { claim, type } = transactions[i]!;\n  1506→      // eslint-disable-next-line no-await-in-loop\n  1507→      const hash = await executeSingleTransaction(\n  1508→        client,\n  1509→        claim,\n  1510→        type as 'Delegate' | 'Stake',\n  1511→        userDid,\n  1512→        userPk,\n  1513→        getHeaders(i)\n  1514→      );\n  1515→      txHashes.push(hash);\n  1516→    }\n  1517→\n  1518→    const [delegationTxHash, stakingTxHash] = txHashes;\n  1519→\n  1520→    return {\n  1521→      tx_hash: delegationTxHash,\n  1522→      payer: userDid,\n  1523→      type: 'delegate',\n  1524→      staking: {\n  1525→        tx_hash: stakingTxHash,\n  1526→        address: await getCustomerStakeAddress(userDid, nonce || subscriptionId || ''),\n  1527→      },\n  1528→      stakingAmount,\n  1529→    };\n  1530→  } catch (err) {\n  1531→    logger.error('executeOcapTransactions failed', { error: err, userDid });\n  1532→    throw err;\n  1533→  }\n  1534→}\n  1535→\n  1536→export async function updateStripeSubscriptionAfterChangePayment(setupIntent: SetupIntent, subscription: Subscription) {\n  1537→  const { from_method: fromMethodId, to_method: toMethodId } = setupIntent.metadata || {};\n  1538→  const fromMethod = await PaymentMethod.findByPk(fromMethodId);\n  1539→  if (fromMethod?.type === 'stripe') {\n  1540→    // pause Stripe\n  1541→    const client = fromMethod?.getStripeClient();\n  1542→    const stripeSubscriptionId = subscription.payment_details?.stripe?.subscription_id as string;\n  1543→    if (client && stripeSubscriptionId) {\n  1544→      const stripeSubscription = await client.subscriptions.retrieve(stripeSubscriptionId);\n  1545→      if (stripeSubscription) {\n  1546→        const result = await client.subscriptions.update(stripeSubscriptionId, {\n  1547→          pause_collection: {\n  1548→            behavior: 'void',\n  1549→          },\n  1550→        });\n  1551→        logger.info('stripe subscription paused on payment change', {\n  1552→          subscription: subscription.id,\n  1553→          stripeSubscription: stripeSubscriptionId,\n  1554→          result,\n  1555→        });\n  1556→      }\n  1557→    }\n  1558→  } else {\n  1559→    const toMethod = await PaymentMethod.findByPk(toMethodId);\n  1560→    if (toMethod?.type === 'stripe') {\n  1561→      // resume stripe\n  1562→      const client = toMethod?.getStripeClient();\n  1563→      const stripeSubscriptionId = subscription.payment_details?.stripe?.subscription_id as string;\n  1564→      if (client && stripeSubscriptionId) {\n  1565→        const stripeSubscription = await client.subscriptions.retrieve(stripeSubscriptionId);\n  1566→        if (stripeSubscription.status === 'paused') {\n  1567→          await client.subscriptions.resume(stripeSubscriptionId, {\n  1568→            proration_behavior: 'none',\n  1569→          });\n  1570→          logger.info('stripe subscription resumed on payment change', {\n  1571→            subscription: subscription.id,\n  1572→            stripeSubscription: stripeSubscriptionId,\n  1573→          });\n  1574→        }\n  1575→      }\n  1576→    }\n  1577→  }\n  1578→}\n  1579→\n  1580→export async function ensureAutoRechargeAuthorization(\n  1581→  autoRechargeConfigId: string\n  1582→): Promise<{ autoRechargeConfig: AutoRechargeConfig; paymentMethod: PaymentMethod; paymentCurrency: PaymentCurrency }> {\n  1583→  const autoRechargeConfig = await AutoRechargeConfig.findByPk(autoRechargeConfigId);\n  1584→  if (!autoRechargeConfig) {\n  1585→    throw new Error(`Auto recharge config ${autoRechargeConfigId} not found`);\n  1586→  }\n  1587→\n  1588→  const price = await Price.findByPk(autoRechargeConfig.price_id);\n  1589→  if (!price) {\n  1590→    throw new Error(`Price ${autoRechargeConfig.price_id} not found`);\n  1591→  }\n  1592→  const paymentCurrency = await PaymentCurrency.findByPk(autoRechargeConfig.recharge_currency_id);\n  1593→  if (!paymentCurrency) {\n  1594→    throw new Error(`Payment currency ${autoRechargeConfig.recharge_currency_id} not found`);\n  1595→  }\n  1596→\n  1597→  if (paymentCurrency.payment_method_id !== autoRechargeConfig.payment_method_id) {\n  1598→    await autoRechargeConfig.update({\n  1599→      payment_method_id: paymentCurrency.payment_method_id,\n  1600→    });\n  1601→  }\n  1602→\n  1603→  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  1604→  if (!paymentMethod) {\n  1605→    throw new Error(`Payment method ${paymentCurrency.payment_method_id} not found`);\n  1606→  }\n  1607→\n  1608→  return {\n  1609→    autoRechargeConfig,\n  1610→    paymentMethod,\n  1611→    paymentCurrency,\n  1612→  };\n  1613→}\n  1614→\n  1615→export async function returnStakeForCanceledSubscription(subscriptionId: string) {\n  1616→  if (!subscriptionId) {\n  1617→    return;\n  1618→  }\n  1619→  try {\n  1620→    const subscription = await Subscription.findByPk(subscriptionId);\n  1621→    if (!subscription) {\n  1622→      throw new Error(`Subscription ${subscriptionId} not found`);\n  1623→    }\n  1624→    if (subscription.status !== 'canceled') {\n  1625→      throw new Error(`Subscription ${subscriptionId} is not canceled`);\n  1626→    }\n  1627→\n  1628→    if (!subscription.payment_details?.arcblock?.staking?.tx_hash) {\n  1629→      throw new Error(`No staking transaction found in subscription ${subscriptionId}`);\n  1630→    }\n  1631→    returnStakeQueue.push({ id: `return-stake-${subscription.id}`, job: { subscriptionId: subscription.id } });\n  1632→    logger.info('Subscription return stake job scheduled', {\n  1633→      jobId: `return-stake-${subscription.id}`,\n  1634→      subscription: subscription.id,\n  1635→    });\n  1636→  } catch (err) {\n  1637→    logger.error('returnStakeForCanceledSubscription failed', { error: err, subscriptionId });\n  1638→  }\n  1639→}\n  1640→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"81091065-95fe-48c7-81ae-1b27b160c3a5","timestamp":"2026-01-06T14:31:24.373Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts","content":"/* eslint-disable @typescript-eslint/indent */\n/* eslint-disable prettier/prettier */\nimport { toTypeInfo } from '@arcblock/did';\nimport { toDelegateAddress } from '@arcblock/did-util';\nimport type { Transaction } from '@ocap/client';\nimport { BN, fromTokenToUnit, toBase58 } from '@ocap/util';\nimport { fromPublicKey } from '@ocap/wallet';\nimport type { Request } from 'express';\nimport { isEmpty } from 'lodash';\nimport { Op } from 'sequelize';\nimport dayjs from '../../libs/dayjs';\nimport { estimateMaxGasForTx, hasStakedForGas } from '../../integrations/arcblock/stake';\nimport { encodeApproveItx } from '../../integrations/ethereum/token';\nimport { blocklet, ethWallet, wallet } from '../../libs/auth';\nimport logger from '../../libs/logger';\nimport { getGasPayerExtra, getTokenLimitsForDelegation } from '../../libs/payment';\nimport {\n  getCheckoutAmount,\n  getCheckoutSessionSubscriptionIds,\n  getFastCheckoutAmount,\n  getStatementDescriptor,\n  getSubscriptionCreateSetup,\n  isDonationCheckoutSession,\n  getSubscriptionLineItems,\n} from '../../libs/session';\nimport { getDiscountRecordsForCheckout } from '../../libs/discount/coupon';\nimport {\n  expandSubscriptionItems,\n  getSubscriptionPaymentAddress,\n  getSubscriptionStakeSetup,\n} from '../../libs/subscription';\nimport { getCustomerStakeAddress, OCAP_PAYMENT_TX_TYPE } from '../../libs/util';\n\nimport { invoiceQueue } from '../../queues/invoice';\nimport { AutoRechargeConfig, type TLineItemExpanded } from '../../store/models';\nimport { CheckoutSession } from '../../store/models/checkout-session';\nimport { Customer } from '../../store/models/customer';\nimport { Invoice, TInvoice } from '../../store/models/invoice';\nimport { InvoiceItem } from '../../store/models/invoice-item';\nimport { PaymentCurrency } from '../../store/models/payment-currency';\nimport { PaymentIntent } from '../../store/models/payment-intent';\nimport { PaymentMethod } from '../../store/models/payment-method';\nimport { Price } from '../../store/models/price';\nimport { PriceQuote } from '../../store/models/price-quote';\nimport { SetupIntent } from '../../store/models/setup-intent';\nimport { Subscription } from '../../store/models/subscription';\nimport { ensureInvoiceAndItems } from '../../libs/invoice';\nimport { CHARGE_SUPPORTED_CHAIN_TYPES, EVM_CHAIN_TYPES } from '../../libs/constants';\nimport { returnStakeQueue } from '../../queues/subscription';\n\ntype Result = {\n  checkoutSession: CheckoutSession;\n  customer: Customer;\n  paymentIntent?: PaymentIntent;\n  subscription?: Subscription;\n  subscriptions?: Subscription[];\n  paymentCurrency: PaymentCurrency;\n  paymentMethod: PaymentMethod;\n  invoice?: Invoice;\n};\n\nexport async function ensureCheckoutSession(checkoutSessionId: string) {\n  const checkoutSession = await CheckoutSession.findByPk(checkoutSessionId);\n  if (!checkoutSession) {\n    throw new Error('Checkout session not found');\n  }\n  if (checkoutSession.isImmutable()) {\n    throw new Error('Checkout session is immutable');\n  }\n\n  return checkoutSession;\n}\n\nexport async function ensurePaymentIntent(\n  checkoutSessionId: string,\n  userDid?: string,\n  skipCustomer?: boolean\n): Promise<Result> {\n  const checkoutSession = await ensureCheckoutSession(checkoutSessionId);\n\n  let paymentCurrencyId;\n  let paymentMethodId;\n\n  let paymentIntent;\n  if (checkoutSession.payment_intent_id) {\n    paymentIntent = await PaymentIntent.findByPk(checkoutSession.payment_intent_id);\n    if (!paymentIntent) {\n      throw new Error('Payment intent not found');\n    }\n    if (paymentIntent.status === 'succeeded') {\n      throw new Error('Payment intent completed');\n    }\n    if (paymentIntent.status === 'canceled') {\n      throw new Error('Payment intent canceled');\n    }\n    if (paymentIntent.status === 'processing') {\n      throw new Error('Payment intent processing');\n    }\n\n    paymentCurrencyId = paymentIntent.currency_id;\n    paymentMethodId = paymentIntent.payment_method_id;\n  }\n\n  const subscriptionIds = getCheckoutSessionSubscriptionIds(checkoutSession);\n\n  let subscriptions: Subscription[] = [];\n  let primarySubscription: Subscription | null = null;\n  if (subscriptionIds.length > 0) {\n    // @ts-ignore\n    subscriptions = await Promise.all(subscriptionIds.filter(Boolean).map((id) => Subscription.findByPk(id)));\n\n    subscriptions = subscriptions.filter(Boolean);\n    for (const subscription of subscriptions) {\n      if (subscription && subscription.status !== 'incomplete') {\n        throw new Error(`Subscription ${subscription.id} is not in incomplete status: ${subscription.status}`);\n      }\n    }\n    if (subscriptions.length > 0) {\n      // @ts-ignore\n      primarySubscription = subscriptions.find((sub) => sub.metadata?.is_primary_subscription) || subscriptions[0];\n      paymentCurrencyId = primarySubscription?.currency_id;\n      paymentMethodId = primarySubscription?.default_payment_method_id;\n    }\n  }\n  let customer = null;\n\n  if (!skipCustomer) {\n    // 检查是否为打赏场景\n    const isDonation = isDonationCheckoutSession(checkoutSession);\n\n    // if donation, create customer if not exists\n    if (isDonation && !checkoutSession.customer_id && userDid) {\n      customer = await Customer.findByPkOrDid(userDid);\n      if (!customer) {\n        const { user } = await blocklet.getUser(userDid);\n        if (user) {\n          customer = await Customer.create({\n            did: userDid,\n            email: user.email,\n            name: user.fullName || userDid,\n            description: user.remark,\n            metadata: { fromDonation: true },\n            livemode: checkoutSession.livemode,\n            phone: user.phone,\n            address: Customer.formatAddressFromUser(user),\n            delinquent: false,\n            balance: '0',\n            next_invoice_sequence: 1,\n            invoice_prefix: Customer.getInvoicePrefix(),\n          });\n          logger.info('Customer created for donation', { userDid, customerId: customer.id });\n        } else {\n          customer = await Customer.create({\n            did: userDid,\n            email: '',\n            name: 'anonymous',\n            description: 'Anonymous customer',\n            metadata: { fromDonation: true, anonymous: true },\n            livemode: checkoutSession.livemode,\n            phone: '',\n            delinquent: false,\n            balance: '0',\n            next_invoice_sequence: 1,\n            invoice_prefix: Customer.getInvoicePrefix(),\n          });\n        }\n      }\n\n      if (customer) {\n        await checkoutSession.update({ customer_id: customer.id, customer_did: customer.did });\n        if (paymentIntent) {\n          await paymentIntent.update({ customer_id: customer.id });\n        }\n        logger.info('Customer associated with donation', {\n          userDid,\n          customerId: customer.id,\n          checkoutSessionId: checkoutSession.id,\n          paymentIntentId: paymentIntent?.id,\n        });\n      }\n    } else {\n      // 非打赏场景或已有客户ID的情况\n      customer = await Customer.findByPk(checkoutSession.customer_id);\n    }\n    if (!customer) {\n      throw new Error('Customer not found');\n    }\n  }\n\n  const [paymentMethod, paymentCurrency] = await Promise.all([\n    PaymentMethod.findByPk(paymentMethodId),\n    PaymentCurrency.findByPk(paymentCurrencyId),\n  ]);\n  if (!paymentMethod) {\n    throw new Error('Payment method not found');\n  }\n  if (!paymentCurrency) {\n    throw new Error('Payment currency not found');\n  }\n\n  if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type) === false) {\n    throw new Error(`Payment method ${paymentMethod.type} should not be here`);\n  }\n\n  checkoutSession.line_items = await Price.expand(checkoutSession.line_items);\n\n  return {\n    checkoutSession,\n    paymentIntent,\n    customer: customer as Customer,\n    subscription: primarySubscription as Subscription,\n    subscriptions,\n    paymentMethod,\n    paymentCurrency,\n  };\n}\n\nexport async function ensureSetupIntent(checkoutSessionId: string, skipInvoice?: boolean) {\n  const checkoutSession = await ensureCheckoutSession(checkoutSessionId);\n\n  if (!checkoutSession.setup_intent_id) {\n    throw new Error('SetupIntent for checkoutSession not found');\n  }\n  if (!checkoutSession.subscription_id) {\n    throw new Error('Subscription for checkoutSession not found');\n  }\n\n  const setupIntent = await SetupIntent.findByPk(checkoutSession.setup_intent_id);\n  if (!setupIntent) {\n    throw new Error('SetupIntent not found for checkoutSession');\n  }\n  if (setupIntent.isImmutable()) {\n    throw new Error('SetupIntent completed or canceled for checkoutSession');\n  }\n  if (setupIntent.status === 'processing') {\n    throw new Error('SetupIntent processing for checkoutSession');\n  }\n\n  const subscription = await Subscription.findByPk(checkoutSession.subscription_id);\n  if (!subscription) {\n    throw new Error('Subscription not found for checkoutSession');\n  }\n  if (subscription.status !== 'incomplete') {\n    throw new Error('Subscription is not in incomplete status for checkoutSession');\n  }\n\n  const customer = await Customer.findByPk(subscription.customer_id);\n  if (!customer) {\n    throw new Error('Customer not found for checkoutSession');\n  }\n\n  const [paymentMethod, paymentCurrency] = await Promise.all([\n    PaymentMethod.findByPk(subscription.default_payment_method_id),\n    PaymentCurrency.findByPk(subscription.currency_id),\n  ]);\n  if (!paymentMethod) {\n    throw new Error('Payment method not found for checkoutSession');\n  }\n  if (!paymentCurrency) {\n    throw new Error('Payment currency not found for checkoutSession');\n  }\n\n  if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type) === false) {\n    throw new Error(`Payment method ${paymentMethod.type} should not be here`);\n  }\n\n  checkoutSession.line_items = await Price.expand(checkoutSession.line_items);\n\n  let invoice;\n  if (subscription && !skipInvoice) {\n    if (checkoutSession.invoice_id) {\n      invoice = await Invoice.findByPk(checkoutSession.invoice_id);\n    } else {\n      // Get discount information for this checkout session\n      let discountInfo: { appliedDiscounts: string[]; discountBreakdown: Array<{ amount: string; discount: string }> } =\n        {\n          appliedDiscounts: [],\n          discountBreakdown: [],\n        };\n\n      try {\n        discountInfo = await getDiscountRecordsForCheckout({\n          checkoutSessionId: checkoutSession.id,\n          customerId: customer.id,\n        });\n      } catch (error) {\n        logger.warn('Failed to get discount records for setup intent checkout session', {\n          checkoutSessionId: checkoutSession.id,\n          customerId: customer.id,\n          error: error.message,\n        });\n      }\n\n      // generate empty invoice here with discount information\n      const result = await ensureInvoiceAndItems({\n        customer,\n        currency: paymentCurrency,\n        subscription,\n        lineItems: [],\n        trialing: !!checkoutSession.subscription_data?.trial_period_days,\n        metered: false,\n        props: {\n          livemode: checkoutSession.livemode,\n          description: checkoutSession.invoice_creation?.invoice_data?.description || 'Subscription creation',\n          statement_descriptor: getStatementDescriptor(checkoutSession.line_items),\n          period_start: subscription.current_period_start,\n          period_end: subscription.current_period_end,\n\n          auto_advance: true,\n          billing_reason: 'subscription_create',\n\n          currency_id: checkoutSession.currency_id,\n          payment_intent_id: '',\n          checkout_session_id: checkoutSession.id,\n\n          total: '0',\n\n          default_payment_method_id: subscription.default_payment_method_id as string,\n\n          discounts: discountInfo.appliedDiscounts,\n          total_discount_amounts: discountInfo.discountBreakdown,\n\n          custom_fields: checkoutSession.invoice_creation?.invoice_data?.custom_fields || [],\n          footer: checkoutSession.invoice_creation?.invoice_data?.footer || '',\n          metadata: checkoutSession.invoice_creation?.invoice_data?.metadata || {},\n        } as unknown as Invoice,\n      });\n      invoice = result.invoice;\n\n      logger.info(`Invoice created for checkoutSession ${checkoutSession.id} in setup mode: ${invoice.id}`, {\n        hasDiscounts: discountInfo.appliedDiscounts.length > 0,\n        discountCount: discountInfo.appliedDiscounts.length,\n      });\n\n      // persist invoice id\n      await checkoutSession.update({ invoice_id: invoice.id });\n      await subscription.update({ latest_invoice_id: invoice.id });\n    }\n  }\n\n  return {\n    checkoutSession,\n    setupIntent,\n    customer,\n    subscription,\n    paymentMethod,\n    paymentCurrency,\n    invoice,\n  };\n}\n\nexport async function ensureSubscriptionDelegation(subscriptionId: string) {\n  const subscription = (await Subscription.findOne({\n    where: { id: subscriptionId },\n    include: [\n      { model: PaymentCurrency, as: 'paymentCurrency' },\n      { model: PaymentMethod, as: 'paymentMethod' },\n    ],\n  })) as\n    | (Subscription & { paymentCurrency: PaymentCurrency; paymentMethod: PaymentMethod; items?: TLineItemExpanded[] })\n    | null;\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n  if (!CHARGE_SUPPORTED_CHAIN_TYPES.includes(subscription.paymentMethod?.type)) {\n    throw new Error(`Payment method ${subscription.paymentMethod?.type} not supported for delegation`);\n  }\n  subscription.items = await expandSubscriptionItems(subscription.id);\n  return {\n    paymentCurrency: subscription.paymentCurrency!,\n    paymentMethod: subscription.paymentMethod!,\n    subscription,\n    payerAddress: getSubscriptionPaymentAddress(subscription, subscription.paymentMethod?.type),\n  };\n}\n\ntype Args = {\n  checkoutSession: CheckoutSession;\n  customer: Customer;\n  paymentIntent?: PaymentIntent;\n  subscription?: Subscription;\n  props?: Partial<TInvoice>;\n  subscriptions?: Subscription[];\n  lineItems?: TLineItemExpanded[];\n};\n\nexport async function ensureInvoiceForCheckout({\n  checkoutSession,\n  customer,\n  paymentIntent,\n  subscription,\n  props,\n  subscriptions,\n  lineItems,\n}: Args): Promise<{ invoice: Invoice | null; items: InvoiceItem[] }> {\n  const isGroupInvoice = subscriptions && subscriptions.length > 1;\n  // invoices are optional when checkout session is in payment mode\n  if (checkoutSession.mode === 'payment' && !checkoutSession.invoice_creation?.enabled) {\n    logger.warn('Invoice creation disabled for payment mode');\n    return { invoice: null, items: [] };\n  }\n\n  const existingInvoice = checkoutSession.invoice_id || (isGroupInvoice && subscription?.latest_invoice_id);\n  // Do not create invoice if it's already created\n  if (existingInvoice) {\n    logger.info(`Invoice already created for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n    const invoice = await Invoice.findByPk(existingInvoice);\n    if (invoice) {\n      if (invoice.status === 'paid') {\n        logger.info(`Invoice already paid for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n        throw new Error('Invoice already paid');\n      }\n\n      // invoice currency is aligned\n      if (invoice.currency_id === checkoutSession.currency_id && invoice.status !== 'draft') {\n        await invoice.update({ status: 'open' });\n        logger.info(`Invoice status reset for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n\n        if (invoice.payment_intent_id) {\n          await PaymentIntent.update({ status: 'requires_capture' }, { where: { id: invoice.payment_intent_id } });\n          logger.info(\n            `PaymentIntent status reset for checkout session ${checkoutSession.id}: ${invoice.payment_intent_id}`\n          );\n        }\n\n        // Reset related quotes to allow retry payment\n        // Find quotes associated with this invoice and checkout session\n        const relatedQuotes = await PriceQuote.findAll({\n          where: {\n            [Op.or]: [\n              { session_id: checkoutSession.id },\n              { invoice_id: existingInvoice }\n            ],\n            status: { [Op.in]: ['used', 'paid'] }\n          }\n        });\n\n        // Reset non-expired quotes to 'active' status, mark expired ones as 'expired'\n        const now = Math.floor(Date.now() / 1000);\n        const resetToActivePromises = relatedQuotes\n          .filter((quote) => quote.expires_at > now)\n          .map((quote) => quote.update({ status: 'active' }));\n\n        const markExpiredPromises = relatedQuotes\n          .filter((quote) => quote.expires_at <= now)\n          .map((quote) => quote.update({ status: 'expired' }));\n\n        const allPromises = [...resetToActivePromises, ...markExpiredPromises];\n        if (allPromises.length > 0) {\n          await Promise.all(allPromises);\n          logger.info('Reset quotes for retry payment', {\n            checkoutSessionId: checkoutSession.id,\n            invoiceId: existingInvoice,\n            resetToActive: resetToActivePromises.length,\n            markedExpired: markExpiredPromises.length,\n            quoteIds: relatedQuotes.map((q) => q.id),\n          });\n        }\n\n        return {\n          invoice,\n          items: await InvoiceItem.findAll({ where: { invoice_id: existingInvoice } }),\n        };\n      }\n\n      // invalid currency not aligned: we should generate new invoice\n      await invoice.update({ status: 'void' });\n      logger.info(`Invoice marked void for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n      const method = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n      if (method?.type === 'stripe' && invoice.metadata?.stripe_id) {\n        const client = method.getStripeClient();\n        client.invoices\n          .voidInvoice(invoice.metadata.stripe_id)\n          .then(() => {\n            logger.info(`Invoice marked void on stripe for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n          })\n          .catch((err) => {\n            logger.error(\n              `Invoice marked void on stripe failed for checkout session ${checkoutSession.id}: ${existingInvoice}`,\n              err\n            );\n          });\n      }\n    }\n  }\n\n  const currency = await PaymentCurrency.findByPk(checkoutSession.currency_id);\n\n  const metadata = {\n    ...(checkoutSession.invoice_creation?.invoice_data?.metadata || {}),\n  };\n\n  if (isGroupInvoice) {\n    metadata.subscription_ids = subscriptions.map((sub) => sub.id);\n    metadata.is_group_invoice = true;\n  }\n\n  const trialInDays = Number(checkoutSession.subscription_data?.trial_period_days || 0);\n  const trialEnd = Number(checkoutSession.subscription_data?.trial_end || 0);\n  const now = dayjs().unix();\n  const invoiceItems = lineItems || (await Price.expand(checkoutSession.line_items, { product: true }));\n\n  // Get discount records for this checkout session\n  let discountInfo: { appliedDiscounts: string[]; discountBreakdown: Array<{ amount: string; discount: string }> } = {\n    appliedDiscounts: [],\n    discountBreakdown: [],\n  };\n\n  // Prepare discount configuration for getCheckoutAmount\n  let discountConfig;\n  try {\n    discountInfo = await getDiscountRecordsForCheckout({\n      checkoutSessionId: checkoutSession.id,\n      customerId: customer.id,\n    });\n\n    // Apply discount if we have discount records\n    if (discountInfo.appliedDiscounts.length > 0 && checkoutSession.discounts?.length) {\n      const firstDiscount = checkoutSession.discounts[0];\n      if (firstDiscount?.coupon && firstDiscount?.promotion_code) {\n        discountConfig = {\n          promotionCodeId: firstDiscount.promotion_code,\n          couponId: firstDiscount.coupon,\n          customerId: customer.id,\n        };\n      }\n    }\n  } catch (error) {\n    logger.warn('Failed to get discount records for checkout session', {\n      checkoutSessionId: checkoutSession.id,\n      customerId: customer.id,\n      error: error.message,\n    });\n  }\n\n  const totalAmount = await getCheckoutAmount(\n    invoiceItems,\n    checkoutSession.currency_id,\n    trialInDays > 0 || trialEnd > now,\n    discountConfig\n  );\n  const { invoice, items } = await ensureInvoiceAndItems({\n    customer,\n    currency: currency as PaymentCurrency,\n    subscription,\n    lineItems: invoiceItems,\n    trialing: !!checkoutSession.subscription_data?.trial_period_days,\n    metered: false,\n    props: {\n      livemode: checkoutSession.livemode,\n      description:\n        checkoutSession.invoice_creation?.invoice_data?.description ||\n        paymentIntent?.description ||\n        'Subscription creation',\n      statement_descriptor: paymentIntent?.statement_descriptor || getStatementDescriptor(checkoutSession.line_items),\n      period_start: subscription?.current_period_start ?? 0,\n      period_end: subscription?.current_period_end ?? 0,\n\n      auto_advance: !paymentIntent,\n      billing_reason: subscription ? 'subscription_create' : 'manual',\n\n      currency_id: checkoutSession.currency_id,\n      payment_intent_id: paymentIntent?.id,\n      checkout_session_id: checkoutSession.id,\n\n      total: totalAmount.total,\n      subtotal: totalAmount.subtotal,\n\n      default_payment_method_id: (subscription?.default_payment_method_id ||\n        paymentIntent?.payment_method_id) as string,\n\n      custom_fields: checkoutSession.invoice_creation?.invoice_data?.custom_fields || [],\n      footer: checkoutSession.invoice_creation?.invoice_data?.footer || '',\n      metadata,\n\n      discounts: discountInfo.appliedDiscounts,\n      total_discount_amounts: discountInfo.discountBreakdown,\n\n      ...(props || {}),\n    } as unknown as Invoice,\n  });\n\n  logger.info('Invoice created for checkoutSession', {\n    checkoutSessionId: checkoutSession.id,\n    invoiceId: invoice.id,\n    hasDiscounts: discountInfo.appliedDiscounts.length > 0,\n    discountCount: discountInfo.appliedDiscounts.length,\n  });\n\n  // only update invoice_id for single invoice\n  if (!isGroupInvoice) {\n    await checkoutSession.update({ invoice_id: invoice.id });\n  }\n  if (paymentIntent) {\n    await paymentIntent.update({ invoice_id: invoice.id });\n  }\n  if (subscription) {\n    await subscription.update({ latest_invoice_id: invoice.id });\n  }\n\n  return { invoice, items };\n}\n\nexport async function ensureInvoicesForSubscriptions({\n  checkoutSession,\n  customer,\n  subscriptions,\n  invoiceProps,\n}: Omit<Args, 'subscription'> & { subscriptions: Subscription[]; invoiceProps?: Partial<TInvoice> }): Promise<{\n  invoices: Invoice[];\n}> {\n  if (!subscriptions?.length) {\n    logger.warn('No subscriptions provided for invoice creation');\n    return { invoices: [] };\n  }\n\n  const lineItems = await Price.expand(checkoutSession.line_items, { product: true });\n\n  const primarySubscription = (subscriptions.find((x) => x.metadata.is_primary_subscription) ||\n    subscriptions[0]) as Subscription;\n  const invoices = await Promise.all(\n    subscriptions.map(async (subscription) => {\n      const subItems = await getSubscriptionLineItems(subscription, lineItems, primarySubscription);\n      const { invoice } = await ensureInvoiceForCheckout({\n        checkoutSession,\n        customer,\n        subscription,\n        subscriptions,\n        lineItems: subItems,\n        props: invoiceProps,\n      });\n      return invoice;\n    })\n  );\n\n  const createdInvoices = invoices.filter(Boolean);\n\n  logger.info(`Created ${createdInvoices.length} invoices for subscriptions`, {\n    checkoutSessionId: checkoutSession.id,\n    invoiceIds: createdInvoices.map((inv) => inv?.id),\n  });\n\n  return { invoices: createdInvoices as Invoice[] };\n}\n\nexport async function ensureInvoiceForCollect(invoiceId: string) {\n  const invoice = await Invoice.findByPk(invoiceId);\n  if (!invoice) {\n    throw new Error(`Invoice ${invoiceId} not found`);\n  }\n  if (invoice.status === 'paid') {\n    throw new Error(`Invoice ${invoiceId} already paid`);\n  }\n  if (invoice.status === 'void') {\n    throw new Error(`Invoice ${invoiceId} already void`);\n  }\n  if (invoice.status === 'draft') {\n    throw new Error(`Invoice ${invoiceId} is draft`);\n  }\n\n  if (!invoice.payment_intent_id) {\n    await invoiceQueue.pushAndWait({\n      id: invoice.id,\n      job: { invoiceId: invoice.id, retryOnError: false, justCreate: true },\n    });\n    await invoice.reload();\n  }\n\n  const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n  if (!paymentIntent) {\n    throw new Error(`Payment intent not found for invoice ${invoiceId}`);\n  }\n  if (paymentIntent.status === 'canceled') {\n    throw new Error(`Payment intent already canceled for invoice ${invoiceId}`);\n  }\n  if (paymentIntent.status === 'succeeded') {\n    await invoice.update({ status: 'paid' });\n    throw new Error(`Payment intent already succeeded for invoice ${invoiceId}`);\n  }\n\n  await paymentIntent.update({ status: 'requires_capture' });\n\n  const paymentCurrency = await PaymentCurrency.findByPk(paymentIntent.currency_id);\n  const paymentMethod = await PaymentMethod.findByPk(paymentIntent.payment_method_id);\n\n  return {\n    invoice,\n    paymentIntent,\n    paymentCurrency: paymentCurrency as PaymentCurrency,\n    paymentMethod: paymentMethod as PaymentMethod,\n  };\n}\n\nexport async function ensureSubscriptionRecharge(subscriptionId: string) {\n  const subscription = await Subscription.findByPk(subscriptionId);\n  if (!subscription) {\n    throw new Error(`Subscription ${subscriptionId} not found`);\n  }\n  const paymentCurrency = await PaymentCurrency.findByPk(subscription.currency_id);\n  if (!paymentCurrency) {\n    throw new Error(`Currency ${subscription.currency_id} not found`);\n  }\n  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  if (!paymentMethod) {\n    throw new Error(`Payment method ${paymentCurrency.payment_method_id} not found`);\n  }\n  // @ts-ignore\n  const receiverAddress = getSubscriptionPaymentAddress(subscription, paymentMethod.type);\n  if (!receiverAddress) {\n    throw new Error(`Receiver address not found for subscription ${subscriptionId}`);\n  }\n\n  const customer = await Customer.findByPk(subscription.customer_id);\n  if (!customer) {\n    throw new Error(`Customer ${subscription.customer_id} not found`);\n  }\n  return {\n    paymentCurrency: paymentCurrency as PaymentCurrency,\n    paymentMethod: paymentMethod as PaymentMethod,\n    receiverAddress,\n    subscription,\n    customer,\n  };\n}\n\nexport async function ensureAccountRecharge(customerId: string, currencyId: string, rechargeAddress?: string) {\n  const customer = await Customer.findByPkOrDid(customerId);\n  if (!customer) {\n    throw new Error(`Customer ${customerId} not found`);\n  }\n  const paymentCurrency = await PaymentCurrency.findByPk(currencyId);\n  if (!paymentCurrency) {\n    throw new Error(`Currency ${currencyId} not found`);\n  }\n  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  if (!paymentMethod) {\n    throw new Error(`Payment method ${paymentCurrency.payment_method_id} not found`);\n  }\n\n  const receiverAddress = rechargeAddress || customer.did;\n\n  return {\n    paymentCurrency: paymentCurrency as PaymentCurrency,\n    paymentMethod: paymentMethod as PaymentMethod,\n    customer,\n    receiverAddress,\n  };\n}\nexport function getAuthPrincipalClaim(method: PaymentMethod, action: string) {\n  let chainInfo = { type: 'none', id: 'none', host: 'none' };\n  if (method.type === 'arcblock') {\n    chainInfo = {\n      type: 'arcblock',\n      id: method.settings?.arcblock?.chain_id as string,\n      host: method.settings?.arcblock?.api_host as string,\n    };\n  }\n  if (method.type === 'ethereum') {\n    chainInfo = {\n      type: 'ethereum',\n      // @ts-ignore\n      id: method.settings?.ethereum?.chain_id as number,\n      host: method.settings?.ethereum?.api_host as string,\n    };\n  }\n  if (method.type === 'base') {\n    chainInfo = {\n      type: 'ethereum',\n      // @ts-ignore\n      id: method.settings?.base?.chain_id as number,\n      host: method.settings?.base?.api_host as string,\n    };\n  }\n\n  return {\n    description: `Select account to ${action}`,\n    chainInfo,\n  };\n}\n\nexport async function getDelegationTxClaim({\n  userDid,\n  userPk,\n  nonce,\n  mode,\n  data,\n  items,\n  paymentCurrency,\n  paymentMethod,\n  trialing = false,\n  billingThreshold = 0,\n  requiredStake = true,\n}: {\n  userDid: string;\n  userPk: string;\n  nonce: string;\n  mode: string;\n  data: any;\n  items: TLineItemExpanded[];\n  paymentCurrency: PaymentCurrency;\n  paymentMethod: PaymentMethod;\n  trialing: boolean;\n  billingThreshold?: number;\n  requiredStake?: boolean;\n  requiredAmount?: string;\n}) {\n  const amount = await getFastCheckoutAmount({ items, mode, currencyId: paymentCurrency.id });\n  const address = toDelegateAddress(userDid, wallet.address);\n  const tokenLimits = await getTokenLimitsForDelegation(items, paymentMethod, paymentCurrency, address, amount);\n  let tokenRequirements = await getTokenRequirements({\n    items,\n    mode,\n    trialing,\n    billingThreshold,\n    paymentMethod,\n    paymentCurrency,\n    requiredStake,\n  });\n\n  if (mode === 'delegation') {\n    tokenRequirements = [];\n  }\n  if (paymentMethod.type === 'arcblock') {\n    return {\n      type: 'DelegateTx',\n      description: 'Sign the delegation to continue',\n      wallet: fromPublicKey(userPk, toTypeInfo(userDid)),\n      data: {\n        itx: {\n          address,\n          to: wallet.address,\n          ops: [{ typeUrl: OCAP_PAYMENT_TX_TYPE, limit: { tokens: tokenLimits, assets: [] } }],\n          data,\n        },\n      },\n      nonce,\n      requirement: {\n        tokens: tokenRequirements,\n      },\n      meta: {\n        purpose: 'delegation',\n        address,\n      },\n      chainInfo: {\n        host: paymentMethod.settings?.arcblock?.api_host as string,\n        id: paymentMethod.settings?.arcblock?.chain_id as string,\n      },\n    };\n  }\n\n  if (EVM_CHAIN_TYPES.includes(paymentMethod.type) && paymentCurrency.contract) {\n    const requirement = tokenRequirements.find((x) => x.address === paymentCurrency.contract);\n    const limit = tokenLimits.find((x) => x.address === paymentCurrency.contract);\n    // logger.info('getDelegationTxClaim base', {\n    //   address: ethWallet.address,\n    //   amount: mode === 'setup' ? requirement!.value : limit!.totalAllowance,\n    //   contract: paymentCurrency.contract,\n    //   mode,\n    //   requirement,\n    //   limit,\n    // });\n    return {\n      type: 'eth:transaction',\n      description: 'Sign the approval to continue',\n      data: toBase58(\n        Buffer.from(\n          JSON.stringify({\n            // @ts-ignore\n            network: paymentMethod.settings?.[paymentMethod.type]?.chain_id,\n            tx: await encodeApproveItx(\n              paymentMethod.getEvmClient(),\n              ethWallet.address,\n              mode === 'setup' ? requirement!.value : limit!.totalAllowance,\n              paymentCurrency.contract\n            ),\n          }),\n          'utf-8'\n        )\n      ),\n      nonce,\n      meta: {\n        purpose: 'delegation',\n        address,\n      },\n    };\n  }\n\n  throw new Error(`getDelegationTxClaim: Payment method ${paymentMethod.type} not supported`);\n}\n\nexport function getStakeAmount(\n  subscription: Subscription,\n  paymentCurrency: PaymentCurrency,\n  items: TLineItemExpanded[]\n) {\n  const billingThreshold = Number(subscription.billing_thresholds?.amount_gte || 0);\n  const minStakeAmount = Number(subscription.billing_thresholds?.stake_gte || 0);\n  const threshold = fromTokenToUnit(Math.max(billingThreshold, minStakeAmount), paymentCurrency.decimal);\n  const staking = getSubscriptionStakeSetup(items, paymentCurrency.id, threshold.toString());\n  const amount = staking.licensed.add(staking.metered).toString();\n  return amount;\n}\n\nexport async function getStakeTxClaim({\n  userDid,\n  userPk,\n  subscription,\n  items,\n  paymentCurrency,\n  paymentMethod,\n  subscriptions,\n}: {\n  userDid: string;\n  userPk: string;\n  subscription: Subscription;\n  items: TLineItemExpanded[];\n  paymentCurrency: PaymentCurrency;\n  paymentMethod: PaymentMethod;\n  subscriptions?: Subscription[];\n}) {\n  let billingThreshold = Number(subscription.billing_thresholds?.amount_gte || 0);\n  let minStakeAmount = Number(subscription.billing_thresholds?.stake_gte || 0);\n\n  const hasGrouping = subscriptions && subscriptions.length > 1;\n  if (hasGrouping) {\n    const primarySubscription = subscriptions[0] as Subscription;\n    // use the settings of the primary subscription, not the scattered staking\n    billingThreshold = Number(primarySubscription.billing_thresholds?.amount_gte || 0);\n    minStakeAmount = Number(primarySubscription.billing_thresholds?.stake_gte || 0);\n\n    logger.info('Using primary subscription for staking', {\n      primarySubscriptionId: primarySubscription.id,\n      billingThreshold,\n      minStakeAmount,\n      allSubscriptionIds: subscriptions.map((s) => s.id),\n    });\n  }\n\n  const threshold = fromTokenToUnit(Math.max(billingThreshold, minStakeAmount), paymentCurrency.decimal);\n  const staking = getSubscriptionStakeSetup(items, paymentCurrency.id, threshold.toString());\n  const amount = staking.licensed.add(staking.metered).toString();\n\n  logger.info('getStakeTxClaim', {\n    subscriptionId: subscription.id,\n    allSubscriptions: subscriptions?.map((s) => s.id) || [],\n    billingThreshold,\n    minStakeAmount,\n    threshold: threshold.toString(),\n    staking,\n    amount: amount.toString(),\n  });\n\n  if (paymentMethod.type === 'arcblock') {\n    // create staking data\n    const client = paymentMethod.getOcapClient();\n\n    const stakeId = hasGrouping ? `stake-group-${subscription.id}` : subscription.id;\n\n    const address = await getCustomerStakeAddress(userDid, stakeId);\n    const { state } = await client.getStakeState({ address });\n    const data = {\n      type: 'json',\n      value: Object.assign(\n        {\n          appId: wallet.address,\n          subscriptionId: subscription.id,\n          ...(hasGrouping\n            ? {\n                subscriptionGroup: true,\n                subscriptionIds: subscriptions.map((s) => s.id),\n              }\n            : {}),\n        },\n        JSON.parse(state?.data?.value || '{}')\n      ),\n    };\n\n    const setup = getSubscriptionCreateSetup(items, paymentCurrency.id, 0, 0);\n\n    return {\n      type: 'StakeTx',\n      description: hasGrouping\n        ? `Stake for ${subscriptions.length} subscriptions`\n        : `Stake for subscription ${subscription.id}`,\n      partialTx: {\n        from: userDid,\n        pk: userPk,\n        itx: {\n          address,\n          receiver: wallet.address,\n          slashers: [wallet.address],\n          revokeWaitingPeriod: setup.cycle.duration / 1000, // wait for at least 1 billing cycle\n          message: hasGrouping\n            ? `Stake for ${subscriptions.length} subscriptions`\n            : `Stake for subscription ${subscription.id}`,\n          nonce: stakeId,\n          inputs: [],\n          data,\n        },\n        signatures: [],\n      },\n      requirement: {\n        tokens: [{ address: paymentCurrency.contract as string, value: amount }],\n      },\n      nonce: `stake-${stakeId}`,\n      meta: {\n        purpose: 'staking',\n        address,\n        ...(hasGrouping\n          ? {\n              subscriptionGroup: true,\n              primarySubscriptionId: subscription.id,\n              allSubscriptionIds: subscriptions.map((s) => s.id),\n            }\n          : {}),\n      },\n      chainInfo: {\n        host: paymentMethod.settings?.arcblock?.api_host as string,\n        id: paymentMethod.settings?.arcblock?.chain_id as string,\n      },\n    };\n  }\n\n  throw new Error(`getStakeTxClaim: Payment method ${paymentMethod.type} not supported`);\n}\n\nexport async function getOverdraftProtectionStakeTxClaim({\n  userDid,\n  userPk,\n  subscription,\n  paymentCurrency,\n  paymentMethod,\n  stakeAmount,\n  items,\n}: {\n  userDid: string;\n  userPk: string;\n  subscription: Subscription;\n  paymentCurrency: PaymentCurrency;\n  paymentMethod: PaymentMethod;\n  stakeAmount: string;\n  items: TLineItemExpanded[];\n}) {\n  // create staking amount\n  logger.info('getStakeTxClaim', {\n    subscriptionId: subscription.id,\n    paymentCurrencyId: paymentCurrency.id,\n    paymentMethodId: paymentMethod.id,\n    stakeAmount,\n  });\n\n  if (paymentMethod.type === 'arcblock') {\n    // create staking data\n    const client = paymentMethod.getOcapClient();\n    const nonce = `overdraft-protection-${subscription.id}`;\n    const address = await getCustomerStakeAddress(userDid, nonce);\n    const { state } = await client.getStakeState({ address });\n    const data = {\n      type: 'json',\n      value: Object.assign(\n        {\n          appId: wallet.address,\n          subscriptionId: subscription.id,\n        },\n        JSON.parse(state?.data?.value || '{}')\n      ),\n    };\n\n    const setup = getSubscriptionCreateSetup(items, paymentCurrency.id, 0, 0);\n\n    return {\n      type: 'StakeTx',\n      description: `Stake to complete subscription ${subscription.id} SubGuard`,\n      partialTx: {\n        from: userDid,\n        pk: userPk,\n        itx: {\n          address,\n          receiver: wallet.address,\n          slashers: [wallet.address],\n          revokeWaitingPeriod: setup.cycle.duration / 1000, // wait for at least 1 billing cycle\n          message: `Stake for subscription ${subscription.id} SubGuard`,\n          nonce,\n          inputs: [],\n          data,\n        },\n        signatures: [],\n      },\n      requirement: {\n        tokens: [{ address: paymentCurrency.contract as string, value: stakeAmount }],\n      },\n      nonce: `stake-${subscription.id}`,\n      meta: {\n        purpose: 'staking',\n        address,\n      },\n      chainInfo: {\n        host: paymentMethod.settings?.arcblock?.api_host as string,\n        id: paymentMethod.settings?.arcblock?.chain_id as string,\n      },\n    };\n  }\n\n  throw new Error(`getStakeTxClaim: Payment method ${paymentMethod.type} not supported`);\n}\n\nexport type TokenRequirementArgs = {\n  items: TLineItemExpanded[];\n  mode: string;\n  paymentMethod: PaymentMethod;\n  paymentCurrency: PaymentCurrency;\n  trialing: boolean;\n  billingThreshold: number;\n  requiredStake?: boolean;\n};\n\nexport async function getTokenRequirements({\n  items,\n  mode,\n  paymentMethod,\n  paymentCurrency,\n  trialing = false,\n  billingThreshold = 0,\n  requiredStake,\n}: TokenRequirementArgs) {\n  const tokenRequirements: { address: string; value: string }[] = [];\n  let amount = await getFastCheckoutAmount({ items, mode, currencyId: paymentCurrency.id, trialing: !!trialing });\n\n  const addStakeRequired =\n    requiredStake && ((paymentMethod.type === 'arcblock' && mode !== 'delegation') || mode === 'setup');\n\n  if (!addStakeRequired && amount === '0') {\n    return tokenRequirements;\n  }\n\n  // If the app has not staked, we need to add the gas fee to the amount\n  if ((await hasStakedForGas(paymentMethod)) === false) {\n    const maxGas = await estimateMaxGasForTx(paymentMethod);\n    // pay with the base currency? just add gas to it\n    if (paymentCurrency.is_base_currency) {\n      amount = new BN(amount).add(new BN(maxGas)).toString();\n      tokenRequirements.push({ address: paymentCurrency.contract as string, value: amount });\n    } else {\n      tokenRequirements.push({ address: paymentCurrency.contract as string, value: amount });\n      const baseCurrency = await PaymentCurrency.findOne({\n        where: { active: true, is_base_currency: true, payment_method_id: paymentMethod.id },\n      });\n      if (baseCurrency) {\n        tokenRequirements.push({ address: baseCurrency.contract as string, value: maxGas });\n      } else {\n        throw new Error('Base currency not found since app has not staked for gas');\n      }\n    }\n  } else {\n    tokenRequirements.push({ address: paymentCurrency.contract as string, value: amount });\n  }\n\n  // Add stake requirement to token requirement\n  if (addStakeRequired) {\n    const staking = getSubscriptionStakeSetup(\n      items,\n      paymentCurrency.id,\n      fromTokenToUnit(billingThreshold, paymentCurrency.decimal).toString()\n    );\n    const exist = tokenRequirements.find((x) => x.address === paymentCurrency.contract);\n    if (exist) {\n      exist.value = new BN(exist.value).add(staking.licensed).add(staking.metered).toString();\n    } else {\n      tokenRequirements.push({\n        address: paymentCurrency.contract as string,\n        value: staking.licensed.add(staking.metered).toString(),\n      });\n    }\n  }\n\n  return tokenRequirements;\n}\n\nexport async function ensureSubscription(subscriptionId: string): Promise<Result & { customer: Customer }> {\n  const subscription = await Subscription.findByPk(subscriptionId);\n  if (!subscription) {\n    throw new Error(`Subscription not found: ${subscriptionId}`);\n  }\n\n  if (subscription.isActive() === false) {\n    throw new Error(`Subscription ${subscriptionId} is not active`);\n  }\n\n  const paymentCurrencyId = subscription.currency_id;\n  const paymentMethodId = subscription.default_payment_method_id;\n\n  const [paymentMethod, paymentCurrency, invoice] = await Promise.all([\n    PaymentMethod.findByPk(paymentMethodId),\n    PaymentCurrency.findByPk(paymentCurrencyId),\n    Invoice.findByPk(subscription.latest_invoice_id),\n  ]);\n  if (!paymentMethod) {\n    throw new Error(`Payment method not found for subscription ${subscriptionId}`);\n  }\n  if (!paymentCurrency) {\n    throw new Error(`Payment currency not found for subscription ${subscriptionId}`);\n  }\n\n  if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type) === false) {\n    throw new Error(`Payment method ${paymentMethod.type} should not be here`);\n  }\n\n  // @ts-ignore\n  subscription.items = await expandSubscriptionItems(subscription.id);\n\n  return {\n    // @ts-ignore\n    checkoutSession: null,\n    subscription,\n    paymentMethod,\n    paymentCurrency,\n    // @ts-ignore\n    invoice,\n    // @ts-ignore\n    customer: await Customer.findByPk(subscription.customer_id),\n  };\n}\n\nexport async function ensureChangePaymentContext(subscriptionId: string) {\n  const subscription = await Subscription.findByPk(subscriptionId);\n  if (!subscription) {\n    throw new Error(`Subscription not found: ${subscriptionId}`);\n  }\n\n  const context = subscription.metadata?.changePayment || {};\n  if (!context || !context.setup_intent_id) {\n    throw new Error(`Change payment context not found: ${subscriptionId}`);\n  }\n\n  const setupIntent = await SetupIntent.findByPk(context.setup_intent_id);\n  if (!setupIntent) {\n    throw new Error(`SetupIntent not found for subscription payment change ${subscriptionId}`);\n  }\n  if (setupIntent.status === 'succeeded') {\n    throw new Error(`SetupIntent completed for subscription payment change ${subscriptionId}`);\n  }\n\n  const paymentCurrencyId = setupIntent.currency_id;\n  const paymentMethodId = setupIntent.payment_method_id;\n\n  const [paymentMethod, paymentCurrency] = await Promise.all([\n    PaymentMethod.findByPk(paymentMethodId),\n    PaymentCurrency.findByPk(paymentCurrencyId),\n  ]);\n  if (!paymentMethod) {\n    throw new Error(`Payment method not found for SetupIntent ${setupIntent.id}`);\n  }\n  if (!paymentCurrency) {\n    throw new Error(`Payment currency not found for SetupIntent ${setupIntent.id}`);\n  }\n\n  if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type) === false) {\n    throw new Error(`Payment method ${paymentMethod.type} should not be here`);\n  }\n\n  // @ts-ignore\n  subscription.items = await expandSubscriptionItems(subscription.id);\n\n  return {\n    subscription,\n    setupIntent,\n    paymentMethod,\n    paymentCurrency,\n    customer: await Customer.findByPk(subscription.customer_id),\n  };\n}\n\nexport async function ensurePayerChangeContext(subscriptionId: string) {\n  const subscription = await Subscription.findByPk(subscriptionId);\n  if (!subscription) {\n    throw new Error(`Subscription not found: ${subscriptionId}`);\n  }\n  if (!['active', 'trialing', 'past_due'].includes(subscription.status)) {\n    throw new Error(`Subscription ${subscriptionId} is not in a valid status to change payer`);\n  }\n  const paymentMethod = await PaymentMethod.findByPk(subscription.default_payment_method_id);\n  if (!paymentMethod) {\n    throw new Error(`Payment method not found for subscription ${subscriptionId}`);\n  }\n  const payerAddress = getSubscriptionPaymentAddress(subscription, paymentMethod?.type);\n  const paymentCurrency = await PaymentCurrency.findByPk(subscription.currency_id);\n  if (!paymentCurrency) {\n    throw new Error(`PaymentCurrency ${subscription.currency_id} not found for subscription ${subscriptionId}`);\n  }\n\n  // @ts-ignore\n  subscription.items = await expandSubscriptionItems(subscription.id);\n\n  return {\n    subscription,\n    paymentCurrency,\n    paymentMethod,\n    customer: await Customer.findByPk(subscription.customer_id),\n    payerAddress,\n  };\n}\n\nexport async function ensureReStakeContext(subscriptionId: string) {\n  const subscription = await Subscription.findByPk(subscriptionId);\n  if (!subscription) {\n    throw new Error(`Subscription not found: ${subscriptionId}`);\n  }\n  if (subscription.status === 'canceled') {\n    throw new Error(`Subscription ${subscriptionId} not recoverable from cancellation`);\n  }\n  if (!subscription.cancel_at_period_end) {\n    throw new Error(`Subscription ${subscriptionId} not recoverable from cancellation config`);\n  }\n  if (subscription.cancelation_details?.reason === 'payment_failed') {\n    throw new Error(`Subscription ${subscriptionId} not recoverable from payment failed`);\n  }\n\n  const paymentCurrency = await PaymentCurrency.findByPk(subscription.currency_id);\n  if (!paymentCurrency) {\n    throw new Error(`PaymentCurrency ${subscription.currency_id} not found for subscription ${subscriptionId}`);\n  }\n  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  if (!paymentMethod) {\n    throw new Error(`Payment method not found for subscription ${subscriptionId}`);\n  }\n\n  if (paymentMethod.type !== 'arcblock') {\n    throw new Error(`Payment method ${paymentMethod.type} not supported for subscription ${subscriptionId}`);\n  }\n\n  const customer = await Customer.findByPk(subscription.customer_id);\n  if (!customer) {\n    throw new Error(`Customer not found for subscription ${subscriptionId}`);\n  }\n\n  // @ts-ignore\n  subscription.items = await expandSubscriptionItems(subscription.id);\n\n  return {\n    subscription,\n    paymentCurrency,\n    paymentMethod,\n    customer,\n    payerAddress: getSubscriptionPaymentAddress(subscription, paymentMethod?.type),\n  };\n}\nexport async function ensureSubscriptionForCollectBatch(\n  subscriptionId?: string,\n  currencyId?: string,\n  customerId?: string\n) {\n  if (!currencyId) {\n    throw new Error('Currency ID must be provided');\n  }\n  if (!subscriptionId && !customerId) {\n    throw new Error('Either subscriptionId or customerId must be provided');\n  }\n\n  const paymentCurrency = await PaymentCurrency.findByPk(currencyId);\n  if (!paymentCurrency) {\n    throw new Error(`PaymentCurrency ${currencyId} not found when prepare batch collect`);\n  }\n\n  let subscription;\n  let searchCustomerId = customerId;\n\n  if (subscriptionId) {\n    subscription = await Subscription.findByPk(subscriptionId);\n    if (!subscription) {\n      throw new Error(`Subscription ${subscriptionId} not found when prepare batch collect`);\n    }\n    searchCustomerId = subscription.customer_id;\n  } else if (customerId) {\n    const customer = await Customer.findByPkOrDid(customerId);\n    if (!customer) {\n      throw new Error(`Customer ${customerId} not found when prepare batch collect`);\n    }\n    searchCustomerId = customer.id;\n  }\n\n  const [summary, detail] = await Invoice.getUncollectibleAmount({\n    ...(subscriptionId ? { subscriptionId } : {}),\n    customerId: searchCustomerId,\n    currencyId,\n  });\n  if (isEmpty(summary) || !summary[currencyId] || summary[currencyId] === '0') {\n    throw new Error('No uncollectible invoice found to batch collect');\n  }\n\n  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  if (!paymentMethod) {\n    throw new Error(`Payment method not found for currency ${currencyId}`);\n  }\n\n  return {\n    subscription,\n    paymentCurrency: paymentCurrency as PaymentCurrency,\n    paymentMethod: paymentMethod as PaymentMethod,\n    amount: summary[currencyId],\n    invoices: detail[currencyId],\n  };\n}\n\nexport async function ensureSubscriptionForOverdraftProtection(subscriptionId: string, amount: string) {\n  const subscription = await Subscription.findByPk(subscriptionId);\n  if (!subscription) {\n    throw new Error(`Subscription ${subscriptionId} not found when prepare SubGuard`);\n  }\n  // @ts-ignore\n  subscription.items = await expandSubscriptionItems(subscription.id);\n  const paymentCurrency = await PaymentCurrency.findByPk(subscription.currency_id);\n  if (!paymentCurrency) {\n    throw new Error(`PaymentCurrency ${subscription.currency_id} not found when prepare SubGuard`);\n  }\n\n  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n\n  if (!paymentMethod) {\n    throw new Error(`Payment method not found for subscription ${subscriptionId}`);\n  }\n  if (paymentMethod.type !== 'arcblock') {\n    throw new Error(`Payment method ${paymentMethod.type} not supported for SubGuard`);\n  }\n\n  const customer = await Customer.findByPk(subscription.customer_id);\n  if (!customer) {\n    throw new Error(`Customer not found for subscription ${subscriptionId}`);\n  }\n\n  return {\n    subscription,\n    paymentCurrency: paymentCurrency as PaymentCurrency,\n    paymentMethod: paymentMethod as PaymentMethod,\n    customer,\n    stakeAmount: fromTokenToUnit(amount, paymentCurrency.decimal).toString(),\n  };\n}\n\nasync function executeSingleTransaction(\n  client: any,\n  claim: any,\n  type: 'Delegate' | 'Stake',\n  userDid: string,\n  userPk: string,\n  gasPayerHeaders: Record<string, string>\n): Promise<string> {\n  if (!claim) return '';\n\n  const tx: Partial<Transaction> = client.decodeTx(claim.finalTx || claim.origin);\n  if (claim.sig) {\n    tx.signature = claim.sig;\n  }\n\n  const { buffer } = await client[`encode${type}Tx`]({ tx });\n  return client[`send${type}Tx`](\n    { tx, wallet: fromPublicKey(userPk, toTypeInfo(userDid)) },\n    await getGasPayerExtra(buffer, gasPayerHeaders)\n  );\n}\n\nexport async function executeOcapTransactions(\n  userDid: string,\n  userPk: string,\n  claims: any[],\n  paymentMethod: PaymentMethod,\n  requestSource: Request | Request[] | any[],\n  subscriptionId?: string,\n  paymentCurrencyContract?: string,\n  nonce?: string\n) {\n  const client = paymentMethod.getOcapClient();\n  logger.info('start executeOcapTransactions', { userDid, claims });\n\n  const delegation = claims.find((x) => x.type === 'signature' && x.meta?.purpose === 'delegation');\n  const staking = claims.find((x) => x.type === 'prepareTx' && x.meta?.purpose === 'staking');\n\n  const stakingAmount =\n    staking?.requirement?.tokens?.find((x: any) => x?.address === paymentCurrencyContract)?.value || '0';\n\n  try {\n    const getHeaders = (index: number): Record<string, string> => {\n      if (Array.isArray(requestSource)) {\n        if (requestSource.length === 0) {\n          return {};\n        }\n        const headerIndex = index < requestSource.length ? index : 0;\n        const req = requestSource[headerIndex];\n        return req ? client.pickGasPayerHeaders(req) : {};\n      }\n\n      if (requestSource && typeof requestSource === 'object') {\n        return client.pickGasPayerHeaders(requestSource);\n      }\n\n      return {};\n    };\n\n    const transactions = [\n      { claim: delegation, type: 'Delegate' },\n      { claim: staking, type: 'Stake' },\n    ];\n\n    const txHashes = [];\n    for (let i = 0; i < transactions.length; i++) {\n      const { claim, type } = transactions[i]!;\n      // eslint-disable-next-line no-await-in-loop\n      const hash = await executeSingleTransaction(\n        client,\n        claim,\n        type as 'Delegate' | 'Stake',\n        userDid,\n        userPk,\n        getHeaders(i)\n      );\n      txHashes.push(hash);\n    }\n\n    const [delegationTxHash, stakingTxHash] = txHashes;\n\n    return {\n      tx_hash: delegationTxHash,\n      payer: userDid,\n      type: 'delegate',\n      staking: {\n        tx_hash: stakingTxHash,\n        address: await getCustomerStakeAddress(userDid, nonce || subscriptionId || ''),\n      },\n      stakingAmount,\n    };\n  } catch (err) {\n    logger.error('executeOcapTransactions failed', { error: err, userDid });\n    throw err;\n  }\n}\n\nexport async function updateStripeSubscriptionAfterChangePayment(setupIntent: SetupIntent, subscription: Subscription) {\n  const { from_method: fromMethodId, to_method: toMethodId } = setupIntent.metadata || {};\n  const fromMethod = await PaymentMethod.findByPk(fromMethodId);\n  if (fromMethod?.type === 'stripe') {\n    // pause Stripe\n    const client = fromMethod?.getStripeClient();\n    const stripeSubscriptionId = subscription.payment_details?.stripe?.subscription_id as string;\n    if (client && stripeSubscriptionId) {\n      const stripeSubscription = await client.subscriptions.retrieve(stripeSubscriptionId);\n      if (stripeSubscription) {\n        const result = await client.subscriptions.update(stripeSubscriptionId, {\n          pause_collection: {\n            behavior: 'void',\n          },\n        });\n        logger.info('stripe subscription paused on payment change', {\n          subscription: subscription.id,\n          stripeSubscription: stripeSubscriptionId,\n          result,\n        });\n      }\n    }\n  } else {\n    const toMethod = await PaymentMethod.findByPk(toMethodId);\n    if (toMethod?.type === 'stripe') {\n      // resume stripe\n      const client = toMethod?.getStripeClient();\n      const stripeSubscriptionId = subscription.payment_details?.stripe?.subscription_id as string;\n      if (client && stripeSubscriptionId) {\n        const stripeSubscription = await client.subscriptions.retrieve(stripeSubscriptionId);\n        if (stripeSubscription.status === 'paused') {\n          await client.subscriptions.resume(stripeSubscriptionId, {\n            proration_behavior: 'none',\n          });\n          logger.info('stripe subscription resumed on payment change', {\n            subscription: subscription.id,\n            stripeSubscription: stripeSubscriptionId,\n          });\n        }\n      }\n    }\n  }\n}\n\nexport async function ensureAutoRechargeAuthorization(\n  autoRechargeConfigId: string\n): Promise<{ autoRechargeConfig: AutoRechargeConfig; paymentMethod: PaymentMethod; paymentCurrency: PaymentCurrency }> {\n  const autoRechargeConfig = await AutoRechargeConfig.findByPk(autoRechargeConfigId);\n  if (!autoRechargeConfig) {\n    throw new Error(`Auto recharge config ${autoRechargeConfigId} not found`);\n  }\n\n  const price = await Price.findByPk(autoRechargeConfig.price_id);\n  if (!price) {\n    throw new Error(`Price ${autoRechargeConfig.price_id} not found`);\n  }\n  const paymentCurrency = await PaymentCurrency.findByPk(autoRechargeConfig.recharge_currency_id);\n  if (!paymentCurrency) {\n    throw new Error(`Payment currency ${autoRechargeConfig.recharge_currency_id} not found`);\n  }\n\n  if (paymentCurrency.payment_method_id !== autoRechargeConfig.payment_method_id) {\n    await autoRechargeConfig.update({\n      payment_method_id: paymentCurrency.payment_method_id,\n    });\n  }\n\n  const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  if (!paymentMethod) {\n    throw new Error(`Payment method ${paymentCurrency.payment_method_id} not found`);\n  }\n\n  return {\n    autoRechargeConfig,\n    paymentMethod,\n    paymentCurrency,\n  };\n}\n\nexport async function returnStakeForCanceledSubscription(subscriptionId: string) {\n  if (!subscriptionId) {\n    return;\n  }\n  try {\n    const subscription = await Subscription.findByPk(subscriptionId);\n    if (!subscription) {\n      throw new Error(`Subscription ${subscriptionId} not found`);\n    }\n    if (subscription.status !== 'canceled') {\n      throw new Error(`Subscription ${subscriptionId} is not canceled`);\n    }\n\n    if (!subscription.payment_details?.arcblock?.staking?.tx_hash) {\n      throw new Error(`No staking transaction found in subscription ${subscriptionId}`);\n    }\n    returnStakeQueue.push({ id: `return-stake-${subscription.id}`, job: { subscriptionId: subscription.id } });\n    logger.info('Subscription return stake job scheduled', {\n      jobId: `return-stake-${subscription.id}`,\n      subscription: subscription.id,\n    });\n  } catch (err) {\n    logger.error('returnStakeForCanceledSubscription failed', { error: err, subscriptionId });\n  }\n}\n","numLines":1640,"startLine":1,"totalLines":1640}}}
{"parentUuid":"81091065-95fe-48c7-81ae-1b27b160c3a5","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TKBDwY7uRtV4sU9BxnbjRJ","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我检查 invoice item 的 metadata 字段定义和查询接口的具体实现："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4497,"cache_creation_input_tokens":22837,"cache_read_input_tokens":53724,"cache_creation":{"ephemeral_5m_input_tokens":22837,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrHYvPWfHMXs22wFHLVY","type":"assistant","uuid":"4f546389-d52d-40e5-a84f-82a7cc22cae8","timestamp":"2026-01-06T14:31:28.904Z"}
{"parentUuid":"4f546389-d52d-40e5-a84f-82a7cc22cae8","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TKBDwY7uRtV4sU9BxnbjRJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KuvALxDtY4wugs3inovFib","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice-item.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4497,"cache_creation_input_tokens":22837,"cache_read_input_tokens":53724,"cache_creation":{"ephemeral_5m_input_tokens":22837,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrHYvPWfHMXs22wFHLVY","type":"assistant","uuid":"0298d624-17cc-4a6e-9ff5-292d17557a0c","timestamp":"2026-01-06T14:31:29.782Z"}
{"parentUuid":"0298d624-17cc-4a6e-9ff5-292d17557a0c","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01TKBDwY7uRtV4sU9BxnbjRJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NQ8UTRniYgQRJnWiA1uT8D","name":"Grep","input":{"pattern":"expandLineItems","output_mode":"content","path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs","-B":3,"-A":20}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4497,"cache_creation_input_tokens":22837,"cache_read_input_tokens":53724,"cache_creation":{"ephemeral_5m_input_tokens":22837,"ephemeral_1h_input_tokens":0},"output_tokens":256,"service_tier":"standard"}},"requestId":"req_011CWrHYvPWfHMXs22wFHLVY","type":"assistant","uuid":"9219d9c8-2749-4c99-88d2-d367c700da80","timestamp":"2026-01-06T14:31:31.171Z"}
{"parentUuid":"9219d9c8-2749-4c99-88d2-d367c700da80","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KuvALxDtY4wugs3inovFib","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/indent */\n     2→/* eslint-disable @typescript-eslint/lines-between-class-members */\n     3→import { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n     4→\n     5→import { createIdGenerator } from '../../libs/util';\n     6→import type { DiscountAmount } from './types';\n     7→\n     8→export const nextInvoiceItemId = createIdGenerator('ii', 24);\n     9→\n    10→export type InvoiceLineItem = {\n    11→  id: string;\n    12→};\n    13→\n    14→// @link https://stripe.com/docs/api/invoiceitems\n    15→// eslint-disable-next-line prettier/prettier\n    16→export class InvoiceItem extends Model<InferAttributes<InvoiceItem>, InferCreationAttributes<InvoiceItem>> {\n    17→  declare id: CreationOptional<string>;\n    18→  declare livemode: boolean;\n    19→\n    20→  declare amount: string;\n    21→  declare quantity: number;\n    22→  declare description: string;\n    23→  declare period?: {\n    24→    start: number;\n    25→    end: number;\n    26→  };\n    27→\n    28→  declare currency_id: string;\n    29→  declare customer_id: string;\n    30→  declare price_id: string;\n    31→  declare invoice_id: string;\n    32→  declare subscription_id?: string;\n    33→  declare subscription_item_id?: string;\n    34→  declare test_clock_id?: string;\n    35→  declare tax_rate_id?: string;\n    36→\n    37→  declare discountable: boolean;\n    38→  declare discount_amounts: DiscountAmount[];\n    39→  declare discounts: string[];\n    40→\n    41→  declare proration: boolean;\n    42→  declare proration_details: {\n    43→    credited_items?: {\n    44→      invoice_id: string;\n    45→      invoice_line_items: string[];\n    46→    };\n    47→  };\n    48→\n    49→  declare metadata: Record<string, any>;\n    50→\n    51→  // TODO: following fields not supported\n    52→  // tax_amounts: any;\n    53→  // tax_rates: any;\n    54→  // unit_amount_excluding_tax: string;\n    55→\n    56→  declare created_at: CreationOptional<Date>;\n    57→  declare updated_at: CreationOptional<Date>;\n    58→\n    59→  public static readonly GENESIS_ATTRIBUTES = {\n    60→    id: {\n    61→      type: DataTypes.STRING(30),\n    62→      primaryKey: true,\n    63→      allowNull: false,\n    64→      defaultValue: nextInvoiceItemId,\n    65→    },\n    66→    livemode: {\n    67→      type: DataTypes.BOOLEAN,\n    68→      allowNull: false,\n    69→    },\n    70→    amount: {\n    71→      type: DataTypes.STRING(32),\n    72→      allowNull: false,\n    73→    },\n    74→    quantity: {\n    75→      type: DataTypes.INTEGER,\n    76→      allowNull: false,\n    77→    },\n    78→    description: {\n    79→      type: DataTypes.STRING(256),\n    80→      allowNull: false,\n    81→    },\n    82→    period: {\n    83→      type: DataTypes.JSON,\n    84→      allowNull: true,\n    85→    },\n    86→    customer_id: {\n    87→      type: DataTypes.STRING(18),\n    88→      allowNull: false,\n    89→    },\n    90→    currency_id: {\n    91→      type: DataTypes.STRING(15),\n    92→      allowNull: false,\n    93→    },\n    94→    price_id: {\n    95→      type: DataTypes.STRING(30),\n    96→      allowNull: false,\n    97→    },\n    98→    invoice_id: {\n    99→      type: DataTypes.STRING(30),\n   100→      allowNull: false,\n   101→    },\n   102→    subscription_id: {\n   103→      type: DataTypes.STRING(30),\n   104→      allowNull: true,\n   105→    },\n   106→    subscription_item_id: {\n   107→      type: DataTypes.STRING(30),\n   108→      allowNull: true,\n   109→    },\n   110→    tax_rate_id: {\n   111→      type: DataTypes.STRING(30),\n   112→      allowNull: true,\n   113→    },\n   114→    discountable: {\n   115→      type: DataTypes.BOOLEAN,\n   116→      allowNull: false,\n   117→    },\n   118→    // Dynamically generated?\n   119→    discount_amounts: {\n   120→      type: DataTypes.JSON,\n   121→      defaultValue: [],\n   122→    },\n   123→    discounts: {\n   124→      type: DataTypes.JSON,\n   125→      defaultValue: [],\n   126→    },\n   127→    proration: {\n   128→      type: DataTypes.BOOLEAN,\n   129→      defaultValue: false,\n   130→    },\n   131→    proration_details: {\n   132→      type: DataTypes.JSON,\n   133→      allowNull: true,\n   134→    },\n   135→    metadata: {\n   136→      type: DataTypes.JSON,\n   137→      defaultValue: {},\n   138→    },\n   139→    created_at: {\n   140→      type: DataTypes.DATE,\n   141→      defaultValue: DataTypes.NOW,\n   142→      allowNull: false,\n   143→    },\n   144→    updated_at: {\n   145→      type: DataTypes.DATE,\n   146→      defaultValue: DataTypes.NOW,\n   147→      allowNull: false,\n   148→    },\n   149→  };\n   150→\n   151→  public static initialize(sequelize: any) {\n   152→    this.init(InvoiceItem.GENESIS_ATTRIBUTES, {\n   153→      sequelize,\n   154→      modelName: 'InvoiceItem',\n   155→      tableName: 'invoice_items',\n   156→      createdAt: 'created_at',\n   157→      updatedAt: 'updated_at',\n   158→    });\n   159→  }\n   160→\n   161→  public static associate(models: any) {\n   162→    this.hasOne(models.PaymentCurrency, {\n   163→      sourceKey: 'currency_id',\n   164→      foreignKey: 'id',\n   165→      as: 'currency',\n   166→    });\n   167→    this.hasOne(models.Customer, {\n   168→      sourceKey: 'customer_id',\n   169→      foreignKey: 'id',\n   170→      as: 'customer',\n   171→    });\n   172→    this.hasOne(models.Price, {\n   173→      sourceKey: 'price_id',\n   174→      foreignKey: 'id',\n   175→      as: 'price',\n   176→    });\n   177→    this.hasOne(models.Invoice, {\n   178→      sourceKey: 'invoice_id',\n   179→      foreignKey: 'id',\n   180→      as: 'invoice',\n   181→    });\n   182→    this.hasOne(models.Subscription, {\n   183→      sourceKey: 'subscription_id',\n   184→      foreignKey: 'id',\n   185→      as: 'subscription',\n   186→    });\n   187→    this.hasOne(models.SubscriptionItem, {\n   188→      sourceKey: 'subscription_item_id',\n   189→      foreignKey: 'id',\n   190→      as: 'subscriptionItem',\n   191→    });\n   192→    this.hasOne(models.TaxRate, {\n   193→      sourceKey: 'tax_rate_id',\n   194→      foreignKey: 'id',\n   195→      as: 'tax_rate',\n   196→    });\n   197→  }\n   198→\n   199→  public static async isPriceUsed(priceId: string) {\n   200→    const count = await InvoiceItem.count({\n   201→      where: { price_id: priceId },\n   202→    });\n   203→\n   204→    return count > 0;\n   205→  }\n   206→}\n   207→\n   208→export type TInvoiceItem = InferAttributes<InvoiceItem>;\n   209→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"36643ef2-79cd-465e-bda4-9e2176f6fe2d","timestamp":"2026-01-06T14:31:31.259Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice-item.ts","content":"/* eslint-disable @typescript-eslint/indent */\n/* eslint-disable @typescript-eslint/lines-between-class-members */\nimport { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n\nimport { createIdGenerator } from '../../libs/util';\nimport type { DiscountAmount } from './types';\n\nexport const nextInvoiceItemId = createIdGenerator('ii', 24);\n\nexport type InvoiceLineItem = {\n  id: string;\n};\n\n// @link https://stripe.com/docs/api/invoiceitems\n// eslint-disable-next-line prettier/prettier\nexport class InvoiceItem extends Model<InferAttributes<InvoiceItem>, InferCreationAttributes<InvoiceItem>> {\n  declare id: CreationOptional<string>;\n  declare livemode: boolean;\n\n  declare amount: string;\n  declare quantity: number;\n  declare description: string;\n  declare period?: {\n    start: number;\n    end: number;\n  };\n\n  declare currency_id: string;\n  declare customer_id: string;\n  declare price_id: string;\n  declare invoice_id: string;\n  declare subscription_id?: string;\n  declare subscription_item_id?: string;\n  declare test_clock_id?: string;\n  declare tax_rate_id?: string;\n\n  declare discountable: boolean;\n  declare discount_amounts: DiscountAmount[];\n  declare discounts: string[];\n\n  declare proration: boolean;\n  declare proration_details: {\n    credited_items?: {\n      invoice_id: string;\n      invoice_line_items: string[];\n    };\n  };\n\n  declare metadata: Record<string, any>;\n\n  // TODO: following fields not supported\n  // tax_amounts: any;\n  // tax_rates: any;\n  // unit_amount_excluding_tax: string;\n\n  declare created_at: CreationOptional<Date>;\n  declare updated_at: CreationOptional<Date>;\n\n  public static readonly GENESIS_ATTRIBUTES = {\n    id: {\n      type: DataTypes.STRING(30),\n      primaryKey: true,\n      allowNull: false,\n      defaultValue: nextInvoiceItemId,\n    },\n    livemode: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    amount: {\n      type: DataTypes.STRING(32),\n      allowNull: false,\n    },\n    quantity: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n    },\n    description: {\n      type: DataTypes.STRING(256),\n      allowNull: false,\n    },\n    period: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    customer_id: {\n      type: DataTypes.STRING(18),\n      allowNull: false,\n    },\n    currency_id: {\n      type: DataTypes.STRING(15),\n      allowNull: false,\n    },\n    price_id: {\n      type: DataTypes.STRING(30),\n      allowNull: false,\n    },\n    invoice_id: {\n      type: DataTypes.STRING(30),\n      allowNull: false,\n    },\n    subscription_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    subscription_item_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    tax_rate_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    discountable: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    // Dynamically generated?\n    discount_amounts: {\n      type: DataTypes.JSON,\n      defaultValue: [],\n    },\n    discounts: {\n      type: DataTypes.JSON,\n      defaultValue: [],\n    },\n    proration: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: false,\n    },\n    proration_details: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    metadata: {\n      type: DataTypes.JSON,\n      defaultValue: {},\n    },\n    created_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n    updated_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n  };\n\n  public static initialize(sequelize: any) {\n    this.init(InvoiceItem.GENESIS_ATTRIBUTES, {\n      sequelize,\n      modelName: 'InvoiceItem',\n      tableName: 'invoice_items',\n      createdAt: 'created_at',\n      updatedAt: 'updated_at',\n    });\n  }\n\n  public static associate(models: any) {\n    this.hasOne(models.PaymentCurrency, {\n      sourceKey: 'currency_id',\n      foreignKey: 'id',\n      as: 'currency',\n    });\n    this.hasOne(models.Customer, {\n      sourceKey: 'customer_id',\n      foreignKey: 'id',\n      as: 'customer',\n    });\n    this.hasOne(models.Price, {\n      sourceKey: 'price_id',\n      foreignKey: 'id',\n      as: 'price',\n    });\n    this.hasOne(models.Invoice, {\n      sourceKey: 'invoice_id',\n      foreignKey: 'id',\n      as: 'invoice',\n    });\n    this.hasOne(models.Subscription, {\n      sourceKey: 'subscription_id',\n      foreignKey: 'id',\n      as: 'subscription',\n    });\n    this.hasOne(models.SubscriptionItem, {\n      sourceKey: 'subscription_item_id',\n      foreignKey: 'id',\n      as: 'subscriptionItem',\n    });\n    this.hasOne(models.TaxRate, {\n      sourceKey: 'tax_rate_id',\n      foreignKey: 'id',\n      as: 'tax_rate',\n    });\n  }\n\n  public static async isPriceUsed(priceId: string) {\n    const count = await InvoiceItem.count({\n      where: { price_id: priceId },\n    });\n\n    return count > 0;\n  }\n}\n\nexport type TInvoiceItem = InferAttributes<InvoiceItem>;\n","numLines":209,"startLine":1,"totalLines":209}}}
{"parentUuid":"36643ef2-79cd-465e-bda4-9e2176f6fe2d","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NQ8UTRniYgQRJnWiA1uT8D","type":"tool_result","content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-190-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-191-}\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-192-\napi/src/libs/session.ts:193:export function expandLineItems(\napi/src/libs/session.ts-194-  items: any[],\napi/src/libs/session.ts-195-  products: Product[],\napi/src/libs/session.ts-196-  prices: Price[],\napi/src/libs/session.ts-197-  creditCurrencies?: TPaymentCurrency[]\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-198-) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-199-  items.forEach((item) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-200-    item.price = prices.find((x) => x.id === item.price_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-201-    if (item.price) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-202-      item.price.product = products.find((x) => x.id === item.price.product_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-203-      if (item.price.product?.type === 'credit' && item.price.metadata?.credit_config) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-204-        item.price.credit = {\napi/src/libs/session.ts-205-          amount: Number(item.price.metadata.credit_config.credit_amount || 0) * Number(item.quantity),\napi/src/libs/session.ts-206-          currency_id: item.price.metadata.credit_config.currency_id,\napi/src/libs/session.ts-207-          currency: creditCurrencies?.find((x) => x.id === item.price.metadata.credit_config.currency_id),\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-208-        };\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-209-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-210-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-211-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-212-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-213-  return items;\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-28-  DiscountAmount,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-29-} from '../store/models';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-30-import { getConnectQueryParam } from './util';\napi/src/libs/invoice.ts:31:import { expandLineItems } from './session';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-32-import dayjs from './dayjs';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-33-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-34-  getSubscriptionCycleAmount,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-35-  getSubscriptionCycleSetup,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-36-  getSubscriptionItemPrice,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-37-  getSubscriptionStakeAmountSetup,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-38-  isSubscriptionOverdraftProtectionEnabled,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-39-} from './subscription';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-40-import logger from './logger';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-41-import { ensureOverdraftProtectionPrice } from './overdraft-protection';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-42-import { CHARGE_SUPPORTED_CHAIN_TYPES } from './constants';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-43-import { emitAsync } from './event';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-44-import { getPriceUintAmountByCurrency } from './price';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-45-import { generateQuotesForInvoiceItems } from './invoice-quote';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-46-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-47-export function getCustomerInvoicePageUrl({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-48-  invoiceId,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-49-  userDid,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-50-  locale = 'en',\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-51-  action = '',\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-77-    const products = (await Product.findAll()).map((x) => x.toJSON());\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-78-    const prices = (await Price.findAll()).map((x) => x.toJSON());\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-79-    // @ts-ignore\napi/src/libs/invoice.ts:80:    expandLineItems(json.lines, products, prices);\napi/src/libs/invoice.ts-81-    const oneTimePaymentInfo: Array<{\napi/src/libs/invoice.ts-82-      productName: string;\napi/src/libs/invoice.ts-83-      paymentInfo: string;\napi/src/libs/invoice.ts-84-      quantity: number;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-85-    }> = [];\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-86-    // @ts-ignore\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-87-    (json.lines || []).forEach((x) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-88-      const { recurring, product } = x.price;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-89-      if (!recurring) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-90-        // it's one-time product\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-91-        oneTimePaymentInfo.push({\napi/src/libs/invoice.ts-92-          productName: product?.name,\napi/src/libs/invoice.ts-93-          paymentInfo: `${fromUnitToToken(x.amount, paymentCurrency.decimal)} ${paymentCurrency.symbol}`,\napi/src/libs/invoice.ts-94-          quantity: x.quantity,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-95-        });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-96-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-97-    });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-98-    return oneTimePaymentInfo;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-99-  } catch (err) {\napi/src/libs/invoice.ts-100-    console.error(`Error in getOneTimeProductInfo for invoice ${invoiceId}:`, err);\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-13-  Price,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-14-  PaymentMethod,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-15-} from '../../store/models';\napi/src/libs/discount/redemption.ts:16:import { expandLineItems } from '../session';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-17-import { formatCurrencyInfo } from '../util';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-18-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-19-interface RedemptionFilters {\napi/src/libs/discount/redemption.ts-20-  coupon_id?: string;\napi/src/libs/discount/redemption.ts-21-  promotion_code_id?: string;\napi/src/libs/discount/redemption.ts-22-  start?: { [Op.lte]: number };\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-23-}\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-24-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-25-interface RedemptionOptions {\napi/src/libs/discount/redemption.ts-26-  page: number;\napi/src/libs/discount/redemption.ts-27-  pageSize: number;\napi/src/libs/discount/redemption.ts-28-  type?: 'customer' | 'subscription';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-29-}\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-30-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-31-interface SavingsByCurrency {\napi/src/libs/discount/redemption.ts-32-  amount: string;\napi/src/libs/discount/redemption.ts-33-  currency: PaymentCurrency;\napi/src/libs/discount/redemption.ts-34-  formattedAmount: string;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-35-}\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-36-\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-189-  const subscriptionDocs = subscriptions.map((x) => x.toJSON());\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-190-  subscriptionDocs.forEach((doc) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-191-    // @ts-ignore\napi/src/libs/discount/redemption.ts:192:    expandLineItems(doc.items, products, prices);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-193-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-194-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-195-  const subscriptionMap = new Map(subscriptionDocs.map((s) => [s.id, s]));\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-196-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-197-  // Group discounts by subscription for efficient processing\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-198-  const discountsBySubscription = new Map<string, any[]>();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-199-  subscriptionDiscounts.forEach((discount) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-200-    const subId = discount.subscription_id!;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-201-    if (!discountsBySubscription.has(subId)) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-202-      discountsBySubscription.set(subId, []);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-203-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-204-    discountsBySubscription.get(subId)!.push(discount);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-205-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-206-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-207-  // Build results with savings calculation\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-208-  const results = await Promise.all(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-209-    Array.from(discountsBySubscription.entries()).map(async ([subscriptionId, discounts]) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-210-      const subscription = subscriptionMap.get(subscriptionId);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-211-      if (!subscription) return [];\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-212-\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-936- * Expand line items with complete coupon information\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-937- * Similar to Price.expand but for coupon information\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-938- */\napi/src/libs/discount/coupon.ts:939:export async function expandLineItemsWithCouponInfo(\napi/src/libs/discount/coupon.ts-940-  lineItems: TLineItemExpanded[],\napi/src/libs/discount/coupon.ts-941-  sessionDiscounts?: any[],\napi/src/libs/discount/coupon.ts-942-  currencyId?: string\napi/src/libs/discount/coupon.ts-943-): Promise<TLineItemExpanded[]> {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-944-  if (!sessionDiscounts?.length) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-945-    return lineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-946-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-947-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-948-  const enhancedLineItems = await Promise.all(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-949-    lineItems.map(async (item) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-950-      if (!item.discount_amounts?.length) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-951-        return item;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-952-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-953-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-954-      const enhancedDiscountAmounts = await Promise.all(\napi/src/libs/discount/coupon.ts-955-        item.discount_amounts.map(async (discountAmount: any) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-956-          let couponInfo = null;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-957-          let promotionCodeInfo = null;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-958-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-959-          // Find the discount in checkout session discounts to get IDs"}]},"uuid":"16855939-141b-4801-aeb4-883b394079f5","timestamp":"2026-01-06T14:31:31.272Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-190-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-191-}\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-192-\napi/src/libs/session.ts:193:export function expandLineItems(\napi/src/libs/session.ts-194-  items: any[],\napi/src/libs/session.ts-195-  products: Product[],\napi/src/libs/session.ts-196-  prices: Price[],\napi/src/libs/session.ts-197-  creditCurrencies?: TPaymentCurrency[]\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-198-) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-199-  items.forEach((item) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-200-    item.price = prices.find((x) => x.id === item.price_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-201-    if (item.price) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-202-      item.price.product = products.find((x) => x.id === item.price.product_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-203-      if (item.price.product?.type === 'credit' && item.price.metadata?.credit_config) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-204-        item.price.credit = {\napi/src/libs/session.ts-205-          amount: Number(item.price.metadata.credit_config.credit_amount || 0) * Number(item.quantity),\napi/src/libs/session.ts-206-          currency_id: item.price.metadata.credit_config.currency_id,\napi/src/libs/session.ts-207-          currency: creditCurrencies?.find((x) => x.id === item.price.metadata.credit_config.currency_id),\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-208-        };\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-209-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-210-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-211-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-212-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-213-  return items;\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-28-  DiscountAmount,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-29-} from '../store/models';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-30-import { getConnectQueryParam } from './util';\napi/src/libs/invoice.ts:31:import { expandLineItems } from './session';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-32-import dayjs from './dayjs';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-33-import {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-34-  getSubscriptionCycleAmount,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-35-  getSubscriptionCycleSetup,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-36-  getSubscriptionItemPrice,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-37-  getSubscriptionStakeAmountSetup,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-38-  isSubscriptionOverdraftProtectionEnabled,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-39-} from './subscription';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-40-import logger from './logger';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-41-import { ensureOverdraftProtectionPrice } from './overdraft-protection';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-42-import { CHARGE_SUPPORTED_CHAIN_TYPES } from './constants';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-43-import { emitAsync } from './event';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-44-import { getPriceUintAmountByCurrency } from './price';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-45-import { generateQuotesForInvoiceItems } from './invoice-quote';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-46-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-47-export function getCustomerInvoicePageUrl({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-48-  invoiceId,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-49-  userDid,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-50-  locale = 'en',\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-51-  action = '',\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-77-    const products = (await Product.findAll()).map((x) => x.toJSON());\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-78-    const prices = (await Price.findAll()).map((x) => x.toJSON());\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-79-    // @ts-ignore\napi/src/libs/invoice.ts:80:    expandLineItems(json.lines, products, prices);\napi/src/libs/invoice.ts-81-    const oneTimePaymentInfo: Array<{\napi/src/libs/invoice.ts-82-      productName: string;\napi/src/libs/invoice.ts-83-      paymentInfo: string;\napi/src/libs/invoice.ts-84-      quantity: number;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-85-    }> = [];\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-86-    // @ts-ignore\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-87-    (json.lines || []).forEach((x) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-88-      const { recurring, product } = x.price;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-89-      if (!recurring) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-90-        // it's one-time product\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-91-        oneTimePaymentInfo.push({\napi/src/libs/invoice.ts-92-          productName: product?.name,\napi/src/libs/invoice.ts-93-          paymentInfo: `${fromUnitToToken(x.amount, paymentCurrency.decimal)} ${paymentCurrency.symbol}`,\napi/src/libs/invoice.ts-94-          quantity: x.quantity,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-95-        });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-96-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-97-    });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-98-    return oneTimePaymentInfo;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts-99-  } catch (err) {\napi/src/libs/invoice.ts-100-    console.error(`Error in getOneTimeProductInfo for invoice ${invoiceId}:`, err);\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-13-  Price,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-14-  PaymentMethod,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-15-} from '../../store/models';\napi/src/libs/discount/redemption.ts:16:import { expandLineItems } from '../session';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-17-import { formatCurrencyInfo } from '../util';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-18-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-19-interface RedemptionFilters {\napi/src/libs/discount/redemption.ts-20-  coupon_id?: string;\napi/src/libs/discount/redemption.ts-21-  promotion_code_id?: string;\napi/src/libs/discount/redemption.ts-22-  start?: { [Op.lte]: number };\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-23-}\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-24-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-25-interface RedemptionOptions {\napi/src/libs/discount/redemption.ts-26-  page: number;\napi/src/libs/discount/redemption.ts-27-  pageSize: number;\napi/src/libs/discount/redemption.ts-28-  type?: 'customer' | 'subscription';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-29-}\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-30-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-31-interface SavingsByCurrency {\napi/src/libs/discount/redemption.ts-32-  amount: string;\napi/src/libs/discount/redemption.ts-33-  currency: PaymentCurrency;\napi/src/libs/discount/redemption.ts-34-  formattedAmount: string;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-35-}\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-36-\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-189-  const subscriptionDocs = subscriptions.map((x) => x.toJSON());\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-190-  subscriptionDocs.forEach((doc) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-191-    // @ts-ignore\napi/src/libs/discount/redemption.ts:192:    expandLineItems(doc.items, products, prices);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-193-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-194-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-195-  const subscriptionMap = new Map(subscriptionDocs.map((s) => [s.id, s]));\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-196-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-197-  // Group discounts by subscription for efficient processing\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-198-  const discountsBySubscription = new Map<string, any[]>();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-199-  subscriptionDiscounts.forEach((discount) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-200-    const subId = discount.subscription_id!;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-201-    if (!discountsBySubscription.has(subId)) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-202-      discountsBySubscription.set(subId, []);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-203-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-204-    discountsBySubscription.get(subId)!.push(discount);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-205-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-206-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-207-  // Build results with savings calculation\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-208-  const results = await Promise.all(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-209-    Array.from(discountsBySubscription.entries()).map(async ([subscriptionId, discounts]) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-210-      const subscription = subscriptionMap.get(subscriptionId);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-211-      if (!subscription) return [];\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/redemption.ts-212-\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-936- * Expand line items with complete coupon information\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-937- * Similar to Price.expand but for coupon information\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-938- */\napi/src/libs/discount/coupon.ts:939:export async function expandLineItemsWithCouponInfo(\napi/src/libs/discount/coupon.ts-940-  lineItems: TLineItemExpanded[],\napi/src/libs/discount/coupon.ts-941-  sessionDiscounts?: any[],\napi/src/libs/discount/coupon.ts-942-  currencyId?: string\napi/src/libs/discount/coupon.ts-943-): Promise<TLineItemExpanded[]> {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-944-  if (!sessionDiscounts?.length) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-945-    return lineItems;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-946-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-947-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-948-  const enhancedLineItems = await Promise.all(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-949-    lineItems.map(async (item) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-950-      if (!item.discount_amounts?.length) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-951-        return item;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-952-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-953-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-954-      const enhancedDiscountAmounts = await Promise.all(\napi/src/libs/discount/coupon.ts-955-        item.discount_amounts.map(async (discountAmount: any) => {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-956-          let couponInfo = null;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-957-          let promotionCodeInfo = null;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-958-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts-959-          // Find the discount in checkout session discounts to get IDs","numLines":149}}
{"parentUuid":"16855939-141b-4801-aeb4-883b394079f5","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01N9jRzudJZCL5pdPwCGJAKQ","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我检查在payment mode下的invoice创建流程："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13252,"cache_read_input_tokens":76561,"cache_creation":{"ephemeral_5m_input_tokens":13252,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrHZRhsxTGKY7ty5x5uJ","type":"assistant","uuid":"1e0742b8-0c69-4ce9-817a-909f34e00c23","timestamp":"2026-01-06T14:31:35.604Z"}
{"parentUuid":"1e0742b8-0c69-4ce9-817a-909f34e00c23","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01N9jRzudJZCL5pdPwCGJAKQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GK5rGuG1hzNCSJnJkKh2YK","name":"Grep","input":{"pattern":"mode === 'payment'","output_mode":"content","path":"~/Arcblock/payment-kit-master/blocklets/core/api/src","-B":5,"-A":10}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13252,"cache_read_input_tokens":76561,"cache_creation":{"ephemeral_5m_input_tokens":13252,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrHZRhsxTGKY7ty5x5uJ","type":"assistant","uuid":"333c6d32-085c-497b-b755-56700c7330fc","timestamp":"2026-01-06T14:31:37.012Z"}
{"parentUuid":"333c6d32-085c-497b-b755-56700c7330fc","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01N9jRzudJZCL5pdPwCGJAKQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HH8wyPagyWtK4ZY9yAUmCn","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","offset":2750,"limit":50}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13252,"cache_read_input_tokens":76561,"cache_creation":{"ephemeral_5m_input_tokens":13252,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrHZRhsxTGKY7ty5x5uJ","type":"assistant","uuid":"8516d28e-fd19-4d6c-87ec-e68b29168a0c","timestamp":"2026-01-06T14:31:38.260Z"}
{"parentUuid":"8516d28e-fd19-4d6c-87ec-e68b29168a0c","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HH8wyPagyWtK4ZY9yAUmCn","type":"tool_result","content":"  2750→      });\n  2751→      if (balance.sufficient) {\n  2752→        logger.info(`CheckoutSession ${checkoutSession.id} will pay from balance ${paymentIntent?.id}`);\n  2753→      }\n  2754→      if (delegation.sufficient) {\n  2755→        logger.info(`CheckoutSession ${checkoutSession.id} will pay from delegation ${paymentIntent?.id}`);\n  2756→      }\n  2757→      if (balance.sufficient || delegation.sufficient) {\n  2758→        fastPaid = true;\n  2759→        await paymentIntent.update({ status: 'requires_capture' });\n  2760→        const { invoice } = await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n  2761→        if (invoice) {\n  2762→          await invoice.update({ auto_advance: true, payment_settings: paymentSettings });\n  2763→          invoiceQueue.push({ id: invoice.id, job: { invoiceId: invoice.id, retryOnError: false } });\n  2764→        } else {\n  2765→          paymentQueue.push({\n  2766→            id: paymentIntent.id,\n  2767→            job: { paymentIntentId: paymentIntent.id, paymentSettings, retryOnError: false },\n  2768→          });\n  2769→        }\n  2770→      }\n  2771→    } else if (\n  2772→      paymentMethod.type === 'arcblock' &&\n  2773→      checkoutSession.mode === 'subscription' &&\n  2774→      checkoutSession.subscription_data?.no_stake\n  2775→    ) {\n  2776→      const subscriptionIds = getCheckoutSessionSubscriptionIds(checkoutSession);\n  2777→      const subscriptions = await Subscription.findAll({ where: { id: subscriptionIds } });\n  2778→      // if we can complete purchase without any wallet interaction\n  2779→      const result = await processSubscriptionFastCheckout({\n  2780→        checkoutSession,\n  2781→        customer,\n  2782→        subscriptions,\n  2783→        paymentMethod,\n  2784→        paymentCurrency,\n  2785→        paymentSettings,\n  2786→        lineItems,\n  2787→        trialEnd,\n  2788→        now,\n  2789→      });\n  2790→      if (!result.success) {\n  2791→        logger.warn(`Fast checkout processing failed: ${result.message}`, {\n  2792→          checkoutSessionId: checkoutSession.id,\n  2793→        });\n  2794→      } else {\n  2795→        fastPaid = true;\n  2796→        delegation = {\n  2797→          sufficient: true,\n  2798→        };\n  2799→        canFastPay = true;\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"f02516fa-c9fe-4a52-a06a-9dc28444233b","timestamp":"2026-01-06T14:31:38.355Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","content":"      });\n      if (balance.sufficient) {\n        logger.info(`CheckoutSession ${checkoutSession.id} will pay from balance ${paymentIntent?.id}`);\n      }\n      if (delegation.sufficient) {\n        logger.info(`CheckoutSession ${checkoutSession.id} will pay from delegation ${paymentIntent?.id}`);\n      }\n      if (balance.sufficient || delegation.sufficient) {\n        fastPaid = true;\n        await paymentIntent.update({ status: 'requires_capture' });\n        const { invoice } = await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n        if (invoice) {\n          await invoice.update({ auto_advance: true, payment_settings: paymentSettings });\n          invoiceQueue.push({ id: invoice.id, job: { invoiceId: invoice.id, retryOnError: false } });\n        } else {\n          paymentQueue.push({\n            id: paymentIntent.id,\n            job: { paymentIntentId: paymentIntent.id, paymentSettings, retryOnError: false },\n          });\n        }\n      }\n    } else if (\n      paymentMethod.type === 'arcblock' &&\n      checkoutSession.mode === 'subscription' &&\n      checkoutSession.subscription_data?.no_stake\n    ) {\n      const subscriptionIds = getCheckoutSessionSubscriptionIds(checkoutSession);\n      const subscriptions = await Subscription.findAll({ where: { id: subscriptionIds } });\n      // if we can complete purchase without any wallet interaction\n      const result = await processSubscriptionFastCheckout({\n        checkoutSession,\n        customer,\n        subscriptions,\n        paymentMethod,\n        paymentCurrency,\n        paymentSettings,\n        lineItems,\n        trialEnd,\n        now,\n      });\n      if (!result.success) {\n        logger.warn(`Fast checkout processing failed: ${result.message}`, {\n          checkoutSessionId: checkoutSession.id,\n        });\n      } else {\n        fastPaid = true;\n        delegation = {\n          sufficient: true,\n        };\n        canFastPay = true;","numLines":50,"startLine":2750,"totalLines":3727}}}
{"parentUuid":"f02516fa-c9fe-4a52-a06a-9dc28444233b","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GK5rGuG1hzNCSJnJkKh2YK","type":"tool_result","content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-350-    minimumCycle = 1;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-351-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-352-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-353-  const { total, renew } = await getCheckoutAmount(items, currencyId, trialing, discountConfig);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-354-\napi/src/libs/session.ts:355:  if (mode === 'payment' || mode === 'auto-recharge-auth') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-356-    return total;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-357-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-358-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-359-  if (mode === 'setup') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-360-    return new BN(renew).mul(new BN(minimumCycle)).toString();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-361-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-362-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-363-  if (mode === 'subscription') {\napi/src/libs/session.ts-364-    return new BN(total).add(new BN(renew).mul(new BN(trialing ? minimumCycle : minimumCycle - 1))).toString();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-365-  }\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-506-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-507-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-508-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-509-  // 一次性购买成功\napi/src/queues/notification.ts-510-  events.on('checkout.session.completed', async (checkoutSession: CheckoutSession) => {\napi/src/queues/notification.ts:511:    if (checkoutSession.mode === 'payment') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-512-      const paymentLink = await PaymentLink.findByPk(checkoutSession.payment_link_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-513-      if (paymentLink?.submit_type === 'donate') {\napi/src/queues/notification.ts-514-        addNotificationJob('customer.reward.succeeded', { checkoutSessionId: checkoutSession.id }, [\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-515-          checkoutSession.id,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-516-        ]);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-517-        return;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-518-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-519-\napi/src/queues/notification.ts-520-      addNotificationJob('checkout.session.completed', { checkoutSessionId: checkoutSession.id }, [checkoutSession.id]);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-521-    }\n--\napi/src/routes/checkout-sessions.ts-403-      shipping: amount.shipping,\napi/src/routes/checkout-sessions.ts-404-      tax: amount.tax,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-405-    },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-406-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-407-\napi/src/routes/checkout-sessions.ts:408:  if (checkoutSession.mode === 'payment' && new BN(amount.total || '0').lt(new BN('0'))) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-409-    throw new Error('Payment amount should be greater or equal to 0');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-410-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-411-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-412-  return {\napi/src/routes/checkout-sessions.ts-413-    lineItems: amount.processedItems || lineItems,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-414-    amount,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-415-    trialInDays,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-416-    trialEnd,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-417-    now,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-418-  };\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1999-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2000-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2001-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2002-    // create or update payment intent\napi/src/routes/checkout-sessions.ts-2003-    let paymentIntent: PaymentIntent | null = null;\napi/src/routes/checkout-sessions.ts:2004:    if (checkoutSession.mode === 'payment') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2005-      const result = await createOrUpdatePaymentIntent(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2006-        checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2007-        paymentMethod,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2008-        paymentCurrency,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2009-        lineItems,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2010-        customer.id,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2011-        customer.email,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2012-        undefined,\napi/src/routes/checkout-sessions.ts-2013-        { quoteIds: consumedQuotes.map((q) => q.id) }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2014-      );\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2216-      paymentCurrency,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2217-      customer,\napi/src/routes/checkout-sessions.ts-2218-      amount: fastCheckoutAmount,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2219-    });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2220-\napi/src/routes/checkout-sessions.ts:2221:    const isPayment = checkoutSession.mode === 'payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2222-    let canFastPay = isPayment && canPayWithDelegation(paymentIntent?.beneficiaries || []);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2223-    let fastPayInfo = null;\napi/src/routes/checkout-sessions.ts-2224-    let delegation: SufficientForPaymentResult | null = null;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2225-    let creditSufficient = false;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2226-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2227-    const canFastPayForSubscription =\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2228-      paymentCurrency.isCredit() ||\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2229-      (checkoutSession.mode === 'subscription' && checkoutSession.subscription_data?.no_stake);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2230-    if (isPayment && paymentIntent && canFastPay) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2231-      // if we can complete purchase without any wallet interaction\n--\napi/src/routes/checkout-sessions.ts-2624-        lineItemsOverride: lineItemsWithQuotes,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2625-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2626-    );\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2627-\napi/src/routes/checkout-sessions.ts-2628-    let paymentIntent: PaymentIntent | null = null;\napi/src/routes/checkout-sessions.ts:2629:    if (checkoutSession.mode === 'payment') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2630-      const result = await createOrUpdatePaymentIntent(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2631-        checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2632-        paymentMethod,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2633-        paymentCurrency,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2634-        lineItems,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2635-        customer.id,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2636-        customer.email,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2637-        undefined,\napi/src/routes/checkout-sessions.ts-2638-        { quoteIds: consumedQuotes.map((q) => q.id) }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2639-      );\n--\napi/src/routes/checkout-sessions.ts-2668-      amount: fastCheckoutAmount,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2669-    });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2670-    // Check if this is a credit payment\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2671-    const isCredit = paymentCurrency.isCredit();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2672-\napi/src/routes/checkout-sessions.ts:2673:    const isPayment = checkoutSession.mode === 'payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2674-    let fastPaid = false;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2675-    let canFastPay = isPayment && canPayWithDelegation(paymentIntent?.beneficiaries || []);\napi/src/routes/checkout-sessions.ts-2676-    let delegation: SufficientForPaymentResult | null = null;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2677-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2678-    // Handle credit payment directly\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2679-    if (isCredit) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2680-      const result = await isCreditGrantSufficientForPayment({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2681-        paymentMethod,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2682-        paymentCurrency,\napi/src/routes/checkout-sessions.ts-2683-        userDid: customer.did,\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-393-  subscriptions,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-394-  lineItems,\napi/src/routes/connect/shared.ts-395-}: Args): Promise<{ invoice: Invoice | null; items: InvoiceItem[] }> {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-396-  const isGroupInvoice = subscriptions && subscriptions.length > 1;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-397-  // invoices are optional when checkout session is in payment mode\napi/src/routes/connect/shared.ts:398:  if (checkoutSession.mode === 'payment' && !checkoutSession.invoice_creation?.enabled) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-399-    logger.warn('Invoice creation disabled for payment mode');\napi/src/routes/connect/shared.ts-400-    return { invoice: null, items: [] };\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-401-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-402-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-403-  const existingInvoice = checkoutSession.invoice_id || (isGroupInvoice && subscription?.latest_invoice_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-404-  // Do not create invoice if it's already created\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-405-  if (existingInvoice) {\napi/src/routes/connect/shared.ts-406-    logger.info(`Invoice already created for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-407-    const invoice = await Invoice.findByPk(existingInvoice);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-408-    if (invoice) {"}]},"uuid":"0cd2f47c-b7fa-4e8f-8f59-8bbf1c81bb20","timestamp":"2026-01-06T14:31:38.372Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-350-    minimumCycle = 1;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-351-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-352-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-353-  const { total, renew } = await getCheckoutAmount(items, currencyId, trialing, discountConfig);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-354-\napi/src/libs/session.ts:355:  if (mode === 'payment' || mode === 'auto-recharge-auth') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-356-    return total;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-357-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-358-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-359-  if (mode === 'setup') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-360-    return new BN(renew).mul(new BN(minimumCycle)).toString();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-361-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-362-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-363-  if (mode === 'subscription') {\napi/src/libs/session.ts-364-    return new BN(total).add(new BN(renew).mul(new BN(trialing ? minimumCycle : minimumCycle - 1))).toString();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts-365-  }\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-506-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-507-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-508-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-509-  // 一次性购买成功\napi/src/queues/notification.ts-510-  events.on('checkout.session.completed', async (checkoutSession: CheckoutSession) => {\napi/src/queues/notification.ts:511:    if (checkoutSession.mode === 'payment') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-512-      const paymentLink = await PaymentLink.findByPk(checkoutSession.payment_link_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-513-      if (paymentLink?.submit_type === 'donate') {\napi/src/queues/notification.ts-514-        addNotificationJob('customer.reward.succeeded', { checkoutSessionId: checkoutSession.id }, [\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-515-          checkoutSession.id,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-516-        ]);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-517-        return;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-518-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-519-\napi/src/queues/notification.ts-520-      addNotificationJob('checkout.session.completed', { checkoutSessionId: checkoutSession.id }, [checkoutSession.id]);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/notification.ts-521-    }\n--\napi/src/routes/checkout-sessions.ts-403-      shipping: amount.shipping,\napi/src/routes/checkout-sessions.ts-404-      tax: amount.tax,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-405-    },\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-406-  });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-407-\napi/src/routes/checkout-sessions.ts:408:  if (checkoutSession.mode === 'payment' && new BN(amount.total || '0').lt(new BN('0'))) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-409-    throw new Error('Payment amount should be greater or equal to 0');\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-410-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-411-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-412-  return {\napi/src/routes/checkout-sessions.ts-413-    lineItems: amount.processedItems || lineItems,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-414-    amount,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-415-    trialInDays,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-416-    trialEnd,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-417-    now,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-418-  };\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-1999-      });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2000-    }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2001-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2002-    // create or update payment intent\napi/src/routes/checkout-sessions.ts-2003-    let paymentIntent: PaymentIntent | null = null;\napi/src/routes/checkout-sessions.ts:2004:    if (checkoutSession.mode === 'payment') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2005-      const result = await createOrUpdatePaymentIntent(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2006-        checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2007-        paymentMethod,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2008-        paymentCurrency,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2009-        lineItems,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2010-        customer.id,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2011-        customer.email,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2012-        undefined,\napi/src/routes/checkout-sessions.ts-2013-        { quoteIds: consumedQuotes.map((q) => q.id) }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2014-      );\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2216-      paymentCurrency,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2217-      customer,\napi/src/routes/checkout-sessions.ts-2218-      amount: fastCheckoutAmount,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2219-    });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2220-\napi/src/routes/checkout-sessions.ts:2221:    const isPayment = checkoutSession.mode === 'payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2222-    let canFastPay = isPayment && canPayWithDelegation(paymentIntent?.beneficiaries || []);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2223-    let fastPayInfo = null;\napi/src/routes/checkout-sessions.ts-2224-    let delegation: SufficientForPaymentResult | null = null;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2225-    let creditSufficient = false;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2226-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2227-    const canFastPayForSubscription =\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2228-      paymentCurrency.isCredit() ||\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2229-      (checkoutSession.mode === 'subscription' && checkoutSession.subscription_data?.no_stake);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2230-    if (isPayment && paymentIntent && canFastPay) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2231-      // if we can complete purchase without any wallet interaction\n--\napi/src/routes/checkout-sessions.ts-2624-        lineItemsOverride: lineItemsWithQuotes,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2625-      }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2626-    );\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2627-\napi/src/routes/checkout-sessions.ts-2628-    let paymentIntent: PaymentIntent | null = null;\napi/src/routes/checkout-sessions.ts:2629:    if (checkoutSession.mode === 'payment') {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2630-      const result = await createOrUpdatePaymentIntent(\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2631-        checkoutSession,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2632-        paymentMethod,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2633-        paymentCurrency,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2634-        lineItems,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2635-        customer.id,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2636-        customer.email,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2637-        undefined,\napi/src/routes/checkout-sessions.ts-2638-        { quoteIds: consumedQuotes.map((q) => q.id) }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2639-      );\n--\napi/src/routes/checkout-sessions.ts-2668-      amount: fastCheckoutAmount,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2669-    });\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2670-    // Check if this is a credit payment\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2671-    const isCredit = paymentCurrency.isCredit();\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2672-\napi/src/routes/checkout-sessions.ts:2673:    const isPayment = checkoutSession.mode === 'payment';\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2674-    let fastPaid = false;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2675-    let canFastPay = isPayment && canPayWithDelegation(paymentIntent?.beneficiaries || []);\napi/src/routes/checkout-sessions.ts-2676-    let delegation: SufficientForPaymentResult | null = null;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2677-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2678-    // Handle credit payment directly\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2679-    if (isCredit) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2680-      const result = await isCreditGrantSufficientForPayment({\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2681-        paymentMethod,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts-2682-        paymentCurrency,\napi/src/routes/checkout-sessions.ts-2683-        userDid: customer.did,\n--\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-393-  subscriptions,\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-394-  lineItems,\napi/src/routes/connect/shared.ts-395-}: Args): Promise<{ invoice: Invoice | null; items: InvoiceItem[] }> {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-396-  const isGroupInvoice = subscriptions && subscriptions.length > 1;\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-397-  // invoices are optional when checkout session is in payment mode\napi/src/routes/connect/shared.ts:398:  if (checkoutSession.mode === 'payment' && !checkoutSession.invoice_creation?.enabled) {\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-399-    logger.warn('Invoice creation disabled for payment mode');\napi/src/routes/connect/shared.ts-400-    return { invoice: null, items: [] };\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-401-  }\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-402-\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-403-  const existingInvoice = checkoutSession.invoice_id || (isGroupInvoice && subscription?.latest_invoice_id);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-404-  // Do not create invoice if it's already created\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-405-  if (existingInvoice) {\napi/src/routes/connect/shared.ts-406-    logger.info(`Invoice already created for checkout session ${checkoutSession.id}: ${existingInvoice}`);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-407-    const invoice = await Invoice.findByPk(existingInvoice);\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts-408-    if (invoice) {","numLines":135}}
{"parentUuid":"0cd2f47c-b7fa-4e8f-8f59-8bbf1c81bb20","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"b65a1a74-c50b-4858-a2ba-bd6cfa850f18","version":"2.0.76","gitBranch":"feat-quote","agentId":"a14bea1","slug":"distributed-painting-curry","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01QL71VEFc3eu4fZVAMW27HS","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我总结调查结果。我已经找到了问题的根源和完整调用链。让我创建调查报告：\n\n## 调查结果总结\n\n经过深入分析代码，我发现了账单item缺少quote信息的根本原因和完整调用链。\n\n### **核心问题：Payment Mode下Invoice创建被跳过**\n\n在 `~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/shared.ts` 的 `ensureInvoiceForCheckout` 函数中（第398行）：\n\n```typescript\nif (checkoutSession.mode === 'payment' && !checkoutSession.invoice_creation?.enabled) {\n  logger.warn('Invoice creation disabled for payment mode');\n  return { invoice: null, items: [] };\n}\n```\n\n**这意味着：在payment模式下，如果没有显式启用invoice_creation，invoice根本不会被创建，自然也就不会调用generateQuotesForInvoiceItems函数。**\n\n### **完整的Invoice创建调用链**\n\n#### 1. **Subscription模式的调用链（quote信息正常）**\n\n```\nensureInvoiceAndItems (invoice.ts:688)\n  ↓\ncreateInvoiceWithItems (invoice.ts:439)\n  ↓\ngenerateQuotesForInvoiceItems (invoice.ts:527-533) ✅ 被调用\n  ↓\nenrichedItemsData 包含 quote 信息\n  ↓\nInvoiceItem.create (invoice.ts:561-586)\n  ↓\nmetadata: {\n    ...(item.metadata || {}),\n    ...((item as any).quote_id && { quote_id: (item as any).quote_id }),  ✅ quote_id 被保存\n}\n```\n\n**关键代码** (invoice.ts:527-533):\n```typescript\nconst enrichedItemsData = subscription\n  ? await generateQuotesForInvoiceItems({\n      invoiceId: invoice.id,\n      items: itemsData,\n      currencyId,\n    })\n  : itemsData;\n```\n\n#### 2. **Payment模式的调用链（quote信息丢失）**\n\n```\nensureInvoiceForCheckout (shared.ts:387)\n  ↓\n检查 mode === 'payment' && !invoice_creation?.enabled (shared.ts:398) ❌\n  ↓\nreturn { invoice: null, items: [] }  ❌ 直接返回，不创建invoice\n  ↓\n❌ generateQuotesForInvoiceItems 从未被调用\n❌ invoice items 从未被创建\n```\n\n### **invoice-quote.ts中的generateQuotesForInvoiceItems函数**\n\n该函数的逻辑是完整的，会把quote信息放入item.metadata：\n\n```typescript\nenrichedItems.push({\n  ...item,\n  amount: quote.quoted_amount,\n  quote_id: quote.id,\n  metadata: {\n    ...item.metadata,\n    quote: {  // ✅ 详细的quote信息\n      id: quote.id,\n      base_currency: quote.base_currency,\n      base_amount: quote.base_amount,\n      quoted_amount: quote.quoted_amount,\n      // ... 更多字段\n    },\n  },\n});\n```\n\n### **InvoiceItem模型的metadata字段**\n\n在 `~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice-item.ts`:\n\n```typescript\nmetadata: {\n  type: DataTypes.JSON,\n  defaultValue: {},\n},\n```\n\n字段定义正确，支持JSON存储。\n\n### **Invoice查询接口**\n\n在 `~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/invoices.ts` 的 GET `/:id` 路由（641-822行）：\n\n```typescript\nconst doc = await Invoice.findOne({\n  where: { id: req.params.id },\n  include: [\n    { model: InvoiceItem, as: 'lines' },  // ✅ 会查询invoice items\n    // ... 其他关联\n  ],\n});\n\n// ... 后续处理\nexpandLineItems(json.lines, products, prices, paymentCurrencies);  // ✅ 展开line items\n\n// Fetch related price quotes\nlet quotes: any[] = [];\ntry {\n  quotes = await PriceQuote.findAll({\n    where: { invoice_id: doc.id },  // ✅ 查询quote表\n    order: [['created_at', 'ASC']],\n  });\n} catch (error) {\n  logger.error('Failed to fetch related price quotes', { error, invoiceId: doc.id });\n}\n\nreturn res.json({\n  ...json,\n  discountDetails,\n  relatedCreditGrants,\n  paymentLink,\n  checkoutSession,\n  quotes,  // ✅ 返回quotes数组\n});\n```\n\n**查询接口会返回：**\n1. `json.lines` - invoice items数组（应该包含metadata.quote）\n2. `quotes` - 独立的PriceQuote表记录数组\n\n### **问题根源总结**\n\n1. **Payment模式下invoice未创建**：`ensureInvoiceForCheckout`函数在payment模式下会提前返回，不创建invoice\n2. **generateQuotesForInvoiceItems仅在subscription模式下调用**：`createInvoiceWithItems`函数中，只有当`subscription`参数存在时才会调用\n3. **Payment模式下的调用场景**：\n   - `routes/connect/pay.ts` 第100行：`ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent })`\n   - `routes/checkout-sessions.ts` 第2760行：`ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent })`\n   - 这些调用都没有传入`subscription`参数\n\n### **可能导致quote信息丢失的代码位置**\n\n1. **shared.ts:398** - Payment模式下invoice创建被跳过\n2. **invoice.ts:527-533** - generateQuotesForInvoiceItems仅在subscription模式下调用\n3. **invoice.ts:561-586** - InvoiceItem创建时metadata的传递是正确的，但如果enrichedItemsData没有quote信息，metadata也不会有\n\n### **修复建议**\n\n需要修改以下位置：\n\n1. **invoice.ts:527-533** - 将generateQuotesForInvoiceItems的调用逻辑改为检查是否有dynamic pricing items，而不是仅检查subscription\n2. **shared.ts** - 确保payment模式下也能创建invoice（当有dynamic pricing时）\n3. 或者在payment intent创建时就生成quote，并在创建invoice item时传递quote信息\n\n这样可以确保无论是payment模式还是subscription模式，只要使用了dynamic pricing，都能正确生成和保存quote信息。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":829,"cache_creation_input_tokens":6240,"cache_read_input_tokens":89813,"cache_creation":{"ephemeral_5m_input_tokens":6240,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWrHZxJdo9GwbPxypbUDh","type":"assistant","uuid":"2fb6da5c-3b53-43be-8d9b-55dbcb07a097","timestamp":"2026-01-06T14:32:13.660Z"}
