{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","type":"user","message":{"role":"user","content":"我需要了解 Payment Kit 代码库中以下核心领域的实现：\n\n1. **计费系统**（Invoice/Pricing）：数据模型、计算逻辑、支付流程\n2. **订阅系统**（Subscription）：订阅模型、续费逻辑、状态管理\n3. **优惠券系统**（Discount/Coupon）：折扣计算、适用规则、有效期管理\n4. **税务系统**（Tax）：税率计算、税务规则\n\n请探索相关的：\n- 数据模型文件（store/models/）\n- 业务逻辑文件（libs/）\n- API 路由文件（routes/）\n- 测试文件（tests/）\n\n重点关注：\n- 核心数据结构和字段\n- 关键业务规则和计算逻辑\n- 模块之间的依赖关系\n- 常见的边界情况处理\n\n请提供详细的分析结果，包括关键文件路径和核心代码片段。"},"uuid":"547fbab0-df72-431e-afe8-b044cda291bc","timestamp":"2026-01-09T01:49:02.269Z"}
{"parentUuid":"547fbab0-df72-431e-afe8-b044cda291bc","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CyqtiavyaFXqTkVL6DVGuj","type":"message","role":"assistant","content":[{"type":"text","text":"我将全面探索 Payment Kit 代码库中这四个核心领域的实现。让我先找到相关的文件，然后进行深入分析。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14754,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14754,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWvxqmKLzo4pmbuYvxbP6","type":"assistant","uuid":"a0e4eb33-8abb-4ad6-97a7-94b7a994784f","timestamp":"2026-01-09T01:49:05.581Z"}
{"parentUuid":"a0e4eb33-8abb-4ad6-97a7-94b7a994784f","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CyqtiavyaFXqTkVL6DVGuj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01X8smt9AkKTgcoM9wdW8Jer","name":"Glob","input":{"pattern":"**/store/models/*.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14754,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14754,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWvxqmKLzo4pmbuYvxbP6","type":"assistant","uuid":"02d6b7f2-b682-49d6-a97c-80190978ca42","timestamp":"2026-01-09T01:49:05.979Z"}
{"parentUuid":"02d6b7f2-b682-49d6-a97c-80190978ca42","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CyqtiavyaFXqTkVL6DVGuj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XMwqnUZnSyRUmrMovjj5g6","name":"Glob","input":{"pattern":"**/api/src/libs/*.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14754,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14754,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWvxqmKLzo4pmbuYvxbP6","type":"assistant","uuid":"41e28d91-15fb-432b-88ae-d53c441a7558","timestamp":"2026-01-09T01:49:06.424Z"}
{"parentUuid":"41e28d91-15fb-432b-88ae-d53c441a7558","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CyqtiavyaFXqTkVL6DVGuj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UYaJw9UuJaLpDupcZZHCS2","name":"Glob","input":{"pattern":"**/api/src/routes/*.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14754,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14754,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWvxqmKLzo4pmbuYvxbP6","type":"assistant","uuid":"e88370e3-1982-4725-8d4b-15103623736e","timestamp":"2026-01-09T01:49:06.673Z"}
{"parentUuid":"e88370e3-1982-4725-8d4b-15103623736e","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01CyqtiavyaFXqTkVL6DVGuj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HEDeD2XbgRUesQqH6bpsJj","name":"Glob","input":{"pattern":"**/api/tests/**/*.spec.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":14754,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":14754,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"}},"requestId":"req_011CWvxqmKLzo4pmbuYvxbP6","type":"assistant","uuid":"db695c3d-a13e-48d0-a7ac-91037fb1de05","timestamp":"2026-01-09T01:49:07.168Z"}
{"parentUuid":"db695c3d-a13e-48d0-a7ac-91037fb1de05","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X8smt9AkKTgcoM9wdW8Jer","type":"tool_result","content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/auto-recharge-config.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/checkout-session.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/coupon.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/customer.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/discount.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/event.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice-item.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/job.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/lock.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/meter.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payment-intent.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payment-link.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payment-method.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payment-stat.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/pricing-table.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/product-vendor.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/product.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/promotion-code.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/setting.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/setup-intent.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription-item.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription-schedule.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/tax-rate.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/usage-record.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/webhook-attempt.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/webhook-endpoint.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payout.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/types.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/event.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/invoice.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/subscription.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payment-intent.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/checkout-session.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payment-currency.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/coupon.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/customer.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/discount.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/invoice-item.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/job.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/lock.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payment-link.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payment-method.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payment-stat.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payout.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/meter.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/price.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/pricing-table.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/product.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/promotion-code.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/refund.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/setup-intent.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/subscription-item.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/subscription-schedule.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/usage-record.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/webhook-attempt.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/webhook-endpoint.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/setting.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/credit-grant.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/credit-transaction.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/meter-event.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/product-vendor.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/tax-rate.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/index.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/types/store/models/auto-recharge-config.d.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/meter-event.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/credit-grant.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/credit-transaction.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payment-currency.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/refund.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/index.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price-quote.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/types.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/exchange-rate-provider.ts"}]},"uuid":"406cd337-3be0-4f3b-a861-e5796fd96392","timestamp":"2026-01-09T01:49:07.362Z","toolUseResult":{"filenames":["~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/auto-recharge-config.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/checkout-session.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/coupon.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/customer.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/discount.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/event.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice-item.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/job.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/lock.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/meter.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payment-intent.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payment-link.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payment-method.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payment-stat.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/pricing-table.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/product-vendor.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/product.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/promotion-code.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/setting.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/setup-intent.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription-item.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription-schedule.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/tax-rate.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/usage-record.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/webhook-attempt.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/webhook-endpoint.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payout.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/types.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/event.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/invoice.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/subscription.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payment-intent.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/checkout-session.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payment-currency.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/coupon.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/customer.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/discount.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/invoice-item.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/job.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/lock.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payment-link.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payment-method.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payment-stat.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/payout.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/meter.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/price.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/pricing-table.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/product.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/promotion-code.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/refund.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/setup-intent.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/subscription-item.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/subscription-schedule.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/usage-record.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/webhook-attempt.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/webhook-endpoint.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/setting.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/credit-grant.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/credit-transaction.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/meter-event.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/product-vendor.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/tax-rate.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/index.d.ts","~/Arcblock/payment-kit-master/blocklets/core/types/store/models/auto-recharge-config.d.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/meter-event.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/credit-grant.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/credit-transaction.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/payment-currency.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/refund.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/index.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price-quote.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/types.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/exchange-rate-provider.ts"],"durationMs":48,"numFiles":76,"truncated":false}}
{"parentUuid":"406cd337-3be0-4f3b-a861-e5796fd96392","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XMwqnUZnSyRUmrMovjj5g6","type":"tool_result","content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/api.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/audit.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/constants.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/context.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/dayjs.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/did-space.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/event.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/lock.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/logger.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/overdraft-protection.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/pagination.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/payout.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/product.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/time.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/url.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/ws.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/middleware.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/auth.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/payment.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/refund.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/remote-signer.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/security.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/resource.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/setting.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/price.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/currency.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/credit-grant.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/util.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/env.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/math-utils.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice-quote.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/error.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/quote-validation.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/quote-service.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/subscription.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts"}]},"uuid":"a07a3c67-5777-4320-abc9-75ec48beee81","timestamp":"2026-01-09T01:49:07.364Z","toolUseResult":{"filenames":["~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/api.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/audit.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/constants.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/context.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/dayjs.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/did-space.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/event.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/lock.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/logger.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/overdraft-protection.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/pagination.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/payout.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/product.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/time.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/url.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/ws.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/middleware.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/auth.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/payment.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/refund.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/remote-signer.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/security.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/resource.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/setting.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/price.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/currency.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/credit-grant.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/util.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/env.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/math-utils.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice-quote.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/error.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/quote-validation.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/quote-service.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/subscription.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts"],"durationMs":50,"numFiles":37,"truncated":false}}
{"parentUuid":"a07a3c67-5777-4320-abc9-75ec48beee81","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UYaJw9UuJaLpDupcZZHCS2","type":"tool_result","content":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/coupons.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/donations.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/passports.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payment-methods.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payment-stats.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/pricing-table.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/promotion-codes.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/redirect.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/subscription-items.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/tax-rates.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/usage-records.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/webhook-attempts.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/webhook-endpoints.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/auto-recharge-configs.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/subscriptions.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/customers.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/tool.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payment-intents.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payouts.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/refunds.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/vendor.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/events.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/credit-tokens.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/meters.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payment-currencies.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/products.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/settings.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/credit-grants.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/credit-transactions.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/meter-events.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/invoices.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/index.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/exchange-rate-providers.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/exchange-rates.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/prices.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payment-links.ts"}]},"uuid":"c6976d7f-6e0c-4013-ae02-7e9f27321daf","timestamp":"2026-01-09T01:49:07.371Z","toolUseResult":{"filenames":["~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/coupons.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/donations.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/passports.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payment-methods.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payment-stats.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/pricing-table.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/promotion-codes.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/redirect.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/subscription-items.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/tax-rates.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/usage-records.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/webhook-attempts.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/webhook-endpoints.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/auto-recharge-configs.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/subscriptions.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/customers.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/tool.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payment-intents.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payouts.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/refunds.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/vendor.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/events.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/credit-tokens.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/meters.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payment-currencies.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/products.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/settings.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/credit-grants.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/credit-transactions.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/meter-events.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/invoices.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/index.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/exchange-rate-providers.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/exchange-rates.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/prices.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts","~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/payment-links.ts"],"durationMs":56,"numFiles":37,"truncated":false}}
{"parentUuid":"c6976d7f-6e0c-4013-ae02-7e9f27321daf","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HEDeD2XbgRUesQqH6bpsJj","type":"tool_result","content":"~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/api.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/coupon.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/discount.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/lock.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/pagination.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/session.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/subscription.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/time.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/util.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/models/tax-rate.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/models/price-dynamic.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/token-data-provider.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/models/price-quote.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/exchange-rate-service.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/models/exchange-rate-provider.spec.ts\n~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/quote-service.spec.ts"}]},"uuid":"ced430e9-2526-4931-8fea-c842a4399e7d","timestamp":"2026-01-09T01:49:07.370Z","toolUseResult":{"filenames":["~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/api.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/coupon.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/discount.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/lock.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/pagination.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/session.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/subscription.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/time.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/util.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/models/tax-rate.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/models/price-dynamic.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/token-data-provider.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/models/price-quote.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/exchange-rate-service.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/models/exchange-rate-provider.spec.ts","~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/quote-service.spec.ts"],"durationMs":55,"numFiles":16,"truncated":false}}
{"parentUuid":"ced430e9-2526-4931-8fea-c842a4399e7d","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015jozjGLgjP5xSjbiMPJA5S","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我读取核心文件来分析这四个系统的实现："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6392,"cache_read_input_tokens":14754,"cache_creation":{"ephemeral_5m_input_tokens":6392,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxr9TMop988toTkYmHo","type":"assistant","uuid":"45027228-94f7-4834-bb5d-82f23b9bd5be","timestamp":"2026-01-09T01:49:11.222Z"}
{"parentUuid":"45027228-94f7-4834-bb5d-82f23b9bd5be","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015jozjGLgjP5xSjbiMPJA5S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0116fgn8ifLyGFEMEMbF5vqJ","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6392,"cache_read_input_tokens":14754,"cache_creation":{"ephemeral_5m_input_tokens":6392,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxr9TMop988toTkYmHo","type":"assistant","uuid":"fa1cc14d-9d3e-4926-8455-32fd98d57bc8","timestamp":"2026-01-09T01:49:12.221Z"}
{"parentUuid":"fa1cc14d-9d3e-4926-8455-32fd98d57bc8","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015jozjGLgjP5xSjbiMPJA5S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EBg42G3FiQoV1s7MDEvz3y","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6392,"cache_read_input_tokens":14754,"cache_creation":{"ephemeral_5m_input_tokens":6392,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxr9TMop988toTkYmHo","type":"assistant","uuid":"16d1b280-66b0-46e2-85d8-ec72d8f9dda9","timestamp":"2026-01-09T01:49:12.847Z"}
{"parentUuid":"16d1b280-66b0-46e2-85d8-ec72d8f9dda9","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015jozjGLgjP5xSjbiMPJA5S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018PqKnb5Dq12cUALhf4WqLe","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6392,"cache_read_input_tokens":14754,"cache_creation":{"ephemeral_5m_input_tokens":6392,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxr9TMop988toTkYmHo","type":"assistant","uuid":"9e10b926-fd39-486f-91ed-dfa543915b8a","timestamp":"2026-01-09T01:49:13.561Z"}
{"parentUuid":"9e10b926-fd39-486f-91ed-dfa543915b8a","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015jozjGLgjP5xSjbiMPJA5S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01W3Gbh2mjAu9GKgmnMuF93r","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/discount.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6392,"cache_read_input_tokens":14754,"cache_creation":{"ephemeral_5m_input_tokens":6392,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxr9TMop988toTkYmHo","type":"assistant","uuid":"9d99ec4a-123f-4de3-9892-f7a3c34532df","timestamp":"2026-01-09T01:49:13.625Z"}
{"parentUuid":"9d99ec4a-123f-4de3-9892-f7a3c34532df","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015jozjGLgjP5xSjbiMPJA5S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017aqkMGzbF1i6xfrBRoxroW","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/coupon.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6392,"cache_read_input_tokens":14754,"cache_creation":{"ephemeral_5m_input_tokens":6392,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxr9TMop988toTkYmHo","type":"assistant","uuid":"1dfda628-0d7e-4e49-9870-7d56cd7fade2","timestamp":"2026-01-09T01:49:14.156Z"}
{"parentUuid":"1dfda628-0d7e-4e49-9870-7d56cd7fade2","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_015jozjGLgjP5xSjbiMPJA5S","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QNHcEfnhALSHUEHFwsGuWH","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/tax-rate.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":6392,"cache_read_input_tokens":14754,"cache_creation":{"ephemeral_5m_input_tokens":6392,"ephemeral_1h_input_tokens":0},"output_tokens":463,"service_tier":"standard"}},"requestId":"req_011CWvxr9TMop988toTkYmHo","type":"assistant","uuid":"14258eff-8ef9-484e-b7d6-87d55fb31400","timestamp":"2026-01-09T01:49:14.832Z"}
{"parentUuid":"14258eff-8ef9-484e-b7d6-87d55fb31400","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0116fgn8ifLyGFEMEMbF5vqJ","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/indent */\n     2→/* eslint-disable @typescript-eslint/lines-between-class-members */\n     3→import { BN } from '@ocap/util';\n     4→import {\n     5→  CreationOptional,\n     6→  DataTypes,\n     7→  InferAttributes,\n     8→  InferCreationAttributes,\n     9→  Model,\n    10→  Op,\n    11→  Sequelize,\n    12→  WhereOptions,\n    13→} from 'sequelize';\n    14→import type { LiteralUnion } from 'type-fest';\n    15→\n    16→import { createEvent, createStatusEvent } from '../../libs/audit';\n    17→import { createIdGenerator } from '../../libs/util';\n    18→import type {\n    19→  CustomerAddress,\n    20→  CustomerShipping,\n    21→  DiscountAmount,\n    22→  GroupedBN,\n    23→  GroupedStrList,\n    24→  PaymentError,\n    25→  PaymentSettings,\n    26→  SimpleCustomField,\n    27→} from './types';\n    28→\n    29→export const nextInvoiceId = createIdGenerator('in', 24);\n    30→\n    31→// eslint-disable-next-line prettier/prettier\n    32→export class Invoice extends Model<InferAttributes<Invoice>, InferCreationAttributes<Invoice>> {\n    33→  declare id: CreationOptional<string>;\n    34→\n    35→  // A unique, identifying string that appears on emails sent to the customer for this invoice\n    36→  declare number: string;\n    37→\n    38→  declare livemode: boolean;\n    39→  declare description?: string;\n    40→  declare statement_descriptor: string;\n    41→  declare period_end: number;\n    42→  declare period_start: number;\n    43→\n    44→  declare auto_advance: boolean;\n    45→  // Whether payment was successfully collected for this invoice\n    46→  declare paid: boolean;\n    47→  // Returns true if the invoice was manually marked paid\n    48→  declare paid_out_of_band: boolean;\n    49→\n    50→  declare status: LiteralUnion<'draft' | 'open' | 'void' | 'paid' | 'uncollectible', string>;\n    51→  declare collection_method: LiteralUnion<'charge_automatically' | 'send_invoice', string>;\n    52→  declare billing_reason: LiteralUnion<\n    53→    | 'subscription_create'\n    54→    | 'subscription_cycle'\n    55→    | 'subscription_update'\n    56→    | 'subscription_recover'\n    57→    | 'subscription_threshold'\n    58→    | 'subscription_cancel'\n    59→    | 'subscription'\n    60→    | 'manual'\n    61→    | 'upcoming'\n    62→    | 'slash_stake'\n    63→    | 'stake'\n    64→    | 'overdraft_protection'\n    65→    | 'stake_overdraft_protection'\n    66→    | 'recharge'\n    67→    | 'auto_recharge',\n    68→    string\n    69→  >;\n    70→\n    71→  declare currency_id: string;\n    72→  declare customer_id: string;\n    73→  declare payment_intent_id?: string;\n    74→  declare subscription_id?: string;\n    75→  declare checkout_session_id?: string;\n    76→  declare quote_id?: string;\n    77→  declare charge_id?: string;\n    78→\n    79→  declare subscription_details?: any;\n    80→  declare subscription_proration_date?: number;\n    81→\n    82→  declare subtotal: string;\n    83→  declare subtotal_excluding_tax: string;\n    84→  declare tax: string;\n    85→  declare total: string;\n    86→\n    87→  declare amount_due: string; // total - amount_paid\n    88→  declare amount_paid: string;\n    89→  declare amount_remaining: string; // amount_due - amount_paid\n    90→  declare amount_shipping: string;\n    91→\n    92→  declare starting_balance: string; // usd credit\n    93→  declare ending_balance: string; // usd credit\n    94→  declare starting_token_balance?: Record<string, string>; // token balances\n    95→  declare ending_token_balance?: Record<string, string>; // token balances\n    96→\n    97→  declare attempt_count: number;\n    98→  declare attempted: boolean;\n    99→  declare next_payment_attempt?: number;\n   100→\n   101→  declare custom_fields?: SimpleCustomField[];\n   102→  declare customer_address?: CustomerAddress;\n   103→  declare customer_email?: string;\n   104→  declare customer_name?: string;\n   105→  declare customer_phone?: string;\n   106→  declare customer_shipping?: CustomerShipping;\n   107→\n   108→  declare discounts?: string[];\n   109→  declare total_discount_amounts?: DiscountAmount[];\n   110→\n   111→  declare due_date?: number;\n   112→  declare effective_at?: number;\n   113→\n   114→  declare footer?: string;\n   115→\n   116→  declare from_invoice?: any;\n   117→\n   118→  declare account_country?: string;\n   119→  declare account_name?: string;\n   120→  declare hosted_invoice_url?: string;\n   121→\n   122→  // The link to download the PDF for the invoice\n   123→  declare invoice_pdf?: string;\n   124→  declare last_finalization_error?: PaymentError;\n   125→  declare latest_revision?: string;\n   126→\n   127→  declare payment_settings?: PaymentSettings;\n   128→  declare default_payment_method_id: string;\n   129→\n   130→  declare post_payment_credit_notes_amount?: string;\n   131→  declare pre_payment_credit_notes_amount?: string;\n   132→\n   133→  declare rendering_options?: any;\n   134→\n   135→  declare status_transitions?: {\n   136→    finalized_at?: number;\n   137→    marked_uncollectible_at?: number;\n   138→    paid_at?: number;\n   139→    voided_at?: number;\n   140→  };\n   141→\n   142→  declare test_clock_id?: string;\n   143→\n   144→  declare threshold_reason?: any;\n   145→\n   146→  declare webhooks_delivered_at?: number;\n   147→\n   148→  // This is the transaction number that appears on email receipts sent for this invoice.\n   149→  declare receipt_number?: string;\n   150→\n   151→  declare metadata?: Record<string, any>;\n   152→\n   153→  // TODO: following fields not supported\n   154→  // account_tax_ids\n   155→  // application\n   156→  // application_fee_amount\n   157→  // automatic_tax\n   158→  // customer_tax_exempt\n   159→  // customer_tax_ids\n   160→  // default_tax_rates\n   161→  // on_behalf_of\n   162→  // shipping_cost\n   163→  // shipping_details\n   164→  // total_tax_amounts\n   165→  // transfer_data\n   166→\n   167→  declare created_at: CreationOptional<Date>;\n   168→  declare updated_at: CreationOptional<Date>;\n   169→\n   170→  public static readonly GENESIS_ATTRIBUTES = {\n   171→    id: {\n   172→      type: DataTypes.STRING(30),\n   173→      primaryKey: true,\n   174→      allowNull: false,\n   175→      defaultValue: nextInvoiceId,\n   176→    },\n   177→    livemode: {\n   178→      type: DataTypes.BOOLEAN,\n   179→      allowNull: false,\n   180→    },\n   181→    auto_advance: {\n   182→      type: DataTypes.BOOLEAN,\n   183→      allowNull: false,\n   184→    },\n   185→    account_country: {\n   186→      type: DataTypes.STRING(64),\n   187→      allowNull: true,\n   188→    },\n   189→    account_name: {\n   190→      type: DataTypes.STRING(64),\n   191→      allowNull: true,\n   192→    },\n   193→    charge_id: {\n   194→      type: DataTypes.STRING(30),\n   195→      allowNull: true,\n   196→    },\n   197→    collection_method: {\n   198→      type: DataTypes.ENUM('charge_automatically', 'send_invoice'),\n   199→      allowNull: false,\n   200→    },\n   201→    currency_id: {\n   202→      type: DataTypes.STRING(15),\n   203→      allowNull: false,\n   204→    },\n   205→    customer_id: {\n   206→      type: DataTypes.STRING(18),\n   207→      allowNull: false,\n   208→    },\n   209→    description: {\n   210→      type: DataTypes.STRING(512),\n   211→      allowNull: true,\n   212→    },\n   213→    hosted_invoice_url: {\n   214→      type: DataTypes.STRING(512),\n   215→      allowNull: true,\n   216→    },\n   217→    payment_intent_id: {\n   218→      type: DataTypes.STRING(30),\n   219→      allowNull: true,\n   220→    },\n   221→    period_end: {\n   222→      type: DataTypes.INTEGER,\n   223→      defaultValue: 0,\n   224→    },\n   225→    period_start: {\n   226→      type: DataTypes.INTEGER,\n   227→      defaultValue: 0,\n   228→    },\n   229→    status: {\n   230→      type: DataTypes.ENUM('draft', 'open', 'void', 'paid', 'uncollectible'),\n   231→      allowNull: false,\n   232→    },\n   233→    checkout_session_id: {\n   234→      type: DataTypes.STRING(64),\n   235→      allowNull: true,\n   236→    },\n   237→    subscription_id: {\n   238→      type: DataTypes.STRING(30),\n   239→      allowNull: true,\n   240→    },\n   241→    subscription_details: {\n   242→      type: DataTypes.JSON,\n   243→      defaultValue: {},\n   244→    },\n   245→    subscription_proration_date: {\n   246→      type: DataTypes.INTEGER,\n   247→      allowNull: true,\n   248→    },\n   249→    total: {\n   250→      type: DataTypes.STRING(32),\n   251→      allowNull: false,\n   252→    },\n   253→    subtotal: {\n   254→      type: DataTypes.STRING(32),\n   255→      allowNull: false,\n   256→    },\n   257→    subtotal_excluding_tax: {\n   258→      type: DataTypes.STRING(32),\n   259→      allowNull: false,\n   260→    },\n   261→    tax: {\n   262→      type: DataTypes.STRING(32),\n   263→      defaultValue: '0',\n   264→    },\n   265→    amount_due: {\n   266→      type: DataTypes.STRING(32),\n   267→      allowNull: false,\n   268→    },\n   269→    amount_paid: {\n   270→      type: DataTypes.STRING(32),\n   271→      defaultValue: '0',\n   272→    },\n   273→    amount_remaining: {\n   274→      type: DataTypes.STRING(32),\n   275→      allowNull: false,\n   276→    },\n   277→    amount_shipping: {\n   278→      type: DataTypes.STRING(32),\n   279→      defaultValue: '0',\n   280→    },\n   281→    attempt_count: {\n   282→      type: DataTypes.INTEGER,\n   283→      defaultValue: 0,\n   284→    },\n   285→    attempted: {\n   286→      type: DataTypes.BOOLEAN,\n   287→      defaultValue: false,\n   288→    },\n   289→    next_payment_attempt: {\n   290→      type: DataTypes.INTEGER,\n   291→      allowNull: true,\n   292→    },\n   293→    billing_reason: {\n   294→      type: DataTypes.ENUM(\n   295→        'subscription_create',\n   296→        'subscription_cycle',\n   297→        'subscription_update',\n   298→        'subscription_threshold',\n   299→        'subscription_cancel',\n   300→        'subscription',\n   301→        'manual',\n   302→        'upcoming',\n   303→        'slash_stake',\n   304→        'stake',\n   305→        'overdraft_protection',\n   306→        'stake_overdraft_protection',\n   307→        'recharge'\n   308→      ),\n   309→    },\n   310→    custom_fields: {\n   311→      type: DataTypes.JSON,\n   312→      defaultValue: [],\n   313→    },\n   314→    customer_address: {\n   315→      type: DataTypes.JSON,\n   316→      allowNull: true,\n   317→    },\n   318→    customer_name: {\n   319→      type: DataTypes.STRING(64),\n   320→      allowNull: true,\n   321→    },\n   322→    customer_email: {\n   323→      type: DataTypes.STRING(128),\n   324→      allowNull: true,\n   325→    },\n   326→    customer_phone: {\n   327→      type: DataTypes.STRING(32),\n   328→      allowNull: true,\n   329→    },\n   330→    customer_shipping: {\n   331→      type: DataTypes.JSON,\n   332→      allowNull: true,\n   333→    },\n   334→    default_payment_method_id: {\n   335→      type: DataTypes.STRING(30),\n   336→      allowNull: true,\n   337→    },\n   338→    discounts: {\n   339→      type: DataTypes.JSON,\n   340→      defaultValue: [],\n   341→    },\n   342→    due_date: {\n   343→      type: DataTypes.INTEGER,\n   344→      allowNull: true,\n   345→    },\n   346→    effective_at: {\n   347→      type: DataTypes.INTEGER,\n   348→      allowNull: true,\n   349→    },\n   350→    ending_balance: {\n   351→      type: DataTypes.STRING(32),\n   352→      defaultValue: '0',\n   353→    },\n   354→    footer: {\n   355→      type: DataTypes.STRING(512),\n   356→      allowNull: true,\n   357→    },\n   358→    from_invoice_id: {\n   359→      type: DataTypes.STRING(30),\n   360→      allowNull: true,\n   361→    },\n   362→    invoice_pdf: {\n   363→      type: DataTypes.STRING(512),\n   364→      allowNull: true,\n   365→    },\n   366→    last_finalization_error: {\n   367→      type: DataTypes.JSON,\n   368→      allowNull: true,\n   369→    },\n   370→    latest_revision: {\n   371→      type: DataTypes.STRING(30),\n   372→      allowNull: true,\n   373→    },\n   374→    number: {\n   375→      type: DataTypes.STRING(64),\n   376→      allowNull: true,\n   377→    },\n   378→    paid: {\n   379→      type: DataTypes.BOOLEAN,\n   380→      defaultValue: false,\n   381→    },\n   382→    paid_out_of_band: {\n   383→      type: DataTypes.BOOLEAN,\n   384→      defaultValue: false,\n   385→    },\n   386→    payment_settings: {\n   387→      type: DataTypes.JSON,\n   388→      allowNull: true,\n   389→    },\n   390→    post_payment_credit_notes_amount: {\n   391→      type: DataTypes.STRING(32),\n   392→      defaultValue: '0',\n   393→    },\n   394→    pre_payment_credit_notes_amount: {\n   395→      type: DataTypes.STRING(32),\n   396→      defaultValue: '0',\n   397→    },\n   398→    quote_id: {\n   399→      type: DataTypes.STRING(30),\n   400→      allowNull: true,\n   401→    },\n   402→    receipt_number: {\n   403→      type: DataTypes.STRING(64),\n   404→      allowNull: true,\n   405→    },\n   406→    days_until_due: {\n   407→      type: DataTypes.NUMBER,\n   408→      allowNull: true,\n   409→    },\n   410→    rendering_options: {\n   411→      type: DataTypes.JSON,\n   412→      allowNull: true,\n   413→    },\n   414→    starting_balance: {\n   415→      type: DataTypes.STRING(32),\n   416→      defaultValue: '0',\n   417→    },\n   418→    statement_descriptor: {\n   419→      type: DataTypes.STRING(64),\n   420→      allowNull: true,\n   421→    },\n   422→    status_transitions: {\n   423→      type: DataTypes.JSON,\n   424→      defaultValue: {},\n   425→    },\n   426→    test_clock_id: {\n   427→      type: DataTypes.STRING(30),\n   428→      allowNull: true,\n   429→    },\n   430→    threshold_reason: {\n   431→      type: DataTypes.JSON,\n   432→      allowNull: true,\n   433→    },\n   434→    total_discount_amounts: {\n   435→      type: DataTypes.JSON,\n   436→      defaultValue: [],\n   437→    },\n   438→    webhooks_delivered_at: {\n   439→      type: DataTypes.INTEGER,\n   440→      allowNull: true,\n   441→    },\n   442→    metadata: {\n   443→      type: DataTypes.JSON,\n   444→      allowNull: true,\n   445→    },\n   446→    created_at: {\n   447→      type: DataTypes.DATE,\n   448→      defaultValue: DataTypes.NOW,\n   449→      allowNull: false,\n   450→    },\n   451→    updated_at: {\n   452→      type: DataTypes.DATE,\n   453→      defaultValue: DataTypes.NOW,\n   454→      allowNull: false,\n   455→    },\n   456→  };\n   457→\n   458→  public static initialize(sequelize: any) {\n   459→    this.init(\n   460→      {\n   461→        ...Invoice.GENESIS_ATTRIBUTES,\n   462→        starting_token_balance: {\n   463→          type: DataTypes.JSON,\n   464→          defaultValue: {},\n   465→        },\n   466→        ending_token_balance: {\n   467→          type: DataTypes.JSON,\n   468→          defaultValue: {},\n   469→        },\n   470→      },\n   471→      {\n   472→        sequelize,\n   473→        modelName: 'Invoice',\n   474→        tableName: 'invoices',\n   475→        createdAt: 'created_at',\n   476→        updatedAt: 'updated_at',\n   477→        hooks: {\n   478→          afterCreate: (model: Invoice, options) => {\n   479→            createEvent('Invoice', 'invoice.created', model, options).catch(console.error);\n   480→            if (model.status === 'paid') {\n   481→              createEvent('Invoice', 'invoice.paid', model, options).catch(console.error);\n   482→            }\n   483→          },\n   484→          afterUpdate: (model: Invoice, options) => {\n   485→            createEvent('Invoice', 'invoice.updated', model, options).catch(console.error);\n   486→            createStatusEvent(\n   487→              'Invoice',\n   488→              'invoice',\n   489→              { open: 'finalized', void: 'voided', paid: 'paid', uncollectible: 'marked_uncollectible' },\n   490→              model,\n   491→              options\n   492→            ).catch(console.error);\n   493→          },\n   494→          afterDestroy: (model: Invoice, options) =>\n   495→            createEvent('Invoice', 'invoice.deleted', model, options).catch(console.error),\n   496→        },\n   497→      }\n   498→    );\n   499→  }\n   500→\n   501→  public static associate(models: any) {\n   502→    this.hasOne(models.PaymentCurrency, {\n   503→      sourceKey: 'currency_id',\n   504→      foreignKey: 'id',\n   505→      as: 'paymentCurrency',\n   506→    });\n   507→    this.hasOne(models.PaymentMethod, {\n   508→      sourceKey: 'default_payment_method_id',\n   509→      foreignKey: 'id',\n   510→      as: 'paymentMethod',\n   511→    });\n   512→    this.hasOne(models.Customer, {\n   513→      sourceKey: 'customer_id',\n   514→      foreignKey: 'id',\n   515→      as: 'customer',\n   516→    });\n   517→    this.hasOne(models.PaymentIntent, {\n   518→      sourceKey: 'payment_intent_id',\n   519→      foreignKey: 'id',\n   520→      as: 'paymentIntent',\n   521→    });\n   522→    this.hasOne(models.Subscription, {\n   523→      sourceKey: 'subscription_id',\n   524→      foreignKey: 'id',\n   525→      as: 'subscription',\n   526→    });\n   527→    this.hasOne(models.SubscriptionItem, {\n   528→      sourceKey: 'id',\n   529→      foreignKey: 'subscription_id',\n   530→      as: 'subscriptionItem',\n   531→    });\n   532→    this.hasMany(models.InvoiceItem, {\n   533→      sourceKey: 'id',\n   534→      foreignKey: 'invoice_id',\n   535→      as: 'lines',\n   536→    });\n   537→  }\n   538→\n   539→  public isImmutable() {\n   540→    return ['paid', 'void'].includes(this.status);\n   541→  }\n   542→\n   543→  private static async _getUncollectibleAmount(\n   544→    where: WhereOptions<Invoice>\n   545→  ): Promise<[GroupedBN, GroupedStrList, Invoice[]]> {\n   546→    const invoices = await Invoice.findAll({ where });\n   547→    const summary: GroupedBN = {};\n   548→    const detail: GroupedStrList = {};\n   549→\n   550→    invoices.forEach((invoice) => {\n   551→      const key = invoice.currency_id;\n   552→      if (!summary[key]) {\n   553→        summary[key] = '0';\n   554→      }\n   555→      if (!detail[key]) {\n   556→        detail[key] = [];\n   557→      }\n   558→\n   559→      summary[key] = new BN(summary[key]).add(new BN(invoice.amount_remaining)).toString();\n   560→      detail[key]!.push(invoice.id);\n   561→    });\n   562→\n   563→    return [summary, detail, invoices];\n   564→  }\n   565→\n   566→  public static getUncollectibleAmount({\n   567→    customerId,\n   568→    subscriptionId,\n   569→    currencyId,\n   570→    excludedInvoiceId,\n   571→    livemode,\n   572→  }: {\n   573→    customerId?: string;\n   574→    subscriptionId?: string;\n   575→    currencyId?: string;\n   576→    excludedInvoiceId?: string;\n   577→    livemode?: boolean;\n   578→  }) {\n   579→    if (!customerId && !subscriptionId) {\n   580→      throw new Error('customerId or subscriptionId is required for getUncollectibleAmount');\n   581→    }\n   582→    const where: WhereOptions<Invoice> = {\n   583→      status: ['uncollectible'],\n   584→      amount_remaining: { [Op.gt]: '0' },\n   585→    };\n   586→    if (currencyId) {\n   587→      where.currency_id = currencyId;\n   588→    }\n   589→    if (customerId) {\n   590→      where.customer_id = customerId;\n   591→    }\n   592→    if (subscriptionId) {\n   593→      where.subscription_id = subscriptionId;\n   594→    }\n   595→    if (excludedInvoiceId) {\n   596→      where.id = { [Op.not]: excludedInvoiceId };\n   597→    }\n   598→    if (typeof livemode === 'boolean') {\n   599→      where.livemode = livemode;\n   600→    }\n   601→\n   602→    return this._getUncollectibleAmount(where);\n   603→  }\n   604→\n   605→  public static getSummary(livemode: boolean = true, field: string = 'status') {\n   606→    return this.findAndCountAll({\n   607→      where: { livemode },\n   608→      attributes: [field, [Sequelize.fn('COUNT', Sequelize.col(field)), 'count']],\n   609→      group: [field],\n   610→      raw: true,\n   611→    }).then((res) => res.rows);\n   612→  }\n   613→}\n   614→\n   615→export type TInvoice = InferAttributes<Invoice>;\n   616→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"587cd2e8-a730-400f-bc03-096a0fc912ab","timestamp":"2026-01-09T01:49:14.892Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice.ts","content":"/* eslint-disable @typescript-eslint/indent */\n/* eslint-disable @typescript-eslint/lines-between-class-members */\nimport { BN } from '@ocap/util';\nimport {\n  CreationOptional,\n  DataTypes,\n  InferAttributes,\n  InferCreationAttributes,\n  Model,\n  Op,\n  Sequelize,\n  WhereOptions,\n} from 'sequelize';\nimport type { LiteralUnion } from 'type-fest';\n\nimport { createEvent, createStatusEvent } from '../../libs/audit';\nimport { createIdGenerator } from '../../libs/util';\nimport type {\n  CustomerAddress,\n  CustomerShipping,\n  DiscountAmount,\n  GroupedBN,\n  GroupedStrList,\n  PaymentError,\n  PaymentSettings,\n  SimpleCustomField,\n} from './types';\n\nexport const nextInvoiceId = createIdGenerator('in', 24);\n\n// eslint-disable-next-line prettier/prettier\nexport class Invoice extends Model<InferAttributes<Invoice>, InferCreationAttributes<Invoice>> {\n  declare id: CreationOptional<string>;\n\n  // A unique, identifying string that appears on emails sent to the customer for this invoice\n  declare number: string;\n\n  declare livemode: boolean;\n  declare description?: string;\n  declare statement_descriptor: string;\n  declare period_end: number;\n  declare period_start: number;\n\n  declare auto_advance: boolean;\n  // Whether payment was successfully collected for this invoice\n  declare paid: boolean;\n  // Returns true if the invoice was manually marked paid\n  declare paid_out_of_band: boolean;\n\n  declare status: LiteralUnion<'draft' | 'open' | 'void' | 'paid' | 'uncollectible', string>;\n  declare collection_method: LiteralUnion<'charge_automatically' | 'send_invoice', string>;\n  declare billing_reason: LiteralUnion<\n    | 'subscription_create'\n    | 'subscription_cycle'\n    | 'subscription_update'\n    | 'subscription_recover'\n    | 'subscription_threshold'\n    | 'subscription_cancel'\n    | 'subscription'\n    | 'manual'\n    | 'upcoming'\n    | 'slash_stake'\n    | 'stake'\n    | 'overdraft_protection'\n    | 'stake_overdraft_protection'\n    | 'recharge'\n    | 'auto_recharge',\n    string\n  >;\n\n  declare currency_id: string;\n  declare customer_id: string;\n  declare payment_intent_id?: string;\n  declare subscription_id?: string;\n  declare checkout_session_id?: string;\n  declare quote_id?: string;\n  declare charge_id?: string;\n\n  declare subscription_details?: any;\n  declare subscription_proration_date?: number;\n\n  declare subtotal: string;\n  declare subtotal_excluding_tax: string;\n  declare tax: string;\n  declare total: string;\n\n  declare amount_due: string; // total - amount_paid\n  declare amount_paid: string;\n  declare amount_remaining: string; // amount_due - amount_paid\n  declare amount_shipping: string;\n\n  declare starting_balance: string; // usd credit\n  declare ending_balance: string; // usd credit\n  declare starting_token_balance?: Record<string, string>; // token balances\n  declare ending_token_balance?: Record<string, string>; // token balances\n\n  declare attempt_count: number;\n  declare attempted: boolean;\n  declare next_payment_attempt?: number;\n\n  declare custom_fields?: SimpleCustomField[];\n  declare customer_address?: CustomerAddress;\n  declare customer_email?: string;\n  declare customer_name?: string;\n  declare customer_phone?: string;\n  declare customer_shipping?: CustomerShipping;\n\n  declare discounts?: string[];\n  declare total_discount_amounts?: DiscountAmount[];\n\n  declare due_date?: number;\n  declare effective_at?: number;\n\n  declare footer?: string;\n\n  declare from_invoice?: any;\n\n  declare account_country?: string;\n  declare account_name?: string;\n  declare hosted_invoice_url?: string;\n\n  // The link to download the PDF for the invoice\n  declare invoice_pdf?: string;\n  declare last_finalization_error?: PaymentError;\n  declare latest_revision?: string;\n\n  declare payment_settings?: PaymentSettings;\n  declare default_payment_method_id: string;\n\n  declare post_payment_credit_notes_amount?: string;\n  declare pre_payment_credit_notes_amount?: string;\n\n  declare rendering_options?: any;\n\n  declare status_transitions?: {\n    finalized_at?: number;\n    marked_uncollectible_at?: number;\n    paid_at?: number;\n    voided_at?: number;\n  };\n\n  declare test_clock_id?: string;\n\n  declare threshold_reason?: any;\n\n  declare webhooks_delivered_at?: number;\n\n  // This is the transaction number that appears on email receipts sent for this invoice.\n  declare receipt_number?: string;\n\n  declare metadata?: Record<string, any>;\n\n  // TODO: following fields not supported\n  // account_tax_ids\n  // application\n  // application_fee_amount\n  // automatic_tax\n  // customer_tax_exempt\n  // customer_tax_ids\n  // default_tax_rates\n  // on_behalf_of\n  // shipping_cost\n  // shipping_details\n  // total_tax_amounts\n  // transfer_data\n\n  declare created_at: CreationOptional<Date>;\n  declare updated_at: CreationOptional<Date>;\n\n  public static readonly GENESIS_ATTRIBUTES = {\n    id: {\n      type: DataTypes.STRING(30),\n      primaryKey: true,\n      allowNull: false,\n      defaultValue: nextInvoiceId,\n    },\n    livemode: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    auto_advance: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    account_country: {\n      type: DataTypes.STRING(64),\n      allowNull: true,\n    },\n    account_name: {\n      type: DataTypes.STRING(64),\n      allowNull: true,\n    },\n    charge_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    collection_method: {\n      type: DataTypes.ENUM('charge_automatically', 'send_invoice'),\n      allowNull: false,\n    },\n    currency_id: {\n      type: DataTypes.STRING(15),\n      allowNull: false,\n    },\n    customer_id: {\n      type: DataTypes.STRING(18),\n      allowNull: false,\n    },\n    description: {\n      type: DataTypes.STRING(512),\n      allowNull: true,\n    },\n    hosted_invoice_url: {\n      type: DataTypes.STRING(512),\n      allowNull: true,\n    },\n    payment_intent_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    period_end: {\n      type: DataTypes.INTEGER,\n      defaultValue: 0,\n    },\n    period_start: {\n      type: DataTypes.INTEGER,\n      defaultValue: 0,\n    },\n    status: {\n      type: DataTypes.ENUM('draft', 'open', 'void', 'paid', 'uncollectible'),\n      allowNull: false,\n    },\n    checkout_session_id: {\n      type: DataTypes.STRING(64),\n      allowNull: true,\n    },\n    subscription_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    subscription_details: {\n      type: DataTypes.JSON,\n      defaultValue: {},\n    },\n    subscription_proration_date: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    total: {\n      type: DataTypes.STRING(32),\n      allowNull: false,\n    },\n    subtotal: {\n      type: DataTypes.STRING(32),\n      allowNull: false,\n    },\n    subtotal_excluding_tax: {\n      type: DataTypes.STRING(32),\n      allowNull: false,\n    },\n    tax: {\n      type: DataTypes.STRING(32),\n      defaultValue: '0',\n    },\n    amount_due: {\n      type: DataTypes.STRING(32),\n      allowNull: false,\n    },\n    amount_paid: {\n      type: DataTypes.STRING(32),\n      defaultValue: '0',\n    },\n    amount_remaining: {\n      type: DataTypes.STRING(32),\n      allowNull: false,\n    },\n    amount_shipping: {\n      type: DataTypes.STRING(32),\n      defaultValue: '0',\n    },\n    attempt_count: {\n      type: DataTypes.INTEGER,\n      defaultValue: 0,\n    },\n    attempted: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: false,\n    },\n    next_payment_attempt: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    billing_reason: {\n      type: DataTypes.ENUM(\n        'subscription_create',\n        'subscription_cycle',\n        'subscription_update',\n        'subscription_threshold',\n        'subscription_cancel',\n        'subscription',\n        'manual',\n        'upcoming',\n        'slash_stake',\n        'stake',\n        'overdraft_protection',\n        'stake_overdraft_protection',\n        'recharge'\n      ),\n    },\n    custom_fields: {\n      type: DataTypes.JSON,\n      defaultValue: [],\n    },\n    customer_address: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    customer_name: {\n      type: DataTypes.STRING(64),\n      allowNull: true,\n    },\n    customer_email: {\n      type: DataTypes.STRING(128),\n      allowNull: true,\n    },\n    customer_phone: {\n      type: DataTypes.STRING(32),\n      allowNull: true,\n    },\n    customer_shipping: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    default_payment_method_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    discounts: {\n      type: DataTypes.JSON,\n      defaultValue: [],\n    },\n    due_date: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    effective_at: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    ending_balance: {\n      type: DataTypes.STRING(32),\n      defaultValue: '0',\n    },\n    footer: {\n      type: DataTypes.STRING(512),\n      allowNull: true,\n    },\n    from_invoice_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    invoice_pdf: {\n      type: DataTypes.STRING(512),\n      allowNull: true,\n    },\n    last_finalization_error: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    latest_revision: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    number: {\n      type: DataTypes.STRING(64),\n      allowNull: true,\n    },\n    paid: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: false,\n    },\n    paid_out_of_band: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: false,\n    },\n    payment_settings: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    post_payment_credit_notes_amount: {\n      type: DataTypes.STRING(32),\n      defaultValue: '0',\n    },\n    pre_payment_credit_notes_amount: {\n      type: DataTypes.STRING(32),\n      defaultValue: '0',\n    },\n    quote_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    receipt_number: {\n      type: DataTypes.STRING(64),\n      allowNull: true,\n    },\n    days_until_due: {\n      type: DataTypes.NUMBER,\n      allowNull: true,\n    },\n    rendering_options: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    starting_balance: {\n      type: DataTypes.STRING(32),\n      defaultValue: '0',\n    },\n    statement_descriptor: {\n      type: DataTypes.STRING(64),\n      allowNull: true,\n    },\n    status_transitions: {\n      type: DataTypes.JSON,\n      defaultValue: {},\n    },\n    test_clock_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    threshold_reason: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    total_discount_amounts: {\n      type: DataTypes.JSON,\n      defaultValue: [],\n    },\n    webhooks_delivered_at: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    metadata: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    created_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n    updated_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n  };\n\n  public static initialize(sequelize: any) {\n    this.init(\n      {\n        ...Invoice.GENESIS_ATTRIBUTES,\n        starting_token_balance: {\n          type: DataTypes.JSON,\n          defaultValue: {},\n        },\n        ending_token_balance: {\n          type: DataTypes.JSON,\n          defaultValue: {},\n        },\n      },\n      {\n        sequelize,\n        modelName: 'Invoice',\n        tableName: 'invoices',\n        createdAt: 'created_at',\n        updatedAt: 'updated_at',\n        hooks: {\n          afterCreate: (model: Invoice, options) => {\n            createEvent('Invoice', 'invoice.created', model, options).catch(console.error);\n            if (model.status === 'paid') {\n              createEvent('Invoice', 'invoice.paid', model, options).catch(console.error);\n            }\n          },\n          afterUpdate: (model: Invoice, options) => {\n            createEvent('Invoice', 'invoice.updated', model, options).catch(console.error);\n            createStatusEvent(\n              'Invoice',\n              'invoice',\n              { open: 'finalized', void: 'voided', paid: 'paid', uncollectible: 'marked_uncollectible' },\n              model,\n              options\n            ).catch(console.error);\n          },\n          afterDestroy: (model: Invoice, options) =>\n            createEvent('Invoice', 'invoice.deleted', model, options).catch(console.error),\n        },\n      }\n    );\n  }\n\n  public static associate(models: any) {\n    this.hasOne(models.PaymentCurrency, {\n      sourceKey: 'currency_id',\n      foreignKey: 'id',\n      as: 'paymentCurrency',\n    });\n    this.hasOne(models.PaymentMethod, {\n      sourceKey: 'default_payment_method_id',\n      foreignKey: 'id',\n      as: 'paymentMethod',\n    });\n    this.hasOne(models.Customer, {\n      sourceKey: 'customer_id',\n      foreignKey: 'id',\n      as: 'customer',\n    });\n    this.hasOne(models.PaymentIntent, {\n      sourceKey: 'payment_intent_id',\n      foreignKey: 'id',\n      as: 'paymentIntent',\n    });\n    this.hasOne(models.Subscription, {\n      sourceKey: 'subscription_id',\n      foreignKey: 'id',\n      as: 'subscription',\n    });\n    this.hasOne(models.SubscriptionItem, {\n      sourceKey: 'id',\n      foreignKey: 'subscription_id',\n      as: 'subscriptionItem',\n    });\n    this.hasMany(models.InvoiceItem, {\n      sourceKey: 'id',\n      foreignKey: 'invoice_id',\n      as: 'lines',\n    });\n  }\n\n  public isImmutable() {\n    return ['paid', 'void'].includes(this.status);\n  }\n\n  private static async _getUncollectibleAmount(\n    where: WhereOptions<Invoice>\n  ): Promise<[GroupedBN, GroupedStrList, Invoice[]]> {\n    const invoices = await Invoice.findAll({ where });\n    const summary: GroupedBN = {};\n    const detail: GroupedStrList = {};\n\n    invoices.forEach((invoice) => {\n      const key = invoice.currency_id;\n      if (!summary[key]) {\n        summary[key] = '0';\n      }\n      if (!detail[key]) {\n        detail[key] = [];\n      }\n\n      summary[key] = new BN(summary[key]).add(new BN(invoice.amount_remaining)).toString();\n      detail[key]!.push(invoice.id);\n    });\n\n    return [summary, detail, invoices];\n  }\n\n  public static getUncollectibleAmount({\n    customerId,\n    subscriptionId,\n    currencyId,\n    excludedInvoiceId,\n    livemode,\n  }: {\n    customerId?: string;\n    subscriptionId?: string;\n    currencyId?: string;\n    excludedInvoiceId?: string;\n    livemode?: boolean;\n  }) {\n    if (!customerId && !subscriptionId) {\n      throw new Error('customerId or subscriptionId is required for getUncollectibleAmount');\n    }\n    const where: WhereOptions<Invoice> = {\n      status: ['uncollectible'],\n      amount_remaining: { [Op.gt]: '0' },\n    };\n    if (currencyId) {\n      where.currency_id = currencyId;\n    }\n    if (customerId) {\n      where.customer_id = customerId;\n    }\n    if (subscriptionId) {\n      where.subscription_id = subscriptionId;\n    }\n    if (excludedInvoiceId) {\n      where.id = { [Op.not]: excludedInvoiceId };\n    }\n    if (typeof livemode === 'boolean') {\n      where.livemode = livemode;\n    }\n\n    return this._getUncollectibleAmount(where);\n  }\n\n  public static getSummary(livemode: boolean = true, field: string = 'status') {\n    return this.findAndCountAll({\n      where: { livemode },\n      attributes: [field, [Sequelize.fn('COUNT', Sequelize.col(field)), 'count']],\n      group: [field],\n      raw: true,\n    }).then((res) => res.rows);\n  }\n}\n\nexport type TInvoice = InferAttributes<Invoice>;\n","numLines":616,"startLine":1,"totalLines":616}}}
{"parentUuid":"587cd2e8-a730-400f-bc03-096a0fc912ab","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EBg42G3FiQoV1s7MDEvz3y","type":"tool_result","content":"     1→import { fromTokenToUnit } from '@ocap/util';\n     2→import isEmpty from 'lodash/isEmpty';\n     3→import omit from 'lodash/omit';\n     4→import pick from 'lodash/pick';\n     5→import {\n     6→  CreationOptional,\n     7→  DataTypes,\n     8→  FindOptions,\n     9→  InferAttributes,\n    10→  InferCreationAttributes,\n    11→  Model,\n    12→  Op,\n    13→  QueryTypes,\n    14→} from 'sequelize';\n    15→import type { LiteralUnion } from 'type-fest';\n    16→\n    17→import { createEvent } from '../../libs/audit';\n    18→import logger from '../../libs/logger';\n    19→import { createIdGenerator, formatMetadata } from '../../libs/util';\n    20→import { sequelize } from '../sequelize';\n    21→import type { TPaymentCurrency } from './payment-currency';\n    22→import type { CustomUnitAmount, LineItem, PriceCurrency, PriceRecurring, PriceTier, TransformQuantity } from './types';\n    23→import { Meter, type TMeter } from './meter';\n    24→\n    25→export const nextPriceId = createIdGenerator('price', 24);\n    26→\n    27→// Duplicate here\n    28→type TPriceExpanded = TPrice & {\n    29→  object: 'price';\n    30→  product: any;\n    31→  currency: TPaymentCurrency;\n    32→  upsell?: {\n    33→    upsells_to: TPriceExpanded;\n    34→    upsells_to_id: string;\n    35→  };\n    36→  meter?: TMeter;\n    37→};\n    38→type TLineItemExpanded = LineItem & { price: TPriceExpanded; upsell_price: TPriceExpanded };\n    39→\n    40→// @link https://stripe.com/docs/api/prices\n    41→export class Price extends Model<InferAttributes<Price>, InferCreationAttributes<Price>> {\n    42→  // Unique identifier for the object.\n    43→  declare id: CreationOptional<string>;\n    44→\n    45→  // the product id\n    46→  declare product_id: string;\n    47→\n    48→  // A brief description of the price, hidden from customers.\n    49→  declare nickname: string | null;\n    50→\n    51→  // Whether the price can be used for new purchases.\n    52→  declare active: boolean;\n    53→  declare livemode: boolean;\n    54→  declare locked: CreationOptional<boolean>;\n    55→\n    56→  // One of one_time or recurring depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.\n    57→  declare type: LiteralUnion<'one_time' | 'recurring', string>;\n    58→\n    59→  // Describes how to compute the price per period.\n    60→  declare billing_scheme: LiteralUnion<'per_unit' | 'tiered', string>;\n    61→\n    62→  // The unit amount in big number to be charged, represented as a whole integer if possible\n    63→  declare unit_amount: string;\n    64→\n    65→  // The recurring components of a price such as interval and usage_type.\n    66→  declare recurring: PriceRecurring | null;\n    67→\n    68→  // Defines if the tiering price should be graduated or volume based.\n    69→  declare tiers_mode: LiteralUnion<'graduated' | 'volume', string> | null;\n    70→\n    71→  // Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered\n    72→  declare tiers: PriceTier[] | null;\n    73→\n    74→  // When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.\n    75→  declare custom_unit_amount: CustomUnitAmount | null;\n    76→\n    77→  // A lookup key used to retrieve prices dynamically from a static string\n    78→  declare lookup_key: string | null;\n    79→\n    80→  // Set of key-value pairs that you can attach to an object.\n    81→  declare metadata: Record<string, any>;\n    82→\n    83→  declare transform_quantity: TransformQuantity | null;\n    84→\n    85→  // Payment currency id\n    86→  declare currency_id: string;\n    87→  declare currency_options: PriceCurrency[];\n    88→\n    89→  declare upsell?: { upsells_to_id: string } | null;\n    90→\n    91→  declare created_at: CreationOptional<Date>;\n    92→  declare created_via: LiteralUnion<'api' | 'dashboard' | 'portal', string>;\n    93→  declare updated_at: CreationOptional<Date>;\n    94→\n    95→  // Quantity available for purchase,  0 means no limit\n    96→  declare quantity_available: number;\n    97→  // Quantity has been sold\n    98→  declare quantity_sold: number;\n    99→  // Quantity limit per checkout, 0 means no limit\n   100→  declare quantity_limit_per_checkout: number;\n   101→\n   102→  declare tax_behavior?: LiteralUnion<'inclusive' | 'exclusive', string>;\n   103→\n   104→  // Dynamic pricing fields\n   105→  declare pricing_type: LiteralUnion<'fixed' | 'dynamic', string>;\n   106→  declare base_currency: string | null;\n   107→  declare base_amount: string | null;\n   108→  declare dynamic_pricing_config: { lock_duration?: number } | null;\n   109→\n   110→  public static readonly GENESIS_ATTRIBUTES = {\n   111→    id: {\n   112→      type: DataTypes.STRING(32),\n   113→      primaryKey: true,\n   114→      allowNull: false,\n   115→      defaultValue: nextPriceId,\n   116→    },\n   117→    product_id: {\n   118→      type: DataTypes.STRING(32),\n   119→      allowNull: false,\n   120→    },\n   121→    nickname: {\n   122→      type: DataTypes.STRING(512),\n   123→    },\n   124→    active: {\n   125→      type: DataTypes.BOOLEAN,\n   126→      allowNull: false,\n   127→    },\n   128→    livemode: {\n   129→      type: DataTypes.BOOLEAN,\n   130→      allowNull: false,\n   131→    },\n   132→    locked: {\n   133→      type: DataTypes.BOOLEAN,\n   134→      defaultValue: false,\n   135→    },\n   136→    type: {\n   137→      type: DataTypes.ENUM('one_time', 'recurring'),\n   138→      allowNull: false,\n   139→    },\n   140→    billing_scheme: {\n   141→      type: DataTypes.ENUM('per_unit', 'tiered'),\n   142→      allowNull: false,\n   143→    },\n   144→    unit_amount: {\n   145→      type: DataTypes.STRING(32),\n   146→      allowNull: false,\n   147→    },\n   148→    recurring: {\n   149→      type: DataTypes.JSON,\n   150→      allowNull: true,\n   151→    },\n   152→    tiers_mode: {\n   153→      type: DataTypes.ENUM('graduated', 'volume'),\n   154→      allowNull: true,\n   155→    },\n   156→    tiers: {\n   157→      type: DataTypes.JSON,\n   158→      allowNull: true,\n   159→    },\n   160→    custom_unit_amount: {\n   161→      type: DataTypes.JSON,\n   162→      allowNull: true,\n   163→    },\n   164→    lookup_key: {\n   165→      type: DataTypes.STRING(128),\n   166→      allowNull: true,\n   167→    },\n   168→    metadata: {\n   169→      type: DataTypes.JSON,\n   170→      allowNull: true,\n   171→    },\n   172→    transform_quantity: {\n   173→      type: DataTypes.JSON,\n   174→      allowNull: true,\n   175→    },\n   176→    currency_id: {\n   177→      type: DataTypes.STRING(16),\n   178→    },\n   179→    currency_options: {\n   180→      type: DataTypes.JSON,\n   181→      defaultValue: [],\n   182→    },\n   183→    created_at: {\n   184→      type: DataTypes.DATE,\n   185→      defaultValue: DataTypes.NOW,\n   186→      allowNull: false,\n   187→    },\n   188→    created_via: {\n   189→      type: DataTypes.ENUM('api', 'dashboard', 'portal'),\n   190→    },\n   191→    updated_at: {\n   192→      type: DataTypes.DATE,\n   193→      defaultValue: DataTypes.NOW,\n   194→      allowNull: false,\n   195→    },\n   196→  };\n   197→\n   198→  // eslint-disable-next-line @typescript-eslint/no-shadow\n   199→  public static initialize(sequelize: any) {\n   200→    this.init(\n   201→      {\n   202→        ...Price.GENESIS_ATTRIBUTES,\n   203→        upsell: {\n   204→          type: DataTypes.JSON,\n   205→          allowNull: true,\n   206→        },\n   207→        quantity_available: {\n   208→          type: DataTypes.INTEGER,\n   209→          defaultValue: 0,\n   210→          allowNull: false,\n   211→        },\n   212→        quantity_sold: {\n   213→          type: DataTypes.INTEGER,\n   214→          defaultValue: 0,\n   215→          allowNull: false,\n   216→        },\n   217→        quantity_limit_per_checkout: {\n   218→          type: DataTypes.INTEGER,\n   219→          defaultValue: 0,\n   220→          allowNull: false,\n   221→        },\n   222→        tax_behavior: {\n   223→          type: DataTypes.ENUM('inclusive', 'exclusive'),\n   224→          allowNull: false,\n   225→          defaultValue: 'inclusive',\n   226→        },\n   227→        pricing_type: {\n   228→          type: DataTypes.ENUM('fixed', 'dynamic'),\n   229→          allowNull: false,\n   230→          defaultValue: 'fixed',\n   231→        },\n   232→        base_currency: {\n   233→          type: DataTypes.STRING(8),\n   234→          allowNull: true,\n   235→        },\n   236→        base_amount: {\n   237→          type: DataTypes.STRING(32),\n   238→          allowNull: true,\n   239→        },\n   240→        dynamic_pricing_config: {\n   241→          type: DataTypes.JSON,\n   242→          allowNull: true,\n   243→        },\n   244→      },\n   245→      {\n   246→        sequelize,\n   247→        modelName: 'Price',\n   248→        tableName: 'prices',\n   249→        createdAt: 'created_at',\n   250→        updatedAt: 'updated_at',\n   251→        hooks: {\n   252→          afterCreate: (model: Price, options) =>\n   253→            createEvent('Price', 'price.created', model, options).catch(console.error),\n   254→          afterUpdate: (model: Price, options) =>\n   255→            createEvent('Price', 'price.updated', model, options).catch(console.error),\n   256→          afterDestroy: (model: Price, options) =>\n   257→            createEvent('Price', 'price.deleted', model, options).catch(console.error),\n   258→        },\n   259→      }\n   260→    );\n   261→  }\n   262→\n   263→  public static associate(models: any) {\n   264→    this.hasOne(models.Product, {\n   265→      sourceKey: 'product_id',\n   266→      foreignKey: 'id',\n   267→      as: 'product',\n   268→    });\n   269→    this.hasOne(models.PaymentCurrency, {\n   270→      sourceKey: 'currency_id',\n   271→      foreignKey: 'id',\n   272→      as: 'currency',\n   273→    });\n   274→  }\n   275→\n   276→  public static getModel(price: TPrice) {\n   277→    if (price.billing_scheme === 'tiered') {\n   278→      return price.tiers_mode;\n   279→    }\n   280→\n   281→    if (price.transform_quantity) {\n   282→      return 'package';\n   283→    }\n   284→\n   285→    return 'standard';\n   286→  }\n   287→\n   288→  public transformQuantity(quantity: number) {\n   289→    if (this.transform_quantity) {\n   290→      if (this.transform_quantity.round === 'up') {\n   291→        return Math.ceil(quantity / this.transform_quantity.divide_by);\n   292→      }\n   293→      return Math.floor(quantity / this.transform_quantity.divide_by);\n   294→    }\n   295→    return quantity;\n   296→  }\n   297→\n   298→  public static formatBeforeSave(price: Partial<TPrice & { model: string }>) {\n   299→    // Validate dynamic pricing fields\n   300→    if (price.pricing_type === 'dynamic') {\n   301→      if (!price.base_currency || !price.base_amount) {\n   302→        throw new Error('base_currency and base_amount are required for dynamic pricing');\n   303→      }\n   304→      if (price.base_currency !== 'USD') {\n   305→        throw new Error('Only USD is supported as base_currency');\n   306→      }\n   307→      // Set default lock_duration if not provided\n   308→      if (!price.dynamic_pricing_config) {\n   309→        price.dynamic_pricing_config = { lock_duration: 300 };\n   310→      }\n   311→    } else if (price.pricing_type === 'fixed') {\n   312→      // Clear dynamic pricing fields for fixed prices\n   313→      price.base_currency = null;\n   314→      price.base_amount = null;\n   315→      price.dynamic_pricing_config = null;\n   316→    }\n   317→\n   318→    if (price.type) {\n   319→      if (price.type === 'recurring') {\n   320→        if (!price.recurring) {\n   321→          throw new Error('recurring config is required for recurring prices');\n   322→        }\n   323→        price.recurring.interval_count = Number(price.recurring.interval_count);\n   324→      } else {\n   325→        price.recurring = null;\n   326→      }\n   327→    }\n   328→\n   329→    if (price.model) {\n   330→      if (['graduated', 'volume'].includes(price.model)) {\n   331→        price.billing_scheme = 'tiered';\n   332→        price.tiers_mode = price.model;\n   333→        if (isEmpty(price.tiers)) {\n   334→          throw new Error('tiers is required for graduated and volume prices');\n   335→        }\n   336→      } else {\n   337→        price.billing_scheme = 'per_unit';\n   338→        price.tiers = null;\n   339→      }\n   340→\n   341→      if (price.model !== 'package') {\n   342→        price.transform_quantity = null;\n   343→      } else if (price.transform_quantity) {\n   344→        price.transform_quantity.divide_by = Number(price.transform_quantity.divide_by) || 1;\n   345→      }\n   346→    }\n   347→\n   348→    price.metadata = formatMetadata(price.metadata);\n   349→\n   350→    if (Array.isArray(price.currency_options)) {\n   351→      price.currency_options = price.currency_options.map((x) =>\n   352→        pick(x, ['currency_id', 'unit_amount', 'tiers', 'custom_unit_amount'])\n   353→      );\n   354→    }\n   355→\n   356→    if (price.quantity_available) {\n   357→      price.quantity_available = Number(price.quantity_available);\n   358→    }\n   359→\n   360→    if (price.quantity_limit_per_checkout) {\n   361→      price.quantity_limit_per_checkout = Number(price.quantity_limit_per_checkout);\n   362→    }\n   363→\n   364→    if (price.quantity_sold) {\n   365→      price.quantity_sold = Number(price.quantity_sold);\n   366→    }\n   367→\n   368→    return price;\n   369→  }\n   370→\n   371→  public static formatAfterRead(doc: TPrice, currencies: TPaymentCurrency[]) {\n   372→    if (doc.currency_options) {\n   373→      doc.currency_options.forEach((x) => {\n   374→        // @ts-ignore\n   375→        x.currency = currencies.find((c) => c.id === x.currency_id);\n   376→      });\n   377→    } else {\n   378→      doc.currency_options = [\n   379→        {\n   380→          currency_id: doc.currency_id,\n   381→          unit_amount: doc.unit_amount,\n   382→          // @ts-ignore\n   383→          currency: doc.currency,\n   384→          tiers: null,\n   385→          custom_unit_amount: null,\n   386→        },\n   387→      ];\n   388→    }\n   389→\n   390→    return doc;\n   391→  }\n   392→\n   393→  public static formatCurrencies(options: PriceCurrency[], currencies: TPaymentCurrency[]) {\n   394→    return options.map((x) => {\n   395→      const currency = currencies.find((c) => c.id === x.currency_id);\n   396→      if (!currency) {\n   397→        throw new Error(`currency ${x.currency_id} used in price not found or inactive`);\n   398→      }\n   399→\n   400→      return omit(\n   401→        {\n   402→          ...x,\n   403→          unit_amount: fromTokenToUnit(x.unit_amount, currency.decimal).toString(),\n   404→          currency,\n   405→        },\n   406→        ['currency']\n   407→      ) as any;\n   408→    });\n   409→  }\n   410→\n   411→  public static async expand(\n   412→    items: LineItem[],\n   413→    { product = true, upsell }: { product?: boolean; upsell?: boolean } = {}\n   414→  ): Promise<TLineItemExpanded[]> {\n   415→    const priceIds: string[] = items\n   416→      .map((i) => i.price_id)\n   417→      .concat(items.map((i) => i.upsell_price_id as string))\n   418→      .filter(Boolean);\n   419→    const prices = await Price.findAll({\n   420→      where: { id: priceIds },\n   421→      include: product ? [{ model: sequelize.models.Product, as: 'product' }] : [],\n   422→    });\n   423→\n   424→    // expand currency_options\n   425→    prices.forEach((x) => {\n   426→      if (!x.currency_options || x.currency_options?.length === 0) {\n   427→        x.currency_options = [\n   428→          {\n   429→            currency_id: x.currency_id,\n   430→            unit_amount: x.unit_amount,\n   431→            tiers: null,\n   432→            custom_unit_amount: null,\n   433→          },\n   434→        ];\n   435→      }\n   436→    });\n   437→\n   438→    // expand upsell\n   439→    if (upsell) {\n   440→      await Promise.all(\n   441→        prices.map(async (x) => {\n   442→          if (x.upsell?.upsells_to_id) {\n   443→            const to = await Price.findByPk(x.upsell?.upsells_to_id);\n   444→            if (to) {\n   445→              // @ts-ignore\n   446→              x.upsell.upsells_to = to;\n   447→            }\n   448→          }\n   449→          if (x.recurring?.meter_id) {\n   450→            // @ts-ignore\n   451→            x.meter = await Meter.findByPk(x.recurring?.meter_id);\n   452→          }\n   453→        })\n   454→      );\n   455→    }\n   456→\n   457→    // @ts-ignore\n   458→    return items.map((x) => ({\n   459→      ...x,\n   460→      price: prices.find((p) => p.id === x.price_id),\n   461→      upsell_price: x.upsell_price_id ? prices.find((p) => p.id === x.upsell_price_id) : null,\n   462→    })) as TLineItemExpanded[];\n   463→  }\n   464→\n   465→  public static async insert(price: TPrice & { model: string }) {\n   466→    if (price.lookup_key) {\n   467→      const exist = await this.count({ where: { lookup_key: price.lookup_key } });\n   468→      if (exist) {\n   469→        throw new Error('lookup_key already exists');\n   470→      }\n   471→    }\n   472→\n   473→    // @ts-ignore\n   474→    return this.create(this.formatBeforeSave({ model: 'standard', ...price }));\n   475→  }\n   476→\n   477→  public static findByPkOrLookupKey(id: string, options: FindOptions<Price> = {}) {\n   478→    return this.findOne({\n   479→      where: { [Op.or]: [{ id }, { lookup_key: id }] },\n   480→      ...options,\n   481→    });\n   482→  }\n   483→\n   484→  public async isUsed(checkProduct: boolean = false) {\n   485→    const { SubscriptionItem, InvoiceItem, Product } = this.sequelize.models;\n   486→\n   487→    let used = checkProduct ? (await Product!.count({ where: { default_price_id: this.id } })) > 0 : false;\n   488→    if (used) {\n   489→      logger.info('Price is used as default product price', { priceId: this.id });\n   490→      return true;\n   491→    }\n   492→\n   493→    // @ts-ignore\n   494→    used = await InvoiceItem!.isPriceUsed(this.id);\n   495→    if (used) {\n   496→      logger.info('Price is used by invoice item', { priceId: this.id });\n   497→      return true;\n   498→    }\n   499→\n   500→    // @ts-ignore\n   501→    used = await SubscriptionItem!.isPriceUsed(this.id);\n   502→    if (used) {\n   503→      logger.info('Price is used by subscription item', { priceId: this.id });\n   504→      return true;\n   505→    }\n   506→\n   507→    // @ts-ignore\n   508→    let [{ count }] = await this.sequelize.query(\n   509→      `SELECT count(*) AS count FROM pricing_tables JOIN json_each(items) AS item ON json_extract(item.value, '$.price_id') = '${this.id}'`,\n   510→      { type: QueryTypes.SELECT }\n   511→    );\n   512→    used = count > 0;\n   513→    if (used) {\n   514→      logger.info('Price is used by pricing table', { priceId: this.id });\n   515→      return true;\n   516→    }\n   517→\n   518→    // @ts-ignore\n   519→    [{ count }] = await this.sequelize.query(\n   520→      `SELECT count(*) AS count FROM payment_links JOIN json_each(line_items) AS item ON json_extract(item.value, '$.price_id') = '${this.id}'`,\n   521→      { type: QueryTypes.SELECT }\n   522→    );\n   523→    used = count > 0;\n   524→    if (used) {\n   525→      logger.info('Price is used by payment link', { priceId: this.id });\n   526→      return true;\n   527→    }\n   528→\n   529→    // @ts-ignore\n   530→    [{ count }] = await this.sequelize.query(\n   531→      `SELECT count(cs.id) AS count FROM checkout_sessions AS cs JOIN json_each(line_items) AS item ON json_extract(item.value, '$.price_id') = '${this.id}' WHERE cs.status != 'expired'`,\n   532→      { type: QueryTypes.SELECT }\n   533→    );\n   534→    used = count > 0;\n   535→    if (used) {\n   536→      logger.info('Price is used by active checkout session', { priceId: this.id });\n   537→      return true;\n   538→    }\n   539→\n   540→    return false;\n   541→  }\n   542→}\n   543→\n   544→export type TPrice = InferAttributes<Price>;\n   545→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7c9f3e78-73a4-42bf-987e-60295e81a391","timestamp":"2026-01-09T01:49:14.892Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts","content":"import { fromTokenToUnit } from '@ocap/util';\nimport isEmpty from 'lodash/isEmpty';\nimport omit from 'lodash/omit';\nimport pick from 'lodash/pick';\nimport {\n  CreationOptional,\n  DataTypes,\n  FindOptions,\n  InferAttributes,\n  InferCreationAttributes,\n  Model,\n  Op,\n  QueryTypes,\n} from 'sequelize';\nimport type { LiteralUnion } from 'type-fest';\n\nimport { createEvent } from '../../libs/audit';\nimport logger from '../../libs/logger';\nimport { createIdGenerator, formatMetadata } from '../../libs/util';\nimport { sequelize } from '../sequelize';\nimport type { TPaymentCurrency } from './payment-currency';\nimport type { CustomUnitAmount, LineItem, PriceCurrency, PriceRecurring, PriceTier, TransformQuantity } from './types';\nimport { Meter, type TMeter } from './meter';\n\nexport const nextPriceId = createIdGenerator('price', 24);\n\n// Duplicate here\ntype TPriceExpanded = TPrice & {\n  object: 'price';\n  product: any;\n  currency: TPaymentCurrency;\n  upsell?: {\n    upsells_to: TPriceExpanded;\n    upsells_to_id: string;\n  };\n  meter?: TMeter;\n};\ntype TLineItemExpanded = LineItem & { price: TPriceExpanded; upsell_price: TPriceExpanded };\n\n// @link https://stripe.com/docs/api/prices\nexport class Price extends Model<InferAttributes<Price>, InferCreationAttributes<Price>> {\n  // Unique identifier for the object.\n  declare id: CreationOptional<string>;\n\n  // the product id\n  declare product_id: string;\n\n  // A brief description of the price, hidden from customers.\n  declare nickname: string | null;\n\n  // Whether the price can be used for new purchases.\n  declare active: boolean;\n  declare livemode: boolean;\n  declare locked: CreationOptional<boolean>;\n\n  // One of one_time or recurring depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.\n  declare type: LiteralUnion<'one_time' | 'recurring', string>;\n\n  // Describes how to compute the price per period.\n  declare billing_scheme: LiteralUnion<'per_unit' | 'tiered', string>;\n\n  // The unit amount in big number to be charged, represented as a whole integer if possible\n  declare unit_amount: string;\n\n  // The recurring components of a price such as interval and usage_type.\n  declare recurring: PriceRecurring | null;\n\n  // Defines if the tiering price should be graduated or volume based.\n  declare tiers_mode: LiteralUnion<'graduated' | 'volume', string> | null;\n\n  // Each element represents a pricing tier. This parameter requires billing_scheme to be set to tiered\n  declare tiers: PriceTier[] | null;\n\n  // When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.\n  declare custom_unit_amount: CustomUnitAmount | null;\n\n  // A lookup key used to retrieve prices dynamically from a static string\n  declare lookup_key: string | null;\n\n  // Set of key-value pairs that you can attach to an object.\n  declare metadata: Record<string, any>;\n\n  declare transform_quantity: TransformQuantity | null;\n\n  // Payment currency id\n  declare currency_id: string;\n  declare currency_options: PriceCurrency[];\n\n  declare upsell?: { upsells_to_id: string } | null;\n\n  declare created_at: CreationOptional<Date>;\n  declare created_via: LiteralUnion<'api' | 'dashboard' | 'portal', string>;\n  declare updated_at: CreationOptional<Date>;\n\n  // Quantity available for purchase,  0 means no limit\n  declare quantity_available: number;\n  // Quantity has been sold\n  declare quantity_sold: number;\n  // Quantity limit per checkout, 0 means no limit\n  declare quantity_limit_per_checkout: number;\n\n  declare tax_behavior?: LiteralUnion<'inclusive' | 'exclusive', string>;\n\n  // Dynamic pricing fields\n  declare pricing_type: LiteralUnion<'fixed' | 'dynamic', string>;\n  declare base_currency: string | null;\n  declare base_amount: string | null;\n  declare dynamic_pricing_config: { lock_duration?: number } | null;\n\n  public static readonly GENESIS_ATTRIBUTES = {\n    id: {\n      type: DataTypes.STRING(32),\n      primaryKey: true,\n      allowNull: false,\n      defaultValue: nextPriceId,\n    },\n    product_id: {\n      type: DataTypes.STRING(32),\n      allowNull: false,\n    },\n    nickname: {\n      type: DataTypes.STRING(512),\n    },\n    active: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    livemode: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    locked: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: false,\n    },\n    type: {\n      type: DataTypes.ENUM('one_time', 'recurring'),\n      allowNull: false,\n    },\n    billing_scheme: {\n      type: DataTypes.ENUM('per_unit', 'tiered'),\n      allowNull: false,\n    },\n    unit_amount: {\n      type: DataTypes.STRING(32),\n      allowNull: false,\n    },\n    recurring: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    tiers_mode: {\n      type: DataTypes.ENUM('graduated', 'volume'),\n      allowNull: true,\n    },\n    tiers: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    custom_unit_amount: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    lookup_key: {\n      type: DataTypes.STRING(128),\n      allowNull: true,\n    },\n    metadata: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    transform_quantity: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    currency_id: {\n      type: DataTypes.STRING(16),\n    },\n    currency_options: {\n      type: DataTypes.JSON,\n      defaultValue: [],\n    },\n    created_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n    created_via: {\n      type: DataTypes.ENUM('api', 'dashboard', 'portal'),\n    },\n    updated_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  public static initialize(sequelize: any) {\n    this.init(\n      {\n        ...Price.GENESIS_ATTRIBUTES,\n        upsell: {\n          type: DataTypes.JSON,\n          allowNull: true,\n        },\n        quantity_available: {\n          type: DataTypes.INTEGER,\n          defaultValue: 0,\n          allowNull: false,\n        },\n        quantity_sold: {\n          type: DataTypes.INTEGER,\n          defaultValue: 0,\n          allowNull: false,\n        },\n        quantity_limit_per_checkout: {\n          type: DataTypes.INTEGER,\n          defaultValue: 0,\n          allowNull: false,\n        },\n        tax_behavior: {\n          type: DataTypes.ENUM('inclusive', 'exclusive'),\n          allowNull: false,\n          defaultValue: 'inclusive',\n        },\n        pricing_type: {\n          type: DataTypes.ENUM('fixed', 'dynamic'),\n          allowNull: false,\n          defaultValue: 'fixed',\n        },\n        base_currency: {\n          type: DataTypes.STRING(8),\n          allowNull: true,\n        },\n        base_amount: {\n          type: DataTypes.STRING(32),\n          allowNull: true,\n        },\n        dynamic_pricing_config: {\n          type: DataTypes.JSON,\n          allowNull: true,\n        },\n      },\n      {\n        sequelize,\n        modelName: 'Price',\n        tableName: 'prices',\n        createdAt: 'created_at',\n        updatedAt: 'updated_at',\n        hooks: {\n          afterCreate: (model: Price, options) =>\n            createEvent('Price', 'price.created', model, options).catch(console.error),\n          afterUpdate: (model: Price, options) =>\n            createEvent('Price', 'price.updated', model, options).catch(console.error),\n          afterDestroy: (model: Price, options) =>\n            createEvent('Price', 'price.deleted', model, options).catch(console.error),\n        },\n      }\n    );\n  }\n\n  public static associate(models: any) {\n    this.hasOne(models.Product, {\n      sourceKey: 'product_id',\n      foreignKey: 'id',\n      as: 'product',\n    });\n    this.hasOne(models.PaymentCurrency, {\n      sourceKey: 'currency_id',\n      foreignKey: 'id',\n      as: 'currency',\n    });\n  }\n\n  public static getModel(price: TPrice) {\n    if (price.billing_scheme === 'tiered') {\n      return price.tiers_mode;\n    }\n\n    if (price.transform_quantity) {\n      return 'package';\n    }\n\n    return 'standard';\n  }\n\n  public transformQuantity(quantity: number) {\n    if (this.transform_quantity) {\n      if (this.transform_quantity.round === 'up') {\n        return Math.ceil(quantity / this.transform_quantity.divide_by);\n      }\n      return Math.floor(quantity / this.transform_quantity.divide_by);\n    }\n    return quantity;\n  }\n\n  public static formatBeforeSave(price: Partial<TPrice & { model: string }>) {\n    // Validate dynamic pricing fields\n    if (price.pricing_type === 'dynamic') {\n      if (!price.base_currency || !price.base_amount) {\n        throw new Error('base_currency and base_amount are required for dynamic pricing');\n      }\n      if (price.base_currency !== 'USD') {\n        throw new Error('Only USD is supported as base_currency');\n      }\n      // Set default lock_duration if not provided\n      if (!price.dynamic_pricing_config) {\n        price.dynamic_pricing_config = { lock_duration: 300 };\n      }\n    } else if (price.pricing_type === 'fixed') {\n      // Clear dynamic pricing fields for fixed prices\n      price.base_currency = null;\n      price.base_amount = null;\n      price.dynamic_pricing_config = null;\n    }\n\n    if (price.type) {\n      if (price.type === 'recurring') {\n        if (!price.recurring) {\n          throw new Error('recurring config is required for recurring prices');\n        }\n        price.recurring.interval_count = Number(price.recurring.interval_count);\n      } else {\n        price.recurring = null;\n      }\n    }\n\n    if (price.model) {\n      if (['graduated', 'volume'].includes(price.model)) {\n        price.billing_scheme = 'tiered';\n        price.tiers_mode = price.model;\n        if (isEmpty(price.tiers)) {\n          throw new Error('tiers is required for graduated and volume prices');\n        }\n      } else {\n        price.billing_scheme = 'per_unit';\n        price.tiers = null;\n      }\n\n      if (price.model !== 'package') {\n        price.transform_quantity = null;\n      } else if (price.transform_quantity) {\n        price.transform_quantity.divide_by = Number(price.transform_quantity.divide_by) || 1;\n      }\n    }\n\n    price.metadata = formatMetadata(price.metadata);\n\n    if (Array.isArray(price.currency_options)) {\n      price.currency_options = price.currency_options.map((x) =>\n        pick(x, ['currency_id', 'unit_amount', 'tiers', 'custom_unit_amount'])\n      );\n    }\n\n    if (price.quantity_available) {\n      price.quantity_available = Number(price.quantity_available);\n    }\n\n    if (price.quantity_limit_per_checkout) {\n      price.quantity_limit_per_checkout = Number(price.quantity_limit_per_checkout);\n    }\n\n    if (price.quantity_sold) {\n      price.quantity_sold = Number(price.quantity_sold);\n    }\n\n    return price;\n  }\n\n  public static formatAfterRead(doc: TPrice, currencies: TPaymentCurrency[]) {\n    if (doc.currency_options) {\n      doc.currency_options.forEach((x) => {\n        // @ts-ignore\n        x.currency = currencies.find((c) => c.id === x.currency_id);\n      });\n    } else {\n      doc.currency_options = [\n        {\n          currency_id: doc.currency_id,\n          unit_amount: doc.unit_amount,\n          // @ts-ignore\n          currency: doc.currency,\n          tiers: null,\n          custom_unit_amount: null,\n        },\n      ];\n    }\n\n    return doc;\n  }\n\n  public static formatCurrencies(options: PriceCurrency[], currencies: TPaymentCurrency[]) {\n    return options.map((x) => {\n      const currency = currencies.find((c) => c.id === x.currency_id);\n      if (!currency) {\n        throw new Error(`currency ${x.currency_id} used in price not found or inactive`);\n      }\n\n      return omit(\n        {\n          ...x,\n          unit_amount: fromTokenToUnit(x.unit_amount, currency.decimal).toString(),\n          currency,\n        },\n        ['currency']\n      ) as any;\n    });\n  }\n\n  public static async expand(\n    items: LineItem[],\n    { product = true, upsell }: { product?: boolean; upsell?: boolean } = {}\n  ): Promise<TLineItemExpanded[]> {\n    const priceIds: string[] = items\n      .map((i) => i.price_id)\n      .concat(items.map((i) => i.upsell_price_id as string))\n      .filter(Boolean);\n    const prices = await Price.findAll({\n      where: { id: priceIds },\n      include: product ? [{ model: sequelize.models.Product, as: 'product' }] : [],\n    });\n\n    // expand currency_options\n    prices.forEach((x) => {\n      if (!x.currency_options || x.currency_options?.length === 0) {\n        x.currency_options = [\n          {\n            currency_id: x.currency_id,\n            unit_amount: x.unit_amount,\n            tiers: null,\n            custom_unit_amount: null,\n          },\n        ];\n      }\n    });\n\n    // expand upsell\n    if (upsell) {\n      await Promise.all(\n        prices.map(async (x) => {\n          if (x.upsell?.upsells_to_id) {\n            const to = await Price.findByPk(x.upsell?.upsells_to_id);\n            if (to) {\n              // @ts-ignore\n              x.upsell.upsells_to = to;\n            }\n          }\n          if (x.recurring?.meter_id) {\n            // @ts-ignore\n            x.meter = await Meter.findByPk(x.recurring?.meter_id);\n          }\n        })\n      );\n    }\n\n    // @ts-ignore\n    return items.map((x) => ({\n      ...x,\n      price: prices.find((p) => p.id === x.price_id),\n      upsell_price: x.upsell_price_id ? prices.find((p) => p.id === x.upsell_price_id) : null,\n    })) as TLineItemExpanded[];\n  }\n\n  public static async insert(price: TPrice & { model: string }) {\n    if (price.lookup_key) {\n      const exist = await this.count({ where: { lookup_key: price.lookup_key } });\n      if (exist) {\n        throw new Error('lookup_key already exists');\n      }\n    }\n\n    // @ts-ignore\n    return this.create(this.formatBeforeSave({ model: 'standard', ...price }));\n  }\n\n  public static findByPkOrLookupKey(id: string, options: FindOptions<Price> = {}) {\n    return this.findOne({\n      where: { [Op.or]: [{ id }, { lookup_key: id }] },\n      ...options,\n    });\n  }\n\n  public async isUsed(checkProduct: boolean = false) {\n    const { SubscriptionItem, InvoiceItem, Product } = this.sequelize.models;\n\n    let used = checkProduct ? (await Product!.count({ where: { default_price_id: this.id } })) > 0 : false;\n    if (used) {\n      logger.info('Price is used as default product price', { priceId: this.id });\n      return true;\n    }\n\n    // @ts-ignore\n    used = await InvoiceItem!.isPriceUsed(this.id);\n    if (used) {\n      logger.info('Price is used by invoice item', { priceId: this.id });\n      return true;\n    }\n\n    // @ts-ignore\n    used = await SubscriptionItem!.isPriceUsed(this.id);\n    if (used) {\n      logger.info('Price is used by subscription item', { priceId: this.id });\n      return true;\n    }\n\n    // @ts-ignore\n    let [{ count }] = await this.sequelize.query(\n      `SELECT count(*) AS count FROM pricing_tables JOIN json_each(items) AS item ON json_extract(item.value, '$.price_id') = '${this.id}'`,\n      { type: QueryTypes.SELECT }\n    );\n    used = count > 0;\n    if (used) {\n      logger.info('Price is used by pricing table', { priceId: this.id });\n      return true;\n    }\n\n    // @ts-ignore\n    [{ count }] = await this.sequelize.query(\n      `SELECT count(*) AS count FROM payment_links JOIN json_each(line_items) AS item ON json_extract(item.value, '$.price_id') = '${this.id}'`,\n      { type: QueryTypes.SELECT }\n    );\n    used = count > 0;\n    if (used) {\n      logger.info('Price is used by payment link', { priceId: this.id });\n      return true;\n    }\n\n    // @ts-ignore\n    [{ count }] = await this.sequelize.query(\n      `SELECT count(cs.id) AS count FROM checkout_sessions AS cs JOIN json_each(line_items) AS item ON json_extract(item.value, '$.price_id') = '${this.id}' WHERE cs.status != 'expired'`,\n      { type: QueryTypes.SELECT }\n    );\n    used = count > 0;\n    if (used) {\n      logger.info('Price is used by active checkout session', { priceId: this.id });\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport type TPrice = InferAttributes<Price>;\n","numLines":545,"startLine":1,"totalLines":545}}}
{"parentUuid":"7c9f3e78-73a4-42bf-987e-60295e81a391","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018PqKnb5Dq12cUALhf4WqLe","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/indent */\n     2→/* eslint-disable @typescript-eslint/lines-between-class-members */\n     3→import { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model, Sequelize } from 'sequelize';\n     4→import type { LiteralUnion } from 'type-fest';\n     5→\n     6→import { createCustomEvent, createEvent, createStatusEvent } from '../../libs/audit';\n     7→import logger from '../../libs/logger';\n     8→import { createIdGenerator } from '../../libs/util';\n     9→import { Invoice } from './invoice';\n    10→import type {\n    11→  PaymentDetails,\n    12→  PaymentSettings,\n    13→  PriceRecurring,\n    14→  ServiceAction,\n    15→  SubscriptionBillingThresholds,\n    16→} from './types';\n    17→\n    18→export const nextSubscriptionId = createIdGenerator('sub', 24);\n    19→\n    20→// FIXME: subscription settings https://dashboard.stripe.com/settings/billing/automatic\n    21→// eslint-disable-next-line prettier/prettier\n    22→export class Subscription extends Model<InferAttributes<Subscription>, InferCreationAttributes<Subscription>> {\n    23→  declare id: CreationOptional<string>;\n    24→\n    25→  declare livemode: boolean;\n    26→\n    27→  declare currency_id: string;\n    28→  declare customer_id: string;\n    29→\n    30→  declare current_period_end: number;\n    31→  declare current_period_start: number;\n    32→\n    33→  declare default_payment_method_id: string;\n    34→  declare description?: string;\n    35→  declare latest_invoice_id?: string;\n    36→\n    37→  declare metadata: Record<string, any>;\n    38→\n    39→  declare pending_setup_intent?: string;\n    40→  declare pending_update?: {\n    41→    billing_cycle_anchor?: number;\n    42→    expires_at?: number;\n    43→    subscription_items?: any[];\n    44→    trial_end?: number;\n    45→    [key: string]: any;\n    46→  };\n    47→\n    48→  declare status: LiteralUnion<\n    49→    'active' | 'past_due' | 'paused' | 'canceled' | 'incomplete' | 'incomplete_expired' | 'trialing',\n    50→    string\n    51→  >;\n    52→\n    53→  declare cancel_at_period_end: boolean;\n    54→  declare cancel_at: CreationOptional<number>;\n    55→  declare canceled_at: CreationOptional<number>;\n    56→  declare cancelation_details?: {\n    57→    comment: string;\n    58→    feedback: LiteralUnion<\n    59→      | 'too_expensive'\n    60→      | 'missing_features'\n    61→      | 'switched_service'\n    62→      | 'unused'\n    63→      | 'customer_service'\n    64→      | 'too_complex'\n    65→      | 'low_quality'\n    66→      | 'other',\n    67→      string\n    68→    >;\n    69→    reason: LiteralUnion<'cancellation_requested' | 'payment_disputed' | 'payment_failed' | 'stake_revoked', string>;\n    70→    return_stake?: boolean;\n    71→    slash_stake?: boolean;\n    72→    slash_reason?: string;\n    73→    refund?: LiteralUnion<'last' | 'proration' | 'none', string>;\n    74→    requested_by?: string;\n    75→  };\n    76→\n    77→  declare billing_cycle_anchor: number;\n    78→  declare billing_thresholds?: SubscriptionBillingThresholds;\n    79→\n    80→  declare collection_method: LiteralUnion<'charge_automatically' | 'send_invoice', string>;\n    81→\n    82→  // Number of days a customer has to pay invoices generated by this subscription.\n    83→  declare days_until_due?: number;\n    84→\n    85→  // Number of days a subscription is canceled after past_due\n    86→  declare days_until_cancel?: number;\n    87→\n    88→  declare discount_id?: string;\n    89→\n    90→  declare next_pending_invoice_item_invoice?: number;\n    91→\n    92→  declare pause_collection?: {\n    93→    behavior: LiteralUnion<'keep_as_draft' | 'mark_uncollectible' | 'void', string>;\n    94→    resumes_at: number;\n    95→  };\n    96→\n    97→  declare payment_settings?: PaymentSettings;\n    98→\n    99→  declare pending_invoice_item_interval: PriceRecurring;\n   100→\n   101→  declare schedule_id?: string;\n   102→\n   103→  // If the subscription has ended, the date the subscription ended.\n   104→  declare ended_at?: number;\n   105→  declare start_date: number;\n   106→  declare trial_end?: number;\n   107→  declare trial_start?: number;\n   108→  declare trial_settings?: {\n   109→    end_behavior: {\n   110→      missing_payment_method: LiteralUnion<'cancel' | 'pause' | 'create_invoice', string>;\n   111→    };\n   112→  };\n   113→\n   114→  // 3rd party payment tx hash\n   115→  declare payment_details?: PaymentDetails;\n   116→\n   117→  declare proration_behavior?: LiteralUnion<'always_invoice' | 'create_prorations' | 'none', string>;\n   118→  declare payment_behavior?: LiteralUnion<'allow_incomplete' | 'error_if_incomplete' | 'pending_if_incomplete', string>;\n   119→\n   120→  declare service_actions?: ServiceAction[];\n   121→\n   122→  declare recovered_from?: string;\n   123→\n   124→  // TODO: following fields not supported\n   125→  // application\n   126→  // application_fee_percent\n   127→  // automatic_tax\n   128→  // default_tax_rates\n   129→  // on_behalf_of\n   130→  // transfer_data\n   131→\n   132→  declare created_at: CreationOptional<Date>;\n   133→  declare updated_at: CreationOptional<Date>;\n   134→\n   135→  declare overdraft_protection?: {\n   136→    enabled: boolean;\n   137→    payment_method_id: string;\n   138→    payment_details: PaymentDetails;\n   139→  };\n   140→\n   141→  public static readonly GENESIS_ATTRIBUTES = {\n   142→    id: {\n   143→      type: DataTypes.STRING(30),\n   144→      primaryKey: true,\n   145→      allowNull: false,\n   146→      defaultValue: nextSubscriptionId,\n   147→    },\n   148→    livemode: {\n   149→      type: DataTypes.BOOLEAN,\n   150→      allowNull: false,\n   151→    },\n   152→    currency_id: {\n   153→      type: DataTypes.STRING(15),\n   154→      allowNull: false,\n   155→    },\n   156→    customer_id: {\n   157→      type: DataTypes.STRING(18),\n   158→      allowNull: false,\n   159→    },\n   160→    cancel_at_period_end: {\n   161→      type: DataTypes.BOOLEAN,\n   162→      allowNull: false,\n   163→    },\n   164→    current_period_end: {\n   165→      type: DataTypes.INTEGER,\n   166→      allowNull: false,\n   167→    },\n   168→    current_period_start: {\n   169→      type: DataTypes.INTEGER,\n   170→      allowNull: false,\n   171→    },\n   172→    default_payment_method_id: {\n   173→      type: DataTypes.STRING(30),\n   174→      allowNull: true,\n   175→    },\n   176→    description: {\n   177→      type: DataTypes.STRING(512),\n   178→      allowNull: true,\n   179→    },\n   180→    latest_invoice_id: {\n   181→      type: DataTypes.STRING(30),\n   182→      allowNull: true,\n   183→    },\n   184→    pending_setup_intent: {\n   185→      type: DataTypes.STRING(30),\n   186→      allowNull: true,\n   187→    },\n   188→    pending_update: {\n   189→      type: DataTypes.JSON,\n   190→      allowNull: true,\n   191→    },\n   192→    status: {\n   193→      type: DataTypes.ENUM('active', 'canceled', 'incomplete', 'incomplete_expired', 'past_due', 'trialing', 'paused'),\n   194→      allowNull: false,\n   195→    },\n   196→    // 将来在什么时候这个订阅会被取消\n   197→    cancel_at: {\n   198→      type: DataTypes.INTEGER,\n   199→      allowNull: true,\n   200→    },\n   201→    // 什么时候开始说要去取消订阅的\n   202→    canceled_at: {\n   203→      type: DataTypes.INTEGER,\n   204→      allowNull: true,\n   205→    },\n   206→    cancelation_details: {\n   207→      type: DataTypes.JSON,\n   208→      allowNull: true,\n   209→    },\n   210→    billing_cycle_anchor: {\n   211→      type: DataTypes.INTEGER,\n   212→      allowNull: false,\n   213→    },\n   214→    billing_thresholds: {\n   215→      type: DataTypes.JSON,\n   216→      allowNull: true,\n   217→    },\n   218→    collection_method: {\n   219→      type: DataTypes.ENUM('charge_automatically', 'send_invoice'),\n   220→      allowNull: false,\n   221→    },\n   222→    days_until_due: {\n   223→      type: DataTypes.NUMBER,\n   224→      allowNull: true,\n   225→    },\n   226→    discount_id: {\n   227→      type: DataTypes.STRING(30),\n   228→      allowNull: true,\n   229→    },\n   230→    next_pending_invoice_item_invoice_id: {\n   231→      type: DataTypes.STRING(30),\n   232→      allowNull: true,\n   233→    },\n   234→    pause_collection: {\n   235→      type: DataTypes.JSON,\n   236→      allowNull: true,\n   237→    },\n   238→    payment_settings: {\n   239→      type: DataTypes.JSON,\n   240→      allowNull: true,\n   241→    },\n   242→    pending_invoice_item_interval: {\n   243→      type: DataTypes.JSON,\n   244→      allowNull: false,\n   245→    },\n   246→    schedule_id: {\n   247→      type: DataTypes.STRING(30),\n   248→      allowNull: true,\n   249→    },\n   250→    end_at: {\n   251→      type: DataTypes.INTEGER,\n   252→      allowNull: true,\n   253→    },\n   254→    start_date: {\n   255→      type: DataTypes.INTEGER,\n   256→      allowNull: false,\n   257→    },\n   258→    payment_details: {\n   259→      type: DataTypes.JSON,\n   260→      allowNull: true,\n   261→    },\n   262→    metadata: {\n   263→      type: DataTypes.JSON,\n   264→      allowNull: true,\n   265→    },\n   266→    created_at: {\n   267→      type: DataTypes.DATE,\n   268→      defaultValue: DataTypes.NOW,\n   269→      allowNull: false,\n   270→    },\n   271→    updated_at: {\n   272→      type: DataTypes.DATE,\n   273→      defaultValue: DataTypes.NOW,\n   274→      allowNull: false,\n   275→    },\n   276→  };\n   277→\n   278→  public static initialize(sequelize: any) {\n   279→    this.init(\n   280→      {\n   281→        ...Subscription.GENESIS_ATTRIBUTES,\n   282→        proration_behavior: {\n   283→          type: DataTypes.ENUM('always_invoice', 'create_prorations', 'none'),\n   284→          defaultValue: 'none',\n   285→        },\n   286→        payment_behavior: {\n   287→          type: DataTypes.ENUM(\n   288→            'default_incomplete',\n   289→            'allow_incomplete',\n   290→            'error_if_incomplete',\n   291→            'pending_if_incomplete'\n   292→          ),\n   293→          defaultValue: 'default_incomplete',\n   294→        },\n   295→        days_until_cancel: {\n   296→          type: DataTypes.NUMBER,\n   297→          allowNull: true,\n   298→        },\n   299→        service_actions: {\n   300→          type: DataTypes.JSON,\n   301→          allowNull: true,\n   302→          defaultValue: [],\n   303→        },\n   304→        trial_end: {\n   305→          type: DataTypes.INTEGER,\n   306→          allowNull: true,\n   307→        },\n   308→        trial_start: {\n   309→          type: DataTypes.INTEGER,\n   310→          allowNull: true,\n   311→        },\n   312→        trial_settings: {\n   313→          type: DataTypes.JSON,\n   314→          allowNull: true,\n   315→        },\n   316→        recovered_from: {\n   317→          type: DataTypes.STRING(40),\n   318→          allowNull: true,\n   319→        },\n   320→        overdraft_protection: {\n   321→          type: DataTypes.JSON,\n   322→          allowNull: true,\n   323→          defaultValue: {\n   324→            enabled: false,\n   325→            payment_method_id: null,\n   326→            payment_details: null,\n   327→          },\n   328→        },\n   329→      },\n   330→      {\n   331→        sequelize,\n   332→        modelName: 'Subscription',\n   333→        tableName: 'subscriptions',\n   334→        createdAt: 'created_at',\n   335→        updatedAt: 'updated_at',\n   336→        hooks: {\n   337→          afterCreate: (model: Subscription, options) => {\n   338→            createEvent('Subscription', 'customer.subscription.created', model, options).catch(console.error);\n   339→          },\n   340→          afterUpdate: async (model: Subscription, options) => {\n   341→            createEvent('Subscription', 'customer.subscription.updated', model, options).catch(console.error);\n   342→\n   343→            if (model.trial_start) {\n   344→              const previousLatestInvoiceId = model.previous('latest_invoice_id');\n   345→\n   346→              if (\n   347→                previousLatestInvoiceId &&\n   348→                model.latest_invoice_id &&\n   349→                previousLatestInvoiceId !== model.latest_invoice_id\n   350→              ) {\n   351→                const count: number = await Invoice.count({\n   352→                  where: {\n   353→                    subscription_id: model.id,\n   354→                  },\n   355→                });\n   356→                if (count === 2) {\n   357→                  // 当且仅当 有试用期的订阅更新了 && 恰好有 2 次账单,此时订阅的试用期刚好结束\n   358→                  createEvent('Subscription', 'customer.subscription.trial_end', model, options).catch(console.error);\n   359→                }\n   360→              }\n   361→            }\n   362→\n   363→            createStatusEvent(\n   364→              'Subscription',\n   365→              'customer.subscription',\n   366→              { canceled: 'deleted', past_due: 'past_due' },\n   367→              model,\n   368→              options\n   369→            ).catch(console.error);\n   370→            createCustomEvent('Subscription', 'customer.subscription', getSubscriptionEventType, model, options).catch(\n   371→              console.error\n   372→            );\n   373→          },\n   374→        },\n   375→      }\n   376→    );\n   377→  }\n   378→\n   379→  public static associate(models: any) {\n   380→    this.hasOne(models.PaymentCurrency, {\n   381→      sourceKey: 'currency_id',\n   382→      foreignKey: 'id',\n   383→      as: 'paymentCurrency',\n   384→    });\n   385→    this.hasOne(models.PaymentMethod, {\n   386→      sourceKey: 'default_payment_method_id',\n   387→      foreignKey: 'id',\n   388→      as: 'paymentMethod',\n   389→    });\n   390→    this.hasOne(models.Customer, {\n   391→      sourceKey: 'customer_id',\n   392→      foreignKey: 'id',\n   393→      as: 'customer',\n   394→    });\n   395→    this.hasMany(models.SubscriptionItem, {\n   396→      foreignKey: 'subscription_id',\n   397→      as: 'items',\n   398→    });\n   399→  }\n   400→\n   401→  public isImmutable() {\n   402→    return ['canceled', 'incomplete_expired'].includes(this.status);\n   403→  }\n   404→\n   405→  public isActive() {\n   406→    return ['active', 'trialing'].includes(this.status);\n   407→  }\n   408→\n   409→  public isScheduledToCancel() {\n   410→    return this.isActive() && (!!this.cancel_at_period_end || !!this.cancel_at);\n   411→  }\n   412→\n   413→  public async isConsumesCredit(): Promise<boolean> {\n   414→    // @ts-ignore\n   415→    const { SubscriptionItem, Price } = this.sequelize.models;\n   416→    if (!SubscriptionItem || !Price) {\n   417→      return false;\n   418→    }\n   419→\n   420→    // 查询订阅的所有价格项\n   421→    const items = await SubscriptionItem.findAll({\n   422→      where: { subscription_id: this.id },\n   423→      include: [\n   424→        {\n   425→          model: Price,\n   426→          as: 'price',\n   427→        },\n   428→      ],\n   429→    });\n   430→\n   431→    return items.some((item: any) => {\n   432→      const recurring = item.price?.recurring;\n   433→      return recurring && recurring.usage_type === 'metered' && recurring.meter_id;\n   434→    });\n   435→  }\n   436→\n   437→  public async start() {\n   438→    if (this.status === 'active') {\n   439→      logger.warn(`subscription already active: ${this.id}`);\n   440→      return false;\n   441→    }\n   442→\n   443→    if (this.isImmutable()) {\n   444→      logger.warn(`subscription is immutable: ${this.id}`);\n   445→      return false;\n   446→    }\n   447→\n   448→    if (this.trial_end && this.trial_end > Date.now() / 1000) {\n   449→      if (this.status !== 'trialing') {\n   450→        await this.update({ status: 'trialing' });\n   451→        createEvent('Subscription', 'customer.subscription.trial_start', this).catch(console.error);\n   452→      }\n   453→    } else {\n   454→      await this.update({ status: 'active' });\n   455→      createEvent('Subscription', 'customer.subscription.started', this).catch(console.error);\n   456→    }\n   457→\n   458→    return true;\n   459→  }\n   460→\n   461→  public static getSummary(livemode: boolean = true, field: string = 'status') {\n   462→    return this.findAndCountAll({\n   463→      where: { livemode },\n   464→      attributes: [field, [Sequelize.fn('COUNT', Sequelize.col(field)), 'count']],\n   465→      group: [field],\n   466→      raw: true,\n   467→    }).then((res) => res.rows);\n   468→  }\n   469→\n   470→  public static async getToSubscriptions(subscriptionId: string): Promise<string[]> {\n   471→    const subscriptions = [];\n   472→    let cursor = subscriptionId;\n   473→    do {\n   474→      // eslint-disable-next-line no-await-in-loop\n   475→      const from = await this.findOne({ where: { recovered_from: cursor } });\n   476→      if (from) {\n   477→        cursor = from.id;\n   478→        subscriptions.push(cursor);\n   479→      } else {\n   480→        cursor = '';\n   481→      }\n   482→    } while (cursor);\n   483→\n   484→    return subscriptions;\n   485→  }\n   486→\n   487→  public static async getFromSubscriptions(subscriptionId: string): Promise<string[]> {\n   488→    const subscriptions = [];\n   489→    let cursor = subscriptionId;\n   490→    do {\n   491→      // eslint-disable-next-line no-await-in-loop\n   492→      const to = await this.findOne({ where: { id: cursor } });\n   493→      if (to?.recovered_from) {\n   494→        cursor = to.recovered_from;\n   495→        subscriptions.push(cursor);\n   496→      } else {\n   497→        cursor = '';\n   498→      }\n   499→    } while (cursor);\n   500→\n   501→    return subscriptions;\n   502→  }\n   503→}\n   504→\n   505→export type TSubscription = InferAttributes<Subscription>;\n   506→\n   507→export function getSubscriptionEventType(current: TSubscription, previous: Partial<TSubscription>) {\n   508→  if (current.pause_collection && !previous.pause_collection) {\n   509→    return 'paused';\n   510→  }\n   511→  if (!current.pause_collection && previous.pause_collection) {\n   512→    return 'resumed';\n   513→  }\n   514→\n   515→  return '';\n   516→}\n   517→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"481243f8-98e6-4939-8387-f2a0effa6fe6","timestamp":"2026-01-09T01:49:14.893Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription.ts","content":"/* eslint-disable @typescript-eslint/indent */\n/* eslint-disable @typescript-eslint/lines-between-class-members */\nimport { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model, Sequelize } from 'sequelize';\nimport type { LiteralUnion } from 'type-fest';\n\nimport { createCustomEvent, createEvent, createStatusEvent } from '../../libs/audit';\nimport logger from '../../libs/logger';\nimport { createIdGenerator } from '../../libs/util';\nimport { Invoice } from './invoice';\nimport type {\n  PaymentDetails,\n  PaymentSettings,\n  PriceRecurring,\n  ServiceAction,\n  SubscriptionBillingThresholds,\n} from './types';\n\nexport const nextSubscriptionId = createIdGenerator('sub', 24);\n\n// FIXME: subscription settings https://dashboard.stripe.com/settings/billing/automatic\n// eslint-disable-next-line prettier/prettier\nexport class Subscription extends Model<InferAttributes<Subscription>, InferCreationAttributes<Subscription>> {\n  declare id: CreationOptional<string>;\n\n  declare livemode: boolean;\n\n  declare currency_id: string;\n  declare customer_id: string;\n\n  declare current_period_end: number;\n  declare current_period_start: number;\n\n  declare default_payment_method_id: string;\n  declare description?: string;\n  declare latest_invoice_id?: string;\n\n  declare metadata: Record<string, any>;\n\n  declare pending_setup_intent?: string;\n  declare pending_update?: {\n    billing_cycle_anchor?: number;\n    expires_at?: number;\n    subscription_items?: any[];\n    trial_end?: number;\n    [key: string]: any;\n  };\n\n  declare status: LiteralUnion<\n    'active' | 'past_due' | 'paused' | 'canceled' | 'incomplete' | 'incomplete_expired' | 'trialing',\n    string\n  >;\n\n  declare cancel_at_period_end: boolean;\n  declare cancel_at: CreationOptional<number>;\n  declare canceled_at: CreationOptional<number>;\n  declare cancelation_details?: {\n    comment: string;\n    feedback: LiteralUnion<\n      | 'too_expensive'\n      | 'missing_features'\n      | 'switched_service'\n      | 'unused'\n      | 'customer_service'\n      | 'too_complex'\n      | 'low_quality'\n      | 'other',\n      string\n    >;\n    reason: LiteralUnion<'cancellation_requested' | 'payment_disputed' | 'payment_failed' | 'stake_revoked', string>;\n    return_stake?: boolean;\n    slash_stake?: boolean;\n    slash_reason?: string;\n    refund?: LiteralUnion<'last' | 'proration' | 'none', string>;\n    requested_by?: string;\n  };\n\n  declare billing_cycle_anchor: number;\n  declare billing_thresholds?: SubscriptionBillingThresholds;\n\n  declare collection_method: LiteralUnion<'charge_automatically' | 'send_invoice', string>;\n\n  // Number of days a customer has to pay invoices generated by this subscription.\n  declare days_until_due?: number;\n\n  // Number of days a subscription is canceled after past_due\n  declare days_until_cancel?: number;\n\n  declare discount_id?: string;\n\n  declare next_pending_invoice_item_invoice?: number;\n\n  declare pause_collection?: {\n    behavior: LiteralUnion<'keep_as_draft' | 'mark_uncollectible' | 'void', string>;\n    resumes_at: number;\n  };\n\n  declare payment_settings?: PaymentSettings;\n\n  declare pending_invoice_item_interval: PriceRecurring;\n\n  declare schedule_id?: string;\n\n  // If the subscription has ended, the date the subscription ended.\n  declare ended_at?: number;\n  declare start_date: number;\n  declare trial_end?: number;\n  declare trial_start?: number;\n  declare trial_settings?: {\n    end_behavior: {\n      missing_payment_method: LiteralUnion<'cancel' | 'pause' | 'create_invoice', string>;\n    };\n  };\n\n  // 3rd party payment tx hash\n  declare payment_details?: PaymentDetails;\n\n  declare proration_behavior?: LiteralUnion<'always_invoice' | 'create_prorations' | 'none', string>;\n  declare payment_behavior?: LiteralUnion<'allow_incomplete' | 'error_if_incomplete' | 'pending_if_incomplete', string>;\n\n  declare service_actions?: ServiceAction[];\n\n  declare recovered_from?: string;\n\n  // TODO: following fields not supported\n  // application\n  // application_fee_percent\n  // automatic_tax\n  // default_tax_rates\n  // on_behalf_of\n  // transfer_data\n\n  declare created_at: CreationOptional<Date>;\n  declare updated_at: CreationOptional<Date>;\n\n  declare overdraft_protection?: {\n    enabled: boolean;\n    payment_method_id: string;\n    payment_details: PaymentDetails;\n  };\n\n  public static readonly GENESIS_ATTRIBUTES = {\n    id: {\n      type: DataTypes.STRING(30),\n      primaryKey: true,\n      allowNull: false,\n      defaultValue: nextSubscriptionId,\n    },\n    livemode: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    currency_id: {\n      type: DataTypes.STRING(15),\n      allowNull: false,\n    },\n    customer_id: {\n      type: DataTypes.STRING(18),\n      allowNull: false,\n    },\n    cancel_at_period_end: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    current_period_end: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n    },\n    current_period_start: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n    },\n    default_payment_method_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    description: {\n      type: DataTypes.STRING(512),\n      allowNull: true,\n    },\n    latest_invoice_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    pending_setup_intent: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    pending_update: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    status: {\n      type: DataTypes.ENUM('active', 'canceled', 'incomplete', 'incomplete_expired', 'past_due', 'trialing', 'paused'),\n      allowNull: false,\n    },\n    // 将来在什么时候这个订阅会被取消\n    cancel_at: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    // 什么时候开始说要去取消订阅的\n    canceled_at: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    cancelation_details: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    billing_cycle_anchor: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n    },\n    billing_thresholds: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    collection_method: {\n      type: DataTypes.ENUM('charge_automatically', 'send_invoice'),\n      allowNull: false,\n    },\n    days_until_due: {\n      type: DataTypes.NUMBER,\n      allowNull: true,\n    },\n    discount_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    next_pending_invoice_item_invoice_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    pause_collection: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    payment_settings: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    pending_invoice_item_interval: {\n      type: DataTypes.JSON,\n      allowNull: false,\n    },\n    schedule_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    end_at: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    start_date: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n    },\n    payment_details: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    metadata: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    created_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n    updated_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n  };\n\n  public static initialize(sequelize: any) {\n    this.init(\n      {\n        ...Subscription.GENESIS_ATTRIBUTES,\n        proration_behavior: {\n          type: DataTypes.ENUM('always_invoice', 'create_prorations', 'none'),\n          defaultValue: 'none',\n        },\n        payment_behavior: {\n          type: DataTypes.ENUM(\n            'default_incomplete',\n            'allow_incomplete',\n            'error_if_incomplete',\n            'pending_if_incomplete'\n          ),\n          defaultValue: 'default_incomplete',\n        },\n        days_until_cancel: {\n          type: DataTypes.NUMBER,\n          allowNull: true,\n        },\n        service_actions: {\n          type: DataTypes.JSON,\n          allowNull: true,\n          defaultValue: [],\n        },\n        trial_end: {\n          type: DataTypes.INTEGER,\n          allowNull: true,\n        },\n        trial_start: {\n          type: DataTypes.INTEGER,\n          allowNull: true,\n        },\n        trial_settings: {\n          type: DataTypes.JSON,\n          allowNull: true,\n        },\n        recovered_from: {\n          type: DataTypes.STRING(40),\n          allowNull: true,\n        },\n        overdraft_protection: {\n          type: DataTypes.JSON,\n          allowNull: true,\n          defaultValue: {\n            enabled: false,\n            payment_method_id: null,\n            payment_details: null,\n          },\n        },\n      },\n      {\n        sequelize,\n        modelName: 'Subscription',\n        tableName: 'subscriptions',\n        createdAt: 'created_at',\n        updatedAt: 'updated_at',\n        hooks: {\n          afterCreate: (model: Subscription, options) => {\n            createEvent('Subscription', 'customer.subscription.created', model, options).catch(console.error);\n          },\n          afterUpdate: async (model: Subscription, options) => {\n            createEvent('Subscription', 'customer.subscription.updated', model, options).catch(console.error);\n\n            if (model.trial_start) {\n              const previousLatestInvoiceId = model.previous('latest_invoice_id');\n\n              if (\n                previousLatestInvoiceId &&\n                model.latest_invoice_id &&\n                previousLatestInvoiceId !== model.latest_invoice_id\n              ) {\n                const count: number = await Invoice.count({\n                  where: {\n                    subscription_id: model.id,\n                  },\n                });\n                if (count === 2) {\n                  // 当且仅当 有试用期的订阅更新了 && 恰好有 2 次账单,此时订阅的试用期刚好结束\n                  createEvent('Subscription', 'customer.subscription.trial_end', model, options).catch(console.error);\n                }\n              }\n            }\n\n            createStatusEvent(\n              'Subscription',\n              'customer.subscription',\n              { canceled: 'deleted', past_due: 'past_due' },\n              model,\n              options\n            ).catch(console.error);\n            createCustomEvent('Subscription', 'customer.subscription', getSubscriptionEventType, model, options).catch(\n              console.error\n            );\n          },\n        },\n      }\n    );\n  }\n\n  public static associate(models: any) {\n    this.hasOne(models.PaymentCurrency, {\n      sourceKey: 'currency_id',\n      foreignKey: 'id',\n      as: 'paymentCurrency',\n    });\n    this.hasOne(models.PaymentMethod, {\n      sourceKey: 'default_payment_method_id',\n      foreignKey: 'id',\n      as: 'paymentMethod',\n    });\n    this.hasOne(models.Customer, {\n      sourceKey: 'customer_id',\n      foreignKey: 'id',\n      as: 'customer',\n    });\n    this.hasMany(models.SubscriptionItem, {\n      foreignKey: 'subscription_id',\n      as: 'items',\n    });\n  }\n\n  public isImmutable() {\n    return ['canceled', 'incomplete_expired'].includes(this.status);\n  }\n\n  public isActive() {\n    return ['active', 'trialing'].includes(this.status);\n  }\n\n  public isScheduledToCancel() {\n    return this.isActive() && (!!this.cancel_at_period_end || !!this.cancel_at);\n  }\n\n  public async isConsumesCredit(): Promise<boolean> {\n    // @ts-ignore\n    const { SubscriptionItem, Price } = this.sequelize.models;\n    if (!SubscriptionItem || !Price) {\n      return false;\n    }\n\n    // 查询订阅的所有价格项\n    const items = await SubscriptionItem.findAll({\n      where: { subscription_id: this.id },\n      include: [\n        {\n          model: Price,\n          as: 'price',\n        },\n      ],\n    });\n\n    return items.some((item: any) => {\n      const recurring = item.price?.recurring;\n      return recurring && recurring.usage_type === 'metered' && recurring.meter_id;\n    });\n  }\n\n  public async start() {\n    if (this.status === 'active') {\n      logger.warn(`subscription already active: ${this.id}`);\n      return false;\n    }\n\n    if (this.isImmutable()) {\n      logger.warn(`subscription is immutable: ${this.id}`);\n      return false;\n    }\n\n    if (this.trial_end && this.trial_end > Date.now() / 1000) {\n      if (this.status !== 'trialing') {\n        await this.update({ status: 'trialing' });\n        createEvent('Subscription', 'customer.subscription.trial_start', this).catch(console.error);\n      }\n    } else {\n      await this.update({ status: 'active' });\n      createEvent('Subscription', 'customer.subscription.started', this).catch(console.error);\n    }\n\n    return true;\n  }\n\n  public static getSummary(livemode: boolean = true, field: string = 'status') {\n    return this.findAndCountAll({\n      where: { livemode },\n      attributes: [field, [Sequelize.fn('COUNT', Sequelize.col(field)), 'count']],\n      group: [field],\n      raw: true,\n    }).then((res) => res.rows);\n  }\n\n  public static async getToSubscriptions(subscriptionId: string): Promise<string[]> {\n    const subscriptions = [];\n    let cursor = subscriptionId;\n    do {\n      // eslint-disable-next-line no-await-in-loop\n      const from = await this.findOne({ where: { recovered_from: cursor } });\n      if (from) {\n        cursor = from.id;\n        subscriptions.push(cursor);\n      } else {\n        cursor = '';\n      }\n    } while (cursor);\n\n    return subscriptions;\n  }\n\n  public static async getFromSubscriptions(subscriptionId: string): Promise<string[]> {\n    const subscriptions = [];\n    let cursor = subscriptionId;\n    do {\n      // eslint-disable-next-line no-await-in-loop\n      const to = await this.findOne({ where: { id: cursor } });\n      if (to?.recovered_from) {\n        cursor = to.recovered_from;\n        subscriptions.push(cursor);\n      } else {\n        cursor = '';\n      }\n    } while (cursor);\n\n    return subscriptions;\n  }\n}\n\nexport type TSubscription = InferAttributes<Subscription>;\n\nexport function getSubscriptionEventType(current: TSubscription, previous: Partial<TSubscription>) {\n  if (current.pause_collection && !previous.pause_collection) {\n    return 'paused';\n  }\n  if (!current.pause_collection && previous.pause_collection) {\n    return 'resumed';\n  }\n\n  return '';\n}\n","numLines":517,"startLine":1,"totalLines":517}}}
{"parentUuid":"481243f8-98e6-4939-8387-f2a0effa6fe6","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01W3Gbh2mjAu9GKgmnMuF93r","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/lines-between-class-members */\n     2→import { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n     3→\n     4→import { createCodeGenerator } from '../../libs/util';\n     5→\n     6→const nextId = createCodeGenerator('', 8);\n     7→\n     8→// @link https://stripe.com/docs/api/discounts\n     9→// eslint-disable-next-line prettier/prettier\n    10→export class Discount extends Model<InferAttributes<Discount>, InferCreationAttributes<Discount>> {\n    11→  declare id: CreationOptional<string>;\n    12→  declare livemode: boolean;\n    13→\n    14→  declare coupon_id: string;\n    15→  declare promotion_code_id?: string;\n    16→  declare customer_id: string;\n    17→  declare subscription_id?: string;\n    18→  declare checkout_session_id?: string;\n    19→  declare invoice_id?: string;\n    20→  declare invoice_item_id?: string;\n    21→  declare confirmed?: boolean;\n    22→\n    23→  declare start: number;\n    24→  declare end: number | null;\n    25→\n    26→  declare verification_method?: string;\n    27→  declare verification_data?: Record<string, any>;\n    28→  declare metadata?: Record<string, any>;\n    29→\n    30→  declare created_at: CreationOptional<Date>;\n    31→  declare updated_at: CreationOptional<Date>;\n    32→\n    33→  public static readonly GENESIS_ATTRIBUTES = {\n    34→    id: {\n    35→      type: DataTypes.STRING(15),\n    36→      primaryKey: true,\n    37→      allowNull: false,\n    38→      defaultValue: nextId,\n    39→    },\n    40→    livemode: {\n    41→      type: DataTypes.BOOLEAN,\n    42→      allowNull: false,\n    43→    },\n    44→    coupon_id: {\n    45→      type: DataTypes.STRING(30),\n    46→      allowNull: false,\n    47→    },\n    48→    customer_id: {\n    49→      type: DataTypes.STRING(30),\n    50→      allowNull: false,\n    51→    },\n    52→    promotion_code_id: {\n    53→      type: DataTypes.STRING(30),\n    54→      allowNull: true,\n    55→    },\n    56→    subscription_id: {\n    57→      type: DataTypes.STRING(30),\n    58→      allowNull: true,\n    59→    },\n    60→    checkout_session_id: {\n    61→      type: DataTypes.STRING(30),\n    62→      allowNull: true,\n    63→    },\n    64→    invoice_id: {\n    65→      type: DataTypes.STRING(30),\n    66→      allowNull: true,\n    67→    },\n    68→    invoice_item_id: {\n    69→      type: DataTypes.STRING(30),\n    70→      allowNull: true,\n    71→    },\n    72→    start: {\n    73→      type: DataTypes.INTEGER,\n    74→      allowNull: false,\n    75→    },\n    76→    end: {\n    77→      type: DataTypes.INTEGER,\n    78→      allowNull: true,\n    79→    },\n    80→    verification_method: {\n    81→      type: DataTypes.STRING(50),\n    82→      allowNull: true,\n    83→    },\n    84→    verification_data: {\n    85→      type: DataTypes.JSON,\n    86→      allowNull: true,\n    87→    },\n    88→    metadata: {\n    89→      type: DataTypes.JSON,\n    90→      allowNull: true,\n    91→    },\n    92→    created_at: {\n    93→      type: DataTypes.DATE,\n    94→      defaultValue: DataTypes.NOW,\n    95→      allowNull: false,\n    96→    },\n    97→    updated_at: {\n    98→      type: DataTypes.DATE,\n    99→      defaultValue: DataTypes.NOW,\n   100→      allowNull: false,\n   101→    },\n   102→  };\n   103→\n   104→  public static initialize(sequelize: any) {\n   105→    this.init(\n   106→      {\n   107→        ...Discount.GENESIS_ATTRIBUTES,\n   108→        confirmed: {\n   109→          type: DataTypes.BOOLEAN,\n   110→          defaultValue: true,\n   111→          allowNull: false,\n   112→        },\n   113→      },\n   114→      {\n   115→        sequelize,\n   116→        modelName: 'Discount',\n   117→        tableName: 'discounts',\n   118→        createdAt: 'created_at',\n   119→        updatedAt: 'updated_at',\n   120→      }\n   121→    );\n   122→  }\n   123→\n   124→  public static associate(models: any) {\n   125→    this.belongsTo(models.Customer, {\n   126→      foreignKey: 'customer_id',\n   127→      as: 'customer',\n   128→    });\n   129→    this.belongsTo(models.Coupon, {\n   130→      foreignKey: 'coupon_id',\n   131→      as: 'coupon',\n   132→    });\n   133→    this.belongsTo(models.PromotionCode, {\n   134→      foreignKey: 'promotion_code_id',\n   135→      as: 'promotionCode',\n   136→    });\n   137→  }\n   138→}\n   139→\n   140→export type TDiscount = InferAttributes<Discount>;\n   141→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"46c2a4fe-b308-4761-a5b8-3c1b699c49d6","timestamp":"2026-01-09T01:49:14.893Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/discount.ts","content":"/* eslint-disable @typescript-eslint/lines-between-class-members */\nimport { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n\nimport { createCodeGenerator } from '../../libs/util';\n\nconst nextId = createCodeGenerator('', 8);\n\n// @link https://stripe.com/docs/api/discounts\n// eslint-disable-next-line prettier/prettier\nexport class Discount extends Model<InferAttributes<Discount>, InferCreationAttributes<Discount>> {\n  declare id: CreationOptional<string>;\n  declare livemode: boolean;\n\n  declare coupon_id: string;\n  declare promotion_code_id?: string;\n  declare customer_id: string;\n  declare subscription_id?: string;\n  declare checkout_session_id?: string;\n  declare invoice_id?: string;\n  declare invoice_item_id?: string;\n  declare confirmed?: boolean;\n\n  declare start: number;\n  declare end: number | null;\n\n  declare verification_method?: string;\n  declare verification_data?: Record<string, any>;\n  declare metadata?: Record<string, any>;\n\n  declare created_at: CreationOptional<Date>;\n  declare updated_at: CreationOptional<Date>;\n\n  public static readonly GENESIS_ATTRIBUTES = {\n    id: {\n      type: DataTypes.STRING(15),\n      primaryKey: true,\n      allowNull: false,\n      defaultValue: nextId,\n    },\n    livemode: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    coupon_id: {\n      type: DataTypes.STRING(30),\n      allowNull: false,\n    },\n    customer_id: {\n      type: DataTypes.STRING(30),\n      allowNull: false,\n    },\n    promotion_code_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    subscription_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    checkout_session_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    invoice_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    invoice_item_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    start: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n    },\n    end: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    verification_method: {\n      type: DataTypes.STRING(50),\n      allowNull: true,\n    },\n    verification_data: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    metadata: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    created_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n    updated_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n  };\n\n  public static initialize(sequelize: any) {\n    this.init(\n      {\n        ...Discount.GENESIS_ATTRIBUTES,\n        confirmed: {\n          type: DataTypes.BOOLEAN,\n          defaultValue: true,\n          allowNull: false,\n        },\n      },\n      {\n        sequelize,\n        modelName: 'Discount',\n        tableName: 'discounts',\n        createdAt: 'created_at',\n        updatedAt: 'updated_at',\n      }\n    );\n  }\n\n  public static associate(models: any) {\n    this.belongsTo(models.Customer, {\n      foreignKey: 'customer_id',\n      as: 'customer',\n    });\n    this.belongsTo(models.Coupon, {\n      foreignKey: 'coupon_id',\n      as: 'coupon',\n    });\n    this.belongsTo(models.PromotionCode, {\n      foreignKey: 'promotion_code_id',\n      as: 'promotionCode',\n    });\n  }\n}\n\nexport type TDiscount = InferAttributes<Discount>;\n","numLines":141,"startLine":1,"totalLines":141}}}
{"parentUuid":"46c2a4fe-b308-4761-a5b8-3c1b699c49d6","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017aqkMGzbF1i6xfrBRoxroW","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/lines-between-class-members */\n     2→import { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n     3→import type { LiteralUnion } from 'type-fest';\n     4→import { fromTokenToUnit } from '@ocap/util';\n     5→\n     6→import { createEvent } from '../../libs/audit';\n     7→import { createCodeGenerator, formatMetadata } from '../../libs/util';\n     8→import { trimDecimals } from '../../libs/math-utils';\n     9→import logger from '../../libs/logger';\n    10→import type { TPaymentCurrency } from './payment-currency';\n    11→\n    12→const nextId = createCodeGenerator('', 8);\n    13→\n    14→// eslint-disable-next-line prettier/prettier\n    15→export class Coupon extends Model<InferAttributes<Coupon>, InferCreationAttributes<Coupon>> {\n    16→  declare id: CreationOptional<string>;\n    17→  declare livemode: boolean;\n    18→  declare locked: CreationOptional<boolean>;\n    19→\n    20→  declare amount_off: string;\n    21→  declare percent_off: number;\n    22→\n    23→  declare currency_id: string;\n    24→\n    25→  declare duration: LiteralUnion<'forever' | 'once' | 'repeating', string>;\n    26→\n    27→  declare duration_in_months: number;\n    28→\n    29→  declare name: string;\n    30→\n    31→  declare description?: string;\n    32→\n    33→  declare metadata: Record<string, any>;\n    34→\n    35→  declare applies_to?: {\n    36→    products: string[];\n    37→  };\n    38→\n    39→  declare currency_options?: Record<\n    40→    string,\n    41→    {\n    42→      amount_off: string;\n    43→    }\n    44→  >;\n    45→\n    46→  declare max_redemptions?: number;\n    47→\n    48→  declare redeem_by?: number;\n    49→\n    50→  declare times_redeemed?: number;\n    51→\n    52→  declare valid?: boolean;\n    53→  declare created_via: LiteralUnion<'api' | 'dashboard' | 'portal', string>;\n    54→\n    55→  declare created_at: CreationOptional<Date>;\n    56→\n    57→  declare updated_at: CreationOptional<Date>;\n    58→\n    59→  public static readonly GENESIS_ATTRIBUTES = {\n    60→    id: {\n    61→      type: DataTypes.STRING(15),\n    62→      primaryKey: true,\n    63→      allowNull: false,\n    64→      defaultValue: nextId,\n    65→    },\n    66→    livemode: {\n    67→      type: DataTypes.BOOLEAN,\n    68→      allowNull: false,\n    69→    },\n    70→    locked: {\n    71→      type: DataTypes.BOOLEAN,\n    72→      defaultValue: false,\n    73→    },\n    74→    amount_off: {\n    75→      type: DataTypes.STRING(32),\n    76→      defaultValue: '0',\n    77→    },\n    78→    percent_off: {\n    79→      type: DataTypes.INTEGER,\n    80→      defaultValue: 0,\n    81→    },\n    82→    currency_id: {\n    83→      type: DataTypes.STRING(15),\n    84→      allowNull: false,\n    85→      defaultValue: '',\n    86→    },\n    87→    duration: {\n    88→      type: DataTypes.ENUM('forever', 'once', 'repeating'),\n    89→      allowNull: false,\n    90→    },\n    91→    duration_in_months: {\n    92→      type: DataTypes.INTEGER,\n    93→      allowNull: false,\n    94→      defaultValue: 0,\n    95→    },\n    96→    name: {\n    97→      type: DataTypes.STRING(64),\n    98→      allowNull: false,\n    99→    },\n   100→    description: {\n   101→      type: DataTypes.TEXT,\n   102→      allowNull: true,\n   103→    },\n   104→    applies_to: {\n   105→      type: DataTypes.JSON,\n   106→      allowNull: true,\n   107→    },\n   108→    currency_options: {\n   109→      type: DataTypes.JSON,\n   110→      defaultValue: {},\n   111→    },\n   112→    max_redemptions: {\n   113→      type: DataTypes.INTEGER,\n   114→      allowNull: true,\n   115→    },\n   116→    redeem_by: {\n   117→      type: DataTypes.INTEGER,\n   118→      allowNull: true,\n   119→    },\n   120→    times_redeemed: {\n   121→      type: DataTypes.INTEGER,\n   122→      defaultValue: 0,\n   123→    },\n   124→    valid: {\n   125→      type: DataTypes.BOOLEAN,\n   126→      defaultValue: false,\n   127→    },\n   128→    metadata: {\n   129→      type: DataTypes.JSON,\n   130→      allowNull: true,\n   131→    },\n   132→    created_via: {\n   133→      type: DataTypes.ENUM('api', 'dashboard', 'portal'),\n   134→      allowNull: false,\n   135→    },\n   136→    created_at: {\n   137→      type: DataTypes.DATE,\n   138→      defaultValue: DataTypes.NOW,\n   139→      allowNull: false,\n   140→    },\n   141→    updated_at: {\n   142→      type: DataTypes.DATE,\n   143→      defaultValue: DataTypes.NOW,\n   144→      allowNull: false,\n   145→    },\n   146→  };\n   147→\n   148→  public static initialize(sequelize: any) {\n   149→    this.init(Coupon.GENESIS_ATTRIBUTES, {\n   150→      sequelize,\n   151→      modelName: 'Coupon',\n   152→      tableName: 'coupons',\n   153→      createdAt: 'created_at',\n   154→      updatedAt: 'updated_at',\n   155→      hooks: {\n   156→        afterCreate: (model: Coupon, options) =>\n   157→          createEvent('Coupon', 'coupon.created', model, options).catch(console.error),\n   158→        afterUpdate: (model: Coupon, options) =>\n   159→          createEvent('Coupon', 'coupon.updated', model, options).catch(console.error),\n   160→        afterDestroy: (model: Coupon, options) =>\n   161→          createEvent('Coupon', 'coupon.deleted', model, options).catch(console.error),\n   162→      },\n   163→    });\n   164→  }\n   165→\n   166→  public static associate(models: any) {\n   167→    this.hasOne(models.PaymentCurrency, {\n   168→      sourceKey: 'currency_id',\n   169→      foreignKey: 'id',\n   170→      as: 'currency',\n   171→    });\n   172→  }\n   173→\n   174→  public static formatBeforeSave(coupon: Partial<TCoupon>) {\n   175→    if (coupon.metadata) {\n   176→      coupon.metadata = formatMetadata(coupon.metadata);\n   177→    }\n   178→\n   179→    if (coupon.max_redemptions) {\n   180→      coupon.max_redemptions = Number(coupon.max_redemptions);\n   181→    }\n   182→\n   183→    if (coupon.times_redeemed) {\n   184→      coupon.times_redeemed = Number(coupon.times_redeemed);\n   185→    }\n   186→\n   187→    if (coupon.duration === 'repeating') {\n   188→      coupon.duration_in_months = Number(coupon.duration_in_months || 0);\n   189→    }\n   190→\n   191→    return coupon;\n   192→  }\n   193→\n   194→  public static async insert(coupon: Partial<TCoupon>) {\n   195→    const formattedData = this.formatBeforeSave({\n   196→      locked: false,\n   197→      times_redeemed: 0,\n   198→      valid: true,\n   199→      metadata: {},\n   200→      amount_off: '0',\n   201→      currency_options: {},\n   202→      currency_id: '',\n   203→      duration_in_months: 0,\n   204→      ...coupon,\n   205→    });\n   206→    logger.info('Formatted data', { formattedData });\n   207→    try {\n   208→      return await this.create(formattedData as any);\n   209→    } catch (error) {\n   210→      logger.error('Coupon creation error details:', {\n   211→        error: error.message,\n   212→        formattedData,\n   213→        validationErrors: error.errors || [],\n   214→        sqlMessage: error.original?.message || 'No SQL message',\n   215→      });\n   216→      throw error;\n   217→    }\n   218→  }\n   219→\n   220→  public async isUsed() {\n   221→    const { Discount } = this.sequelize.models;\n   222→    const discountCount = await Discount!.count({\n   223→      where: { coupon_id: this.id },\n   224→    });\n   225→\n   226→    if (discountCount > 0) {\n   227→      return true;\n   228→    }\n   229→\n   230→    return false;\n   231→  }\n   232→\n   233→  public async getAppliedProducts() {\n   234→    if (!this.applies_to || !this.applies_to?.products) {\n   235→      return [];\n   236→    }\n   237→    const { Product } = this.sequelize.models;\n   238→    const productsWithPrices = await Promise.all(\n   239→      // @ts-ignore\n   240→      this.applies_to.products.map((productId) => Product!.expand(productId))\n   241→    );\n   242→    return productsWithPrices;\n   243→  }\n   244→\n   245→  /**\n   246→   * Format currency options for storage - convert unit amounts to token amounts\n   247→   */\n   248→  public static formatCurrencyOptions(\n   249→    currencyOptions: Record<string, { amount_off: string }>,\n   250→    currencies: TPaymentCurrency[]\n   251→  ): Record<\n   252→    string,\n   253→    {\n   254→      amount_off: string;\n   255→    }\n   256→  > {\n   257→    const formatted: Record<string, { amount_off: string }> = {};\n   258→\n   259→    for (const [currencyId, amountInfo] of Object.entries(currencyOptions || {})) {\n   260→      const currency = currencies.find((c) => c.id === currencyId);\n   261→      if (!currency) {\n   262→        throw new Error(`currency ${currencyId} used in coupon not found or inactive`);\n   263→      }\n   264→\n   265→      formatted[currencyId] = {\n   266→        amount_off: fromTokenToUnit(\n   267→          trimDecimals(amountInfo.amount_off || '0', currency.decimal),\n   268→          currency.decimal\n   269→        ).toString(),\n   270→      };\n   271→    }\n   272→\n   273→    return formatted;\n   274→  }\n   275→}\n   276→\n   277→export type TCoupon = InferAttributes<Coupon>;\n   278→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"100bee3a-f035-4219-be76-791347a033c3","timestamp":"2026-01-09T01:49:14.893Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/coupon.ts","content":"/* eslint-disable @typescript-eslint/lines-between-class-members */\nimport { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\nimport type { LiteralUnion } from 'type-fest';\nimport { fromTokenToUnit } from '@ocap/util';\n\nimport { createEvent } from '../../libs/audit';\nimport { createCodeGenerator, formatMetadata } from '../../libs/util';\nimport { trimDecimals } from '../../libs/math-utils';\nimport logger from '../../libs/logger';\nimport type { TPaymentCurrency } from './payment-currency';\n\nconst nextId = createCodeGenerator('', 8);\n\n// eslint-disable-next-line prettier/prettier\nexport class Coupon extends Model<InferAttributes<Coupon>, InferCreationAttributes<Coupon>> {\n  declare id: CreationOptional<string>;\n  declare livemode: boolean;\n  declare locked: CreationOptional<boolean>;\n\n  declare amount_off: string;\n  declare percent_off: number;\n\n  declare currency_id: string;\n\n  declare duration: LiteralUnion<'forever' | 'once' | 'repeating', string>;\n\n  declare duration_in_months: number;\n\n  declare name: string;\n\n  declare description?: string;\n\n  declare metadata: Record<string, any>;\n\n  declare applies_to?: {\n    products: string[];\n  };\n\n  declare currency_options?: Record<\n    string,\n    {\n      amount_off: string;\n    }\n  >;\n\n  declare max_redemptions?: number;\n\n  declare redeem_by?: number;\n\n  declare times_redeemed?: number;\n\n  declare valid?: boolean;\n  declare created_via: LiteralUnion<'api' | 'dashboard' | 'portal', string>;\n\n  declare created_at: CreationOptional<Date>;\n\n  declare updated_at: CreationOptional<Date>;\n\n  public static readonly GENESIS_ATTRIBUTES = {\n    id: {\n      type: DataTypes.STRING(15),\n      primaryKey: true,\n      allowNull: false,\n      defaultValue: nextId,\n    },\n    livemode: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    locked: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: false,\n    },\n    amount_off: {\n      type: DataTypes.STRING(32),\n      defaultValue: '0',\n    },\n    percent_off: {\n      type: DataTypes.INTEGER,\n      defaultValue: 0,\n    },\n    currency_id: {\n      type: DataTypes.STRING(15),\n      allowNull: false,\n      defaultValue: '',\n    },\n    duration: {\n      type: DataTypes.ENUM('forever', 'once', 'repeating'),\n      allowNull: false,\n    },\n    duration_in_months: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n      defaultValue: 0,\n    },\n    name: {\n      type: DataTypes.STRING(64),\n      allowNull: false,\n    },\n    description: {\n      type: DataTypes.TEXT,\n      allowNull: true,\n    },\n    applies_to: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    currency_options: {\n      type: DataTypes.JSON,\n      defaultValue: {},\n    },\n    max_redemptions: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    redeem_by: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    times_redeemed: {\n      type: DataTypes.INTEGER,\n      defaultValue: 0,\n    },\n    valid: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: false,\n    },\n    metadata: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    created_via: {\n      type: DataTypes.ENUM('api', 'dashboard', 'portal'),\n      allowNull: false,\n    },\n    created_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n    updated_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n  };\n\n  public static initialize(sequelize: any) {\n    this.init(Coupon.GENESIS_ATTRIBUTES, {\n      sequelize,\n      modelName: 'Coupon',\n      tableName: 'coupons',\n      createdAt: 'created_at',\n      updatedAt: 'updated_at',\n      hooks: {\n        afterCreate: (model: Coupon, options) =>\n          createEvent('Coupon', 'coupon.created', model, options).catch(console.error),\n        afterUpdate: (model: Coupon, options) =>\n          createEvent('Coupon', 'coupon.updated', model, options).catch(console.error),\n        afterDestroy: (model: Coupon, options) =>\n          createEvent('Coupon', 'coupon.deleted', model, options).catch(console.error),\n      },\n    });\n  }\n\n  public static associate(models: any) {\n    this.hasOne(models.PaymentCurrency, {\n      sourceKey: 'currency_id',\n      foreignKey: 'id',\n      as: 'currency',\n    });\n  }\n\n  public static formatBeforeSave(coupon: Partial<TCoupon>) {\n    if (coupon.metadata) {\n      coupon.metadata = formatMetadata(coupon.metadata);\n    }\n\n    if (coupon.max_redemptions) {\n      coupon.max_redemptions = Number(coupon.max_redemptions);\n    }\n\n    if (coupon.times_redeemed) {\n      coupon.times_redeemed = Number(coupon.times_redeemed);\n    }\n\n    if (coupon.duration === 'repeating') {\n      coupon.duration_in_months = Number(coupon.duration_in_months || 0);\n    }\n\n    return coupon;\n  }\n\n  public static async insert(coupon: Partial<TCoupon>) {\n    const formattedData = this.formatBeforeSave({\n      locked: false,\n      times_redeemed: 0,\n      valid: true,\n      metadata: {},\n      amount_off: '0',\n      currency_options: {},\n      currency_id: '',\n      duration_in_months: 0,\n      ...coupon,\n    });\n    logger.info('Formatted data', { formattedData });\n    try {\n      return await this.create(formattedData as any);\n    } catch (error) {\n      logger.error('Coupon creation error details:', {\n        error: error.message,\n        formattedData,\n        validationErrors: error.errors || [],\n        sqlMessage: error.original?.message || 'No SQL message',\n      });\n      throw error;\n    }\n  }\n\n  public async isUsed() {\n    const { Discount } = this.sequelize.models;\n    const discountCount = await Discount!.count({\n      where: { coupon_id: this.id },\n    });\n\n    if (discountCount > 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  public async getAppliedProducts() {\n    if (!this.applies_to || !this.applies_to?.products) {\n      return [];\n    }\n    const { Product } = this.sequelize.models;\n    const productsWithPrices = await Promise.all(\n      // @ts-ignore\n      this.applies_to.products.map((productId) => Product!.expand(productId))\n    );\n    return productsWithPrices;\n  }\n\n  /**\n   * Format currency options for storage - convert unit amounts to token amounts\n   */\n  public static formatCurrencyOptions(\n    currencyOptions: Record<string, { amount_off: string }>,\n    currencies: TPaymentCurrency[]\n  ): Record<\n    string,\n    {\n      amount_off: string;\n    }\n  > {\n    const formatted: Record<string, { amount_off: string }> = {};\n\n    for (const [currencyId, amountInfo] of Object.entries(currencyOptions || {})) {\n      const currency = currencies.find((c) => c.id === currencyId);\n      if (!currency) {\n        throw new Error(`currency ${currencyId} used in coupon not found or inactive`);\n      }\n\n      formatted[currencyId] = {\n        amount_off: fromTokenToUnit(\n          trimDecimals(amountInfo.amount_off || '0', currency.decimal),\n          currency.decimal\n        ).toString(),\n      };\n    }\n\n    return formatted;\n  }\n}\n\nexport type TCoupon = InferAttributes<Coupon>;\n","numLines":278,"startLine":1,"totalLines":278}}}
{"parentUuid":"100bee3a-f035-4219-be76-791347a033c3","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QNHcEfnhALSHUEHFwsGuWH","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/lines-between-class-members */\n     2→import { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n     3→\n     4→import { BN } from '@ocap/util';\n     5→\n     6→import { createIdGenerator } from '../../libs/util';\n     7→import logger from '../../libs/logger';\n     8→\n     9→const nextTaxRateId = createIdGenerator('txr', 16);\n    10→\n    11→// eslint-disable-next-line prettier/prettier\n    12→export class TaxRate extends Model<InferAttributes<TaxRate>, InferCreationAttributes<TaxRate>> {\n    13→  declare id: CreationOptional<string>;\n    14→  declare livemode: boolean;\n    15→  declare active: boolean;\n    16→\n    17→  declare country: string; // ISO 3166-1 alpha-2 country code\n    18→  declare state?: string; // State, province, or region\n    19→  declare postal_code?: string; // Postal code or ZIP code (supports wildcards like \"95*\")\n    20→  declare tax_code?: string; // Product tax code (txcd_*)\n    21→\n    22→  declare percentage: number; // Tax rate percentage (e.g., 8.5 for 8.5%)\n    23→\n    24→  declare display_name: string; // Display name for the tax rate\n    25→  declare description?: string; // Description of the tax rate\n    26→\n    27→  declare metadata?: Record<string, any>;\n    28→\n    29→  declare created_at: CreationOptional<Date>;\n    30→  declare updated_at: CreationOptional<Date>;\n    31→\n    32→  public static readonly GENESIS_ATTRIBUTES = {\n    33→    id: {\n    34→      type: DataTypes.STRING(30),\n    35→      primaryKey: true,\n    36→      allowNull: false,\n    37→      defaultValue: nextTaxRateId,\n    38→    },\n    39→    livemode: {\n    40→      type: DataTypes.BOOLEAN,\n    41→      allowNull: false,\n    42→    },\n    43→    active: {\n    44→      type: DataTypes.BOOLEAN,\n    45→      defaultValue: true,\n    46→    },\n    47→    country: {\n    48→      type: DataTypes.STRING(2),\n    49→      allowNull: false,\n    50→    },\n    51→    state: {\n    52→      type: DataTypes.STRING(50),\n    53→      allowNull: true,\n    54→    },\n    55→    postal_code: {\n    56→      type: DataTypes.STRING(20),\n    57→      allowNull: true,\n    58→    },\n    59→    tax_code: {\n    60→      type: DataTypes.STRING(20),\n    61→      allowNull: true,\n    62→    },\n    63→    percentage: {\n    64→      type: DataTypes.DECIMAL(5, 4), // Supports up to 99.9999%\n    65→      allowNull: false,\n    66→    },\n    67→    display_name: {\n    68→      type: DataTypes.STRING(100),\n    69→      allowNull: false,\n    70→    },\n    71→    description: {\n    72→      type: DataTypes.STRING(500),\n    73→      allowNull: true,\n    74→    },\n    75→    metadata: {\n    76→      type: DataTypes.JSON,\n    77→      allowNull: true,\n    78→    },\n    79→    created_at: {\n    80→      type: DataTypes.DATE,\n    81→      defaultValue: DataTypes.NOW,\n    82→      allowNull: false,\n    83→    },\n    84→    updated_at: {\n    85→      type: DataTypes.DATE,\n    86→      defaultValue: DataTypes.NOW,\n    87→      allowNull: false,\n    88→    },\n    89→  };\n    90→\n    91→  public static initialize(sequelize: any) {\n    92→    this.init(TaxRate.GENESIS_ATTRIBUTES, {\n    93→      sequelize,\n    94→      modelName: 'TaxRate',\n    95→      tableName: 'tax_rates',\n    96→      createdAt: 'created_at',\n    97→      updatedAt: 'updated_at',\n    98→      indexes: [\n    99→        {\n   100→          fields: ['country'],\n   101→        },\n   102→        {\n   103→          fields: ['country', 'state'],\n   104→        },\n   105→        {\n   106→          fields: ['country', 'state', 'postal_code'],\n   107→        },\n   108→      ],\n   109→    });\n   110→  }\n   111→\n   112→  public static associate() {}\n   113→\n   114→  /**\n   115→   * Find matching tax rate for given location and tax code\n   116→   *\n   117→   * Uses hierarchical scoring (lexicographic ordering) to match tax rates.\n   118→   * Priority: postal_code > state > tax_code\n   119→   *\n   120→   * Note: Country is pre-filtered to ensure postal codes are compared within\n   121→   * the correct national context (e.g., prevents US 90210 from matching CA 90210).\n   122→   *\n   123→   * Score ranges per dimension (0-100):\n   124→   *   - 100: Exact match\n   125→   *   - 50-95: Wildcard match (e.g., \"902*\" prefix matching)\n   126→   *   - 10: General fallback (rate has no restriction)\n   127→   *   - 5: Both empty\n   128→   */\n   129→  public static async findMatchingRate({\n   130→    country,\n   131→    state,\n   132→    postalCode,\n   133→    taxCode,\n   134→    livemode = true,\n   135→  }: {\n   136→    country: string;\n   137→    state?: string;\n   138→    postalCode?: string;\n   139→    taxCode?: string;\n   140→    livemode?: boolean;\n   141→  }): Promise<TaxRate | null> {\n   142→    const normalizedCountry = country?.trim().toUpperCase();\n   143→    const normalizedState = state?.trim().toLowerCase();\n   144→    const normalizedPostal = postalCode?.trim().toUpperCase();\n   145→    const normalizedTaxCode = taxCode?.trim().toLowerCase();\n   146→\n   147→    if (!normalizedCountry) {\n   148→      logger.error('findMatchingRate: country is required');\n   149→      return null;\n   150→    }\n   151→\n   152→    try {\n   153→      const { sequelize } = this;\n   154→      if (!sequelize) {\n   155→        throw new Error('Sequelize instance not found');\n   156→      }\n   157→\n   158→      const candidates = await this.findAll({\n   159→        where: sequelize.where(sequelize.fn('UPPER', sequelize.col('country')), normalizedCountry) as any,\n   160→        attributes: {\n   161→          include: [[sequelize.literal('UPPER(country)'), 'normalized_country']],\n   162→        },\n   163→        order: [['updated_at', 'DESC']],\n   164→      });\n   165→\n   166→      const activeCandidates = candidates.filter((rate) => rate.active && rate.livemode === livemode);\n   167→\n   168→      if (!activeCandidates.length) {\n   169→        logger.debug('findMatchingRate: no active candidates found', {\n   170→          country: normalizedCountry,\n   171→          state: normalizedState,\n   172→          postal: normalizedPostal,\n   173→          taxCode: normalizedTaxCode,\n   174→          livemode,\n   175→          totalCandidates: candidates.length,\n   176→        });\n   177→        return null;\n   178→      }\n   179→\n   180→      let bestMatch: TaxRate | null = null;\n   181→      let bestScore = { postal: 0, state: 0, tax: 0 };\n   182→\n   183→      for (const rate of activeCandidates) {\n   184→        const rateTaxCode = rate.tax_code ? String(rate.tax_code).trim().toLowerCase() : null;\n   185→        const ratePostal = rate.postal_code ? String(rate.postal_code).trim().toUpperCase() : null;\n   186→        const rateState = rate.state ? String(rate.state).trim().toLowerCase() : null;\n   187→\n   188→        let isValid = true;\n   189→        const scores = { postal: 0, state: 0, tax: 0 };\n   190→\n   191→        // Postal Code Matching\n   192→        if (ratePostal && normalizedPostal) {\n   193→          if (ratePostal.endsWith('*')) {\n   194→            const prefix = ratePostal.slice(0, -1);\n   195→            if (normalizedPostal.startsWith(prefix)) {\n   196→              const prefixLength = Math.min(prefix.length, 20);\n   197→              scores.postal = 50 + prefixLength * 5;\n   198→            } else {\n   199→              isValid = false;\n   200→            }\n   201→          } else if (ratePostal === normalizedPostal) {\n   202→            scores.postal = 100;\n   203→          } else {\n   204→            isValid = false;\n   205→          }\n   206→        } else if (!ratePostal && !normalizedPostal) {\n   207→          scores.postal = 5;\n   208→        } else if (!ratePostal && normalizedPostal) {\n   209→          scores.postal = 10;\n   210→        } else if (ratePostal && !normalizedPostal) {\n   211→          isValid = false;\n   212→        }\n   213→\n   214→        // State Matching\n   215→        if (isValid && rateState && normalizedState) {\n   216→          if (rateState === normalizedState) {\n   217→            scores.state = 100;\n   218→          } else {\n   219→            isValid = false;\n   220→          }\n   221→        } else if (isValid && !rateState && !normalizedState) {\n   222→          scores.state = 5;\n   223→        } else if (isValid && !rateState && normalizedState) {\n   224→          scores.state = 10;\n   225→        } else if (isValid && rateState && !normalizedState) {\n   226→          isValid = false;\n   227→        }\n   228→\n   229→        // Tax Code Matching\n   230→        if (isValid) {\n   231→          if (normalizedTaxCode) {\n   232→            if (rateTaxCode === normalizedTaxCode) {\n   233→              scores.tax = 100;\n   234→            } else if (!rateTaxCode) {\n   235→              scores.tax = 10;\n   236→            } else {\n   237→              isValid = false;\n   238→            }\n   239→          } else if (!rateTaxCode) {\n   240→            scores.tax = 5;\n   241→          }\n   242→        }\n   243→\n   244→        if (!isValid) {\n   245→          // eslint-disable-next-line no-continue\n   246→          continue;\n   247→        }\n   248→\n   249→        // Hierarchical comparison (lexicographic ordering)\n   250→        // Use > not >= to prefer first match when scores are equal (newer rate due to DESC sort)\n   251→        const isBetter =\n   252→          scores.postal > bestScore.postal ||\n   253→          (scores.postal === bestScore.postal && scores.state > bestScore.state) ||\n   254→          (scores.postal === bestScore.postal && scores.state === bestScore.state && scores.tax > bestScore.tax);\n   255→\n   256→        if (isBetter) {\n   257→          bestScore = scores;\n   258→          bestMatch = rate;\n   259→        }\n   260→      }\n   261→\n   262→      if (!bestMatch) {\n   263→        logger.error('findMatchingRate: no matches found after scoring', {\n   264→          country: normalizedCountry,\n   265→          state: normalizedState,\n   266→          postal: normalizedPostal,\n   267→          taxCode: normalizedTaxCode,\n   268→          livemode,\n   269→          candidatesCount: activeCandidates.length,\n   270→        });\n   271→      } else {\n   272→        logger.info('findMatchingRate: found match', {\n   273→          taxRateId: bestMatch.id,\n   274→          score: bestScore,\n   275→          displayName: bestMatch.display_name,\n   276→          percentage: bestMatch.percentage,\n   277→        });\n   278→      }\n   279→\n   280→      return bestMatch;\n   281→    } catch (error) {\n   282→      logger.error('findMatchingRate failed', {\n   283→        error,\n   284→        country: normalizedCountry,\n   285→        state: normalizedState,\n   286→        postal: normalizedPostal,\n   287→        taxCode: normalizedTaxCode,\n   288→        livemode,\n   289→      });\n   290→      return null;\n   291→    }\n   292→  }\n   293→\n   294→  /**\n   295→   * Calculate tax amount from tax-inclusive total\n   296→   * Formula: tax = total × (rate / (100 + rate))\n   297→   */\n   298→  public static calculateTaxFromInclusive(total: string, percentage: number): string {\n   299→    const totalBN = new BN(total);\n   300→    if (totalBN.lte(new BN('0'))) return '0';\n   301→\n   302→    const rateBN = new BN(percentage.toString()).mul(new BN('100'));\n   303→    const denominator = new BN('10000').add(rateBN);\n   304→\n   305→    // tax = total * rate / (10000 + rate)\n   306→    const taxAmount = totalBN.mul(rateBN).div(denominator);\n   307→    return taxAmount.toString();\n   308→  }\n   309→\n   310→  /**\n   311→   * Calculate subtotal from tax-inclusive total\n   312→   * Formula: subtotal = total - tax\n   313→   */\n   314→  public static calculateSubtotalFromInclusive(total: string, percentage: number): string {\n   315→    const totalBN = new BN(total);\n   316→    if (totalBN.lte(new BN('0'))) return total;\n   317→\n   318→    const taxAmount = new BN(this.calculateTaxFromInclusive(total, percentage));\n   319→    return totalBN.sub(taxAmount).toString();\n   320→  }\n   321→\n   322→  /**\n   323→   * Calculate tax amount for a single invoice item\n   324→   * Formula: tax = amount × (rate / 100)\n   325→   */\n   326→  public static calculateTaxForItem(amount: string, percentage: number): string {\n   327→    const amountBN = new BN(amount);\n   328→    if (amountBN.lte(new BN('0'))) return '0';\n   329→\n   330→    const rateBN = new BN(percentage.toString()).mul(new BN('100'));\n   331→\n   332→    // tax = amount * rate / 10000\n   333→    const taxAmount = amountBN.mul(rateBN).div(new BN('10000'));\n   334→    return taxAmount.toString();\n   335→  }\n   336→\n   337→  /**\n   338→   * Calculate total tax for multiple invoice items\n   339→   */\n   340→  public static calculateTotalTax(\n   341→    items: Array<{ amount: string; tax_rate_id?: string; tax_rate?: { percentage: number } }>\n   342→  ): string {\n   343→    return items.reduce((total, item) => {\n   344→      if (!item.tax_rate_id || !item.tax_rate) return total;\n   345→\n   346→      const itemTax = this.calculateTaxForItem(item.amount, item.tax_rate.percentage);\n   347→      return new BN(total).add(new BN(itemTax)).toString();\n   348→    }, '0');\n   349→  }\n   350→}\n   351→\n   352→export type TTaxRate = InferAttributes<TaxRate>;\n   353→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"cf862766-1101-4f1b-9efb-6fbdf1c4f7b7","timestamp":"2026-01-09T01:49:14.893Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/tax-rate.ts","content":"/* eslint-disable @typescript-eslint/lines-between-class-members */\nimport { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n\nimport { BN } from '@ocap/util';\n\nimport { createIdGenerator } from '../../libs/util';\nimport logger from '../../libs/logger';\n\nconst nextTaxRateId = createIdGenerator('txr', 16);\n\n// eslint-disable-next-line prettier/prettier\nexport class TaxRate extends Model<InferAttributes<TaxRate>, InferCreationAttributes<TaxRate>> {\n  declare id: CreationOptional<string>;\n  declare livemode: boolean;\n  declare active: boolean;\n\n  declare country: string; // ISO 3166-1 alpha-2 country code\n  declare state?: string; // State, province, or region\n  declare postal_code?: string; // Postal code or ZIP code (supports wildcards like \"95*\")\n  declare tax_code?: string; // Product tax code (txcd_*)\n\n  declare percentage: number; // Tax rate percentage (e.g., 8.5 for 8.5%)\n\n  declare display_name: string; // Display name for the tax rate\n  declare description?: string; // Description of the tax rate\n\n  declare metadata?: Record<string, any>;\n\n  declare created_at: CreationOptional<Date>;\n  declare updated_at: CreationOptional<Date>;\n\n  public static readonly GENESIS_ATTRIBUTES = {\n    id: {\n      type: DataTypes.STRING(30),\n      primaryKey: true,\n      allowNull: false,\n      defaultValue: nextTaxRateId,\n    },\n    livemode: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    active: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: true,\n    },\n    country: {\n      type: DataTypes.STRING(2),\n      allowNull: false,\n    },\n    state: {\n      type: DataTypes.STRING(50),\n      allowNull: true,\n    },\n    postal_code: {\n      type: DataTypes.STRING(20),\n      allowNull: true,\n    },\n    tax_code: {\n      type: DataTypes.STRING(20),\n      allowNull: true,\n    },\n    percentage: {\n      type: DataTypes.DECIMAL(5, 4), // Supports up to 99.9999%\n      allowNull: false,\n    },\n    display_name: {\n      type: DataTypes.STRING(100),\n      allowNull: false,\n    },\n    description: {\n      type: DataTypes.STRING(500),\n      allowNull: true,\n    },\n    metadata: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    created_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n    updated_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n  };\n\n  public static initialize(sequelize: any) {\n    this.init(TaxRate.GENESIS_ATTRIBUTES, {\n      sequelize,\n      modelName: 'TaxRate',\n      tableName: 'tax_rates',\n      createdAt: 'created_at',\n      updatedAt: 'updated_at',\n      indexes: [\n        {\n          fields: ['country'],\n        },\n        {\n          fields: ['country', 'state'],\n        },\n        {\n          fields: ['country', 'state', 'postal_code'],\n        },\n      ],\n    });\n  }\n\n  public static associate() {}\n\n  /**\n   * Find matching tax rate for given location and tax code\n   *\n   * Uses hierarchical scoring (lexicographic ordering) to match tax rates.\n   * Priority: postal_code > state > tax_code\n   *\n   * Note: Country is pre-filtered to ensure postal codes are compared within\n   * the correct national context (e.g., prevents US 90210 from matching CA 90210).\n   *\n   * Score ranges per dimension (0-100):\n   *   - 100: Exact match\n   *   - 50-95: Wildcard match (e.g., \"902*\" prefix matching)\n   *   - 10: General fallback (rate has no restriction)\n   *   - 5: Both empty\n   */\n  public static async findMatchingRate({\n    country,\n    state,\n    postalCode,\n    taxCode,\n    livemode = true,\n  }: {\n    country: string;\n    state?: string;\n    postalCode?: string;\n    taxCode?: string;\n    livemode?: boolean;\n  }): Promise<TaxRate | null> {\n    const normalizedCountry = country?.trim().toUpperCase();\n    const normalizedState = state?.trim().toLowerCase();\n    const normalizedPostal = postalCode?.trim().toUpperCase();\n    const normalizedTaxCode = taxCode?.trim().toLowerCase();\n\n    if (!normalizedCountry) {\n      logger.error('findMatchingRate: country is required');\n      return null;\n    }\n\n    try {\n      const { sequelize } = this;\n      if (!sequelize) {\n        throw new Error('Sequelize instance not found');\n      }\n\n      const candidates = await this.findAll({\n        where: sequelize.where(sequelize.fn('UPPER', sequelize.col('country')), normalizedCountry) as any,\n        attributes: {\n          include: [[sequelize.literal('UPPER(country)'), 'normalized_country']],\n        },\n        order: [['updated_at', 'DESC']],\n      });\n\n      const activeCandidates = candidates.filter((rate) => rate.active && rate.livemode === livemode);\n\n      if (!activeCandidates.length) {\n        logger.debug('findMatchingRate: no active candidates found', {\n          country: normalizedCountry,\n          state: normalizedState,\n          postal: normalizedPostal,\n          taxCode: normalizedTaxCode,\n          livemode,\n          totalCandidates: candidates.length,\n        });\n        return null;\n      }\n\n      let bestMatch: TaxRate | null = null;\n      let bestScore = { postal: 0, state: 0, tax: 0 };\n\n      for (const rate of activeCandidates) {\n        const rateTaxCode = rate.tax_code ? String(rate.tax_code).trim().toLowerCase() : null;\n        const ratePostal = rate.postal_code ? String(rate.postal_code).trim().toUpperCase() : null;\n        const rateState = rate.state ? String(rate.state).trim().toLowerCase() : null;\n\n        let isValid = true;\n        const scores = { postal: 0, state: 0, tax: 0 };\n\n        // Postal Code Matching\n        if (ratePostal && normalizedPostal) {\n          if (ratePostal.endsWith('*')) {\n            const prefix = ratePostal.slice(0, -1);\n            if (normalizedPostal.startsWith(prefix)) {\n              const prefixLength = Math.min(prefix.length, 20);\n              scores.postal = 50 + prefixLength * 5;\n            } else {\n              isValid = false;\n            }\n          } else if (ratePostal === normalizedPostal) {\n            scores.postal = 100;\n          } else {\n            isValid = false;\n          }\n        } else if (!ratePostal && !normalizedPostal) {\n          scores.postal = 5;\n        } else if (!ratePostal && normalizedPostal) {\n          scores.postal = 10;\n        } else if (ratePostal && !normalizedPostal) {\n          isValid = false;\n        }\n\n        // State Matching\n        if (isValid && rateState && normalizedState) {\n          if (rateState === normalizedState) {\n            scores.state = 100;\n          } else {\n            isValid = false;\n          }\n        } else if (isValid && !rateState && !normalizedState) {\n          scores.state = 5;\n        } else if (isValid && !rateState && normalizedState) {\n          scores.state = 10;\n        } else if (isValid && rateState && !normalizedState) {\n          isValid = false;\n        }\n\n        // Tax Code Matching\n        if (isValid) {\n          if (normalizedTaxCode) {\n            if (rateTaxCode === normalizedTaxCode) {\n              scores.tax = 100;\n            } else if (!rateTaxCode) {\n              scores.tax = 10;\n            } else {\n              isValid = false;\n            }\n          } else if (!rateTaxCode) {\n            scores.tax = 5;\n          }\n        }\n\n        if (!isValid) {\n          // eslint-disable-next-line no-continue\n          continue;\n        }\n\n        // Hierarchical comparison (lexicographic ordering)\n        // Use > not >= to prefer first match when scores are equal (newer rate due to DESC sort)\n        const isBetter =\n          scores.postal > bestScore.postal ||\n          (scores.postal === bestScore.postal && scores.state > bestScore.state) ||\n          (scores.postal === bestScore.postal && scores.state === bestScore.state && scores.tax > bestScore.tax);\n\n        if (isBetter) {\n          bestScore = scores;\n          bestMatch = rate;\n        }\n      }\n\n      if (!bestMatch) {\n        logger.error('findMatchingRate: no matches found after scoring', {\n          country: normalizedCountry,\n          state: normalizedState,\n          postal: normalizedPostal,\n          taxCode: normalizedTaxCode,\n          livemode,\n          candidatesCount: activeCandidates.length,\n        });\n      } else {\n        logger.info('findMatchingRate: found match', {\n          taxRateId: bestMatch.id,\n          score: bestScore,\n          displayName: bestMatch.display_name,\n          percentage: bestMatch.percentage,\n        });\n      }\n\n      return bestMatch;\n    } catch (error) {\n      logger.error('findMatchingRate failed', {\n        error,\n        country: normalizedCountry,\n        state: normalizedState,\n        postal: normalizedPostal,\n        taxCode: normalizedTaxCode,\n        livemode,\n      });\n      return null;\n    }\n  }\n\n  /**\n   * Calculate tax amount from tax-inclusive total\n   * Formula: tax = total × (rate / (100 + rate))\n   */\n  public static calculateTaxFromInclusive(total: string, percentage: number): string {\n    const totalBN = new BN(total);\n    if (totalBN.lte(new BN('0'))) return '0';\n\n    const rateBN = new BN(percentage.toString()).mul(new BN('100'));\n    const denominator = new BN('10000').add(rateBN);\n\n    // tax = total * rate / (10000 + rate)\n    const taxAmount = totalBN.mul(rateBN).div(denominator);\n    return taxAmount.toString();\n  }\n\n  /**\n   * Calculate subtotal from tax-inclusive total\n   * Formula: subtotal = total - tax\n   */\n  public static calculateSubtotalFromInclusive(total: string, percentage: number): string {\n    const totalBN = new BN(total);\n    if (totalBN.lte(new BN('0'))) return total;\n\n    const taxAmount = new BN(this.calculateTaxFromInclusive(total, percentage));\n    return totalBN.sub(taxAmount).toString();\n  }\n\n  /**\n   * Calculate tax amount for a single invoice item\n   * Formula: tax = amount × (rate / 100)\n   */\n  public static calculateTaxForItem(amount: string, percentage: number): string {\n    const amountBN = new BN(amount);\n    if (amountBN.lte(new BN('0'))) return '0';\n\n    const rateBN = new BN(percentage.toString()).mul(new BN('100'));\n\n    // tax = amount * rate / 10000\n    const taxAmount = amountBN.mul(rateBN).div(new BN('10000'));\n    return taxAmount.toString();\n  }\n\n  /**\n   * Calculate total tax for multiple invoice items\n   */\n  public static calculateTotalTax(\n    items: Array<{ amount: string; tax_rate_id?: string; tax_rate?: { percentage: number } }>\n  ): string {\n    return items.reduce((total, item) => {\n      if (!item.tax_rate_id || !item.tax_rate) return total;\n\n      const itemTax = this.calculateTaxForItem(item.amount, item.tax_rate.percentage);\n      return new BN(total).add(new BN(itemTax)).toString();\n    }, '0');\n  }\n}\n\nexport type TTaxRate = InferAttributes<TaxRate>;\n","numLines":353,"startLine":1,"totalLines":353}}}
{"parentUuid":"cf862766-1101-4f1b-9efb-6fbdf1c4f7b7","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017ZsGuzygzmVBdw2UCkxzXu","type":"message","role":"assistant","content":[{"type":"text","text":"现在让我读取核心的业务逻辑文件："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":29421,"cache_read_input_tokens":21146,"cache_creation":{"ephemeral_5m_input_tokens":29421,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxriKnb5VrxzmZ2RL3T","type":"assistant","uuid":"aac91875-eedd-4d5d-b135-c237164356ad","timestamp":"2026-01-09T01:49:18.582Z"}
{"parentUuid":"aac91875-eedd-4d5d-b135-c237164356ad","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017ZsGuzygzmVBdw2UCkxzXu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qp7RdXpKAKG21ufgrL1HXF","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":29421,"cache_read_input_tokens":21146,"cache_creation":{"ephemeral_5m_input_tokens":29421,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxriKnb5VrxzmZ2RL3T","type":"assistant","uuid":"4d4e472d-a53c-45e0-8f5f-c2c3c33c05e9","timestamp":"2026-01-09T01:49:20.402Z"}
{"parentUuid":"4d4e472d-a53c-45e0-8f5f-c2c3c33c05e9","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017ZsGuzygzmVBdw2UCkxzXu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01P7PFQNCqPJrfzh88sg9zcv","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/subscription.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":29421,"cache_read_input_tokens":21146,"cache_creation":{"ephemeral_5m_input_tokens":29421,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxriKnb5VrxzmZ2RL3T","type":"assistant","uuid":"e648c2dd-002a-421e-bddd-1affe07f93e6","timestamp":"2026-01-09T01:49:20.935Z"}
{"parentUuid":"e648c2dd-002a-421e-bddd-1affe07f93e6","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_017ZsGuzygzmVBdw2UCkxzXu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ExTYdkKzRUp1uMCeXBCN8V","name":"Glob","input":{"pattern":"**/api/src/libs/discount*.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":29421,"cache_read_input_tokens":21146,"cache_creation":{"ephemeral_5m_input_tokens":29421,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxriKnb5VrxzmZ2RL3T","type":"assistant","uuid":"0de1efe6-ee0c-435a-a430-1eadf544cf9a","timestamp":"2026-01-09T01:49:21.397Z"}
{"parentUuid":"0de1efe6-ee0c-435a-a430-1eadf544cf9a","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ExTYdkKzRUp1uMCeXBCN8V","type":"tool_result","content":"No files found"}]},"uuid":"ba7f1990-c006-46eb-ad57-91e5f4e764ca","timestamp":"2026-01-09T01:49:21.580Z","toolUseResult":{"filenames":[],"durationMs":29,"numFiles":0,"truncated":false}}
{"parentUuid":"ba7f1990-c006-46eb-ad57-91e5f4e764ca","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Qp7RdXpKAKG21ufgrL1HXF","type":"tool_result","content":"     1→import { component } from '@blocklet/sdk';\n     2→import type { LiteralUnion } from 'type-fest';\n     3→import { withQuery } from 'ufo';\n     4→\n     5→import { BN, fromUnitToToken } from '@ocap/util';\n     6→import { Op, type WhereOptions } from 'sequelize';\n     7→import { cloneDeep, pick } from 'lodash';\n     8→import {\n     9→  Customer,\n    10→  Invoice,\n    11→  InvoiceItem,\n    12→  PaymentCurrency,\n    13→  PaymentIntent,\n    14→  PaymentMethod,\n    15→  PaymentSettings,\n    16→  Price,\n    17→  PriceQuote,\n    18→  Product,\n    19→  Refund,\n    20→  SetupIntent,\n    21→  SimpleCustomField,\n    22→  Subscription,\n    23→  SubscriptionItem,\n    24→  TaxRate,\n    25→  TInvoice,\n    26→  TLineItemExpanded,\n    27→  UsageRecord,\n    28→  Lock,\n    29→  DiscountAmount,\n    30→} from '../store/models';\n    31→import { getConnectQueryParam } from './util';\n    32→import { expandLineItems } from './session';\n    33→import dayjs from './dayjs';\n    34→import {\n    35→  getSubscriptionCycleAmount,\n    36→  getSubscriptionCycleSetup,\n    37→  getSubscriptionItemPrice,\n    38→  getSubscriptionStakeAmountSetup,\n    39→  isSubscriptionOverdraftProtectionEnabled,\n    40→} from './subscription';\n    41→import logger from './logger';\n    42→import { ensureOverdraftProtectionPrice } from './overdraft-protection';\n    43→import { CHARGE_SUPPORTED_CHAIN_TYPES } from './constants';\n    44→import { emitAsync } from './event';\n    45→import { getPriceUintAmountByCurrency } from './price';\n    46→import { generateQuotesForInvoiceItems } from './invoice-quote';\n    47→\n    48→export function getCustomerInvoicePageUrl({\n    49→  invoiceId,\n    50→  userDid,\n    51→  locale = 'en',\n    52→  action = '',\n    53→}: {\n    54→  userDid: string;\n    55→  invoiceId: string;\n    56→  locale: LiteralUnion<'en' | 'zh', string>;\n    57→  action?: LiteralUnion<'pay', string>;\n    58→}) {\n    59→  return component.getUrl(\n    60→    withQuery(`customer/invoice/${invoiceId}`, {\n    61→      locale,\n    62→      action,\n    63→      ...getConnectQueryParam({ userDid }),\n    64→    })\n    65→  );\n    66→}\n    67→\n    68→export async function getOneTimeProductInfo(invoiceId: string, paymentCurrency: PaymentCurrency) {\n    69→  try {\n    70→    const doc = await Invoice.findOne({\n    71→      where: { id: invoiceId },\n    72→      include: [{ model: InvoiceItem, as: 'lines' }],\n    73→    });\n    74→    if (!doc) {\n    75→      throw new Error(`Invoice not found: ${invoiceId}`);\n    76→    }\n    77→    const json = doc.toJSON();\n    78→    const products = (await Product.findAll()).map((x) => x.toJSON());\n    79→    const prices = (await Price.findAll()).map((x) => x.toJSON());\n    80→    // @ts-ignore\n    81→    expandLineItems(json.lines, products, prices);\n    82→    const oneTimePaymentInfo: Array<{\n    83→      productName: string;\n    84→      paymentInfo: string;\n    85→      quantity: number;\n    86→    }> = [];\n    87→    // @ts-ignore\n    88→    (json.lines || []).forEach((x) => {\n    89→      const { recurring, product } = x.price;\n    90→      if (!recurring) {\n    91→        // it's one-time product\n    92→        oneTimePaymentInfo.push({\n    93→          productName: product?.name,\n    94→          paymentInfo: `${fromUnitToToken(x.amount, paymentCurrency.decimal)} ${paymentCurrency.symbol}`,\n    95→          quantity: x.quantity,\n    96→        });\n    97→      }\n    98→    });\n    99→    return oneTimePaymentInfo;\n   100→  } catch (err) {\n   101→    console.error(`Error in getOneTimeProductInfo for invoice ${invoiceId}:`, err);\n   102→    return [];\n   103→  }\n   104→}\n   105→\n   106→export async function getInvoiceShouldPayTotal(invoice: Invoice) {\n   107→  try {\n   108→    const subscription = await Subscription.findByPk(invoice.subscription_id);\n   109→    if (!subscription) {\n   110→      throw new Error(`Subscription not found: ${invoice.subscription_id}`);\n   111→    }\n   112→\n   113→    const paymentCurrency = await PaymentCurrency.findByPk(invoice.currency_id);\n   114→    if (!paymentCurrency) {\n   115→      throw new Error(`Payment currency not found: ${invoice.currency_id}`);\n   116→    }\n   117→\n   118→    const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n   119→    if (!paymentMethod) {\n   120→      throw new Error(`Payment method not found: ${paymentCurrency.payment_method_id}`);\n   121→    }\n   122→\n   123→    const subscriptionItems = await SubscriptionItem.findAll({\n   124→      where: { subscription_id: subscription.id },\n   125→    });\n   126→    const invoiceItems = await InvoiceItem.findAll({\n   127→      where: { invoice_id: invoice.id },\n   128→    });\n   129→    const invoiceQuoteIds = invoiceItems\n   130→      .map((item) => item.metadata?.quote_id)\n   131→      .filter((id): id is string => typeof id === 'string' && id.length > 0);\n   132→    const invoiceQuotes = invoiceQuoteIds.length\n   133→      ? await PriceQuote.findAll({ where: { id: invoiceQuoteIds } })\n   134→      : [];\n   135→    const invoiceQuotesById = new Map(invoiceQuotes.map((quote) => [quote.id, quote]));\n   136→    const invoiceQuoteBySubscriptionItemId = new Map<string, { quotedAmount?: string; amount?: string }>();\n   137→    invoiceItems.forEach((item) => {\n   138→      if (!item.subscription_item_id) {\n   139→        return;\n   140→      }\n   141→      const quoteId = typeof item.metadata?.quote_id === 'string' ? item.metadata?.quote_id : undefined;\n   142→      const quote = quoteId ? invoiceQuotesById.get(quoteId) : undefined;\n   143→      const quotedAmount = quote?.quoted_amount || (item.metadata as any)?.quote?.quoted_amount;\n   144→      invoiceQuoteBySubscriptionItemId.set(item.subscription_item_id, {\n   145→        quotedAmount,\n   146→        amount: item.amount,\n   147→      });\n   148→    });\n   149→\n   150→    let expandedItems = await Price.expand(\n   151→      subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n   152→      { product: true }\n   153→    );\n   154→\n   155→    const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, invoice.period_start);\n   156→    let offset = 0;\n   157→    let filterFunc = (item: any) => item;\n   158→    if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type)) {\n   159→      switch (invoice.billing_reason) {\n   160→        case 'subscription_cancel':\n   161→          filterFunc = (item: any) => item.price?.recurring?.usage_type === 'metered';\n   162→          break;\n   163→        case 'subscription_cycle':\n   164→          filterFunc = (item: any) => item.price?.type === 'recurring';\n   165→          offset = setup.cycle / 1000;\n   166→          break;\n   167→        default:\n   168→          filterFunc = () => true;\n   169→      }\n   170→    }\n   171→    const previousPeriodStart = setup.period.start - offset;\n   172→    const previousPeriodEnd = setup.period.end - offset;\n   173→    expandedItems = await Promise.all(\n   174→      expandedItems.filter(filterFunc).map(async (item: any) => {\n   175→        const { price } = item;\n   176→        if (price?.recurring?.usage_type === 'metered') {\n   177→          const rawQuantity = await UsageRecord.getSummary({\n   178→            id: item.id,\n   179→            start: previousPeriodStart,\n   180→            end: previousPeriodEnd,\n   181→            method: price.recurring?.aggregate_usage,\n   182→            dryRun: true,\n   183→            searchBilled: false,\n   184→          });\n   185→          item.quantity = price.transformQuantity(rawQuantity);\n   186→        }\n   187→        return item;\n   188→      })\n   189→    );\n   190→\n   191→    if (invoiceQuoteBySubscriptionItemId.size > 0) {\n   192→      expandedItems = expandedItems.map((item: any) => {\n   193→        const price = item.price;\n   194→        if (price?.pricing_type !== 'dynamic') {\n   195→          return item;\n   196→        }\n   197→        const quoteInfo = invoiceQuoteBySubscriptionItemId.get(item.id);\n   198→        if (!quoteInfo) {\n   199→          return item;\n   200→        }\n   201→        const quotedAmount = quoteInfo.quotedAmount || quoteInfo.amount;\n   202→        if (!quotedAmount) {\n   203→          return item;\n   204→        }\n   205→        return {\n   206→          ...item,\n   207→          custom_amount: quotedAmount,\n   208→          quoted_amount: quotedAmount,\n   209→        };\n   210→      });\n   211→    }\n   212→\n   213→    const baseAmount = getSubscriptionCycleAmount(expandedItems, subscription.currency_id);\n   214→    let shouldPayTotal = baseAmount?.total || invoice.total;\n   215→\n   216→    // Apply discount if exists\n   217→    if (baseAmount?.total && invoice.total_discount_amounts && invoice.total_discount_amounts.length > 0) {\n   218→      const totalDiscountAmount = invoice.total_discount_amounts.reduce((sum, discount) => {\n   219→        return new BN(sum).add(new BN(discount.amount.toString())).toString();\n   220→      }, '0');\n   221→\n   222→      shouldPayTotal = new BN(shouldPayTotal).sub(new BN(totalDiscountAmount)).toString();\n   223→\n   224→      // Ensure the final amount doesn't go below zero\n   225→      if (new BN(shouldPayTotal).lt(new BN('0'))) {\n   226→        shouldPayTotal = '0';\n   227→      }\n   228→    }\n   229→\n   230→    return shouldPayTotal;\n   231→  } catch (err) {\n   232→    console.error(`Error in getInvoiceShouldPayTotal for invoice ${invoice.id}:`, err);\n   233→    return invoice.total;\n   234→  }\n   235→}\n   236→\n   237→export async function getReturnStakeInvoices(subscription: Subscription) {\n   238→  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n   239→  const returnStakeInvoice: Invoice[] = [];\n   240→  const refunds = await Refund.findAll({\n   241→    where: { subscription_id: subscription.id, status: 'succeeded', type: 'stake_return' },\n   242→    include: [\n   243→      { model: Invoice, as: 'invoice' },\n   244→      { model: Customer, as: 'customer' },\n   245→      { model: PaymentCurrency, as: 'paymentCurrency' },\n   246→    ],\n   247→  });\n   248→\n   249→  await Promise.all(\n   250→    refunds.map(async (r: any) => {\n   251→      const invoice =\n   252→        r.invoice ||\n   253→        (await Invoice.findOne({\n   254→          where: {\n   255→            subscription_id: subscription.id,\n   256→            currency_id: r.currency_id,\n   257→          },\n   258→          order: [['created_at', 'ASC']],\n   259→        }));\n   260→      returnStakeInvoice.push({\n   261→        id: r.id,\n   262→        status: 'paid',\n   263→        billing_reason: 'return_stake',\n   264→        description: 'Return Subscription staking',\n   265→        total: r.amount,\n   266→        amount_due: '0',\n   267→        amount_paid: r.amount,\n   268→        amount_remaining: '0',\n   269→        subscription_id: subscription.id,\n   270→        paid: true,\n   271→        ...pick(invoice, ['number', 'auto_advance', 'period_start', 'period_end']),\n   272→        ...pick(r, ['created_at', 'updated_at', 'currency_id', 'customer_id']),\n   273→        // @ts-ignore\n   274→        paymentCurrency: r.paymentCurrency,\n   275→        paymentMethod: method,\n   276→        customer: r.customer,\n   277→        metadata: {\n   278→          payment_details: {\n   279→            arcblock: {\n   280→              tx_hash: r?.payment_details?.arcblock?.tx_hash,\n   281→              payer: r?.payment_details?.arcblock?.payer,\n   282→            },\n   283→          },\n   284→        },\n   285→      });\n   286→    })\n   287→  );\n   288→  return returnStakeInvoice;\n   289→}\n   290→\n   291→export async function getSetupInvoice(\n   292→  subscription: Subscription,\n   293→  paymentMethod: PaymentMethod,\n   294→  currencyId: string,\n   295→  stakingProps: { tx_hash: string; payer: string; address: string }\n   296→) {\n   297→  const currency = await PaymentCurrency.findByPk(currencyId);\n   298→  if (!currency) {\n   299→    return null;\n   300→  }\n   301→  if (!stakingProps?.tx_hash) {\n   302→    return null;\n   303→  }\n   304→  if (paymentMethod?.type !== 'arcblock') {\n   305→    return null;\n   306→  }\n   307→  const firstInvoice = await Invoice.findOne({\n   308→    where: { subscription_id: subscription.id, currency_id: currency.id },\n   309→    order: [['created_at', 'ASC']],\n   310→    include: [{ model: Customer, as: 'customer' }],\n   311→  });\n   312→  if (!firstInvoice) {\n   313→    return null;\n   314→  }\n   315→  const stakeAmountResult = await getSubscriptionStakeAmountSetup(subscription, paymentMethod, stakingProps.tx_hash);\n   316→  // @ts-ignore\n   317→  const stakeAmount = stakeAmountResult?.[currency?.contract] || '0';\n   318→  return {\n   319→    id: stakingProps.address as string,\n   320→    status: 'paid',\n   321→    description: 'Subscription staking',\n   322→    billing_reason: 'stake',\n   323→    total: stakeAmount,\n   324→    amount_due: '0',\n   325→    amount_paid: stakeAmount,\n   326→    amount_remaining: '0',\n   327→    ...pick(firstInvoice, [\n   328→      'number',\n   329→      'paid',\n   330→      'auto_advance',\n   331→      'currency_id',\n   332→      'customer_id',\n   333→      'subscription_id',\n   334→      'period_start',\n   335→      'period_end',\n   336→      'created_at',\n   337→      'updated_at',\n   338→    ]),\n   339→    // @ts-ignore\n   340→    paymentCurrency: currency,\n   341→    paymentMethod,\n   342→    // @ts-ignore\n   343→    customer: firstInvoice?.customer,\n   344→    metadata: {\n   345→      payment_details: {\n   346→        arcblock: {\n   347→          tx_hash: stakingProps?.tx_hash,\n   348→          payer: stakingProps?.payer,\n   349→        },\n   350→      },\n   351→    },\n   352→  };\n   353→}\n   354→\n   355→export async function getStakingInvoices(subscription: Subscription): Promise<Invoice[]> {\n   356→  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n   357→  if (!method) {\n   358→    return [];\n   359→  }\n   360→  const stakeInvoices = await Invoice.findAll({\n   361→    where: { subscription_id: subscription.id, billing_reason: 'stake', status: 'paid' },\n   362→    include: [\n   363→      { model: Customer, as: 'customer' },\n   364→      { model: PaymentCurrency, as: 'paymentCurrency' },\n   365→      { model: PaymentMethod, as: 'paymentMethod' },\n   366→    ],\n   367→  });\n   368→  const invoices = cloneDeep(stakeInvoices);\n   369→  const setups = await SetupIntent.findAll({\n   370→    where: {\n   371→      customer_id: subscription.customer_id,\n   372→      payment_method_id: method?.id,\n   373→      status: 'succeeded',\n   374→      [Op.and]: [\n   375→        { metadata: { [Op.not]: null } },\n   376→        { 'metadata.subscription_id': subscription.id },\n   377→        { setup_details: { [Op.not]: null } },\n   378→        { 'setup_details.arcblock': { [Op.not]: null } },\n   379→        { 'setup_details.arcblock.staking': { [Op.not]: null } },\n   380→      ] as any,\n   381→    },\n   382→  });\n   383→  if (setups.length === 0) {\n   384→    // No payment change, use the first invoice\n   385→    if (stakeInvoices.length > 0) {\n   386→      return stakeInvoices;\n   387→    }\n   388→    const newInvoice = await getSetupInvoice(subscription, method, subscription.currency_id, {\n   389→      tx_hash: subscription.payment_details?.arcblock?.staking?.tx_hash!,\n   390→      payer: subscription.payment_details?.arcblock?.payer!,\n   391→      address: subscription.payment_details?.arcblock?.staking?.address!,\n   392→    });\n   393→    // @ts-ignore\n   394→    return [newInvoice].filter(Boolean);\n   395→  }\n   396→\n   397→  await Promise.all(\n   398→    setups.map(async (setup: SetupIntent, index: number) => {\n   399→      if (\n   400→        index === 0 &&\n   401→        setup.metadata?.from_currency &&\n   402→        !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.from_currency)\n   403→      ) {\n   404→        const paymentDetails =\n   405→          setup?.metadata?.from_payment_details?.arcblock || subscription.payment_details?.arcblock;\n   406→        const fromMethod = await PaymentMethod.findByPk(setup?.metadata?.from_payment_method_id);\n   407→        const newInvoice = await getSetupInvoice(subscription, fromMethod!, setup.metadata?.from_currency, {\n   408→          tx_hash: paymentDetails?.staking?.tx_hash!,\n   409→          payer: paymentDetails?.payer!,\n   410→          address: paymentDetails?.staking?.address!,\n   411→        });\n   412→        if (newInvoice) {\n   413→          // @ts-ignore\n   414→          invoices.push(newInvoice);\n   415→        }\n   416→      }\n   417→      if (setup.metadata?.to_currency && !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.to_currency)) {\n   418→        const newInvoice = await getSetupInvoice(subscription, method, setup.metadata?.to_currency, {\n   419→          tx_hash: setup.setup_details?.arcblock?.staking?.tx_hash!,\n   420→          payer: setup.setup_details?.arcblock?.payer!,\n   421→          address: setup.setup_details?.arcblock?.staking?.address!,\n   422→        });\n   423→        if (newInvoice) {\n   424→          // @ts-ignore\n   425→          invoices.push(newInvoice);\n   426→        }\n   427→      }\n   428→    })\n   429→  );\n   430→  return invoices;\n   431→}\n   432→\n   433→type BaseInvoiceProps = {\n   434→  customer: Customer;\n   435→  subscription?: Subscription | null;\n   436→  currency_id: string;\n   437→  livemode: boolean;\n   438→  period_start: number;\n   439→  period_end: number;\n   440→  status?: string;\n   441→  billing_reason: string;\n   442→  description: string;\n   443→  statement_descriptor?: string;\n   444→  total: string;\n   445→  subtotal?: string;\n   446→  amount_due?: string;\n   447→  amount_paid?: string;\n   448→  amount_remaining?: string;\n   449→  default_payment_method_id: string;\n   450→  payment_intent_id?: string;\n   451→  checkout_session_id?: string;\n   452→  metadata?: Record<string, any>;\n   453→  // Discount fields\n   454→  discounts?: string[];\n   455→  total_discount_amounts?: DiscountAmount[];\n   456→  items?: Array<{\n   457→    price_id: string;\n   458→    amount: string;\n   459→    quantity: number;\n   460→    description: string;\n   461→    period?: {\n   462→      start: number;\n   463→      end: number;\n   464→    };\n   465→    metadata?: Record<string, any>;\n   466→    subscription_item_id?: string;\n   467→    // Discount fields for InvoiceItem\n   468→    discountable?: boolean;\n   469→    discount_amounts?: DiscountAmount[];\n   470→  }>;\n   471→  auto_advance?: boolean;\n   472→  paid?: boolean;\n   473→  paid_out_of_band?: boolean;\n   474→  payment_settings?: PaymentSettings;\n   475→  footer?: string;\n   476→  custom_fields?: SimpleCustomField[];\n   477→  starting_token_balance?: Record<string, string>;\n   478→  ending_token_balance?: Record<string, string>;\n   479→  subtotal_excluding_tax?: string;\n   480→  collection_method?: 'charge_automatically' | 'send_invoice';\n   481→  id?: string;\n   482→  quote_id?: string;\n   483→};\n   484→\n   485→async function createInvoiceWithItems(props: BaseInvoiceProps): Promise<{\n   486→  invoice: Invoice;\n   487→  items: InvoiceItem[];\n   488→}> {\n   489→  const {\n   490→    customer,\n   491→    subscription,\n   492→    currency_id: currencyId,\n   493→    livemode,\n   494→    period_start: periodStart,\n   495→    period_end: periodEnd,\n   496→    status = 'open',\n   497→    billing_reason: billingReason,\n   498→    description,\n   499→    statement_descriptor: statementDescriptor = '',\n   500→    total,\n   501→    amount_due: amountDue = total,\n   502→    amount_paid: amountPaid = '0',\n   503→    amount_remaining: amountRemaining = total,\n   504→    default_payment_method_id: paymentMethodId,\n   505→    payment_intent_id: paymentIntentId = '',\n   506→    checkout_session_id: checkoutSessionId = '',\n   507→    items: itemsData,\n   508→    metadata = {},\n   509→    paid = false,\n   510→    auto_advance: autoAdvance = true,\n   511→    paid_out_of_band: paidOutOfBand = false,\n   512→    payment_settings: paymentSettings,\n   513→    ...extraProps\n   514→  } = props;\n   515→\n   516→  const invoiceNumber = await customer.getInvoiceNumber();\n   517→  // create invoice\n   518→  const invoice = await Invoice.create({\n   519→    amount_shipping: '0',\n   520→    starting_balance: '0',\n   521→    ending_balance: '0',\n   522→    subtotal_excluding_tax: '0',\n   523→    starting_token_balance: {},\n   524→    ending_token_balance: {},\n   525→    attempt_count: 0,\n   526→    attempted: false,\n   527→    tax: '0',\n   528→    discounts: props.discounts || [],\n   529→    total_discount_amounts: props.total_discount_amounts || [],\n   530→    collection_method: 'charge_automatically',\n   531→    ...extraProps,\n   532→    livemode,\n   533→    number: invoiceNumber,\n   534→    description,\n   535→    statement_descriptor: statementDescriptor,\n   536→    period_start: periodStart,\n   537→    period_end: periodEnd,\n   538→    auto_advance: autoAdvance,\n   539→    paid,\n   540→    paid_out_of_band: paidOutOfBand,\n   541→    status,\n   542→    billing_reason: billingReason,\n   543→    currency_id: currencyId,\n   544→    customer_id: customer.id,\n   545→    default_payment_method_id: paymentMethodId,\n   546→    payment_intent_id: paymentIntentId,\n   547→    subscription_id: subscription?.id,\n   548→    checkout_session_id: checkoutSessionId,\n   549→    total,\n   550→    subtotal: props.subtotal || total,\n   551→    amount_due: amountDue,\n   552→    amount_paid: amountPaid,\n   553→    amount_remaining: amountRemaining,\n   554→\n   555→    customer_address: customer.address,\n   556→    customer_email: customer.email,\n   557→    customer_name: customer.name,\n   558→    customer_phone: customer.phone,\n   559→\n   560→    effective_at: dayjs().unix(),\n   561→    status_transitions: {\n   562→      finalized_at: dayjs().unix(),\n   563→    },\n   564→    payment_settings: paymentSettings || subscription?.payment_settings,\n   565→    metadata,\n   566→  });\n   567→\n   568→  if (!itemsData) {\n   569→    return { invoice, items: [] };\n   570→  }\n   571→\n   572→  // Generate quotes for dynamic pricing items (subscription invoices)\n   573→  const enrichedItemsData = subscription\n   574→    ? await generateQuotesForInvoiceItems({\n   575→        invoiceId: invoice.id,\n   576→        items: itemsData,\n   577→        currencyId,\n   578→      })\n   579→    : itemsData;\n   580→\n   581→  // create invoice items\n   582→  const items = await Promise.all(\n   583→    enrichedItemsData.map(async (item) => {\n   584→      // Match tax rate for this specific item\n   585→      let taxRateId: string | undefined;\n   586→      if (customer.address?.country && item.price_id) {\n   587→        try {\n   588→          const price = await Price.findByPk(item.price_id);\n   589→          if (price?.product_id) {\n   590→            const product = await Product.findByPk(price.product_id);\n   591→            if (product) {\n   592→              const taxRate = await TaxRate.findMatchingRate({\n   593→                country: customer.address.country,\n   594→                state: customer.address.state,\n   595→                postalCode: customer.address.postal_code,\n   596→                taxCode: product.tax_code,\n   597→                livemode,\n   598→              });\n   599→              taxRateId = taxRate?.id;\n   600→            }\n   601→          }\n   602→        } catch (error) {\n   603→          logger.error('Failed to match tax rate for invoice item:', error);\n   604→        }\n   605→      }\n   606→\n   607→      return InvoiceItem.create({\n   608→        livemode,\n   609→        amount: item.amount,\n   610→        quantity: item.quantity,\n   611→        description: item.description,\n   612→        period: item.period,\n   613→        currency_id: currencyId,\n   614→        customer_id: customer.id,\n   615→        price_id: item.price_id,\n   616→        invoice_id: invoice.id,\n   617→        subscription_id: subscription?.id,\n   618→        subscription_item_id: item.subscription_item_id,\n   619→        tax_rate_id: taxRateId,\n   620→        discountable: item.discountable || false,\n   621→        discounts: [], // Keep as empty for now - this is legacy field\n   622→        discount_amounts:\n   623→          item.discount_amounts?.map((d) => ({ amount: new BN(d.amount || '0').toString(), discount: d.discount })) ||\n   624→          [],\n   625→        proration: false,\n   626→        proration_details: {},\n   627→        metadata: {\n   628→          ...(item.metadata || {}),\n   629→          // Include quote_id in metadata if it exists (for dynamic pricing)\n   630→          ...((item as any).quote_id && { quote_id: (item as any).quote_id }),\n   631→        },\n   632→      });\n   633→    })\n   634→  );\n   635→\n   636→  return { invoice, items };\n   637→}\n   638→\n   639→export async function ensureInvoiceAndItems({\n   640→  customer,\n   641→  currency,\n   642→  subscription,\n   643→  subscriptions,\n   644→  props,\n   645→  lineItems,\n   646→  trialing,\n   647→  metered,\n   648→  applyCredit = true,\n   649→}: {\n   650→  customer: Customer;\n   651→  currency: PaymentCurrency;\n   652→  subscription?: Subscription;\n   653→  subscriptions?: Subscription[];\n   654→  props: TInvoice;\n   655→  lineItems: TLineItemExpanded[];\n   656→  trialing: boolean; // do we have trialing\n   657→  metered: boolean; // is the quantity metered\n   658→  applyCredit?: boolean; // should we apply customer credit?\n   659→}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n   660→  // apply possible balance to invoice\n   661→  let remaining = props.total;\n   662→  let result = { starting: {}, ending: {} };\n   663→  if (applyCredit && props.total > '0' && !props.amount_remaining) {\n   664→    const balance = customer.getBalanceToApply(currency.id, props.total);\n   665→    result = await customer.decreaseTokenBalance(currency.id, balance);\n   666→    remaining = new BN(props.total).sub(new BN(balance)).toString();\n   667→    logger.info('Invoice will use customer credit', { result, remaining, total: props.total });\n   668→  }\n   669→\n   670→  // get subscription items\n   671→  let subscriptionItems: SubscriptionItem[] = [];\n   672→  if (subscriptions && subscriptions.length > 0) {\n   673→    subscriptionItems = await SubscriptionItem.findAll({\n   674→      where: { subscription_id: { [Op.in]: subscriptions.map((s) => s.id) } },\n   675→    });\n   676→  } else if (subscription) {\n   677→    subscriptionItems = await SubscriptionItem.findAll({\n   678→      where: { subscription_id: subscription?.id },\n   679→    });\n   680→  }\n   681→\n   682→  function getLineSetup(x: TLineItemExpanded) {\n   683→    const price = getSubscriptionItemPrice(x);\n   684→    if (price.type === 'recurring' && trialing) {\n   685→      return {\n   686→        price,\n   687→        amount: '0',\n   688→        // @ts-ignore\n   689→        description: trialing ? `${price.product.name} (trialing)` : price.product.name,\n   690→        period: {\n   691→          start: props.period_start,\n   692→          end: props.period_end,\n   693→        },\n   694→      };\n   695→    }\n   696→\n   697→    return {\n   698→      price,\n   699→      amount:\n   700→        x.custom_amount ||\n   701→        new BN(getPriceUintAmountByCurrency(price, props.currency_id)).mul(new BN(x.quantity)).toString(),\n   702→      description: price.product.name,\n   703→      period: undefined,\n   704→    };\n   705→  }\n   706→  // process line items\n   707→  const processedItems = lineItems.map((x: TLineItemExpanded) => {\n   708→    const setup = getLineSetup(x);\n   709→    const { price } = setup;\n   710→    let { quantity } = x;\n   711→    if (price.type === 'recurring') {\n   712→      if (price.recurring?.usage_type === 'metered' && !metered) {\n   713→        quantity = 0;\n   714→      }\n   715→      if (trialing) {\n   716→        quantity = 0;\n   717→      }\n   718→    }\n   719→\n   720→    return {\n   721→      price_id: price.id,\n   722→      amount: quantity > 0 ? setup.amount : '0',\n   723→      quantity,\n   724→      description: setup.description,\n   725→      period: setup.period,\n   726→      metadata: x.metadata || {},\n   727→      subscription_item_id: subscriptionItems.find((si) => si.price_id === price.id)?.id,\n   728→      // Discount fields from pre-calculated line items\n   729→      discountable: x.discountable || false,\n   730→      discount_amounts: x.discount_amounts || [],\n   731→    };\n   732→  });\n   733→\n   734→  return createInvoiceWithItems({\n   735→    customer,\n   736→    subscription,\n   737→    items: processedItems,\n   738→    livemode: props.livemode,\n   739→    status: props.status || 'open',\n   740→    billing_reason: props.billing_reason,\n   741→    description: props.description || '',\n   742→    statement_descriptor: props.statement_descriptor,\n   743→\n   744→    currency_id: props.currency_id,\n   745→    payment_intent_id: props.payment_intent_id,\n   746→    checkout_session_id: props.checkout_session_id,\n   747→    default_payment_method_id: props.default_payment_method_id,\n   748→\n   749→    period_start: props.period_start,\n   750→    period_end: props.period_end,\n   751→    auto_advance: props.auto_advance,\n   752→\n   753→    total: props.total,\n   754→    subtotal: props.subtotal || props.total,\n   755→    amount_remaining: props.amount_remaining || remaining,\n   756→    amount_paid: props.amount_paid,\n   757→    amount_due: props.amount_due || remaining,\n   758→    subtotal_excluding_tax: props.subtotal || props.total || '0',\n   759→    starting_token_balance: result.starting,\n   760→    ending_token_balance: result.ending,\n   761→\n   762→    footer: props.footer,\n   763→    custom_fields: props.custom_fields,\n   764→    payment_settings: props.payment_settings || subscription?.payment_settings,\n   765→    discounts: props.discounts,\n   766→    total_discount_amounts: props.total_discount_amounts || [],\n   767→    metadata: {\n   768→      ...props.metadata,\n   769→      starting_token_balance: result.starting,\n   770→      ending_token_balance: result.ending,\n   771→    },\n   772→  });\n   773→}\n   774→\n   775→export async function cleanupInvoiceAndItems(invoiceId: string) {\n   776→  const invoice = await Invoice.findByPk(invoiceId);\n   777→  if (!invoice) {\n   778→    return;\n   779→  }\n   780→  if (invoice.isImmutable()) {\n   781→    return;\n   782→  }\n   783→\n   784→  const removedItem = await InvoiceItem.destroy({ where: { invoice_id: invoiceId } });\n   785→  const removedInvoice = await Invoice.destroy({ where: { id: invoiceId } });\n   786→  logger.info('cleanup invoice and items', { invoiceId, removedItem, removedInvoice });\n   787→}\n   788→\n   789→export async function ensureRechargeInvoice(\n   790→  invoiceProps: {\n   791→    total: string;\n   792→    description?: string;\n   793→    checkout_session_id?: string;\n   794→    currency_id: string;\n   795→    metadata?: any;\n   796→    payment_settings?: any;\n   797→    livemode?: boolean;\n   798→  },\n   799→  subscription: Subscription | null,\n   800→  paymentMethod: PaymentMethod,\n   801→  customer: Customer\n   802→) {\n   803→  try {\n   804→    const { livemode = true } = invoiceProps;\n   805→    const { invoice } = await createInvoiceWithItems({\n   806→      customer,\n   807→      subscription,\n   808→      currency_id: invoiceProps.currency_id,\n   809→      livemode: subscription?.livemode ?? livemode,\n   810→      period_start: dayjs().unix(),\n   811→      period_end: dayjs().unix(),\n   812→      status: 'paid',\n   813→      billing_reason: 'recharge',\n   814→      description: invoiceProps?.description || 'Add funds for subscription',\n   815→      total: invoiceProps.total || '0',\n   816→      amount_due: '0',\n   817→      amount_paid: invoiceProps.total || '0',\n   818→      amount_remaining: '0',\n   819→      default_payment_method_id: paymentMethod.id,\n   820→      checkout_session_id: invoiceProps?.checkout_session_id || '',\n   821→      metadata: invoiceProps.metadata || {},\n   822→      auto_advance: false,\n   823→      paid: true,\n   824→      paid_out_of_band: false,\n   825→      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n   826→    });\n   827→\n   828→    logger.info('create recharge invoice success', {\n   829→      invoice,\n   830→      subscriptionId: subscription?.id,\n   831→      paymentMethod: paymentMethod.id,\n   832→    });\n   833→  } catch (error) {\n   834→    logger.error('ensureRechargeInvoice: create invoice failed', {\n   835→      error,\n   836→      subscriptionId: subscription?.id,\n   837→      paymentMethod: paymentMethod.id,\n   838→    });\n   839→    throw error;\n   840→  }\n   841→}\n   842→\n   843→export async function ensureOverdraftProtectionInvoiceAndItems({\n   844→  customer,\n   845→  subscription,\n   846→  paymentIntent,\n   847→  props,\n   848→}: {\n   849→  customer: Customer;\n   850→  subscription: Subscription;\n   851→  paymentIntent: PaymentIntent;\n   852→  props: Partial<TInvoice> & { period_start: number; period_end: number };\n   853→}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n   854→  const { price, product } = await ensureOverdraftProtectionPrice(subscription.livemode);\n   855→  const invoicePrice = price?.currency_options?.find((x: any) => x.currency_id === paymentIntent?.currency_id);\n   856→\n   857→  if (!subscription.overdraft_protection?.enabled) {\n   858→    throw new Error('Overdraft protection invoice creation skipped: overdraft protection is not enabled');\n   859→  }\n   860→\n   861→  if (!invoicePrice) {\n   862→    throw new Error('Overdraft protection invoice price not found');\n   863→  }\n   864→  const currency = await PaymentCurrency.findByPk(invoicePrice.currency_id);\n   865→  if (!currency) {\n   866→    throw new Error('Overdraft protection invoice currency not found');\n   867→  }\n   868→  const paymentMethod = await PaymentMethod.findByPk(currency?.payment_method_id);\n   869→  if (!paymentMethod) {\n   870→    throw new Error('Overdraft protection invoice payment method not found');\n   871→  }\n   872→\n   873→  if (paymentMethod.type !== 'arcblock') {\n   874→    throw new Error(`Payment method ${paymentMethod.type} not supported for overdraft protection`);\n   875→  }\n   876→\n   877→  const { unused } = await isSubscriptionOverdraftProtectionEnabled(subscription, paymentIntent?.currency_id);\n   878→  if (new BN(unused).lt(new BN(invoicePrice.unit_amount))) {\n   879→    throw new Error('Overdraft protection invoice creation skipped: insufficient overdraft protection funds');\n   880→  }\n   881→\n   882→  const result = await createInvoiceWithItems({\n   883→    customer,\n   884→    subscription,\n   885→    currency_id: invoicePrice.currency_id,\n   886→    livemode: subscription.livemode,\n   887→    period_start: props.period_start || 0,\n   888→    period_end: props.period_end || 0,\n   889→    status: props.status,\n   890→    billing_reason: 'overdraft_protection',\n   891→    description: 'Overdraft protection',\n   892→    collection_method: 'send_invoice',\n   893→    default_payment_method_id: paymentMethod.id,\n   894→    total: invoicePrice.unit_amount || '0',\n   895→    items: [\n   896→      {\n   897→        price_id: price?.id || '',\n   898→        amount: invoicePrice.unit_amount || '0',\n   899→        quantity: 1,\n   900→        description: product?.name || '',\n   901→        period: {\n   902→          start: props.period_start || 0,\n   903→          end: props.period_end || 0,\n   904→        },\n   905→      },\n   906→    ],\n   907→    metadata: {\n   908→      ...(props.metadata || {}),\n   909→      payment_intent_id: paymentIntent.id,\n   910→    },\n   911→  });\n   912→\n   913→  await Price.increment({ quantity_sold: 1 }, { where: { id: price?.id } });\n   914→  return result;\n   915→}\n   916→\n   917→export async function ensureStakeInvoice(\n   918→  invoiceProps: {\n   919→    total: string;\n   920→    description?: string;\n   921→    checkout_session_id?: string;\n   922→    currency_id: string;\n   923→    billing_reason?: string;\n   924→    metadata?: any;\n   925→    payment_settings?: any;\n   926→  },\n   927→  subscription: Subscription,\n   928→  paymentMethod: PaymentMethod,\n   929→  customer: Customer,\n   930→  allSubscriptions?: Subscription[]\n   931→) {\n   932→  if (paymentMethod.type !== 'arcblock') {\n   933→    return;\n   934→  }\n   935→\n   936→  try {\n   937→    const isMultiSubscription = allSubscriptions && allSubscriptions.length > 1;\n   938→    const metadata = {\n   939→      ...(invoiceProps.metadata || {}),\n   940→    };\n   941→\n   942→    if (isMultiSubscription) {\n   943→      metadata.all_subscription_ids = allSubscriptions.map((s) => s.id);\n   944→      metadata.is_shared_stake = true;\n   945→      metadata.primary_subscription_id = subscription.id;\n   946→    }\n   947→\n   948→    const { invoice } = await createInvoiceWithItems({\n   949→      customer,\n   950→      subscription,\n   951→      currency_id: invoiceProps.currency_id,\n   952→      livemode: subscription.livemode,\n   953→      period_start: dayjs().unix(),\n   954→      period_end: subscription.current_period_end,\n   955→      status: 'paid',\n   956→      billing_reason: invoiceProps?.billing_reason || 'stake',\n   957→      description: invoiceProps?.description || 'Stake for subscription',\n   958→      total: invoiceProps.total || '0',\n   959→      amount_due: '0',\n   960→      amount_paid: invoiceProps.total || '0',\n   961→      amount_remaining: '0',\n   962→      default_payment_method_id: paymentMethod.id,\n   963→      checkout_session_id: invoiceProps?.checkout_session_id || '',\n   964→      metadata,\n   965→      auto_advance: false,\n   966→      paid: true,\n   967→      paid_out_of_band: false,\n   968→      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n   969→    });\n   970→\n   971→    logger.info('create staking invoice success', {\n   972→      invoice,\n   973→      subscriptionId: subscription?.id,\n   974→      paymentMethod: paymentMethod.id,\n   975→    });\n   976→  } catch (error) {\n   977→    logger.error('ensureStake: create invoice failed', {\n   978→      error,\n   979→      subscriptionId: subscription?.id,\n   980→      paymentMethod: paymentMethod.id,\n   981→    });\n   982→    throw error;\n   983→  }\n   984→}\n   985→\n   986→export async function getStakeInvoiceForSubscription(subscriptionId: string, currencyId: string) {\n   987→  const where: WhereOptions = {\n   988→    [Op.or]: [\n   989→      { subscription_id: subscriptionId },\n   990→      { 'metadata.all_subscription_ids': { [Op.contains]: [subscriptionId] } },\n   991→    ],\n   992→    billing_reason: 'stake',\n   993→    status: 'paid',\n   994→  };\n   995→\n   996→  if (currencyId) {\n   997→    where.currency_id = currencyId;\n   998→  }\n   999→  try {\n  1000→    const invoice = await Invoice.findOne({ where });\n  1001→    return invoice;\n  1002→  } catch (error) {\n  1003→    logger.error('getStakeInvoiceForSubscription: find invoice failed', {\n  1004→      error,\n  1005→      subscriptionId,\n  1006→      currencyId,\n  1007→    });\n  1008→    return null;\n  1009→  }\n  1010→}\n  1011→\n  1012→// mark overdraft protection invoice as void after payment\n  1013→export async function handleOverdraftProtectionInvoiceAfterPayment(invoice: Invoice) {\n  1014→  try {\n  1015→    if (['stake', 'overdraft_protection', 'stake_overdraft_protection'].includes(invoice.billing_reason)) {\n  1016→      return;\n  1017→    }\n  1018→    const subscription = await Subscription.findByPk(invoice.subscription_id);\n  1019→    if (!subscription) {\n  1020→      logger.info('handle overdraft protection invoice skipped due to subscription not found', {\n  1021→        invoiceId: invoice.id,\n  1022→      });\n  1023→      return;\n  1024→    }\n  1025→    if (!subscription.overdraft_protection?.enabled) {\n  1026→      logger.info('handle overdraft protection invoice skipped due to overdraft protection not enabled', {\n  1027→        subscriptionId: subscription.id,\n  1028→      });\n  1029→      return;\n  1030→    }\n  1031→    const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n  1032→    if (!paymentMethod || paymentMethod?.type !== 'arcblock') {\n  1033→      logger.info('handle overdraft protection invoice skipped due to payment method not supported', {\n  1034→        invoiceId: invoice.id,\n  1035→        paymentMethodId: paymentMethod?.id,\n  1036→      });\n  1037→      return;\n  1038→    }\n  1039→    const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n  1040→    if (!paymentIntent) {\n  1041→      logger.info('handle overdraft protection invoice skipped due to payment intent not found', {\n  1042→        invoiceId: invoice.id,\n  1043→      });\n  1044→      return;\n  1045→    }\n  1046→    if (paymentIntent.status !== 'succeeded') {\n  1047→      logger.info('handle overdraft protection invoice skipped due to payment intent not succeeded', {\n  1048→        invoiceId: invoice.id,\n  1049→      });\n  1050→      return;\n  1051→    }\n  1052→    if (paymentIntent.payment_details?.arcblock?.type !== 'transfer') {\n  1053→      logger.info('handle overdraft protection invoice skipped due to payment type not transfer', {\n  1054→        invoiceId: invoice.id,\n  1055→        paymentIntentId: paymentIntent.id,\n  1056→      });\n  1057→      return;\n  1058→    }\n  1059→    const overdraftProtectionInvoice = await Invoice.findOne({\n  1060→      where: {\n  1061→        subscription_id: subscription.id,\n  1062→        billing_reason: 'overdraft_protection',\n  1063→        'metadata.invoice_id': invoice.id,\n  1064→        status: {\n  1065→          [Op.notIn]: ['paid', 'void'],\n  1066→        },\n  1067→      },\n  1068→    });\n  1069→    if (!overdraftProtectionInvoice) {\n  1070→      logger.info('handle overdraft protection invoice skipped due to overdraft protection invoice not found', {\n  1071→        invoiceId: invoice.id,\n  1072→      });\n  1073→      return;\n  1074→    }\n  1075→\n  1076→    if (overdraftProtectionInvoice.payment_intent_id) {\n  1077→      const overdraftProtectionPaymentIntent = await PaymentIntent.findOne({\n  1078→        where: {\n  1079→          id: overdraftProtectionInvoice.payment_intent_id,\n  1080→        },\n  1081→      });\n  1082→      if (overdraftProtectionPaymentIntent) {\n  1083→        await overdraftProtectionPaymentIntent.update({\n  1084→          status: 'canceled',\n  1085→          canceled_at: dayjs().unix(),\n  1086→          cancellation_reason: 'void_invoice',\n  1087→        });\n  1088→      }\n  1089→    }\n  1090→\n  1091→    await overdraftProtectionInvoice.update({\n  1092→      status: 'void',\n  1093→      status_transitions: {\n  1094→        ...(overdraftProtectionInvoice.status_transitions || {}),\n  1095→        voided_at: dayjs().unix(),\n  1096→      },\n  1097→    });\n  1098→  } catch (error) {\n  1099→    logger.error('handle overdraft protection invoice failed', {\n  1100→      error,\n  1101→      invoiceId: invoice.id,\n  1102→    });\n  1103→  }\n  1104→}\n  1105→\n  1106→/**\n  1107→ * retry uncollectible invoices\n  1108→ * @param options\n  1109→ */\n  1110→export async function retryUncollectibleInvoices(options: {\n  1111→  customerId?: string;\n  1112→  subscriptionId?: string;\n  1113→  invoiceId?: string;\n  1114→  invoiceIds?: string[];\n  1115→  currencyId?: string;\n  1116→}) {\n  1117→  const lockKey = `retry-uncollectible-${JSON.stringify(options)}`;\n  1118→\n  1119→  const isLocked = await Lock.isLocked(lockKey);\n  1120→  if (isLocked) {\n  1121→    logger.warn('Retry uncollectible invoices already in progress', {\n  1122→      lockKey,\n  1123→      options,\n  1124→    });\n  1125→    throw new Error('Retry already in progress');\n  1126→  }\n  1127→\n  1128→  try {\n  1129→    await Lock.acquire(lockKey, dayjs().add(5, 'minutes').unix());\n  1130→\n  1131→    const { customerId, subscriptionId, invoiceId, invoiceIds, currencyId } = options;\n  1132→\n  1133→    const where: WhereOptions = {\n  1134→      status: { [Op.in]: ['uncollectible'] },\n  1135→      payment_intent_id: { [Op.ne]: null },\n  1136→    };\n  1137→\n  1138→    if (customerId) {\n  1139→      where.customer_id = customerId;\n  1140→    }\n  1141→\n  1142→    if (subscriptionId) {\n  1143→      where.subscription_id = subscriptionId;\n  1144→    }\n  1145→\n  1146→    if (invoiceId) {\n  1147→      where.id = invoiceId;\n  1148→    }\n  1149→\n  1150→    if (invoiceIds && invoiceIds.length > 0) {\n  1151→      where.id = { [Op.in]: invoiceIds };\n  1152→    }\n  1153→\n  1154→    if (currencyId) {\n  1155→      where.currency_id = currencyId;\n  1156→    }\n  1157→\n  1158→    const overdueInvoices = (await Invoice.findAll({\n  1159→      where,\n  1160→      include: [{ model: PaymentIntent, as: 'paymentIntent' }],\n  1161→      attributes: ['id', 'payment_intent_id', 'subscription_id', 'customer_id', 'created_at', 'status', 'currency_id'],\n  1162→      order: [['created_at', 'ASC']],\n  1163→    })) as (Invoice & { paymentIntent?: PaymentIntent })[];\n  1164→\n  1165→    const startTime = Date.now();\n  1166→    logger.info('Found uncollectible invoices to retry', {\n  1167→      count: overdueInvoices.length,\n  1168→      criteria: options,\n  1169→      invoiceIds: overdueInvoices.map((inv) => inv.id),\n  1170→    });\n  1171→\n  1172→    const results = {\n  1173→      processed: overdueInvoices.length,\n  1174→      successful: [] as string[],\n  1175→      failed: [] as Array<{ id: string; reason: string }>,\n  1176→    };\n  1177→\n  1178→    const settledResults = await Promise.allSettled(\n  1179→      overdueInvoices.map(async (invoice, index) => {\n  1180→        const { paymentIntent } = invoice;\n  1181→        const delay = index * 2;\n  1182→        if (!paymentIntent) {\n  1183→          throw new Error('No payment intent found');\n  1184→        }\n  1185→\n  1186→        await paymentIntent.update({ status: 'requires_capture' });\n  1187→        await emitAsync(\n  1188→          'payment.queued',\n  1189→          paymentIntent.id,\n  1190→          { paymentIntentId: paymentIntent.id, retryOnError: true, ignoreMaxRetryCheck: true },\n  1191→          { sync: false, delay }\n  1192→        );\n  1193→\n  1194→        return invoice;\n  1195→      })\n  1196→    );\n  1197→\n  1198→    settledResults.forEach((result, index) => {\n  1199→      const invoice = overdueInvoices[index];\n  1200→      if (!invoice) {\n  1201→        return;\n  1202→      }\n  1203→      if (result.status === 'fulfilled') {\n  1204→        results.successful.push(invoice.id);\n  1205→        logger.info('Successfully queued uncollectible invoice retry', {\n  1206→          invoiceId: invoice.id,\n  1207→          customerId: invoice.customer_id,\n  1208→          paymentIntentId: invoice.payment_intent_id,\n  1209→        });\n  1210→      } else {\n  1211→        const error = result.reason;\n  1212→        const errorType = error.name || 'Unknown';\n  1213→        const errorCode = error.code || 'UNKNOWN_ERROR';\n  1214→\n  1215→        results.failed.push({\n  1216→          id: invoice.id,\n  1217→          reason: error.message || 'Unknown error',\n  1218→        });\n  1219→\n  1220→        logger.error('Failed to queue uncollectible invoice retry', {\n  1221→          invoiceId: invoice.id,\n  1222→          customerId: invoice.customer_id,\n  1223→          subscriptionId: invoice.subscription_id,\n  1224→          paymentIntentId: invoice.payment_intent_id,\n  1225→          errorType,\n  1226→          errorCode,\n  1227→          error,\n  1228→        });\n  1229→      }\n  1230→    });\n  1231→\n  1232→    const processingTime = Date.now() - startTime;\n  1233→    logger.info('Completed retrying uncollectible invoices', {\n  1234→      totalProcessed: results.processed,\n  1235→      successful: results.successful.length,\n  1236→      failed: results.failed.length,\n  1237→      processingTimeMs: processingTime,\n  1238→    });\n  1239→\n  1240→    return results;\n  1241→  } finally {\n  1242→    await Lock.release(lockKey);\n  1243→    logger.info('Released retry uncollectible lock', { lockKey });\n  1244→  }\n  1245→}\n  1246→\n  1247→/**\n  1248→ * Migrate billing when a subscription's payment method changes.\n  1249→ * Steps:\n  1250→ * 1. Check if all subscription items are prepaid (licensed recurring).\n  1251→ * 2. If so, check if there is an unpaid invoice for the current period with the old payment method.\n  1252→ * 3. If such an invoice exists, void the old invoice and cancel its payment intent if present.\n  1253→ * 4. Create a new invoice for the current period with the new payment method.\n  1254→ * 5. If any step fails, throw an error and log details.\n  1255→ *\n  1256→ * @param subscription Subscription instance\n  1257→ * @param oldCurrencyId Old payment currency ID\n  1258→ * @param newCurrencyId New payment currency ID\n  1259→ * @returns Migration result: { migrated, oldInvoice, newInvoice }\n  1260→ */\n  1261→export const migrateSubscriptionPaymentMethodInvoice = async (\n  1262→  subscription: Subscription,\n  1263→  oldCurrencyId: string,\n  1264→  newCurrencyId: string\n  1265→) => {\n  1266→  // 1. Check if all subscription items are prepaid (licensed recurring)\n  1267→  const subscriptionItems = await SubscriptionItem.findAll({\n  1268→    where: { subscription_id: subscription.id },\n  1269→    include: [{ model: Price, as: 'price' }],\n  1270→  });\n  1271→\n  1272→  const subscriptionItemsExpanded = await Price.expand(subscriptionItems.map((x) => x.toJSON()));\n  1273→  const isPrepaid = subscriptionItemsExpanded.every((item: TLineItemExpanded) => {\n  1274→    const price = getSubscriptionItemPrice(item);\n  1275→    return price.type === 'recurring' && price.recurring?.usage_type === 'licensed';\n  1276→  });\n  1277→\n  1278→  if (!isPrepaid) {\n  1279→    logger.info('Skip billing migration for non-prepaid items', {\n  1280→      subscriptionId: subscription.id,\n  1281→    });\n  1282→    return { migrated: false, reason: 'has_non_prepaid_items' };\n  1283→  }\n  1284→\n  1285→  // 2. Find unpaid invoice for the current period with the old payment method\n  1286→  const currentPeriodInvoice = await Invoice.findOne({\n  1287→    where: {\n  1288→      subscription_id: subscription.id,\n  1289→      billing_reason: 'subscription_cycle',\n  1290→      status: ['open', 'uncollectible'],\n  1291→      currency_id: oldCurrencyId,\n  1292→      period_start: {\n  1293→        [Op.gte]: subscription.current_period_start,\n  1294→        [Op.lt]: subscription.current_period_end,\n  1295→      },\n  1296→    },\n  1297→    order: [['created_at', 'DESC']],\n  1298→  });\n  1299→\n  1300→  let voidedInvoice: Invoice | null = null;\n  1301→\n  1302→  if (!currentPeriodInvoice) {\n  1303→    voidedInvoice = await Invoice.findOne({\n  1304→      where: {\n  1305→        subscription_id: subscription.id,\n  1306→        billing_reason: 'subscription_cycle',\n  1307→        status: 'void',\n  1308→        currency_id: oldCurrencyId,\n  1309→        period_start: {\n  1310→          [Op.gte]: subscription.current_period_start,\n  1311→          [Op.lt]: subscription.current_period_end,\n  1312→        },\n  1313→      },\n  1314→      order: [['created_at', 'DESC']],\n  1315→    });\n  1316→    if (!voidedInvoice) {\n  1317→      logger.info('Skip billing migration for no unpaid invoice', {\n  1318→        subscriptionId: subscription.id,\n  1319→        periodStart: subscription.current_period_start,\n  1320→        periodEnd: subscription.current_period_end,\n  1321→        oldCurrencyId,\n  1322→      });\n  1323→      return { migrated: false, reason: 'no_unpaid_invoice' };\n  1324→    }\n  1325→  }\n  1326→\n  1327→  // 3. Get old and new payment method/currency\n  1328→  const oldPaymentCurrency = await PaymentCurrency.findByPk(oldCurrencyId);\n  1329→  if (!oldPaymentCurrency) {\n  1330→    throw new Error(`Payment currency ${oldCurrencyId} not found`);\n  1331→  }\n  1332→  const oldPaymentMethod = await PaymentMethod.findByPk(oldPaymentCurrency.payment_method_id);\n  1333→  if (!oldPaymentMethod) {\n  1334→    throw new Error(`Payment method for currency ${oldCurrencyId} not found`);\n  1335→  }\n  1336→\n  1337→  const newPaymentCurrency = await PaymentCurrency.findByPk(newCurrencyId);\n  1338→  if (!newPaymentCurrency) {\n  1339→    throw new Error(`Payment currency ${newCurrencyId} not found`);\n  1340→  }\n  1341→  const newPaymentMethod = await PaymentMethod.findByPk(newPaymentCurrency.payment_method_id);\n  1342→  if (!newPaymentMethod) {\n  1343→    throw new Error(`Payment method for currency ${newCurrencyId} not found`);\n  1344→  }\n  1345→\n  1346→  // 4. Stripe payment method is not supported for migration\n  1347→  if (newPaymentMethod.type === 'stripe') {\n  1348→    logger.info('Skip billing migration for stripe payment method', {\n  1349→      subscriptionId: subscription.id,\n  1350→    });\n  1351→    return { migrated: false, reason: 'stripe_payment_method' };\n  1352→  }\n  1353→\n  1354→  try {\n  1355→    const customer = await Customer.findByPk(subscription.customer_id);\n  1356→    if (!customer) {\n  1357→      throw new Error(`Customer ${subscription.customer_id} not found`);\n  1358→    }\n  1359→\n  1360→    const cancelOldInvoice = async (invoice: Invoice) => {\n  1361→      try {\n  1362→        if (invoice.payment_intent_id) {\n  1363→          const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n  1364→          if (paymentIntent && paymentIntent.status !== 'canceled') {\n  1365→            await paymentIntent.update({\n  1366→              status: 'canceled',\n  1367→              canceled_at: dayjs().unix(),\n  1368→              cancellation_reason: 'void_invoice',\n  1369→            });\n  1370→          }\n  1371→        }\n  1372→\n  1373→        if (oldPaymentMethod.type === 'stripe' && invoice.metadata?.stripe_id) {\n  1374→          const client = oldPaymentMethod.getStripeClient();\n  1375→          await client.invoices.voidInvoice(invoice.metadata.stripe_id);\n  1376→        }\n  1377→\n  1378→        await invoice.update({\n  1379→          status: 'void',\n  1380→          status_transitions: {\n  1381→            ...(invoice.status_transitions || {}),\n  1382→            voided_at: dayjs().unix(),\n  1383→          },\n  1384→        });\n  1385→\n  1386→        logger.info('Successfully voided old invoice for payment method change', {\n  1387→          subscriptionId: subscription.id,\n  1388→          oldInvoice: invoice.id,\n  1389→          oldCurrency: oldCurrencyId,\n  1390→          newCurrency: newCurrencyId,\n  1391→        });\n  1392→      } catch (error) {\n  1393→        logger.error('Failed to void old invoice', {\n  1394→          subscription: subscription.id,\n  1395→          invoiceId: invoice.id,\n  1396→          error: error.message,\n  1397→        });\n  1398→        throw error;\n  1399→      }\n  1400→    };\n  1401→\n  1402→    const createNewInvoice = async () => {\n  1403→      const preInvoice = currentPeriodInvoice || voidedInvoice;\n  1404→      if (!preInvoice) {\n  1405→        throw new Error('No unpaid invoice found');\n  1406→      }\n  1407→      const metadata: Record<string, any> = {\n  1408→        prev_invoice_id: preInvoice.id,\n  1409→      };\n  1410→      const amount = getSubscriptionCycleAmount(subscriptionItemsExpanded, newCurrencyId);\n  1411→\n  1412→      const { invoice } = await ensureInvoiceAndItems({\n  1413→        customer,\n  1414→        currency: newPaymentCurrency,\n  1415→        subscription,\n  1416→        trialing: subscription.status === 'trialing',\n  1417→        metered: false,\n  1418→        lineItems: subscriptionItemsExpanded,\n  1419→        applyCredit: false,\n  1420→        props: {\n  1421→          status: 'open',\n  1422→          total: amount.total,\n  1423→          livemode: subscription.livemode,\n  1424→          description: 'Subscription cycle',\n  1425→          statement_descriptor: preInvoice.statement_descriptor,\n  1426→          period_start: preInvoice.period_start,\n  1427→          period_end: preInvoice.period_end,\n  1428→          auto_advance: true,\n  1429→          billing_reason: 'subscription_cycle',\n  1430→          currency_id: newCurrencyId,\n  1431→          default_payment_method_id: newPaymentMethod.id,\n  1432→          custom_fields: preInvoice.custom_fields || [],\n  1433→          footer: preInvoice.footer || '',\n  1434→          payment_settings: subscription.payment_settings,\n  1435→          metadata,\n  1436→        } as Invoice,\n  1437→      });\n  1438→      return invoice;\n  1439→    };\n  1440→\n  1441→    // 5. Cancel old invoice, then create new invoice\n  1442→    if (currentPeriodInvoice) {\n  1443→      await cancelOldInvoice(currentPeriodInvoice);\n  1444→    }\n  1445→\n  1446→    const invoice = await createNewInvoice();\n  1447→    if (invoice) {\n  1448→      await emitAsync('invoice.queued', invoice.id, { invoiceId: invoice.id, retryOnError: true }, { sync: false });\n  1449→      logger.info('Successfully queued new invoice for payment method change', {\n  1450→        subscriptionId: subscription.id,\n  1451→        invoiceId: invoice.id,\n  1452→      });\n  1453→    }\n  1454→\n  1455→    logger.info('Successfully migrated invoice for payment method change', {\n  1456→      subscriptionId: subscription.id,\n  1457→      oldInvoiceId: currentPeriodInvoice?.id || voidedInvoice?.id,\n  1458→      oldCurrency: oldCurrencyId,\n  1459→      newCurrency: newCurrencyId,\n  1460→      newInvoiceId: invoice.id,\n  1461→    });\n  1462→    return {\n  1463→      migrated: true,\n  1464→      oldInvoice: currentPeriodInvoice,\n  1465→      newInvoice: invoice,\n  1466→    };\n  1467→  } catch (error) {\n  1468→    logger.error('Failed to migrate invoice for payment method change', {\n  1469→      subscriptionId: subscription.id,\n  1470→      oldCurrencyId,\n  1471→      newCurrencyId,\n  1472→      error: error.message,\n  1473→    });\n  1474→    throw error;\n  1475→  }\n  1476→};\n  1477→\n  1478→export async function destroyExistingInvoice(invoice: Invoice) {\n  1479→  const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n  1480→  try {\n  1481→    if (paymentMethod?.type === 'stripe' && invoice.metadata?.stripe_id) {\n  1482→      const client = paymentMethod.getStripeClient();\n  1483→      await client.invoices.del(invoice.metadata.stripe_id);\n  1484→    }\n  1485→  } catch (error) {\n  1486→    logger.error('Failed to destroy invoice on stripe', {\n  1487→      error: error.message,\n  1488→      invoiceId: invoice.id,\n  1489→    });\n  1490→  }\n  1491→  await InvoiceItem.destroy({ where: { invoice_id: invoice.id } });\n  1492→  await invoice.destroy();\n  1493→}\n  1494→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d00a114b-8455-46de-b444-cae7eb083dee","timestamp":"2026-01-09T01:49:22.310Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts","content":"import { component } from '@blocklet/sdk';\nimport type { LiteralUnion } from 'type-fest';\nimport { withQuery } from 'ufo';\n\nimport { BN, fromUnitToToken } from '@ocap/util';\nimport { Op, type WhereOptions } from 'sequelize';\nimport { cloneDeep, pick } from 'lodash';\nimport {\n  Customer,\n  Invoice,\n  InvoiceItem,\n  PaymentCurrency,\n  PaymentIntent,\n  PaymentMethod,\n  PaymentSettings,\n  Price,\n  PriceQuote,\n  Product,\n  Refund,\n  SetupIntent,\n  SimpleCustomField,\n  Subscription,\n  SubscriptionItem,\n  TaxRate,\n  TInvoice,\n  TLineItemExpanded,\n  UsageRecord,\n  Lock,\n  DiscountAmount,\n} from '../store/models';\nimport { getConnectQueryParam } from './util';\nimport { expandLineItems } from './session';\nimport dayjs from './dayjs';\nimport {\n  getSubscriptionCycleAmount,\n  getSubscriptionCycleSetup,\n  getSubscriptionItemPrice,\n  getSubscriptionStakeAmountSetup,\n  isSubscriptionOverdraftProtectionEnabled,\n} from './subscription';\nimport logger from './logger';\nimport { ensureOverdraftProtectionPrice } from './overdraft-protection';\nimport { CHARGE_SUPPORTED_CHAIN_TYPES } from './constants';\nimport { emitAsync } from './event';\nimport { getPriceUintAmountByCurrency } from './price';\nimport { generateQuotesForInvoiceItems } from './invoice-quote';\n\nexport function getCustomerInvoicePageUrl({\n  invoiceId,\n  userDid,\n  locale = 'en',\n  action = '',\n}: {\n  userDid: string;\n  invoiceId: string;\n  locale: LiteralUnion<'en' | 'zh', string>;\n  action?: LiteralUnion<'pay', string>;\n}) {\n  return component.getUrl(\n    withQuery(`customer/invoice/${invoiceId}`, {\n      locale,\n      action,\n      ...getConnectQueryParam({ userDid }),\n    })\n  );\n}\n\nexport async function getOneTimeProductInfo(invoiceId: string, paymentCurrency: PaymentCurrency) {\n  try {\n    const doc = await Invoice.findOne({\n      where: { id: invoiceId },\n      include: [{ model: InvoiceItem, as: 'lines' }],\n    });\n    if (!doc) {\n      throw new Error(`Invoice not found: ${invoiceId}`);\n    }\n    const json = doc.toJSON();\n    const products = (await Product.findAll()).map((x) => x.toJSON());\n    const prices = (await Price.findAll()).map((x) => x.toJSON());\n    // @ts-ignore\n    expandLineItems(json.lines, products, prices);\n    const oneTimePaymentInfo: Array<{\n      productName: string;\n      paymentInfo: string;\n      quantity: number;\n    }> = [];\n    // @ts-ignore\n    (json.lines || []).forEach((x) => {\n      const { recurring, product } = x.price;\n      if (!recurring) {\n        // it's one-time product\n        oneTimePaymentInfo.push({\n          productName: product?.name,\n          paymentInfo: `${fromUnitToToken(x.amount, paymentCurrency.decimal)} ${paymentCurrency.symbol}`,\n          quantity: x.quantity,\n        });\n      }\n    });\n    return oneTimePaymentInfo;\n  } catch (err) {\n    console.error(`Error in getOneTimeProductInfo for invoice ${invoiceId}:`, err);\n    return [];\n  }\n}\n\nexport async function getInvoiceShouldPayTotal(invoice: Invoice) {\n  try {\n    const subscription = await Subscription.findByPk(invoice.subscription_id);\n    if (!subscription) {\n      throw new Error(`Subscription not found: ${invoice.subscription_id}`);\n    }\n\n    const paymentCurrency = await PaymentCurrency.findByPk(invoice.currency_id);\n    if (!paymentCurrency) {\n      throw new Error(`Payment currency not found: ${invoice.currency_id}`);\n    }\n\n    const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n    if (!paymentMethod) {\n      throw new Error(`Payment method not found: ${paymentCurrency.payment_method_id}`);\n    }\n\n    const subscriptionItems = await SubscriptionItem.findAll({\n      where: { subscription_id: subscription.id },\n    });\n    const invoiceItems = await InvoiceItem.findAll({\n      where: { invoice_id: invoice.id },\n    });\n    const invoiceQuoteIds = invoiceItems\n      .map((item) => item.metadata?.quote_id)\n      .filter((id): id is string => typeof id === 'string' && id.length > 0);\n    const invoiceQuotes = invoiceQuoteIds.length\n      ? await PriceQuote.findAll({ where: { id: invoiceQuoteIds } })\n      : [];\n    const invoiceQuotesById = new Map(invoiceQuotes.map((quote) => [quote.id, quote]));\n    const invoiceQuoteBySubscriptionItemId = new Map<string, { quotedAmount?: string; amount?: string }>();\n    invoiceItems.forEach((item) => {\n      if (!item.subscription_item_id) {\n        return;\n      }\n      const quoteId = typeof item.metadata?.quote_id === 'string' ? item.metadata?.quote_id : undefined;\n      const quote = quoteId ? invoiceQuotesById.get(quoteId) : undefined;\n      const quotedAmount = quote?.quoted_amount || (item.metadata as any)?.quote?.quoted_amount;\n      invoiceQuoteBySubscriptionItemId.set(item.subscription_item_id, {\n        quotedAmount,\n        amount: item.amount,\n      });\n    });\n\n    let expandedItems = await Price.expand(\n      subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n      { product: true }\n    );\n\n    const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, invoice.period_start);\n    let offset = 0;\n    let filterFunc = (item: any) => item;\n    if (CHARGE_SUPPORTED_CHAIN_TYPES.includes(paymentMethod.type)) {\n      switch (invoice.billing_reason) {\n        case 'subscription_cancel':\n          filterFunc = (item: any) => item.price?.recurring?.usage_type === 'metered';\n          break;\n        case 'subscription_cycle':\n          filterFunc = (item: any) => item.price?.type === 'recurring';\n          offset = setup.cycle / 1000;\n          break;\n        default:\n          filterFunc = () => true;\n      }\n    }\n    const previousPeriodStart = setup.period.start - offset;\n    const previousPeriodEnd = setup.period.end - offset;\n    expandedItems = await Promise.all(\n      expandedItems.filter(filterFunc).map(async (item: any) => {\n        const { price } = item;\n        if (price?.recurring?.usage_type === 'metered') {\n          const rawQuantity = await UsageRecord.getSummary({\n            id: item.id,\n            start: previousPeriodStart,\n            end: previousPeriodEnd,\n            method: price.recurring?.aggregate_usage,\n            dryRun: true,\n            searchBilled: false,\n          });\n          item.quantity = price.transformQuantity(rawQuantity);\n        }\n        return item;\n      })\n    );\n\n    if (invoiceQuoteBySubscriptionItemId.size > 0) {\n      expandedItems = expandedItems.map((item: any) => {\n        const price = item.price;\n        if (price?.pricing_type !== 'dynamic') {\n          return item;\n        }\n        const quoteInfo = invoiceQuoteBySubscriptionItemId.get(item.id);\n        if (!quoteInfo) {\n          return item;\n        }\n        const quotedAmount = quoteInfo.quotedAmount || quoteInfo.amount;\n        if (!quotedAmount) {\n          return item;\n        }\n        return {\n          ...item,\n          custom_amount: quotedAmount,\n          quoted_amount: quotedAmount,\n        };\n      });\n    }\n\n    const baseAmount = getSubscriptionCycleAmount(expandedItems, subscription.currency_id);\n    let shouldPayTotal = baseAmount?.total || invoice.total;\n\n    // Apply discount if exists\n    if (baseAmount?.total && invoice.total_discount_amounts && invoice.total_discount_amounts.length > 0) {\n      const totalDiscountAmount = invoice.total_discount_amounts.reduce((sum, discount) => {\n        return new BN(sum).add(new BN(discount.amount.toString())).toString();\n      }, '0');\n\n      shouldPayTotal = new BN(shouldPayTotal).sub(new BN(totalDiscountAmount)).toString();\n\n      // Ensure the final amount doesn't go below zero\n      if (new BN(shouldPayTotal).lt(new BN('0'))) {\n        shouldPayTotal = '0';\n      }\n    }\n\n    return shouldPayTotal;\n  } catch (err) {\n    console.error(`Error in getInvoiceShouldPayTotal for invoice ${invoice.id}:`, err);\n    return invoice.total;\n  }\n}\n\nexport async function getReturnStakeInvoices(subscription: Subscription) {\n  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n  const returnStakeInvoice: Invoice[] = [];\n  const refunds = await Refund.findAll({\n    where: { subscription_id: subscription.id, status: 'succeeded', type: 'stake_return' },\n    include: [\n      { model: Invoice, as: 'invoice' },\n      { model: Customer, as: 'customer' },\n      { model: PaymentCurrency, as: 'paymentCurrency' },\n    ],\n  });\n\n  await Promise.all(\n    refunds.map(async (r: any) => {\n      const invoice =\n        r.invoice ||\n        (await Invoice.findOne({\n          where: {\n            subscription_id: subscription.id,\n            currency_id: r.currency_id,\n          },\n          order: [['created_at', 'ASC']],\n        }));\n      returnStakeInvoice.push({\n        id: r.id,\n        status: 'paid',\n        billing_reason: 'return_stake',\n        description: 'Return Subscription staking',\n        total: r.amount,\n        amount_due: '0',\n        amount_paid: r.amount,\n        amount_remaining: '0',\n        subscription_id: subscription.id,\n        paid: true,\n        ...pick(invoice, ['number', 'auto_advance', 'period_start', 'period_end']),\n        ...pick(r, ['created_at', 'updated_at', 'currency_id', 'customer_id']),\n        // @ts-ignore\n        paymentCurrency: r.paymentCurrency,\n        paymentMethod: method,\n        customer: r.customer,\n        metadata: {\n          payment_details: {\n            arcblock: {\n              tx_hash: r?.payment_details?.arcblock?.tx_hash,\n              payer: r?.payment_details?.arcblock?.payer,\n            },\n          },\n        },\n      });\n    })\n  );\n  return returnStakeInvoice;\n}\n\nexport async function getSetupInvoice(\n  subscription: Subscription,\n  paymentMethod: PaymentMethod,\n  currencyId: string,\n  stakingProps: { tx_hash: string; payer: string; address: string }\n) {\n  const currency = await PaymentCurrency.findByPk(currencyId);\n  if (!currency) {\n    return null;\n  }\n  if (!stakingProps?.tx_hash) {\n    return null;\n  }\n  if (paymentMethod?.type !== 'arcblock') {\n    return null;\n  }\n  const firstInvoice = await Invoice.findOne({\n    where: { subscription_id: subscription.id, currency_id: currency.id },\n    order: [['created_at', 'ASC']],\n    include: [{ model: Customer, as: 'customer' }],\n  });\n  if (!firstInvoice) {\n    return null;\n  }\n  const stakeAmountResult = await getSubscriptionStakeAmountSetup(subscription, paymentMethod, stakingProps.tx_hash);\n  // @ts-ignore\n  const stakeAmount = stakeAmountResult?.[currency?.contract] || '0';\n  return {\n    id: stakingProps.address as string,\n    status: 'paid',\n    description: 'Subscription staking',\n    billing_reason: 'stake',\n    total: stakeAmount,\n    amount_due: '0',\n    amount_paid: stakeAmount,\n    amount_remaining: '0',\n    ...pick(firstInvoice, [\n      'number',\n      'paid',\n      'auto_advance',\n      'currency_id',\n      'customer_id',\n      'subscription_id',\n      'period_start',\n      'period_end',\n      'created_at',\n      'updated_at',\n    ]),\n    // @ts-ignore\n    paymentCurrency: currency,\n    paymentMethod,\n    // @ts-ignore\n    customer: firstInvoice?.customer,\n    metadata: {\n      payment_details: {\n        arcblock: {\n          tx_hash: stakingProps?.tx_hash,\n          payer: stakingProps?.payer,\n        },\n      },\n    },\n  };\n}\n\nexport async function getStakingInvoices(subscription: Subscription): Promise<Invoice[]> {\n  const method = await PaymentMethod.findOne({ where: { type: 'arcblock', livemode: subscription.livemode } });\n  if (!method) {\n    return [];\n  }\n  const stakeInvoices = await Invoice.findAll({\n    where: { subscription_id: subscription.id, billing_reason: 'stake', status: 'paid' },\n    include: [\n      { model: Customer, as: 'customer' },\n      { model: PaymentCurrency, as: 'paymentCurrency' },\n      { model: PaymentMethod, as: 'paymentMethod' },\n    ],\n  });\n  const invoices = cloneDeep(stakeInvoices);\n  const setups = await SetupIntent.findAll({\n    where: {\n      customer_id: subscription.customer_id,\n      payment_method_id: method?.id,\n      status: 'succeeded',\n      [Op.and]: [\n        { metadata: { [Op.not]: null } },\n        { 'metadata.subscription_id': subscription.id },\n        { setup_details: { [Op.not]: null } },\n        { 'setup_details.arcblock': { [Op.not]: null } },\n        { 'setup_details.arcblock.staking': { [Op.not]: null } },\n      ] as any,\n    },\n  });\n  if (setups.length === 0) {\n    // No payment change, use the first invoice\n    if (stakeInvoices.length > 0) {\n      return stakeInvoices;\n    }\n    const newInvoice = await getSetupInvoice(subscription, method, subscription.currency_id, {\n      tx_hash: subscription.payment_details?.arcblock?.staking?.tx_hash!,\n      payer: subscription.payment_details?.arcblock?.payer!,\n      address: subscription.payment_details?.arcblock?.staking?.address!,\n    });\n    // @ts-ignore\n    return [newInvoice].filter(Boolean);\n  }\n\n  await Promise.all(\n    setups.map(async (setup: SetupIntent, index: number) => {\n      if (\n        index === 0 &&\n        setup.metadata?.from_currency &&\n        !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.from_currency)\n      ) {\n        const paymentDetails =\n          setup?.metadata?.from_payment_details?.arcblock || subscription.payment_details?.arcblock;\n        const fromMethod = await PaymentMethod.findByPk(setup?.metadata?.from_payment_method_id);\n        const newInvoice = await getSetupInvoice(subscription, fromMethod!, setup.metadata?.from_currency, {\n          tx_hash: paymentDetails?.staking?.tx_hash!,\n          payer: paymentDetails?.payer!,\n          address: paymentDetails?.staking?.address!,\n        });\n        if (newInvoice) {\n          // @ts-ignore\n          invoices.push(newInvoice);\n        }\n      }\n      if (setup.metadata?.to_currency && !stakeInvoices.find((x) => x.currency_id === setup?.metadata?.to_currency)) {\n        const newInvoice = await getSetupInvoice(subscription, method, setup.metadata?.to_currency, {\n          tx_hash: setup.setup_details?.arcblock?.staking?.tx_hash!,\n          payer: setup.setup_details?.arcblock?.payer!,\n          address: setup.setup_details?.arcblock?.staking?.address!,\n        });\n        if (newInvoice) {\n          // @ts-ignore\n          invoices.push(newInvoice);\n        }\n      }\n    })\n  );\n  return invoices;\n}\n\ntype BaseInvoiceProps = {\n  customer: Customer;\n  subscription?: Subscription | null;\n  currency_id: string;\n  livemode: boolean;\n  period_start: number;\n  period_end: number;\n  status?: string;\n  billing_reason: string;\n  description: string;\n  statement_descriptor?: string;\n  total: string;\n  subtotal?: string;\n  amount_due?: string;\n  amount_paid?: string;\n  amount_remaining?: string;\n  default_payment_method_id: string;\n  payment_intent_id?: string;\n  checkout_session_id?: string;\n  metadata?: Record<string, any>;\n  // Discount fields\n  discounts?: string[];\n  total_discount_amounts?: DiscountAmount[];\n  items?: Array<{\n    price_id: string;\n    amount: string;\n    quantity: number;\n    description: string;\n    period?: {\n      start: number;\n      end: number;\n    };\n    metadata?: Record<string, any>;\n    subscription_item_id?: string;\n    // Discount fields for InvoiceItem\n    discountable?: boolean;\n    discount_amounts?: DiscountAmount[];\n  }>;\n  auto_advance?: boolean;\n  paid?: boolean;\n  paid_out_of_band?: boolean;\n  payment_settings?: PaymentSettings;\n  footer?: string;\n  custom_fields?: SimpleCustomField[];\n  starting_token_balance?: Record<string, string>;\n  ending_token_balance?: Record<string, string>;\n  subtotal_excluding_tax?: string;\n  collection_method?: 'charge_automatically' | 'send_invoice';\n  id?: string;\n  quote_id?: string;\n};\n\nasync function createInvoiceWithItems(props: BaseInvoiceProps): Promise<{\n  invoice: Invoice;\n  items: InvoiceItem[];\n}> {\n  const {\n    customer,\n    subscription,\n    currency_id: currencyId,\n    livemode,\n    period_start: periodStart,\n    period_end: periodEnd,\n    status = 'open',\n    billing_reason: billingReason,\n    description,\n    statement_descriptor: statementDescriptor = '',\n    total,\n    amount_due: amountDue = total,\n    amount_paid: amountPaid = '0',\n    amount_remaining: amountRemaining = total,\n    default_payment_method_id: paymentMethodId,\n    payment_intent_id: paymentIntentId = '',\n    checkout_session_id: checkoutSessionId = '',\n    items: itemsData,\n    metadata = {},\n    paid = false,\n    auto_advance: autoAdvance = true,\n    paid_out_of_band: paidOutOfBand = false,\n    payment_settings: paymentSettings,\n    ...extraProps\n  } = props;\n\n  const invoiceNumber = await customer.getInvoiceNumber();\n  // create invoice\n  const invoice = await Invoice.create({\n    amount_shipping: '0',\n    starting_balance: '0',\n    ending_balance: '0',\n    subtotal_excluding_tax: '0',\n    starting_token_balance: {},\n    ending_token_balance: {},\n    attempt_count: 0,\n    attempted: false,\n    tax: '0',\n    discounts: props.discounts || [],\n    total_discount_amounts: props.total_discount_amounts || [],\n    collection_method: 'charge_automatically',\n    ...extraProps,\n    livemode,\n    number: invoiceNumber,\n    description,\n    statement_descriptor: statementDescriptor,\n    period_start: periodStart,\n    period_end: periodEnd,\n    auto_advance: autoAdvance,\n    paid,\n    paid_out_of_band: paidOutOfBand,\n    status,\n    billing_reason: billingReason,\n    currency_id: currencyId,\n    customer_id: customer.id,\n    default_payment_method_id: paymentMethodId,\n    payment_intent_id: paymentIntentId,\n    subscription_id: subscription?.id,\n    checkout_session_id: checkoutSessionId,\n    total,\n    subtotal: props.subtotal || total,\n    amount_due: amountDue,\n    amount_paid: amountPaid,\n    amount_remaining: amountRemaining,\n\n    customer_address: customer.address,\n    customer_email: customer.email,\n    customer_name: customer.name,\n    customer_phone: customer.phone,\n\n    effective_at: dayjs().unix(),\n    status_transitions: {\n      finalized_at: dayjs().unix(),\n    },\n    payment_settings: paymentSettings || subscription?.payment_settings,\n    metadata,\n  });\n\n  if (!itemsData) {\n    return { invoice, items: [] };\n  }\n\n  // Generate quotes for dynamic pricing items (subscription invoices)\n  const enrichedItemsData = subscription\n    ? await generateQuotesForInvoiceItems({\n        invoiceId: invoice.id,\n        items: itemsData,\n        currencyId,\n      })\n    : itemsData;\n\n  // create invoice items\n  const items = await Promise.all(\n    enrichedItemsData.map(async (item) => {\n      // Match tax rate for this specific item\n      let taxRateId: string | undefined;\n      if (customer.address?.country && item.price_id) {\n        try {\n          const price = await Price.findByPk(item.price_id);\n          if (price?.product_id) {\n            const product = await Product.findByPk(price.product_id);\n            if (product) {\n              const taxRate = await TaxRate.findMatchingRate({\n                country: customer.address.country,\n                state: customer.address.state,\n                postalCode: customer.address.postal_code,\n                taxCode: product.tax_code,\n                livemode,\n              });\n              taxRateId = taxRate?.id;\n            }\n          }\n        } catch (error) {\n          logger.error('Failed to match tax rate for invoice item:', error);\n        }\n      }\n\n      return InvoiceItem.create({\n        livemode,\n        amount: item.amount,\n        quantity: item.quantity,\n        description: item.description,\n        period: item.period,\n        currency_id: currencyId,\n        customer_id: customer.id,\n        price_id: item.price_id,\n        invoice_id: invoice.id,\n        subscription_id: subscription?.id,\n        subscription_item_id: item.subscription_item_id,\n        tax_rate_id: taxRateId,\n        discountable: item.discountable || false,\n        discounts: [], // Keep as empty for now - this is legacy field\n        discount_amounts:\n          item.discount_amounts?.map((d) => ({ amount: new BN(d.amount || '0').toString(), discount: d.discount })) ||\n          [],\n        proration: false,\n        proration_details: {},\n        metadata: {\n          ...(item.metadata || {}),\n          // Include quote_id in metadata if it exists (for dynamic pricing)\n          ...((item as any).quote_id && { quote_id: (item as any).quote_id }),\n        },\n      });\n    })\n  );\n\n  return { invoice, items };\n}\n\nexport async function ensureInvoiceAndItems({\n  customer,\n  currency,\n  subscription,\n  subscriptions,\n  props,\n  lineItems,\n  trialing,\n  metered,\n  applyCredit = true,\n}: {\n  customer: Customer;\n  currency: PaymentCurrency;\n  subscription?: Subscription;\n  subscriptions?: Subscription[];\n  props: TInvoice;\n  lineItems: TLineItemExpanded[];\n  trialing: boolean; // do we have trialing\n  metered: boolean; // is the quantity metered\n  applyCredit?: boolean; // should we apply customer credit?\n}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n  // apply possible balance to invoice\n  let remaining = props.total;\n  let result = { starting: {}, ending: {} };\n  if (applyCredit && props.total > '0' && !props.amount_remaining) {\n    const balance = customer.getBalanceToApply(currency.id, props.total);\n    result = await customer.decreaseTokenBalance(currency.id, balance);\n    remaining = new BN(props.total).sub(new BN(balance)).toString();\n    logger.info('Invoice will use customer credit', { result, remaining, total: props.total });\n  }\n\n  // get subscription items\n  let subscriptionItems: SubscriptionItem[] = [];\n  if (subscriptions && subscriptions.length > 0) {\n    subscriptionItems = await SubscriptionItem.findAll({\n      where: { subscription_id: { [Op.in]: subscriptions.map((s) => s.id) } },\n    });\n  } else if (subscription) {\n    subscriptionItems = await SubscriptionItem.findAll({\n      where: { subscription_id: subscription?.id },\n    });\n  }\n\n  function getLineSetup(x: TLineItemExpanded) {\n    const price = getSubscriptionItemPrice(x);\n    if (price.type === 'recurring' && trialing) {\n      return {\n        price,\n        amount: '0',\n        // @ts-ignore\n        description: trialing ? `${price.product.name} (trialing)` : price.product.name,\n        period: {\n          start: props.period_start,\n          end: props.period_end,\n        },\n      };\n    }\n\n    return {\n      price,\n      amount:\n        x.custom_amount ||\n        new BN(getPriceUintAmountByCurrency(price, props.currency_id)).mul(new BN(x.quantity)).toString(),\n      description: price.product.name,\n      period: undefined,\n    };\n  }\n  // process line items\n  const processedItems = lineItems.map((x: TLineItemExpanded) => {\n    const setup = getLineSetup(x);\n    const { price } = setup;\n    let { quantity } = x;\n    if (price.type === 'recurring') {\n      if (price.recurring?.usage_type === 'metered' && !metered) {\n        quantity = 0;\n      }\n      if (trialing) {\n        quantity = 0;\n      }\n    }\n\n    return {\n      price_id: price.id,\n      amount: quantity > 0 ? setup.amount : '0',\n      quantity,\n      description: setup.description,\n      period: setup.period,\n      metadata: x.metadata || {},\n      subscription_item_id: subscriptionItems.find((si) => si.price_id === price.id)?.id,\n      // Discount fields from pre-calculated line items\n      discountable: x.discountable || false,\n      discount_amounts: x.discount_amounts || [],\n    };\n  });\n\n  return createInvoiceWithItems({\n    customer,\n    subscription,\n    items: processedItems,\n    livemode: props.livemode,\n    status: props.status || 'open',\n    billing_reason: props.billing_reason,\n    description: props.description || '',\n    statement_descriptor: props.statement_descriptor,\n\n    currency_id: props.currency_id,\n    payment_intent_id: props.payment_intent_id,\n    checkout_session_id: props.checkout_session_id,\n    default_payment_method_id: props.default_payment_method_id,\n\n    period_start: props.period_start,\n    period_end: props.period_end,\n    auto_advance: props.auto_advance,\n\n    total: props.total,\n    subtotal: props.subtotal || props.total,\n    amount_remaining: props.amount_remaining || remaining,\n    amount_paid: props.amount_paid,\n    amount_due: props.amount_due || remaining,\n    subtotal_excluding_tax: props.subtotal || props.total || '0',\n    starting_token_balance: result.starting,\n    ending_token_balance: result.ending,\n\n    footer: props.footer,\n    custom_fields: props.custom_fields,\n    payment_settings: props.payment_settings || subscription?.payment_settings,\n    discounts: props.discounts,\n    total_discount_amounts: props.total_discount_amounts || [],\n    metadata: {\n      ...props.metadata,\n      starting_token_balance: result.starting,\n      ending_token_balance: result.ending,\n    },\n  });\n}\n\nexport async function cleanupInvoiceAndItems(invoiceId: string) {\n  const invoice = await Invoice.findByPk(invoiceId);\n  if (!invoice) {\n    return;\n  }\n  if (invoice.isImmutable()) {\n    return;\n  }\n\n  const removedItem = await InvoiceItem.destroy({ where: { invoice_id: invoiceId } });\n  const removedInvoice = await Invoice.destroy({ where: { id: invoiceId } });\n  logger.info('cleanup invoice and items', { invoiceId, removedItem, removedInvoice });\n}\n\nexport async function ensureRechargeInvoice(\n  invoiceProps: {\n    total: string;\n    description?: string;\n    checkout_session_id?: string;\n    currency_id: string;\n    metadata?: any;\n    payment_settings?: any;\n    livemode?: boolean;\n  },\n  subscription: Subscription | null,\n  paymentMethod: PaymentMethod,\n  customer: Customer\n) {\n  try {\n    const { livemode = true } = invoiceProps;\n    const { invoice } = await createInvoiceWithItems({\n      customer,\n      subscription,\n      currency_id: invoiceProps.currency_id,\n      livemode: subscription?.livemode ?? livemode,\n      period_start: dayjs().unix(),\n      period_end: dayjs().unix(),\n      status: 'paid',\n      billing_reason: 'recharge',\n      description: invoiceProps?.description || 'Add funds for subscription',\n      total: invoiceProps.total || '0',\n      amount_due: '0',\n      amount_paid: invoiceProps.total || '0',\n      amount_remaining: '0',\n      default_payment_method_id: paymentMethod.id,\n      checkout_session_id: invoiceProps?.checkout_session_id || '',\n      metadata: invoiceProps.metadata || {},\n      auto_advance: false,\n      paid: true,\n      paid_out_of_band: false,\n      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n    });\n\n    logger.info('create recharge invoice success', {\n      invoice,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n  } catch (error) {\n    logger.error('ensureRechargeInvoice: create invoice failed', {\n      error,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n    throw error;\n  }\n}\n\nexport async function ensureOverdraftProtectionInvoiceAndItems({\n  customer,\n  subscription,\n  paymentIntent,\n  props,\n}: {\n  customer: Customer;\n  subscription: Subscription;\n  paymentIntent: PaymentIntent;\n  props: Partial<TInvoice> & { period_start: number; period_end: number };\n}): Promise<{ invoice: Invoice; items: InvoiceItem[] }> {\n  const { price, product } = await ensureOverdraftProtectionPrice(subscription.livemode);\n  const invoicePrice = price?.currency_options?.find((x: any) => x.currency_id === paymentIntent?.currency_id);\n\n  if (!subscription.overdraft_protection?.enabled) {\n    throw new Error('Overdraft protection invoice creation skipped: overdraft protection is not enabled');\n  }\n\n  if (!invoicePrice) {\n    throw new Error('Overdraft protection invoice price not found');\n  }\n  const currency = await PaymentCurrency.findByPk(invoicePrice.currency_id);\n  if (!currency) {\n    throw new Error('Overdraft protection invoice currency not found');\n  }\n  const paymentMethod = await PaymentMethod.findByPk(currency?.payment_method_id);\n  if (!paymentMethod) {\n    throw new Error('Overdraft protection invoice payment method not found');\n  }\n\n  if (paymentMethod.type !== 'arcblock') {\n    throw new Error(`Payment method ${paymentMethod.type} not supported for overdraft protection`);\n  }\n\n  const { unused } = await isSubscriptionOverdraftProtectionEnabled(subscription, paymentIntent?.currency_id);\n  if (new BN(unused).lt(new BN(invoicePrice.unit_amount))) {\n    throw new Error('Overdraft protection invoice creation skipped: insufficient overdraft protection funds');\n  }\n\n  const result = await createInvoiceWithItems({\n    customer,\n    subscription,\n    currency_id: invoicePrice.currency_id,\n    livemode: subscription.livemode,\n    period_start: props.period_start || 0,\n    period_end: props.period_end || 0,\n    status: props.status,\n    billing_reason: 'overdraft_protection',\n    description: 'Overdraft protection',\n    collection_method: 'send_invoice',\n    default_payment_method_id: paymentMethod.id,\n    total: invoicePrice.unit_amount || '0',\n    items: [\n      {\n        price_id: price?.id || '',\n        amount: invoicePrice.unit_amount || '0',\n        quantity: 1,\n        description: product?.name || '',\n        period: {\n          start: props.period_start || 0,\n          end: props.period_end || 0,\n        },\n      },\n    ],\n    metadata: {\n      ...(props.metadata || {}),\n      payment_intent_id: paymentIntent.id,\n    },\n  });\n\n  await Price.increment({ quantity_sold: 1 }, { where: { id: price?.id } });\n  return result;\n}\n\nexport async function ensureStakeInvoice(\n  invoiceProps: {\n    total: string;\n    description?: string;\n    checkout_session_id?: string;\n    currency_id: string;\n    billing_reason?: string;\n    metadata?: any;\n    payment_settings?: any;\n  },\n  subscription: Subscription,\n  paymentMethod: PaymentMethod,\n  customer: Customer,\n  allSubscriptions?: Subscription[]\n) {\n  if (paymentMethod.type !== 'arcblock') {\n    return;\n  }\n\n  try {\n    const isMultiSubscription = allSubscriptions && allSubscriptions.length > 1;\n    const metadata = {\n      ...(invoiceProps.metadata || {}),\n    };\n\n    if (isMultiSubscription) {\n      metadata.all_subscription_ids = allSubscriptions.map((s) => s.id);\n      metadata.is_shared_stake = true;\n      metadata.primary_subscription_id = subscription.id;\n    }\n\n    const { invoice } = await createInvoiceWithItems({\n      customer,\n      subscription,\n      currency_id: invoiceProps.currency_id,\n      livemode: subscription.livemode,\n      period_start: dayjs().unix(),\n      period_end: subscription.current_period_end,\n      status: 'paid',\n      billing_reason: invoiceProps?.billing_reason || 'stake',\n      description: invoiceProps?.description || 'Stake for subscription',\n      total: invoiceProps.total || '0',\n      amount_due: '0',\n      amount_paid: invoiceProps.total || '0',\n      amount_remaining: '0',\n      default_payment_method_id: paymentMethod.id,\n      checkout_session_id: invoiceProps?.checkout_session_id || '',\n      metadata,\n      auto_advance: false,\n      paid: true,\n      paid_out_of_band: false,\n      payment_settings: invoiceProps?.payment_settings || subscription?.payment_settings,\n    });\n\n    logger.info('create staking invoice success', {\n      invoice,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n  } catch (error) {\n    logger.error('ensureStake: create invoice failed', {\n      error,\n      subscriptionId: subscription?.id,\n      paymentMethod: paymentMethod.id,\n    });\n    throw error;\n  }\n}\n\nexport async function getStakeInvoiceForSubscription(subscriptionId: string, currencyId: string) {\n  const where: WhereOptions = {\n    [Op.or]: [\n      { subscription_id: subscriptionId },\n      { 'metadata.all_subscription_ids': { [Op.contains]: [subscriptionId] } },\n    ],\n    billing_reason: 'stake',\n    status: 'paid',\n  };\n\n  if (currencyId) {\n    where.currency_id = currencyId;\n  }\n  try {\n    const invoice = await Invoice.findOne({ where });\n    return invoice;\n  } catch (error) {\n    logger.error('getStakeInvoiceForSubscription: find invoice failed', {\n      error,\n      subscriptionId,\n      currencyId,\n    });\n    return null;\n  }\n}\n\n// mark overdraft protection invoice as void after payment\nexport async function handleOverdraftProtectionInvoiceAfterPayment(invoice: Invoice) {\n  try {\n    if (['stake', 'overdraft_protection', 'stake_overdraft_protection'].includes(invoice.billing_reason)) {\n      return;\n    }\n    const subscription = await Subscription.findByPk(invoice.subscription_id);\n    if (!subscription) {\n      logger.info('handle overdraft protection invoice skipped due to subscription not found', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n    if (!subscription.overdraft_protection?.enabled) {\n      logger.info('handle overdraft protection invoice skipped due to overdraft protection not enabled', {\n        subscriptionId: subscription.id,\n      });\n      return;\n    }\n    const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n    if (!paymentMethod || paymentMethod?.type !== 'arcblock') {\n      logger.info('handle overdraft protection invoice skipped due to payment method not supported', {\n        invoiceId: invoice.id,\n        paymentMethodId: paymentMethod?.id,\n      });\n      return;\n    }\n    const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n    if (!paymentIntent) {\n      logger.info('handle overdraft protection invoice skipped due to payment intent not found', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n    if (paymentIntent.status !== 'succeeded') {\n      logger.info('handle overdraft protection invoice skipped due to payment intent not succeeded', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n    if (paymentIntent.payment_details?.arcblock?.type !== 'transfer') {\n      logger.info('handle overdraft protection invoice skipped due to payment type not transfer', {\n        invoiceId: invoice.id,\n        paymentIntentId: paymentIntent.id,\n      });\n      return;\n    }\n    const overdraftProtectionInvoice = await Invoice.findOne({\n      where: {\n        subscription_id: subscription.id,\n        billing_reason: 'overdraft_protection',\n        'metadata.invoice_id': invoice.id,\n        status: {\n          [Op.notIn]: ['paid', 'void'],\n        },\n      },\n    });\n    if (!overdraftProtectionInvoice) {\n      logger.info('handle overdraft protection invoice skipped due to overdraft protection invoice not found', {\n        invoiceId: invoice.id,\n      });\n      return;\n    }\n\n    if (overdraftProtectionInvoice.payment_intent_id) {\n      const overdraftProtectionPaymentIntent = await PaymentIntent.findOne({\n        where: {\n          id: overdraftProtectionInvoice.payment_intent_id,\n        },\n      });\n      if (overdraftProtectionPaymentIntent) {\n        await overdraftProtectionPaymentIntent.update({\n          status: 'canceled',\n          canceled_at: dayjs().unix(),\n          cancellation_reason: 'void_invoice',\n        });\n      }\n    }\n\n    await overdraftProtectionInvoice.update({\n      status: 'void',\n      status_transitions: {\n        ...(overdraftProtectionInvoice.status_transitions || {}),\n        voided_at: dayjs().unix(),\n      },\n    });\n  } catch (error) {\n    logger.error('handle overdraft protection invoice failed', {\n      error,\n      invoiceId: invoice.id,\n    });\n  }\n}\n\n/**\n * retry uncollectible invoices\n * @param options\n */\nexport async function retryUncollectibleInvoices(options: {\n  customerId?: string;\n  subscriptionId?: string;\n  invoiceId?: string;\n  invoiceIds?: string[];\n  currencyId?: string;\n}) {\n  const lockKey = `retry-uncollectible-${JSON.stringify(options)}`;\n\n  const isLocked = await Lock.isLocked(lockKey);\n  if (isLocked) {\n    logger.warn('Retry uncollectible invoices already in progress', {\n      lockKey,\n      options,\n    });\n    throw new Error('Retry already in progress');\n  }\n\n  try {\n    await Lock.acquire(lockKey, dayjs().add(5, 'minutes').unix());\n\n    const { customerId, subscriptionId, invoiceId, invoiceIds, currencyId } = options;\n\n    const where: WhereOptions = {\n      status: { [Op.in]: ['uncollectible'] },\n      payment_intent_id: { [Op.ne]: null },\n    };\n\n    if (customerId) {\n      where.customer_id = customerId;\n    }\n\n    if (subscriptionId) {\n      where.subscription_id = subscriptionId;\n    }\n\n    if (invoiceId) {\n      where.id = invoiceId;\n    }\n\n    if (invoiceIds && invoiceIds.length > 0) {\n      where.id = { [Op.in]: invoiceIds };\n    }\n\n    if (currencyId) {\n      where.currency_id = currencyId;\n    }\n\n    const overdueInvoices = (await Invoice.findAll({\n      where,\n      include: [{ model: PaymentIntent, as: 'paymentIntent' }],\n      attributes: ['id', 'payment_intent_id', 'subscription_id', 'customer_id', 'created_at', 'status', 'currency_id'],\n      order: [['created_at', 'ASC']],\n    })) as (Invoice & { paymentIntent?: PaymentIntent })[];\n\n    const startTime = Date.now();\n    logger.info('Found uncollectible invoices to retry', {\n      count: overdueInvoices.length,\n      criteria: options,\n      invoiceIds: overdueInvoices.map((inv) => inv.id),\n    });\n\n    const results = {\n      processed: overdueInvoices.length,\n      successful: [] as string[],\n      failed: [] as Array<{ id: string; reason: string }>,\n    };\n\n    const settledResults = await Promise.allSettled(\n      overdueInvoices.map(async (invoice, index) => {\n        const { paymentIntent } = invoice;\n        const delay = index * 2;\n        if (!paymentIntent) {\n          throw new Error('No payment intent found');\n        }\n\n        await paymentIntent.update({ status: 'requires_capture' });\n        await emitAsync(\n          'payment.queued',\n          paymentIntent.id,\n          { paymentIntentId: paymentIntent.id, retryOnError: true, ignoreMaxRetryCheck: true },\n          { sync: false, delay }\n        );\n\n        return invoice;\n      })\n    );\n\n    settledResults.forEach((result, index) => {\n      const invoice = overdueInvoices[index];\n      if (!invoice) {\n        return;\n      }\n      if (result.status === 'fulfilled') {\n        results.successful.push(invoice.id);\n        logger.info('Successfully queued uncollectible invoice retry', {\n          invoiceId: invoice.id,\n          customerId: invoice.customer_id,\n          paymentIntentId: invoice.payment_intent_id,\n        });\n      } else {\n        const error = result.reason;\n        const errorType = error.name || 'Unknown';\n        const errorCode = error.code || 'UNKNOWN_ERROR';\n\n        results.failed.push({\n          id: invoice.id,\n          reason: error.message || 'Unknown error',\n        });\n\n        logger.error('Failed to queue uncollectible invoice retry', {\n          invoiceId: invoice.id,\n          customerId: invoice.customer_id,\n          subscriptionId: invoice.subscription_id,\n          paymentIntentId: invoice.payment_intent_id,\n          errorType,\n          errorCode,\n          error,\n        });\n      }\n    });\n\n    const processingTime = Date.now() - startTime;\n    logger.info('Completed retrying uncollectible invoices', {\n      totalProcessed: results.processed,\n      successful: results.successful.length,\n      failed: results.failed.length,\n      processingTimeMs: processingTime,\n    });\n\n    return results;\n  } finally {\n    await Lock.release(lockKey);\n    logger.info('Released retry uncollectible lock', { lockKey });\n  }\n}\n\n/**\n * Migrate billing when a subscription's payment method changes.\n * Steps:\n * 1. Check if all subscription items are prepaid (licensed recurring).\n * 2. If so, check if there is an unpaid invoice for the current period with the old payment method.\n * 3. If such an invoice exists, void the old invoice and cancel its payment intent if present.\n * 4. Create a new invoice for the current period with the new payment method.\n * 5. If any step fails, throw an error and log details.\n *\n * @param subscription Subscription instance\n * @param oldCurrencyId Old payment currency ID\n * @param newCurrencyId New payment currency ID\n * @returns Migration result: { migrated, oldInvoice, newInvoice }\n */\nexport const migrateSubscriptionPaymentMethodInvoice = async (\n  subscription: Subscription,\n  oldCurrencyId: string,\n  newCurrencyId: string\n) => {\n  // 1. Check if all subscription items are prepaid (licensed recurring)\n  const subscriptionItems = await SubscriptionItem.findAll({\n    where: { subscription_id: subscription.id },\n    include: [{ model: Price, as: 'price' }],\n  });\n\n  const subscriptionItemsExpanded = await Price.expand(subscriptionItems.map((x) => x.toJSON()));\n  const isPrepaid = subscriptionItemsExpanded.every((item: TLineItemExpanded) => {\n    const price = getSubscriptionItemPrice(item);\n    return price.type === 'recurring' && price.recurring?.usage_type === 'licensed';\n  });\n\n  if (!isPrepaid) {\n    logger.info('Skip billing migration for non-prepaid items', {\n      subscriptionId: subscription.id,\n    });\n    return { migrated: false, reason: 'has_non_prepaid_items' };\n  }\n\n  // 2. Find unpaid invoice for the current period with the old payment method\n  const currentPeriodInvoice = await Invoice.findOne({\n    where: {\n      subscription_id: subscription.id,\n      billing_reason: 'subscription_cycle',\n      status: ['open', 'uncollectible'],\n      currency_id: oldCurrencyId,\n      period_start: {\n        [Op.gte]: subscription.current_period_start,\n        [Op.lt]: subscription.current_period_end,\n      },\n    },\n    order: [['created_at', 'DESC']],\n  });\n\n  let voidedInvoice: Invoice | null = null;\n\n  if (!currentPeriodInvoice) {\n    voidedInvoice = await Invoice.findOne({\n      where: {\n        subscription_id: subscription.id,\n        billing_reason: 'subscription_cycle',\n        status: 'void',\n        currency_id: oldCurrencyId,\n        period_start: {\n          [Op.gte]: subscription.current_period_start,\n          [Op.lt]: subscription.current_period_end,\n        },\n      },\n      order: [['created_at', 'DESC']],\n    });\n    if (!voidedInvoice) {\n      logger.info('Skip billing migration for no unpaid invoice', {\n        subscriptionId: subscription.id,\n        periodStart: subscription.current_period_start,\n        periodEnd: subscription.current_period_end,\n        oldCurrencyId,\n      });\n      return { migrated: false, reason: 'no_unpaid_invoice' };\n    }\n  }\n\n  // 3. Get old and new payment method/currency\n  const oldPaymentCurrency = await PaymentCurrency.findByPk(oldCurrencyId);\n  if (!oldPaymentCurrency) {\n    throw new Error(`Payment currency ${oldCurrencyId} not found`);\n  }\n  const oldPaymentMethod = await PaymentMethod.findByPk(oldPaymentCurrency.payment_method_id);\n  if (!oldPaymentMethod) {\n    throw new Error(`Payment method for currency ${oldCurrencyId} not found`);\n  }\n\n  const newPaymentCurrency = await PaymentCurrency.findByPk(newCurrencyId);\n  if (!newPaymentCurrency) {\n    throw new Error(`Payment currency ${newCurrencyId} not found`);\n  }\n  const newPaymentMethod = await PaymentMethod.findByPk(newPaymentCurrency.payment_method_id);\n  if (!newPaymentMethod) {\n    throw new Error(`Payment method for currency ${newCurrencyId} not found`);\n  }\n\n  // 4. Stripe payment method is not supported for migration\n  if (newPaymentMethod.type === 'stripe') {\n    logger.info('Skip billing migration for stripe payment method', {\n      subscriptionId: subscription.id,\n    });\n    return { migrated: false, reason: 'stripe_payment_method' };\n  }\n\n  try {\n    const customer = await Customer.findByPk(subscription.customer_id);\n    if (!customer) {\n      throw new Error(`Customer ${subscription.customer_id} not found`);\n    }\n\n    const cancelOldInvoice = async (invoice: Invoice) => {\n      try {\n        if (invoice.payment_intent_id) {\n          const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n          if (paymentIntent && paymentIntent.status !== 'canceled') {\n            await paymentIntent.update({\n              status: 'canceled',\n              canceled_at: dayjs().unix(),\n              cancellation_reason: 'void_invoice',\n            });\n          }\n        }\n\n        if (oldPaymentMethod.type === 'stripe' && invoice.metadata?.stripe_id) {\n          const client = oldPaymentMethod.getStripeClient();\n          await client.invoices.voidInvoice(invoice.metadata.stripe_id);\n        }\n\n        await invoice.update({\n          status: 'void',\n          status_transitions: {\n            ...(invoice.status_transitions || {}),\n            voided_at: dayjs().unix(),\n          },\n        });\n\n        logger.info('Successfully voided old invoice for payment method change', {\n          subscriptionId: subscription.id,\n          oldInvoice: invoice.id,\n          oldCurrency: oldCurrencyId,\n          newCurrency: newCurrencyId,\n        });\n      } catch (error) {\n        logger.error('Failed to void old invoice', {\n          subscription: subscription.id,\n          invoiceId: invoice.id,\n          error: error.message,\n        });\n        throw error;\n      }\n    };\n\n    const createNewInvoice = async () => {\n      const preInvoice = currentPeriodInvoice || voidedInvoice;\n      if (!preInvoice) {\n        throw new Error('No unpaid invoice found');\n      }\n      const metadata: Record<string, any> = {\n        prev_invoice_id: preInvoice.id,\n      };\n      const amount = getSubscriptionCycleAmount(subscriptionItemsExpanded, newCurrencyId);\n\n      const { invoice } = await ensureInvoiceAndItems({\n        customer,\n        currency: newPaymentCurrency,\n        subscription,\n        trialing: subscription.status === 'trialing',\n        metered: false,\n        lineItems: subscriptionItemsExpanded,\n        applyCredit: false,\n        props: {\n          status: 'open',\n          total: amount.total,\n          livemode: subscription.livemode,\n          description: 'Subscription cycle',\n          statement_descriptor: preInvoice.statement_descriptor,\n          period_start: preInvoice.period_start,\n          period_end: preInvoice.period_end,\n          auto_advance: true,\n          billing_reason: 'subscription_cycle',\n          currency_id: newCurrencyId,\n          default_payment_method_id: newPaymentMethod.id,\n          custom_fields: preInvoice.custom_fields || [],\n          footer: preInvoice.footer || '',\n          payment_settings: subscription.payment_settings,\n          metadata,\n        } as Invoice,\n      });\n      return invoice;\n    };\n\n    // 5. Cancel old invoice, then create new invoice\n    if (currentPeriodInvoice) {\n      await cancelOldInvoice(currentPeriodInvoice);\n    }\n\n    const invoice = await createNewInvoice();\n    if (invoice) {\n      await emitAsync('invoice.queued', invoice.id, { invoiceId: invoice.id, retryOnError: true }, { sync: false });\n      logger.info('Successfully queued new invoice for payment method change', {\n        subscriptionId: subscription.id,\n        invoiceId: invoice.id,\n      });\n    }\n\n    logger.info('Successfully migrated invoice for payment method change', {\n      subscriptionId: subscription.id,\n      oldInvoiceId: currentPeriodInvoice?.id || voidedInvoice?.id,\n      oldCurrency: oldCurrencyId,\n      newCurrency: newCurrencyId,\n      newInvoiceId: invoice.id,\n    });\n    return {\n      migrated: true,\n      oldInvoice: currentPeriodInvoice,\n      newInvoice: invoice,\n    };\n  } catch (error) {\n    logger.error('Failed to migrate invoice for payment method change', {\n      subscriptionId: subscription.id,\n      oldCurrencyId,\n      newCurrencyId,\n      error: error.message,\n    });\n    throw error;\n  }\n};\n\nexport async function destroyExistingInvoice(invoice: Invoice) {\n  const paymentMethod = await PaymentMethod.findByPk(invoice.default_payment_method_id);\n  try {\n    if (paymentMethod?.type === 'stripe' && invoice.metadata?.stripe_id) {\n      const client = paymentMethod.getStripeClient();\n      await client.invoices.del(invoice.metadata.stripe_id);\n    }\n  } catch (error) {\n    logger.error('Failed to destroy invoice on stripe', {\n      error: error.message,\n      invoiceId: invoice.id,\n    });\n  }\n  await InvoiceItem.destroy({ where: { invoice_id: invoice.id } });\n  await invoice.destroy();\n}\n","numLines":1494,"startLine":1,"totalLines":1494}}}
{"parentUuid":"d00a114b-8455-46de-b444-cae7eb083dee","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01P7PFQNCqPJrfzh88sg9zcv","type":"tool_result","content":"     1→/* eslint-disable no-await-in-loop */\n     2→import component from '@blocklet/sdk/lib/component';\n     3→import { BN, fromTokenToUnit, fromUnitToToken } from '@ocap/util';\n     4→import isEmpty from 'lodash/isEmpty';\n     5→import trim from 'lodash/trim';\n     6→import pick from 'lodash/pick';\n     7→import type { LiteralUnion } from 'type-fest';\n     8→import { withQuery } from 'ufo';\n     9→\n    10→import { Op } from 'sequelize';\n    11→import {\n    12→  Customer,\n    13→  Invoice,\n    14→  InvoiceItem,\n    15→  Lock,\n    16→  PaymentCurrency,\n    17→  PaymentIntent,\n    18→  PaymentMethod,\n    19→  Price,\n    20→  PriceRecurring,\n    21→  Refund,\n    22→  Subscription,\n    23→  SubscriptionData,\n    24→  SubscriptionItem,\n    25→  SubscriptionUpdateItem,\n    26→  TLineItemExpanded,\n    27→  UsageRecord,\n    28→} from '../store/models';\n    29→import { createEvent } from './audit';\n    30→import dayjs from './dayjs';\n    31→import env from './env';\n    32→import logger from './logger';\n    33→import { getExchangeRateService } from './exchange-rate';\n    34→import { getExchangeRateSymbol } from './exchange-rate/token-address-mapping';\n    35→import { trimDecimals, limitTokenPrecision } from './math-utils';\n    36→import { getPriceCurrencyOptions, getPriceUintAmountByCurrency } from './price';\n    37→import { getRecurringPeriod, getSubscriptionCreateSetup } from './session';\n    38→import { getConnectQueryParam, getCustomerStakeAddress } from './util';\n    39→import { wallet } from './auth';\n    40→import { getGasPayerExtra } from './payment';\n    41→import { getLock } from './lock';\n    42→import { emitAsync } from './event';\n    43→\n    44→export function getCustomerSubscriptionPageUrl({\n    45→  subscriptionId,\n    46→  locale = 'en',\n    47→  userDid,\n    48→}: {\n    49→  subscriptionId: string;\n    50→  locale: LiteralUnion<'en' | 'zh', string>;\n    51→  userDid: string;\n    52→}) {\n    53→  return component.getUrl(\n    54→    withQuery(`customer/subscription/${subscriptionId}`, {\n    55→      locale,\n    56→      ...getConnectQueryParam({ userDid }),\n    57→    })\n    58→  );\n    59→}\n    60→\n    61→export function getAdminSubscriptionPageUrl({\n    62→  subscriptionId,\n    63→  locale = 'en',\n    64→  userDid,\n    65→}: {\n    66→  subscriptionId: string;\n    67→  locale: LiteralUnion<'en' | 'zh', string>;\n    68→  userDid: string;\n    69→}) {\n    70→  return component.getUrl(\n    71→    withQuery(`admin/billing/${subscriptionId}`, {\n    72→      locale,\n    73→      ...getConnectQueryParam({ userDid }),\n    74→    })\n    75→  );\n    76→}\n    77→\n    78→export function getAdminInvoicePageUrl({\n    79→  invoiceId,\n    80→  locale = 'en',\n    81→  userDid,\n    82→}: {\n    83→  invoiceId: string;\n    84→  locale: LiteralUnion<'en' | 'zh', string>;\n    85→  userDid: string;\n    86→}) {\n    87→  return component.getUrl(\n    88→    withQuery(`admin/billing/${invoiceId}`, {\n    89→      locale,\n    90→      ...getConnectQueryParam({ userDid }),\n    91→    })\n    92→  );\n    93→}\n    94→\n    95→export function parseIntegerConfig(alternatives: any[], defaultValue: number) {\n    96→  for (const raw of alternatives) {\n    97→    const days = parseInt(raw, 10);\n    98→    if (typeof days === 'number' && days >= 0) {\n    99→      return days;\n   100→    }\n   101→  }\n   102→\n   103→  return defaultValue;\n   104→}\n   105→\n   106→export function getDaysUntilDue(query: Record<string, any> = {}) {\n   107→  return parseIntegerConfig([query.days_until_due, process.env.PAYMENT_DAYS_UNTIL_DUE], 6);\n   108→}\n   109→\n   110→export function getDaysUntilCancel(query: Record<string, any> = {}) {\n   111→  return parseIntegerConfig([query.days_until_cancel, process.env.PAYMENT_DAYS_UNTIL_CANCEL], 0);\n   112→}\n   113→\n   114→export const getDueUnit = (interval: string) => {\n   115→  if (interval === 'hour') {\n   116→    return 60;\n   117→  }\n   118→\n   119→  if (interval === 'day') {\n   120→    return 60 * 60;\n   121→  }\n   122→\n   123→  return 60 * 60 * 24;\n   124→};\n   125→\n   126→export const getMaxRetryCount = (interval: string) => {\n   127→  if (interval === 'hour') {\n   128→    return 10; // 34 minutes\n   129→  }\n   130→\n   131→  if (interval === 'day') {\n   132→    return 15; // 18 hours\n   133→  }\n   134→\n   135→  if (interval === 'week') {\n   136→    return 18; // 6 days\n   137→  }\n   138→\n   139→  return 20; // 24 days\n   140→};\n   141→\n   142→export const getMinRetryMail = (interval: string) => {\n   143→  if (interval === 'hour') {\n   144→    return 9; // 17 minutes\n   145→  }\n   146→\n   147→  if (interval === 'day') {\n   148→    return 13; // 4 hours\n   149→  }\n   150→\n   151→  if (interval === 'week') {\n   152→    return 15; // 18 hours\n   153→  }\n   154→\n   155→  return 15; // 18 hours\n   156→};\n   157→\n   158→const ZERO = new BN(0);\n   159→export function getSubscriptionStakeSetup(items: TLineItemExpanded[], currencyId: string, billingThreshold = '0') {\n   160→  const staking = {\n   161→    licensed: new BN(0),\n   162→    metered: new BN(0),\n   163→  };\n   164→\n   165→  const recurringItems = items\n   166→    .map((x) => x.upsell_price || x.price)\n   167→    .filter((x) => x.type === 'recurring' && x.recurring);\n   168→  if (recurringItems.length > 0) {\n   169→    if (new BN(billingThreshold).gt(ZERO)) {\n   170→      staking.licensed = new BN(billingThreshold);\n   171→    } else {\n   172→      items.forEach((x) => {\n   173→        const price = getSubscriptionItemPrice(x);\n   174→        const unit = getPriceUintAmountByCurrency(price, currencyId);\n   175→        const amount = new BN(unit).mul(new BN(x.quantity));\n   176→        if (price.type === 'recurring' && price.recurring) {\n   177→          if (price.recurring.usage_type === 'licensed') {\n   178→            staking.licensed = staking.licensed.add(amount);\n   179→          }\n   180→          if (price.recurring.usage_type === 'metered') {\n   181→            staking.metered = staking.metered.add(amount);\n   182→          }\n   183→        }\n   184→      });\n   185→    }\n   186→  }\n   187→\n   188→  return staking;\n   189→}\n   190→\n   191→export function getSubscriptionCycleSetup(\n   192→  recurring: PriceRecurring,\n   193→  previousPeriodEnd: number,\n   194→  options?: {\n   195→    catchUp?: boolean;\n   196→    maxMissedPeriods?: number;\n   197→  }\n   198→) {\n   199→  const cycle = getRecurringPeriod(recurring);\n   200→  const now = dayjs().unix();\n   201→\n   202→  // Basic setup without catch-up\n   203→  if (!options?.catchUp) {\n   204→    return {\n   205→      recurring,\n   206→      cycle,\n   207→      period: {\n   208→        start: previousPeriodEnd,\n   209→        end: dayjs.unix(previousPeriodEnd).add(cycle, 'millisecond').unix(),\n   210→      },\n   211→      missedPeriods: 0,\n   212→    };\n   213→  }\n   214→\n   215→  // Calculate missed periods if catch-up is enabled\n   216→  const expectedEnd = dayjs.unix(previousPeriodEnd).add(cycle, 'millisecond').unix();\n   217→\n   218→  if (now <= expectedEnd) {\n   219→    // No catch-up needed\n   220→    return {\n   221→      recurring,\n   222→      cycle,\n   223→      period: {\n   224→        start: previousPeriodEnd,\n   225→        end: expectedEnd,\n   226→      },\n   227→      missedPeriods: 0,\n   228→    };\n   229→  }\n   230→\n   231→  // Calculate how many periods we've missed\n   232→  const timeSinceExpected = now - expectedEnd;\n   233→  const cycleInSeconds = cycle / 1000;\n   234→  const missedPeriods = Math.floor(timeSinceExpected / cycleInSeconds);\n   235→  const maxMissedPeriods = options.maxMissedPeriods || 100; // Default limit to prevent excessive catch-up\n   236→\n   237→  const actualMissedPeriods = Math.min(missedPeriods, maxMissedPeriods);\n   238→\n   239→  // Calculate the current period we should be in\n   240→  const currentPeriodStart = dayjs\n   241→    .unix(previousPeriodEnd)\n   242→    .add((actualMissedPeriods + 1) * cycle, 'millisecond')\n   243→    .unix();\n   244→  const currentPeriodEnd = dayjs.unix(currentPeriodStart).add(cycle, 'millisecond').unix();\n   245→\n   246→  return {\n   247→    recurring,\n   248→    cycle,\n   249→    period: {\n   250→      start: currentPeriodStart,\n   251→      end: currentPeriodEnd,\n   252→    },\n   253→    missedPeriods: actualMissedPeriods,\n   254→    // Additional info for recovery handling\n   255→    recovery: {\n   256→      originalPeriodEnd: previousPeriodEnd,\n   257→      expectedPeriodEnd: expectedEnd,\n   258→      timeMissed: timeSinceExpected,\n   259→      periodsSkipped: actualMissedPeriods,\n   260→      wasLimited: missedPeriods > maxMissedPeriods,\n   261→    },\n   262→  };\n   263→}\n   264→\n   265→export function getSubscriptionCycleAmount(items: TLineItemExpanded[], currencyId: string) {\n   266→  let amount = new BN(0);\n   267→\n   268→  items.forEach((x) => {\n   269→    const price = getSubscriptionItemPrice(x) as any;\n   270→    // TODO: why use custom_amount and quoted_amount instead of the price.unit_amount?\n   271→    const dynamicAmount =\n   272→      price?.pricing_type === 'dynamic' ? (x as any).custom_amount || (x as any).quoted_amount : null;\n   273→\n   274→    if (dynamicAmount) {\n   275→      amount = amount.add(new BN(dynamicAmount));\n   276→      return;\n   277→    }\n   278→\n   279→    amount = amount.add(new BN(getPriceUintAmountByCurrency(price, currencyId)).mul(new BN(x.quantity)));\n   280→  });\n   281→\n   282→  return {\n   283→    total: amount.toString(),\n   284→  };\n   285→}\n   286→\n   287→export function getSubscriptionItemPrice(item: TLineItemExpanded) {\n   288→  return item.upsell_price || item.price;\n   289→}\n   290→\n   291→export async function createProration(\n   292→  subscription: Subscription,\n   293→  setup: ReturnType<typeof getSubscriptionCreateSetup>,\n   294→  anchor: number\n   295→) {\n   296→  const lastInvoice = await Invoice.findByPk(subscription.latest_invoice_id);\n   297→  if (!lastInvoice) {\n   298→    throw new Error('Subscription should have latest invoice when create proration');\n   299→  }\n   300→\n   301→  const customer = await Customer.findByPk(subscription.customer_id);\n   302→  if (!customer) {\n   303→    throw new Error('Subscription should have customer when create proration');\n   304→  }\n   305→\n   306→  // 1. get last invoice, and invoice items, filter invoice items that are in licensed recurring mode\n   307→  const invoiceItems = await InvoiceItem.findAll({ where: { invoice_id: lastInvoice.id, proration: false } });\n   308→  const invoiceItemsExpanded = await Price.expand(invoiceItems.map((x) => x.toJSON()));\n   309→  const prorationItems = invoiceItemsExpanded.filter((x) => {\n   310→    const price = getSubscriptionItemPrice(x);\n   311→    return price.type === 'recurring' && price.recurring?.usage_type === 'licensed';\n   312→  });\n   313→\n   314→  // 2. calculate proration args based on the filtered invoice items\n   315→  const precision = 10000;\n   316→  const isInvoicePeriodValid = lastInvoice.period_start < lastInvoice.period_end;\n   317→  const prorationStart = isInvoicePeriodValid ? lastInvoice.period_start : subscription.current_period_start;\n   318→  const prorationEnd = isInvoicePeriodValid ? lastInvoice.period_end : subscription.current_period_end;\n   319→  if (anchor > prorationEnd) {\n   320→    logger.warn('try to create proration with invalid arguments', { anchor, prorationStart, prorationEnd });\n   321→    throw new Error('Subscription proration anchor should not be larger than prorationEnd');\n   322→  }\n   323→  const trialing = subscription.status === 'trialing';\n   324→  if (trialing) {\n   325→    return {\n   326→      lastInvoice,\n   327→      total: '0',\n   328→      shouldPay: '0',\n   329→      used: '0',\n   330→      unused: '0',\n   331→      prorations: [],\n   332→      newCredit: '0',\n   333→      appliedCredit: '0',\n   334→      remaining: '0',\n   335→      remainingUnused: '0',\n   336→    };\n   337→  }\n   338→\n   339→  const prorationRate = Math.ceil(((prorationEnd - anchor) / (prorationEnd - prorationStart)) * precision);\n   340→  let unused = new BN(0);\n   341→  const prorations = await Promise.all(\n   342→    prorationItems.map((x: TLineItemExpanded & { [key: string]: any }) => {\n   343→      const price = getSubscriptionItemPrice(x);\n   344→      const unitAmount = getPriceUintAmountByCurrency(price, lastInvoice.currency_id);\n   345→      const amount = new BN(unitAmount)\n   346→        .mul(new BN(x.quantity))\n   347→        .mul(new BN(prorationRate))\n   348→        .div(new BN(precision))\n   349→        .toString();\n   350→      logger.info('subscription proration item', {\n   351→        subscription: subscription.id,\n   352→        invoice: x.invoice_id,\n   353→        invoiceItem: x.id,\n   354→        amount,\n   355→      });\n   356→      unused = unused.add(new BN(amount));\n   357→\n   358→      return {\n   359→        price_id: price.id,\n   360→        amount: `-${amount}`,\n   361→        quantity: x.quantity,\n   362→        // @ts-ignore\n   363→        description: `Unused time on ${price.product.name} after ${dayjs().format('lll')}`,\n   364→        period: {\n   365→          start: lastInvoice.period_start,\n   366→          end: lastInvoice.period_end,\n   367→        },\n   368→        proration: true,\n   369→        proration_details: {\n   370→          credited_items: {\n   371→            invoice_id: lastInvoice.id,\n   372→            // @ts-ignore\n   373→            invoice_line_items: [x.id],\n   374→          },\n   375→        },\n   376→      };\n   377→    })\n   378→  );\n   379→  logger.info('subscription prorations created', {\n   380→    subscription: subscription.id,\n   381→    prorations,\n   382→  });\n   383→\n   384→  // 5. adjust invoice total && update customer token balance\n   385→  const total = setup.amount.setup;\n   386→\n   387→  // 6. calculate remaining amount\n   388→  const refunds = await Refund.findAll({\n   389→    where: {\n   390→      status: { [Op.not]: 'canceled' },\n   391→      subscription_id: subscription.id,\n   392→      currency_id: lastInvoice?.currency_id,\n   393→      invoice_id: lastInvoice?.id,\n   394→    },\n   395→  });\n   396→  const refundAmount = refunds.reduce((acc, x) => acc.add(new BN(x.amount || '0')), new BN(0));\n   397→\n   398→  // 7. calculate remaining amount, default refund recurring amount\n   399→  const calcRemaining = (amount: BN, subtract: BN) =>\n   400→    amount.sub(subtract).lt(new BN(0)) ? '0' : amount.sub(subtract).toString();\n   401→\n   402→  const remaining = calcRemaining(new BN(total), refundAmount);\n   403→  const remainingUnused = calcRemaining(unused, refundAmount);\n   404→\n   405→  let due = setup.amount.setup;\n   406→  let newCredit = '0';\n   407→  let appliedCredit = '0';\n   408→  if (new BN(total).gte(unused)) {\n   409→    // Proration amount is less than total, all proration are used,\n   410→    due = new BN(total).sub(unused).toString();\n   411→    // Besides, we need to try to apply customer credit\n   412→    appliedCredit = customer.getBalanceToApply(subscription.currency_id, due);\n   413→    due = new BN(due).sub(new BN(appliedCredit)).toString();\n   414→  } else {\n   415→    // Proration amount is greater than total, we need to increase customer credit\n   416→    newCredit = unused.sub(new BN(total)).toString();\n   417→    due = '0';\n   418→  }\n   419→\n   420→  logger.info('subscription proration result', {\n   421→    subscription: subscription.id,\n   422→    prorationStart,\n   423→    prorationEnd,\n   424→    prorationRate,\n   425→    unused: unused.toString(),\n   426→    remaining,\n   427→    remainingUnused,\n   428→    total,\n   429→    due,\n   430→    newCredit,\n   431→    appliedCredit,\n   432→  });\n   433→\n   434→  return {\n   435→    lastInvoice,\n   436→    total,\n   437→    due,\n   438→    remaining,\n   439→    remainingUnused,\n   440→    used: new BN(lastInvoice.amount_due).sub(unused).toString(),\n   441→    unused: unused.toString(),\n   442→    prorations,\n   443→    newCredit,\n   444→    appliedCredit,\n   445→  };\n   446→}\n   447→\n   448→export async function getSubscriptionRefundSetup(subscription: Subscription, anchor: number, currencyId?: string) {\n   449→  const items = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n   450→  const expanded = await Price.expand(items.map((x) => x.toJSON()));\n   451→  const setup = getSubscriptionCreateSetup(expanded, currencyId || subscription.currency_id, 0);\n   452→  return createProration(subscription, setup, anchor);\n   453→}\n   454→\n   455→export function shouldCancelSubscription(\n   456→  subscription: Pick<Subscription, 'status' | 'current_period_end' | 'cancel_at' | 'cancel_at_period_end'>\n   457→) {\n   458→  if (['past_due', 'active', 'trialing'].includes(subscription.status)) {\n   459→    const now = dayjs().unix();\n   460→    if (subscription.cancel_at) {\n   461→      if (subscription.cancel_at <= now) {\n   462→        return true;\n   463→      }\n   464→    } else if (subscription.cancel_at_period_end) {\n   465→      if (subscription.current_period_end <= now) {\n   466→        return true;\n   467→      }\n   468→    }\n   469→  }\n   470→\n   471→  return false;\n   472→}\n   473→\n   474→export async function canChangePaymentMethod(subscriptionId: string) {\n   475→  const item = await SubscriptionItem.findOne({ where: { subscription_id: subscriptionId } });\n   476→  const expanded = await Price.findOne({ where: { id: item!.price_id } });\n   477→  return expanded && getPriceCurrencyOptions(expanded).length > 1;\n   478→}\n   479→\n   480→export async function expandSubscriptionItems(subscriptionId: string) {\n   481→  const items = await SubscriptionItem.findAll({ where: { subscription_id: subscriptionId } });\n   482→  return Price.expand(items.map((x) => x.toJSON()));\n   483→}\n   484→\n   485→export async function getUpcomingInvoiceAmount(subscriptionId: string) {\n   486→  const subscription = await Subscription.findByPk(subscriptionId);\n   487→  if (!subscription) {\n   488→    throw new Error('Subscription not found');\n   489→  }\n   490→\n   491→  if (subscription.isActive() === false && subscription.status !== 'past_due') {\n   492→    throw new Error(`Subscription not active for ${subscriptionId}, so usage check is skipped`);\n   493→  }\n   494→\n   495→  const currency = await PaymentCurrency.findByPk(subscription.currency_id);\n   496→\n   497→  const items = await SubscriptionItem.findAll({ where: { subscription_id: subscriptionId } });\n   498→  const expanded = await Price.expand(items.map((x) => x.toJSON()));\n   499→\n   500→  let amount = new BN(0);\n   501→  let minExpectedAmount = new BN(0);\n   502→  for (const item of expanded) {\n   503→    const price = getSubscriptionItemPrice(item);\n   504→    if (price.type === 'recurring') {\n   505→      const unit = getPriceUintAmountByCurrency(price, subscription.currency_id);\n   506→      if (price.recurring?.usage_type === 'licensed') {\n   507→        amount = amount.add(new BN(unit).mul(new BN(item.quantity)));\n   508→        minExpectedAmount = minExpectedAmount.add(new BN(unit).mul(new BN(item.quantity)));\n   509→      }\n   510→      if (price.recurring?.usage_type === 'metered') {\n   511→        const rawQuantity = await UsageRecord.getSummary({\n   512→          // @ts-ignore\n   513→          id: item?.id as string,\n   514→          start: subscription.current_period_start,\n   515→          end: subscription.current_period_end,\n   516→          method: price.recurring?.aggregate_usage as any,\n   517→          dryRun: true,\n   518→        });\n   519→        // @ts-ignore\n   520→        const quantity = price.transformQuantity(rawQuantity);\n   521→        amount = amount.add(new BN(unit).mul(new BN(quantity)));\n   522→        minExpectedAmount = minExpectedAmount.add(new BN(unit).mul(new BN(item.quantity)));\n   523→      }\n   524→    }\n   525→  }\n   526→\n   527→  return {\n   528→    amount: amount.toString(),\n   529→    minExpectedAmount: minExpectedAmount.toString(),\n   530→    start: subscription.current_period_start,\n   531→    end: subscription.current_period_end,\n   532→    currency,\n   533→  };\n   534→}\n   535→\n   536→export async function getPastInvoicesAmount(subscriptionId: string, aggregationRule: 'sum' | 'avg' | 'max' = 'max') {\n   537→  const subscription = await Subscription.findByPk(subscriptionId);\n   538→  if (!subscription) {\n   539→    throw new Error('Subscription not found');\n   540→  }\n   541→\n   542→  const currency = await PaymentCurrency.findByPk(subscription.currency_id);\n   543→\n   544→  // 获取所有的账单周期\n   545→  const pastInvoices = await Invoice.findAll({\n   546→    where: {\n   547→      subscription_id: subscriptionId,\n   548→      currency_id: subscription.currency_id,\n   549→      billing_reason: [\n   550→        'subscription_create',\n   551→        'subscription_cycle',\n   552→        'subscription_update',\n   553→        'subscription_recover',\n   554→        'subscription_threshold',\n   555→        'subscription_cancel',\n   556→        'subscription',\n   557→      ],\n   558→    },\n   559→    order: [['created_at', 'DESC']],\n   560→  });\n   561→\n   562→  const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, subscription.current_period_end);\n   563→  let start = setup.period.start - setup.cycle / 1000;\n   564→  let end = setup.period.end - setup.cycle / 1000;\n   565→  const createdAt = dayjs(subscription.created_at).unix();\n   566→  const amountsByPeriod: { [key: string]: BN } = {};\n   567→\n   568→  while (start < end && start >= createdAt) {\n   569→    const periodKey = `${start}-${end}`;\n   570→    // eslint-disable-next-line @typescript-eslint/no-loop-func\n   571→    const invoices = pastInvoices.filter((x) => x.period_start >= start && x.period_end <= end);\n   572→    const amount = invoices.reduce((acc, x) => acc.add(new BN(x.total)), new BN(0));\n   573→    amountsByPeriod[periodKey] = amount;\n   574→    start -= setup.cycle / 1000;\n   575→    end -= setup.cycle / 1000;\n   576→  }\n   577→\n   578→  let result = new BN(0);\n   579→  switch (aggregationRule) {\n   580→    case 'sum':\n   581→      result = Object.values(amountsByPeriod).reduce((acc, curr) => acc.add(curr), new BN(0));\n   582→      break;\n   583→    case 'avg':\n   584→      result =\n   585→        Object.values(amountsByPeriod).length > 0\n   586→          ? Object.values(amountsByPeriod)\n   587→              .reduce((acc, curr) => acc.add(curr), new BN(0))\n   588→              .div(new BN(Object.values(amountsByPeriod).length))\n   589→          : new BN(0);\n   590→      break;\n   591→    case 'max':\n   592→      result =\n   593→        Object.values(amountsByPeriod).length > 0\n   594→          ? Object.values(amountsByPeriod).reduce((acc, curr) => (acc.gt(curr) ? acc : curr), new BN(0))\n   595→          : new BN(0);\n   596→      break;\n   597→    default:\n   598→      throw new Error('Invalid aggregation rule');\n   599→  }\n   600→\n   601→  return {\n   602→    amount: result.toString(),\n   603→    currency,\n   604→  };\n   605→}\n   606→\n   607→export async function finalizeSubscriptionUpdate({\n   608→  subscription,\n   609→  customer,\n   610→  invoice,\n   611→  paymentCurrency,\n   612→  appliedCredit,\n   613→  newCredit,\n   614→  addedItems,\n   615→  updatedItems,\n   616→  deletedItems,\n   617→  updates,\n   618→}: {\n   619→  subscription: Subscription;\n   620→  customer: Customer;\n   621→  invoice: Invoice | null;\n   622→  paymentCurrency: PaymentCurrency;\n   623→  appliedCredit: string;\n   624→  newCredit: string;\n   625→  addedItems: SubscriptionUpdateItem[];\n   626→  updatedItems: SubscriptionUpdateItem[];\n   627→  deletedItems: SubscriptionUpdateItem[];\n   628→  updates: any;\n   629→}) {\n   630→  if (isEmpty(updates)) {\n   631→    logger.info('subscription update aborted', { subscription: subscription.id, updates });\n   632→    return;\n   633→  }\n   634→\n   635→  logger.info('subscription update finalized', { subscription: subscription.id, updates });\n   636→  await subscription.update({ ...updates, pending_update: null });\n   637→\n   638→  // update subscription items\n   639→  for (const item of addedItems) {\n   640→    await SubscriptionItem.create({\n   641→      price_id: item.price_id as string,\n   642→      quantity: item.quantity as number,\n   643→      livemode: subscription.livemode,\n   644→      subscription_id: subscription.id,\n   645→      metadata: {},\n   646→    });\n   647→    logger.info('subscription item added on update finalize', { subscription: subscription.id, item: item.id });\n   648→  }\n   649→  for (const item of updatedItems) {\n   650→    await SubscriptionItem.update(pick(item, ['quantity', 'metadata', 'billing_thresholds']), {\n   651→      where: { id: item.id },\n   652→    });\n   653→    logger.info('subscription item updated on update finalize', { subscription: subscription.id, item: item.id });\n   654→  }\n   655→  for (const item of deletedItems) {\n   656→    if (item.clear_usage) {\n   657→      await UsageRecord.destroy({ where: { subscription_item_id: item.id } });\n   658→      logger.info('subscription item usage cleared on update finalize', {\n   659→        subscription: subscription.id,\n   660→        item: item.id,\n   661→      });\n   662→    }\n   663→    await SubscriptionItem.destroy({ where: { id: item.id } });\n   664→    logger.info('subscription item deleted on update finalize', { subscription: subscription.id, item: item.id });\n   665→  }\n   666→\n   667→  // update customer credits\n   668→  if (appliedCredit !== '0') {\n   669→    const creditResult = await customer.decreaseTokenBalance(paymentCurrency.id, appliedCredit);\n   670→    if (invoice) {\n   671→      await invoice.update({\n   672→        starting_token_balance: creditResult.starting,\n   673→        ending_token_balance: creditResult.ending,\n   674→      });\n   675→      logger.info('customer credit applied to invoice after proration', {\n   676→        subscription: subscription.id,\n   677→        appliedCredit,\n   678→        creditResult,\n   679→      });\n   680→    }\n   681→  }\n   682→  if (newCredit !== '0') {\n   683→    const creditResult = await customer.increaseTokenBalance(paymentCurrency.id, newCredit);\n   684→    if (invoice) {\n   685→      await invoice.update({\n   686→        starting_token_balance: creditResult.starting,\n   687→        ending_token_balance: creditResult.ending,\n   688→      });\n   689→      logger.info('subscription proration credit applied to customer', {\n   690→        subscription: subscription.id,\n   691→        newCredit,\n   692→        creditResult,\n   693→      });\n   694→    }\n   695→  }\n   696→\n   697→  // lock for next update\n   698→  const releaseAt = subscription.current_period_end;\n   699→  await Lock.acquire(`${subscription.id}-change-plan`, releaseAt);\n   700→  logger.info('subscription plan change lock acquired on finalize', { subscription: subscription.id, releaseAt });\n   701→}\n   702→\n   703→export async function finalizeStripeSubscriptionUpdate({\n   704→  subscription,\n   705→  items,\n   706→  updates,\n   707→}: {\n   708→  subscription: Subscription;\n   709→  items: any[];\n   710→  updates: any;\n   711→}) {\n   712→  if (isEmpty(updates)) {\n   713→    logger.info('subscription update aborted', { subscription: subscription.id, updates });\n   714→    return;\n   715→  }\n   716→\n   717→  if (subscription.pending_update) {\n   718→    // handle subscription item remove\n   719→    // this must be done before update/create\n   720→    const localItems = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n   721→    const deletedItems = localItems.filter((x) => items.some((y) => y.id === x.id) === false).map((x) => x.id);\n   722→    if (deletedItems.length) {\n   723→      await UsageRecord.destroy({ where: { subscription_item_id: deletedItems } });\n   724→      logger.info('subscription item usage cleared on update', { subscription: subscription.id, deletedItems });\n   725→      await SubscriptionItem.destroy({ where: { id: deletedItems } });\n   726→      logger.info('subscription item deleted on update', { subscription: subscription.id, deletedItems });\n   727→    }\n   728→\n   729→    // handle subscription item update/create\n   730→    for (const item of items) {\n   731→      if (item.id) {\n   732→        // remote item is associated with local item\n   733→        await SubscriptionItem.update(pick(item, ['quantity', 'billing_thresholds']), { where: { id: item.id } });\n   734→        logger.info('subscription item synced on update', { subscription: subscription.id, item });\n   735→      } else {\n   736→        // remote item not associated with local item\n   737→        const created = await SubscriptionItem.create({\n   738→          price_id: item.price_id as string,\n   739→          quantity: (item.quantity || 1) as number,\n   740→          livemode: subscription.livemode,\n   741→          subscription_id: subscription.id,\n   742→          metadata: {\n   743→            stripe_id: item.stripe_id,\n   744→            stripe_subscription_id: item.stripe_subscription_id,\n   745→          },\n   746→        });\n   747→        logger.info('subscription item mirrored on update', { subscription: subscription.id, item });\n   748→        const method = await PaymentMethod.findByPk(subscription.default_payment_method_id);\n   749→        const client = method!.getStripeClient();\n   750→        const result = await client.subscriptionItems.update(item.stripe_id, {\n   751→          metadata: { appPid: env.appPid, id: created.id },\n   752→        });\n   753→        logger.info('subscription item related on mirror', { subscription: subscription.id, item, result });\n   754→      }\n   755→    }\n   756→\n   757→    const releaseAt = subscription.current_period_end;\n   758→    await Lock.acquire(`${subscription.id}-change-plan`, releaseAt);\n   759→    logger.info('subscription plan change lock acquired on finalize', { subscription: subscription.id, releaseAt });\n   760→\n   761→    createEvent('Subscription', 'customer.subscription.upgraded', subscription).catch(console.error);\n   762→  }\n   763→\n   764→  logger.info('subscription update finalized', { subscription: subscription.id, updates, items });\n   765→  await subscription.update({ ...updates, pending_update: null });\n   766→}\n   767→\n   768→export async function onSubscriptionUpdateConnected(subscriptionId: string) {\n   769→  const subscription = await Subscription.findByPk(subscriptionId);\n   770→  if (!subscription) {\n   771→    return;\n   772→  }\n   773→\n   774→  const now = dayjs().unix();\n   775→  const pending = subscription.pending_update;\n   776→  logger.info('subscription update connected', { subscription: subscription.id, pending });\n   777→  if (pending?.updates && pending?.expires_at && pending.expires_at >= now && pending.updates?.latest_invoice_id) {\n   778→    const paymentCurrency = await PaymentCurrency.findByPk(subscription.currency_id);\n   779→    if (!paymentCurrency) {\n   780→      return;\n   781→    }\n   782→\n   783→    const customer = await Customer.findByPk(subscription.customer_id);\n   784→    if (!customer) {\n   785→      return;\n   786→    }\n   787→\n   788→    const invoice = await Invoice.findByPk(pending.updates.latest_invoice_id);\n   789→    if (!invoice) {\n   790→      return;\n   791→    }\n   792→\n   793→    await finalizeSubscriptionUpdate({\n   794→      subscription,\n   795→      customer,\n   796→      invoice,\n   797→      paymentCurrency,\n   798→      appliedCredit: pending.appliedCredit || '0',\n   799→      newCredit: pending.newCredit || '0',\n   800→      addedItems: pending.addedItems || [],\n   801→      deletedItems: pending.deletedItems || [],\n   802→      updatedItems: pending.updatedItems || [],\n   803→      updates: pending.updates,\n   804→    });\n   805→  }\n   806→}\n   807→\n   808→export async function getRemainingStakes(subscriptionIds: string[], subscriptionInitStakes: { [key: string]: string }) {\n   809→  if (!subscriptionIds || subscriptionIds.length === 0) {\n   810→    return '0';\n   811→  }\n   812→  let total = new BN('0');\n   813→  await Promise.all(\n   814→    subscriptionIds.map(async (subscriptionId) => {\n   815→      const refund = await Refund.findOne({\n   816→        where: {\n   817→          subscription_id: subscriptionId,\n   818→          status: {\n   819→            [Op.not]: 'canceled',\n   820→          },\n   821→          type: 'stake_return',\n   822→        },\n   823→      });\n   824→      if (!refund) {\n   825→        // this subscription not return stake\n   826→        total = total.add(new BN(subscriptionInitStakes[subscriptionId] || '0'));\n   827→      }\n   828→    })\n   829→  );\n   830→  return total.toString();\n   831→}\n   832→\n   833→export async function getSubscriptionStakeSlashSetup(\n   834→  subscription: Subscription,\n   835→  address: string,\n   836→  paymentMethod: PaymentMethod,\n   837→  paymentCurrencyId?: string\n   838→) {\n   839→  const lastInvoice = await Invoice.findByPk(subscription.latest_invoice_id);\n   840→  const result = await getSubscriptionRemainingStakeSetup(\n   841→    subscription,\n   842→    address,\n   843→    paymentMethod,\n   844→    'slash',\n   845→    paymentCurrencyId\n   846→  );\n   847→  return {\n   848→    ...result,\n   849→    lastInvoice,\n   850→  };\n   851→}\n   852→\n   853→export async function getSubscriptionStakeReturnSetup(\n   854→  subscription: Subscription,\n   855→  address: string,\n   856→  paymentMethod: PaymentMethod,\n   857→  paymentCurrencyId?: string\n   858→) {\n   859→  const lastInvoice = await Invoice.findByPk(subscription.latest_invoice_id);\n   860→  const result = await getSubscriptionRemainingStakeSetup(\n   861→    subscription,\n   862→    address,\n   863→    paymentMethod,\n   864→    'return',\n   865→    paymentCurrencyId\n   866→  );\n   867→  return {\n   868→    ...result,\n   869→    lastInvoice,\n   870→  };\n   871→}\n   872→\n   873→export async function getSubscriptionRemainingStakeSetup(\n   874→  subscription: Subscription,\n   875→  address: string,\n   876→  paymentMethod: PaymentMethod,\n   877→  action: 'return' | 'slash' = 'return',\n   878→  paymentCurrencyId?: string\n   879→) {\n   880→  const currency = await PaymentCurrency.findByPk(paymentCurrencyId || subscription.currency_id);\n   881→  if (!currency) {\n   882→    return {\n   883→      total: '0',\n   884→      return_amount: '0',\n   885→      sender: '',\n   886→    };\n   887→  }\n   888→\n   889→  const client = paymentMethod.getOcapClient();\n   890→  const { state } = await client.getStakeState({ address });\n   891→  if (!state) {\n   892→    return {\n   893→      total: '0',\n   894→      return_amount: '0',\n   895→      sender: '',\n   896→    };\n   897→  }\n   898→\n   899→  let total = new BN(state.tokens.find((x: any) => x.address === currency.contract)?.value || '0');\n   900→  if (action === 'slash') {\n   901→    // add revoked tokens to total\n   902→    const revoked = state.revokedTokens?.find((x: any) => x.address === currency.contract);\n   903→    total = total.add(new BN(revoked?.value || '0'));\n   904→  }\n   905→  const [summary] = await Invoice.getUncollectibleAmount({\n   906→    subscriptionId: subscription.id,\n   907→    currencyId: currency.id,\n   908→    customerId: subscription.customer_id,\n   909→  });\n   910→  const subscriptionInitStakes = JSON.parse(state.data?.value || '{}');\n   911→  const initStake = subscriptionInitStakes[subscription.id];\n   912→  const uncollectibleAmountBN = new BN(summary?.[currency.id] || '0');\n   913→  if (state.nonce) {\n   914→    const returnStake = total.sub(uncollectibleAmountBN);\n   915→    return {\n   916→      total: total.toString(),\n   917→      return_amount: returnStake.lt(new BN(0)) ? '0' : returnStake.toString(),\n   918→      sender: state.sender,\n   919→    };\n   920→  }\n   921→  const getReturnState = async () => {\n   922→    const initStakeBN = new BN(initStake);\n   923→    const otherSubscriptionIds = Object.keys(subscriptionInitStakes).filter(\n   924→      (k) => k !== 'appId' && k !== subscription.id\n   925→    );\n   926→    const remainingStakes = await getRemainingStakes(otherSubscriptionIds, subscriptionInitStakes);\n   927→    const actualStakeBN = new BN(total).sub(new BN(remainingStakes));\n   928→    const minStakeBN = initStakeBN.lt(actualStakeBN) ? initStakeBN : actualStakeBN;\n   929→    return minStakeBN.sub(uncollectibleAmountBN);\n   930→  };\n   931→  const returnStake = await getReturnState();\n   932→  return {\n   933→    total: initStake,\n   934→    return_amount: returnStake.lt(new BN(0)) ? '0' : returnStake.toString(),\n   935→    sender: state.sender,\n   936→  };\n   937→}\n   938→\n   939→export async function checkRemainingStake(\n   940→  paymentMethod: PaymentMethod,\n   941→  paymentCurrency: PaymentCurrency,\n   942→  address: string,\n   943→  amount: string\n   944→): Promise<{ enough: boolean; staked: any; revoked: any }> {\n   945→  if (paymentMethod?.type !== 'arcblock') {\n   946→    return {\n   947→      enough: false,\n   948→      staked: '0',\n   949→      revoked: '0',\n   950→    };\n   951→  }\n   952→\n   953→  const client = paymentMethod.getOcapClient();\n   954→  const { state } = await client.getStakeState({ address });\n   955→  if (!state) {\n   956→    logger.warn('getStakeState failed in checkRemainingStake', { address });\n   957→    return {\n   958→      enough: false,\n   959→      staked: '0',\n   960→      revoked: '0',\n   961→    };\n   962→  }\n   963→\n   964→  const staked = state.tokens?.find((x: any) => x.address === paymentCurrency.contract);\n   965→  const revoked = state.revokedTokens?.find((x: any) => x.address === paymentCurrency.contract);\n   966→  let total = new BN(0);\n   967→  if (staked) {\n   968→    total = total.add(new BN(staked?.value || '0'));\n   969→  }\n   970→  if (revoked) {\n   971→    total = total.add(new BN(revoked?.value || '0'));\n   972→  }\n   973→\n   974→  return {\n   975→    enough: total.gte(new BN(amount || '0')),\n   976→    staked,\n   977→    revoked,\n   978→  };\n   979→}\n   980→\n   981→// trialing can be customized with currency_id list\n   982→export function getSubscriptionTrialSetup(data: Partial<SubscriptionData>, currencyId: string) {\n   983→  let trialInDays = Number(data?.trial_period_days || 0);\n   984→  let trialEnd = Number(data?.trial_end || 0);\n   985→  const trialCurrencyIds = (data?.trial_currency || '').split(',').map(trim).filter(Boolean);\n   986→  if (trialCurrencyIds.length > 0 && trialCurrencyIds.includes(currencyId) === false) {\n   987→    trialEnd = 0;\n   988→    trialInDays = 0;\n   989→  }\n   990→\n   991→  return {\n   992→    trialInDays,\n   993→    trialEnd,\n   994→  };\n   995→}\n   996→\n   997→export async function getSubscriptionStakeAddress(subscription: Subscription, customerDid: string) {\n   998→  return (\n   999→    subscription.payment_details?.arcblock?.staking?.address ||\n  1000→    (await getCustomerStakeAddress(customerDid, subscription.id))\n  1001→  );\n  1002→}\n  1003→\n  1004→export async function getSubscriptionStakeCancellation(\n  1005→  subscription: Subscription,\n  1006→  paymentMethod: PaymentMethod,\n  1007→  paymentCurrency: PaymentCurrency\n  1008→): Promise<{\n  1009→  stakeReturn: boolean;\n  1010→  stakeSlash: boolean;\n  1011→  stakeEnough: boolean;\n  1012→  hasStake: boolean;\n  1013→}> {\n  1014→  const cancellation = {\n  1015→    stakeReturn: subscription.cancelation_details?.return_stake === true,\n  1016→    stakeSlash: subscription.cancelation_details?.slash_stake === true,\n  1017→    stakeEnough: false,\n  1018→    hasStake: !!subscription?.payment_details?.arcblock?.staking?.tx_hash,\n  1019→  };\n  1020→  const customerCancelRequest = subscription.cancelation_details?.reason === 'cancellation_requested';\n  1021→  if (customerCancelRequest) {\n  1022→    // cancel request from customer\n  1023→    const address = subscription?.payment_details?.arcblock?.staking?.address;\n  1024→    let stakeEnough;\n  1025→    if (address && paymentMethod) {\n  1026→      const stakeReturnResult = await getSubscriptionStakeReturnSetup(subscription, address, paymentMethod);\n  1027→      stakeEnough = await checkRemainingStake(paymentMethod, paymentCurrency, address, stakeReturnResult.return_amount);\n  1028→      cancellation.stakeEnough = stakeEnough?.enough;\n  1029→    }\n  1030→  }\n  1031→  return cancellation;\n  1032→}\n  1033→\n  1034→export async function getSubscriptionStakeAmountSetup(\n  1035→  subscription: Subscription,\n  1036→  paymentMethod: PaymentMethod,\n  1037→  stakingTxHash?: string\n  1038→) {\n  1039→  if (paymentMethod.type !== 'arcblock') {\n  1040→    return null;\n  1041→  }\n  1042→  const txHash = stakingTxHash || subscription?.payment_details?.arcblock?.staking?.tx_hash;\n  1043→  if (!txHash) {\n  1044→    return null;\n  1045→  }\n  1046→  const client = paymentMethod.getOcapClient();\n  1047→  const { info } = await client.getTx({ hash: txHash });\n  1048→  if (!info) {\n  1049→    return null;\n  1050→  }\n  1051→  // @ts-ignore\n  1052→  const inputs = info?.tx?.itxJson?.inputs || [];\n  1053→  if (!inputs || inputs.length === 0) {\n  1054→    logger.info('getSubscriptionStakeAmountSetup failed, no inputs', { txHash, info });\n  1055→    return null;\n  1056→  }\n  1057→  const amountRes: { [key: string]: string } = {};\n  1058→  // calculate stake amount for each address\n  1059→  inputs.forEach((input: any) => {\n  1060→    const { tokens } = input;\n  1061→    tokens.forEach((token: any) => {\n  1062→      const { address, value } = token;\n  1063→      if (amountRes[address]) {\n  1064→        amountRes[address] = new BN(amountRes[address]).add(new BN(value)).toString();\n  1065→      } else {\n  1066→        amountRes[address] = new BN(value).toString();\n  1067→      }\n  1068→    });\n  1069→  });\n  1070→  logger.info('get subscription stake amount setup success', { txHash, amountRes });\n  1071→  return amountRes;\n  1072→}\n  1073→\n  1074→// check if usage report is empty\n  1075→export async function checkUsageReportEmpty(\n  1076→  subscription: Subscription,\n  1077→  usageReportStart: number,\n  1078→  usageReportEnd: number\n  1079→) {\n  1080→  const subscriptionItems = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n  1081→  const expandedItems = await Price.expand(\n  1082→    subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n  1083→    { product: true }\n  1084→  );\n  1085→  const meteredItems = expandedItems.filter((x: any) => x?.price?.recurring?.usage_type === 'metered');\n  1086→  if (meteredItems.length === 0) {\n  1087→    return false;\n  1088→  }\n  1089→  const usageReportEmpty = await Promise.all(\n  1090→    meteredItems.map(async (x: any) => {\n  1091→      const usageRecords = await UsageRecord.findAll({\n  1092→        where: {\n  1093→          subscription_item_id: x.id,\n  1094→          billed: false,\n  1095→          timestamp: {\n  1096→            [Op.gt]: usageReportStart,\n  1097→            [Op.lte]: usageReportEnd,\n  1098→          },\n  1099→        },\n  1100→      });\n  1101→      return usageRecords.length === 0;\n  1102→    })\n  1103→  );\n  1104→  return usageReportEmpty.every(Boolean);\n  1105→}\n  1106→\n  1107→export function getSubscriptionPaymentAddress(subscription: Subscription, paymentMethodType: string) {\n  1108→  return (\n  1109→    // @ts-ignore\n  1110→    subscription.payment_details?.[paymentMethodType]?.payer ||\n  1111→    // @ts-ignore\n  1112→    subscription.payment_settings?.payment_method_options?.[paymentMethodType]?.payer\n  1113→  );\n  1114→}\n  1115→export async function getPaymentAmountForCycleSubscription(\n  1116→  subscription: Subscription,\n  1117→  paymentCurrency: PaymentCurrency\n  1118→) {\n  1119→  const subscriptionItems = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n  1120→  if (subscriptionItems.length === 0) {\n  1121→    logger.info('subscription items not found in getPaymentAmountForCycleSubscription', {\n  1122→      subscription: subscription.id,\n  1123→    });\n  1124→    return 0;\n  1125→  }\n  1126→  let expandedItems = await Price.expand(\n  1127→    subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n  1128→    { product: true }\n  1129→  );\n  1130→  if (expandedItems.length === 0) {\n  1131→    logger.info('expanded items not found in getPaymentAmountForCycleSubscription', {\n  1132→      subscription: subscription.id,\n  1133→    });\n  1134→    return 0;\n  1135→  }\n  1136→  const previousPeriodEnd =\n  1137→    subscription.status === 'trialing' ? subscription.trial_end : subscription.current_period_end;\n  1138→  const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, previousPeriodEnd as number);\n  1139→  // get usage summaries for this billing cycle\n  1140→  expandedItems = await Promise.all(\n  1141→    expandedItems.map(async (x: any) => {\n  1142→      // For metered billing, we need to get usage summary for this billing cycle\n  1143→      // @link https://stripe.com/docs/products-prices/pricing-models#usage-types\n  1144→      if (x.price.recurring?.usage_type === 'metered') {\n  1145→        const rawQuantity = await UsageRecord.getSummary({\n  1146→          id: x.id,\n  1147→          start: setup.period.start - setup.cycle / 1000,\n  1148→          end: setup.period.end - setup.cycle / 1000,\n  1149→          method: x.price.recurring?.aggregate_usage,\n  1150→          dryRun: true,\n  1151→        });\n  1152→        x.quantity = x.price.transformQuantity(rawQuantity);\n  1153→        // record raw quantity in metadata\n  1154→        x.metadata = x.metadata || {};\n  1155→        x.metadata.quantity = rawQuantity;\n  1156→      }\n  1157→      return x;\n  1158→    })\n  1159→  );\n  1160→  if (expandedItems.length > 0) {\n  1161→    const amount = getSubscriptionCycleAmount(expandedItems, paymentCurrency.id);\n  1162→    return +fromUnitToToken(amount?.total || '0', paymentCurrency.decimal);\n  1163→  }\n  1164→  return 0;\n  1165→}\n  1166→\n  1167→export async function getEstimatedPaymentAmountForCycleSubscription(\n  1168→  subscription: Subscription,\n  1169→  paymentCurrency: PaymentCurrency\n  1170→): Promise<{ amount: number; estimatedByRate: boolean }> {\n  1171→  const subscriptionItems = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n  1172→  if (subscriptionItems.length === 0) {\n  1173→    logger.info('subscription items not found in getEstimatedPaymentAmountForCycleSubscription', {\n  1174→      subscription: subscription.id,\n  1175→    });\n  1176→    return { amount: 0, estimatedByRate: false };\n  1177→  }\n  1178→  let expandedItems = await Price.expand(\n  1179→    subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n  1180→    { product: true }\n  1181→  );\n  1182→  if (expandedItems.length === 0) {\n  1183→    logger.info('expanded items not found in getEstimatedPaymentAmountForCycleSubscription', {\n  1184→      subscription: subscription.id,\n  1185→    });\n  1186→    return { amount: 0, estimatedByRate: false };\n  1187→  }\n  1188→  const previousPeriodEnd =\n  1189→    subscription.status === 'trialing' ? subscription.trial_end : subscription.current_period_end;\n  1190→  const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, previousPeriodEnd as number);\n  1191→  expandedItems = await Promise.all(\n  1192→    expandedItems.map(async (x: any) => {\n  1193→      if (x.price.recurring?.usage_type === 'metered') {\n  1194→        const rawQuantity = await UsageRecord.getSummary({\n  1195→          id: x.id,\n  1196→          start: setup.period.start - setup.cycle / 1000,\n  1197→          end: setup.period.end - setup.cycle / 1000,\n  1198→          method: x.price.recurring?.aggregate_usage,\n  1199→          dryRun: true,\n  1200→        });\n  1201→        x.quantity = x.price.transformQuantity(rawQuantity);\n  1202→        x.metadata = x.metadata || {};\n  1203→        x.metadata.quantity = rawQuantity;\n  1204→      }\n  1205→      return x;\n  1206→    })\n  1207→  );\n  1208→  if (expandedItems.length === 0) {\n  1209→    return { amount: 0, estimatedByRate: false };\n  1210→  }\n  1211→\n  1212→  let estimatedByRate = false;\n  1213→  const hasDynamicItems = expandedItems.some((item: any) => item.price?.pricing_type === 'dynamic');\n  1214→  if (hasDynamicItems) {\n  1215→    try {\n  1216→      const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  1217→      if (!paymentMethod) {\n  1218→        throw new Error(`PaymentMethod not found in ${subscription.id}`);\n  1219→      }\n  1220→      const exchangeRateService = getExchangeRateService();\n  1221→      const rateSymbol = getExchangeRateSymbol(paymentCurrency.symbol, paymentMethod.type as any);\n  1222→      const rateResult = await exchangeRateService.getRate(rateSymbol);\n  1223→      const USD_DECIMALS = 8;\n  1224→      const rateBN = fromTokenToUnit(trimDecimals(rateResult.rate, USD_DECIMALS), USD_DECIMALS);\n  1225→\n  1226→      expandedItems = expandedItems.map((item: any) => {\n  1227→        const price = item.price;\n  1228→        if (price?.pricing_type !== 'dynamic') {\n  1229→          return item;\n  1230→        }\n  1231→        if (!price.base_amount) {\n  1232→          logger.warn('Dynamic price missing base_amount for estimate', {\n  1233→            subscriptionId: subscription.id,\n  1234→            priceId: price.id,\n  1235→          });\n  1236→          return item;\n  1237→        }\n  1238→\n  1239→        const baseAmountBN = fromTokenToUnit(trimDecimals(price.base_amount, USD_DECIMALS), USD_DECIMALS);\n  1240→        const quantityBN = new BN(item.quantity || 0);\n  1241→        const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n  1242→        const numerator = totalBaseAmountBN.mul(new BN(10).pow(new BN(paymentCurrency.decimal)));\n  1243→        const quotedAmountRaw = numerator.add(rateBN).sub(new BN(1)).div(rateBN);\n  1244→        const quotedAmount = limitTokenPrecision(quotedAmountRaw, paymentCurrency.decimal, 6);\n  1245→        estimatedByRate = true;\n  1246→        return {\n  1247→          ...item,\n  1248→          custom_amount: quotedAmount.toString(),\n  1249→          quoted_amount: quotedAmount.toString(),\n  1250→        };\n  1251→      });\n  1252→    } catch (error: any) {\n  1253→      logger.warn('Failed to estimate dynamic pricing amount for subscription', {\n  1254→        subscriptionId: subscription.id,\n  1255→        error: error?.message || error,\n  1256→      });\n  1257→    }\n  1258→  }\n  1259→\n  1260→  const amount = getSubscriptionCycleAmount(expandedItems, paymentCurrency.id);\n  1261→  return { amount: +fromUnitToToken(amount?.total || '0', paymentCurrency.decimal), estimatedByRate };\n  1262→}\n  1263→\n  1264→// check if subscription overdraft protection is enabled\n  1265→export async function isSubscriptionOverdraftProtectionEnabled(subscription: Subscription, paymentCurrencyId?: string) {\n  1266→  try {\n  1267→    const paymentCurrency = await PaymentCurrency.findByPk(paymentCurrencyId || subscription.currency_id);\n  1268→    if (!paymentCurrency) {\n  1269→      throw new Error(`PaymentCurrency not found in ${subscription.id}`);\n  1270→    }\n  1271→    const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  1272→    if (!paymentMethod) {\n  1273→      throw new Error(`PaymentMethod not found in ${subscription.id}`);\n  1274→    }\n  1275→\n  1276→    if (paymentMethod.type !== 'arcblock') {\n  1277→      throw new Error(`PaymentMethod type not supported in ${subscription.id}`);\n  1278→    }\n  1279→    if (!subscription.overdraft_protection) {\n  1280→      return {\n  1281→        enabled: false,\n  1282→        remaining: '0',\n  1283→        used: '0',\n  1284→        shouldPay: '0',\n  1285→        unused: '0',\n  1286→        revokedStake: '0',\n  1287→      };\n  1288→    }\n  1289→    const client = paymentMethod.getOcapClient();\n  1290→    const address = subscription?.overdraft_protection?.payment_details?.arcblock?.staking?.address;\n  1291→    if (!address) {\n  1292→      logger.info('Seems you have no staking for overdraft protection', { subscription: subscription.id });\n  1293→      return {\n  1294→        enabled: false,\n  1295→        remaining: '0',\n  1296→        used: '0',\n  1297→        shouldPay: '0',\n  1298→        unused: '0',\n  1299→        revokedStake: '0',\n  1300→      };\n  1301→    }\n  1302→    const { state } = await client.getStakeState({ address });\n  1303→    if (!state) {\n  1304→      throw new Error(`Stake state not found in ${subscription.id}`);\n  1305→    }\n  1306→    const data = JSON.parse(state.data?.value || '{}');\n  1307→    if (!data[subscription.id] && !state.nonce) {\n  1308→      throw new Error(`No staking for subscription: ${subscription.id}, address: ${address}`);\n  1309→    }\n  1310→\n  1311→    // calculate remaining stake, need to subtract refunding amount\n  1312→    let remainingStake = new BN(state.tokens.find((x: any) => x.address === paymentCurrency.contract)?.value || '0');\n  1313→    const revokedStake = new BN(\n  1314→      state.revokedTokens?.find((x: any) => x.address === paymentCurrency.contract)?.value || '0'\n  1315→    );\n  1316→\n  1317→    const refunds = await Refund.findAll({\n  1318→      where: {\n  1319→        subscription_id: subscription.id,\n  1320→        type: 'stake_return',\n  1321→        status: {\n  1322→          [Op.notIn]: ['canceled', 'succeeded'],\n  1323→        },\n  1324→        currency_id: paymentCurrency.id,\n  1325→      },\n  1326→      include: [{ model: Invoice, as: 'invoice' }],\n  1327→    });\n  1328→    const refundAmount = refunds\n  1329→      .filter((x: any) => x.invoice?.billing_reason === 'stake_overdraft_protection')\n  1330→      .reduce((acc, x) => acc.add(new BN(x.amount)), new BN(0));\n  1331→    remainingStake = remainingStake.sub(refundAmount);\n  1332→\n  1333→    const invoices = await Invoice.findAll({\n  1334→      where: {\n  1335→        subscription_id: subscription.id,\n  1336→        status: ['open', 'uncollectible'],\n  1337→        currency_id: paymentCurrency.id,\n  1338→      },\n  1339→    });\n  1340→    let usedAmount = new BN(0);\n  1341→    let dueAmount = new BN(0);\n  1342→    invoices.forEach((invoice) => {\n  1343→      usedAmount = usedAmount.add(new BN(invoice.amount_remaining));\n  1344→      if (invoice.billing_reason !== 'overdraft_protection') {\n  1345→        dueAmount = dueAmount.add(new BN(invoice.amount_remaining));\n  1346→      }\n  1347→    });\n  1348→    return {\n  1349→      enabled: subscription.overdraft_protection.enabled && usedAmount.lte(remainingStake),\n  1350→      remaining: remainingStake.toString(),\n  1351→      used: usedAmount.toString(),\n  1352→      shouldPay: dueAmount.toString(),\n  1353→      revoked: revokedStake.toString(),\n  1354→      unused: remainingStake.gte(usedAmount) ? remainingStake.sub(usedAmount).toString() : '0',\n  1355→    };\n  1356→  } catch (error) {\n  1357→    logger.error('error in isSubscriptionOverdraftProtectionEnabled', { error });\n  1358→    return {\n  1359→      enabled: false,\n  1360→      remaining: '0',\n  1361→      used: '0',\n  1362→      unused: '0',\n  1363→      shouldPay: '0',\n  1364→      revokedStake: '0',\n  1365→    };\n  1366→  }\n  1367→}\n  1368→\n  1369→// return remaining overdraft protection stake to customer\n  1370→export async function returnOverdraftProtectionStake(\n  1371→  subscription: Subscription,\n  1372→  paymentCurrencyId?: string,\n  1373→  refundReason?: string\n  1374→) {\n  1375→  // return remaining stake to customer\n  1376→  logger.info('returnOverdraftProtectionStake', { subscription: subscription.id, paymentCurrencyId });\n  1377→  try {\n  1378→    await slashOverdraftProtectionStake(subscription, paymentCurrencyId);\n  1379→    const { unused } = await isSubscriptionOverdraftProtectionEnabled(subscription, paymentCurrencyId);\n  1380→    if (unused !== '0') {\n  1381→      // return unused stake to customer\n  1382→      const address = subscription?.overdraft_protection?.payment_details?.arcblock?.staking?.address;\n  1383→      if (!address) {\n  1384→        logger.info('Stake return skipped due to missing staking address', { subscription: subscription.id });\n  1385→        return;\n  1386→      }\n  1387→      const invoice = await Invoice.findOne({\n  1388→        where: {\n  1389→          subscription_id: subscription.id,\n  1390→          billing_reason: 'stake_overdraft_protection',\n  1391→          currency_id: paymentCurrencyId || subscription.currency_id,\n  1392→          status: 'paid',\n  1393→        },\n  1394→        order: [['created_at', 'DESC']],\n  1395→      });\n  1396→      const item = await Refund.create({\n  1397→        type: 'stake_return',\n  1398→        amount: unused,\n  1399→        description: 'stake_return_for_subscription_guard',\n  1400→        status: 'pending',\n  1401→        reason: refundReason || 'requested_by_admin',\n  1402→        subscription_id: subscription.id,\n  1403→        currency_id: paymentCurrencyId || subscription.currency_id,\n  1404→        livemode: subscription.livemode,\n  1405→        customer_id: subscription.customer_id,\n  1406→        invoice_id: invoice?.id,\n  1407→        payment_intent_id: invoice?.payment_intent_id || '',\n  1408→        payment_method_id: subscription.overdraft_protection?.payment_method_id || '',\n  1409→        starting_balance: unused,\n  1410→        ending_balance: '0',\n  1411→        attempt_count: 0,\n  1412→        attempted: false,\n  1413→        next_attempt: 0,\n  1414→        last_attempt_error: null,\n  1415→        starting_token_balance: {},\n  1416→        ending_token_balance: {},\n  1417→        payment_details: {\n  1418→          // @ts-ignore\n  1419→          arcblock: {\n  1420→            receiver:\n  1421→              subscription?.overdraft_protection?.payment_details?.arcblock?.payer ||\n  1422→              getSubscriptionPaymentAddress(subscription, 'arcblock'),\n  1423→            staking: {\n  1424→              address: address || '',\n  1425→              tx_hash: '',\n  1426→            },\n  1427→          },\n  1428→        },\n  1429→      });\n  1430→      logger.info('returnOverdraftProtectionStake Refund created', { item });\n  1431→    }\n  1432→  } catch (error) {\n  1433→    logger.error('returnOverdraftProtectionStake failed', { error });\n  1434→    throw error;\n  1435→  }\n  1436→}\n  1437→\n  1438→// slash overdraft protection stake\n  1439→export async function slashOverdraftProtectionStake(subscription: Subscription, paymentCurrencyId?: string) {\n  1440→  const lock = getLock(\n  1441→    `slash_overdraft_protection_stake_${subscription.id}-${paymentCurrencyId || subscription.currency_id}`\n  1442→  );\n  1443→  logger.info('slashOverdraftProtectionStake', { subscription: subscription.id, paymentCurrencyId });\n  1444→  try {\n  1445→    await lock.acquire();\n  1446→    if (!subscription.overdraft_protection) {\n  1447→      logger.info('slashOverdraftProtectionStake skipped due to missing overdraft protection', {\n  1448→        subscription: subscription.id,\n  1449→      });\n  1450→      return;\n  1451→    }\n  1452→\n  1453→    const paymentCurrency = await PaymentCurrency.findByPk(paymentCurrencyId || subscription.currency_id);\n  1454→    if (!paymentCurrency) {\n  1455→      throw new Error(`PaymentCurrency not found in ${subscription.id}`);\n  1456→    }\n  1457→\n  1458→    const { used, remaining, revoked } = await isSubscriptionOverdraftProtectionEnabled(\n  1459→      subscription,\n  1460→      paymentCurrency.id\n  1461→    );\n  1462→    const remainingStake = new BN(remaining).add(new BN(revoked)).toString();\n  1463→    if (used === '0') {\n  1464→      logger.info('slashOverdraftProtectionStake skipped due to no unpaid invoices', {\n  1465→        subscription: subscription.id,\n  1466→        paymentCurrencyId: paymentCurrency.id,\n  1467→      });\n  1468→      return;\n  1469→    }\n  1470→\n  1471→    if (remainingStake === '0') {\n  1472→      logger.info('slashOverdraftProtectionStake skipped due to no remaining stake', {\n  1473→        subscription: subscription.id,\n  1474→        paymentCurrencyId: paymentCurrency.id,\n  1475→      });\n  1476→      return;\n  1477→    }\n  1478→\n  1479→    const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n  1480→    if (!paymentMethod || paymentMethod.type !== 'arcblock') {\n  1481→      throw new Error(`PaymentMethod type not supported in ${subscription.id}`);\n  1482→    }\n  1483→\n  1484→    const address = subscription?.overdraft_protection?.payment_details?.arcblock?.staking?.address;\n  1485→\n  1486→    if (!address) {\n  1487→      // no staking address\n  1488→      logger.info('Stake slashing skipped due to missing staking address', { subscription: subscription.id });\n  1489→      return;\n  1490→    }\n  1491→\n  1492→    const client = paymentMethod.getOcapClient();\n  1493→    const { state } = await client.getStakeState({ address });\n  1494→\n  1495→    if (!state || !state.data?.value) {\n  1496→      throw new Error(\n  1497→        `Stake slashing aborted due to missing staking state for subscription: ${subscription.id}, address: ${address}`\n  1498→      );\n  1499→    }\n  1500→\n  1501→    const data = JSON.parse(state.data.value || '{}');\n  1502→    if (!data[subscription.id] && !state.nonce) {\n  1503→      throw new Error(\n  1504→        `Stake slashing aborted because no staking for subscription: ${subscription.id}, address: ${address}`\n  1505→      );\n  1506→    }\n  1507→\n  1508→    const invoices = await Invoice.findAll({\n  1509→      where: {\n  1510→        subscription_id: subscription.id,\n  1511→        status: ['open', 'uncollectible'],\n  1512→        currency_id: paymentCurrency.id,\n  1513→      },\n  1514→      order: [['created_at', 'ASC']],\n  1515→    });\n  1516→\n  1517→    let slashAmount = new BN(0);\n  1518→    const slashInvoices: Invoice[] = [];\n  1519→    for (const invoice of invoices) {\n  1520→      if (!invoice.payment_intent_id) {\n  1521→        await emitAsync(\n  1522→          'invoice.queued',\n  1523→          invoice.id,\n  1524→          { invoiceId: invoice.id, retryOnError: false, justCreate: true },\n  1525→          { sync: true }\n  1526→        );\n  1527→        await invoice.reload();\n  1528→      }\n  1529→\n  1530→      const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n  1531→      if (paymentIntent) {\n  1532→        const isAlreadyPaid = paymentIntent.status === 'succeeded' && invoice.status === 'paid';\n  1533→\n  1534→        if (!isAlreadyPaid) {\n  1535→          const tmp = slashAmount.add(new BN(invoice.amount_remaining));\n  1536→          if (tmp.lte(new BN(remainingStake))) {\n  1537→            slashAmount = tmp;\n  1538→            slashInvoices.push(invoice);\n  1539→          } else {\n  1540→            break;\n  1541→          }\n  1542→        } else {\n  1543→          logger.info('PaymentIntent and Invoice already updated', {\n  1544→            subscription: subscription.id,\n  1545→            paymentIntent: paymentIntent.id,\n  1546→            invoice: invoice.id,\n  1547→          });\n  1548→        }\n  1549→      }\n  1550→    }\n  1551→\n  1552→    const slashedInvoiceIds: string[] = [];\n  1553→    const processInvoice = async (invoice: Invoice): Promise<void> => {\n  1554→      const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n  1555→      if (!paymentIntent || (paymentIntent.status === 'succeeded' && invoice.status === 'paid')) return;\n  1556→\n  1557→      try {\n  1558→        const stakeEnough = await checkRemainingStake(\n  1559→          paymentMethod,\n  1560→          paymentCurrency,\n  1561→          address,\n  1562→          invoice.amount_remaining\n  1563→        );\n  1564→        if (!stakeEnough.enough) {\n  1565→          throw new Error(`Stake slashing aborted because no enough staking for invoice: ${invoice.id}`);\n  1566→        }\n  1567→        // do the slash\n  1568→        const signed = await client.signSlashStakeTx({\n  1569→          tx: {\n  1570→            itx: {\n  1571→              address,\n  1572→              outputs: [\n  1573→                {\n  1574→                  owner: wallet.address,\n  1575→                  tokens: [{ address: paymentCurrency.contract, value: invoice.amount_remaining }],\n  1576→                },\n  1577→              ],\n  1578→              message: 'overdraft_exceeded',\n  1579→              data: {\n  1580→                typeUrl: 'json',\n  1581→                // @ts-ignore\n  1582→                value: {\n  1583→                  appId: wallet.address,\n  1584→                  reason: 'overdraft_exceeded',\n  1585→                  subscriptionId: subscription.id,\n  1586→                  invoiceId: invoice.id,\n  1587→                  paymentIntentId: paymentIntent.id,\n  1588→                },\n  1589→              },\n  1590→            },\n  1591→          },\n  1592→          wallet,\n  1593→        });\n  1594→        // @ts-ignore\n  1595→        const { buffer } = await client.encodeSlashStakeTx({ tx: signed });\n  1596→        // @ts-ignore\n  1597→        const txHash = await client.sendSlashStakeTx({ tx: signed, wallet }, await getGasPayerExtra(buffer));\n  1598→\n  1599→        await paymentIntent.update({\n  1600→          status: 'succeeded',\n  1601→          amount_received: invoice.amount_remaining,\n  1602→          capture_method: 'manual',\n  1603→          last_payment_error: null,\n  1604→          payment_details: {\n  1605→            arcblock: {\n  1606→              tx_hash: txHash,\n  1607→              payer:\n  1608→                subscription.overdraft_protection?.payment_details?.arcblock?.payer ||\n  1609→                getSubscriptionPaymentAddress(subscription, 'arcblock'),\n  1610→              type: 'slash',\n  1611→            },\n  1612→          },\n  1613→        });\n  1614→        logger.info('PaymentIntent updated after stake slash', {\n  1615→          subscription: subscription.id,\n  1616→          paymentIntent: paymentIntent.id,\n  1617→          status: 'succeeded',\n  1618→        });\n  1619→\n  1620→        await invoice.update({\n  1621→          status: 'paid',\n  1622→          paid: true,\n  1623→          amount_paid: invoice.amount_remaining,\n  1624→          amount_remaining: '0',\n  1625→          attempted: true,\n  1626→          attempt_count: invoice.attempt_count + 1,\n  1627→          status_transitions: { ...invoice.status_transitions, paid_at: dayjs().unix() },\n  1628→        });\n  1629→        logger.info('Invoice updated after stake slash', {\n  1630→          subscription: subscription.id,\n  1631→          invoice: invoice.id,\n  1632→          status: 'paid',\n  1633→        });\n  1634→        slashedInvoiceIds.push(invoice.id);\n  1635→      } catch (updateError) {\n  1636→        logger.error('stake slash failed', {\n  1637→          subscription: subscription.id,\n  1638→          invoice: invoice.id,\n  1639→          error: updateError,\n  1640→        });\n  1641→        throw updateError;\n  1642→      }\n  1643→    };\n  1644→\n  1645→    await Promise.all(slashInvoices.map(processInvoice));\n  1646→    logger.info(`${slashedInvoiceIds.length} invoices updated after stake slash`, {\n  1647→      subscription: subscription.id,\n  1648→      invoices: slashedInvoiceIds,\n  1649→      slashAmount: slashAmount.toString(),\n  1650→    });\n  1651→  } catch (error) {\n  1652→    logger.error('Error in slashOverdraftProtectionStake', { error });\n  1653→    throw error;\n  1654→  } finally {\n  1655→    lock.release();\n  1656→  }\n  1657→}\n  1658→\n  1659→export async function getSubscriptionUnpaidInvoicesCount(subscription: Subscription) {\n  1660→  try {\n  1661→    const count = await Invoice.count({\n  1662→      where: {\n  1663→        subscription_id: subscription.id,\n  1664→        status: ['open', 'uncollectible'],\n  1665→        billing_reason: {\n  1666→          [Op.notIn]: ['overdraft_protection'],\n  1667→        },\n  1668→      },\n  1669→    });\n  1670→    return count;\n  1671→  } catch (error) {\n  1672→    logger.error('getSubscriptionUnpaidInvoicesCount failed', { error });\n  1673→    return 0;\n  1674→  }\n  1675→}\n  1676→\n  1677→/**\n  1678→ * Calculate recommended recharge amount for subscription cycles\n  1679→ * @param subscriptions List of subscriptions\n  1680→ * @param currencyId Currency ID\n  1681→ * @returns {amount: string, cycle: number, desc: string, interval: string} Recommended amount and cycle info\n  1682→ */\n  1683→export function calculateRecommendedRechargeAmount(subscriptions: any[], currencyId: string) {\n  1684→  if (!subscriptions || subscriptions.length === 0) {\n  1685→    return { amount: '0', cycle: 0, desc: 'no subscription', interval: '' };\n  1686→  }\n  1687→\n  1688→  type IntervalType = 'hour' | 'day' | 'month' | 'year';\n  1689→\n  1690→  // Group subscriptions by billing interval\n  1691→  const intervalSubscriptions: Record<IntervalType, any[]> = {\n  1692→    hour: [],\n  1693→    day: [],\n  1694→    month: [],\n  1695→    year: [],\n  1696→  };\n  1697→\n  1698→  // Classify subscriptions by interval\n  1699→  subscriptions.forEach((subscription) => {\n  1700→    if (!subscription.items?.length) return;\n  1701→\n  1702→    subscription.items.forEach((item: any) => {\n  1703→      const { price } = item;\n  1704→      if (price?.type === 'recurring' && price.recurring?.interval) {\n  1705→        const interval = price.recurring.interval as IntervalType;\n  1706→        if (Object.keys(intervalSubscriptions).includes(interval)) {\n  1707→          intervalSubscriptions[interval].push({ subscription, item, price });\n  1708→        }\n  1709→      }\n  1710→    });\n  1711→  });\n  1712→\n  1713→  const hasHourly = intervalSubscriptions.hour.length > 0;\n  1714→  const hasDaily = intervalSubscriptions.day.length > 0;\n  1715→  const hasMonthly = intervalSubscriptions.month.length > 0;\n  1716→  const hasYearly = intervalSubscriptions.year.length > 0;\n  1717→\n  1718→  // Determine recommended cycle based on subscription intervals\n  1719→  let recommendedInterval = '';\n  1720→  let cycleInSeconds = 0;\n  1721→  let desc = '';\n  1722→\n  1723→  if (hasMonthly) {\n  1724→    recommendedInterval = 'month';\n  1725→    cycleInSeconds = 30 * 24 * 60 * 60;\n  1726→    desc = 'monthly';\n  1727→  } else if ((hasHourly || hasDaily) && !hasYearly) {\n  1728→    recommendedInterval = 'week';\n  1729→    cycleInSeconds = 7 * 24 * 60 * 60;\n  1730→    desc = 'weekly';\n  1731→  } else if ((hasDaily || hasHourly) && hasYearly) {\n  1732→    recommendedInterval = 'month';\n  1733→    cycleInSeconds = 30 * 24 * 60 * 60;\n  1734→    desc = 'monthly';\n  1735→  } else if (hasYearly) {\n  1736→    recommendedInterval = 'year';\n  1737→    cycleInSeconds = 365 * 24 * 60 * 60;\n  1738→    desc = 'yearly';\n  1739→  }\n  1740→\n  1741→  let totalAmount = new BN(0);\n  1742→\n  1743→  // Calculate amount based on recommended cycle\n  1744→  subscriptions.forEach((subscription) => {\n  1745→    if (!subscription.items?.length) return;\n  1746→\n  1747→    subscription.items.forEach((item: any) => {\n  1748→      const { price } = item;\n  1749→      if (!price) return;\n  1750→\n  1751→      const unitAmount = getPriceUintAmountByCurrency(price, currencyId);\n  1752→      const quantity = item.quantity || 1;\n  1753→      let itemAmount = new BN(unitAmount).mul(new BN(quantity));\n  1754→\n  1755→      if (price.type === 'recurring' && price.recurring?.interval) {\n  1756→        const { interval } = price.recurring;\n  1757→        const intervalCount = price.recurring.interval_count || 1;\n  1758→\n  1759→        // Apply period conversion calculation\n  1760→        if (recommendedInterval === 'month') {\n  1761→          if (interval === 'hour') {\n  1762→            itemAmount = itemAmount.mul(new BN(720)).div(new BN(intervalCount));\n  1763→          } else if (interval === 'day') {\n  1764→            itemAmount = itemAmount.mul(new BN(30)).div(new BN(intervalCount));\n  1765→          } else if (interval === 'month') {\n  1766→            itemAmount = itemAmount.div(new BN(intervalCount));\n  1767→          } else if (interval === 'year') {\n  1768→            itemAmount = itemAmount.div(new BN(12 * intervalCount));\n  1769→          }\n  1770→        } else if (recommendedInterval === 'week') {\n  1771→          if (interval === 'hour') {\n  1772→            itemAmount = itemAmount.mul(new BN(168)).div(new BN(intervalCount));\n  1773→          } else if (interval === 'day') {\n  1774→            itemAmount = itemAmount.mul(new BN(7)).div(new BN(intervalCount));\n  1775→          }\n  1776→        }\n  1777→\n  1778→        totalAmount = totalAmount.add(itemAmount);\n  1779→      } else if (price.type === 'one_time') {\n  1780→        totalAmount = totalAmount.add(itemAmount);\n  1781→      }\n  1782→    });\n  1783→  });\n  1784→\n  1785→  return {\n  1786→    amount: totalAmount.toString(),\n  1787→    cycle: cycleInSeconds,\n  1788→    desc,\n  1789→    interval: recommendedInterval,\n  1790→  };\n  1791→}\n  1792→\n  1793→export async function getMeterPriceIdsFromSubscription(subscription: Subscription): Promise<string[]> {\n  1794→  const subscriptionItems = (await SubscriptionItem.findAll({\n  1795→    where: { subscription_id: subscription.id },\n  1796→    include: [{ model: Price, as: 'price' }],\n  1797→  })) as (SubscriptionItem & { price: Price })[];\n  1798→\n  1799→  const meterItems = subscriptionItems.filter((x) => x.price.recurring?.meter_id);\n  1800→  return meterItems.map((m) => m.price.id);\n  1801→}\n  1802→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"1bfc443c-90fa-41d8-abbb-ca3206dfe093","timestamp":"2026-01-09T01:49:22.681Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/subscription.ts","content":"/* eslint-disable no-await-in-loop */\nimport component from '@blocklet/sdk/lib/component';\nimport { BN, fromTokenToUnit, fromUnitToToken } from '@ocap/util';\nimport isEmpty from 'lodash/isEmpty';\nimport trim from 'lodash/trim';\nimport pick from 'lodash/pick';\nimport type { LiteralUnion } from 'type-fest';\nimport { withQuery } from 'ufo';\n\nimport { Op } from 'sequelize';\nimport {\n  Customer,\n  Invoice,\n  InvoiceItem,\n  Lock,\n  PaymentCurrency,\n  PaymentIntent,\n  PaymentMethod,\n  Price,\n  PriceRecurring,\n  Refund,\n  Subscription,\n  SubscriptionData,\n  SubscriptionItem,\n  SubscriptionUpdateItem,\n  TLineItemExpanded,\n  UsageRecord,\n} from '../store/models';\nimport { createEvent } from './audit';\nimport dayjs from './dayjs';\nimport env from './env';\nimport logger from './logger';\nimport { getExchangeRateService } from './exchange-rate';\nimport { getExchangeRateSymbol } from './exchange-rate/token-address-mapping';\nimport { trimDecimals, limitTokenPrecision } from './math-utils';\nimport { getPriceCurrencyOptions, getPriceUintAmountByCurrency } from './price';\nimport { getRecurringPeriod, getSubscriptionCreateSetup } from './session';\nimport { getConnectQueryParam, getCustomerStakeAddress } from './util';\nimport { wallet } from './auth';\nimport { getGasPayerExtra } from './payment';\nimport { getLock } from './lock';\nimport { emitAsync } from './event';\n\nexport function getCustomerSubscriptionPageUrl({\n  subscriptionId,\n  locale = 'en',\n  userDid,\n}: {\n  subscriptionId: string;\n  locale: LiteralUnion<'en' | 'zh', string>;\n  userDid: string;\n}) {\n  return component.getUrl(\n    withQuery(`customer/subscription/${subscriptionId}`, {\n      locale,\n      ...getConnectQueryParam({ userDid }),\n    })\n  );\n}\n\nexport function getAdminSubscriptionPageUrl({\n  subscriptionId,\n  locale = 'en',\n  userDid,\n}: {\n  subscriptionId: string;\n  locale: LiteralUnion<'en' | 'zh', string>;\n  userDid: string;\n}) {\n  return component.getUrl(\n    withQuery(`admin/billing/${subscriptionId}`, {\n      locale,\n      ...getConnectQueryParam({ userDid }),\n    })\n  );\n}\n\nexport function getAdminInvoicePageUrl({\n  invoiceId,\n  locale = 'en',\n  userDid,\n}: {\n  invoiceId: string;\n  locale: LiteralUnion<'en' | 'zh', string>;\n  userDid: string;\n}) {\n  return component.getUrl(\n    withQuery(`admin/billing/${invoiceId}`, {\n      locale,\n      ...getConnectQueryParam({ userDid }),\n    })\n  );\n}\n\nexport function parseIntegerConfig(alternatives: any[], defaultValue: number) {\n  for (const raw of alternatives) {\n    const days = parseInt(raw, 10);\n    if (typeof days === 'number' && days >= 0) {\n      return days;\n    }\n  }\n\n  return defaultValue;\n}\n\nexport function getDaysUntilDue(query: Record<string, any> = {}) {\n  return parseIntegerConfig([query.days_until_due, process.env.PAYMENT_DAYS_UNTIL_DUE], 6);\n}\n\nexport function getDaysUntilCancel(query: Record<string, any> = {}) {\n  return parseIntegerConfig([query.days_until_cancel, process.env.PAYMENT_DAYS_UNTIL_CANCEL], 0);\n}\n\nexport const getDueUnit = (interval: string) => {\n  if (interval === 'hour') {\n    return 60;\n  }\n\n  if (interval === 'day') {\n    return 60 * 60;\n  }\n\n  return 60 * 60 * 24;\n};\n\nexport const getMaxRetryCount = (interval: string) => {\n  if (interval === 'hour') {\n    return 10; // 34 minutes\n  }\n\n  if (interval === 'day') {\n    return 15; // 18 hours\n  }\n\n  if (interval === 'week') {\n    return 18; // 6 days\n  }\n\n  return 20; // 24 days\n};\n\nexport const getMinRetryMail = (interval: string) => {\n  if (interval === 'hour') {\n    return 9; // 17 minutes\n  }\n\n  if (interval === 'day') {\n    return 13; // 4 hours\n  }\n\n  if (interval === 'week') {\n    return 15; // 18 hours\n  }\n\n  return 15; // 18 hours\n};\n\nconst ZERO = new BN(0);\nexport function getSubscriptionStakeSetup(items: TLineItemExpanded[], currencyId: string, billingThreshold = '0') {\n  const staking = {\n    licensed: new BN(0),\n    metered: new BN(0),\n  };\n\n  const recurringItems = items\n    .map((x) => x.upsell_price || x.price)\n    .filter((x) => x.type === 'recurring' && x.recurring);\n  if (recurringItems.length > 0) {\n    if (new BN(billingThreshold).gt(ZERO)) {\n      staking.licensed = new BN(billingThreshold);\n    } else {\n      items.forEach((x) => {\n        const price = getSubscriptionItemPrice(x);\n        const unit = getPriceUintAmountByCurrency(price, currencyId);\n        const amount = new BN(unit).mul(new BN(x.quantity));\n        if (price.type === 'recurring' && price.recurring) {\n          if (price.recurring.usage_type === 'licensed') {\n            staking.licensed = staking.licensed.add(amount);\n          }\n          if (price.recurring.usage_type === 'metered') {\n            staking.metered = staking.metered.add(amount);\n          }\n        }\n      });\n    }\n  }\n\n  return staking;\n}\n\nexport function getSubscriptionCycleSetup(\n  recurring: PriceRecurring,\n  previousPeriodEnd: number,\n  options?: {\n    catchUp?: boolean;\n    maxMissedPeriods?: number;\n  }\n) {\n  const cycle = getRecurringPeriod(recurring);\n  const now = dayjs().unix();\n\n  // Basic setup without catch-up\n  if (!options?.catchUp) {\n    return {\n      recurring,\n      cycle,\n      period: {\n        start: previousPeriodEnd,\n        end: dayjs.unix(previousPeriodEnd).add(cycle, 'millisecond').unix(),\n      },\n      missedPeriods: 0,\n    };\n  }\n\n  // Calculate missed periods if catch-up is enabled\n  const expectedEnd = dayjs.unix(previousPeriodEnd).add(cycle, 'millisecond').unix();\n\n  if (now <= expectedEnd) {\n    // No catch-up needed\n    return {\n      recurring,\n      cycle,\n      period: {\n        start: previousPeriodEnd,\n        end: expectedEnd,\n      },\n      missedPeriods: 0,\n    };\n  }\n\n  // Calculate how many periods we've missed\n  const timeSinceExpected = now - expectedEnd;\n  const cycleInSeconds = cycle / 1000;\n  const missedPeriods = Math.floor(timeSinceExpected / cycleInSeconds);\n  const maxMissedPeriods = options.maxMissedPeriods || 100; // Default limit to prevent excessive catch-up\n\n  const actualMissedPeriods = Math.min(missedPeriods, maxMissedPeriods);\n\n  // Calculate the current period we should be in\n  const currentPeriodStart = dayjs\n    .unix(previousPeriodEnd)\n    .add((actualMissedPeriods + 1) * cycle, 'millisecond')\n    .unix();\n  const currentPeriodEnd = dayjs.unix(currentPeriodStart).add(cycle, 'millisecond').unix();\n\n  return {\n    recurring,\n    cycle,\n    period: {\n      start: currentPeriodStart,\n      end: currentPeriodEnd,\n    },\n    missedPeriods: actualMissedPeriods,\n    // Additional info for recovery handling\n    recovery: {\n      originalPeriodEnd: previousPeriodEnd,\n      expectedPeriodEnd: expectedEnd,\n      timeMissed: timeSinceExpected,\n      periodsSkipped: actualMissedPeriods,\n      wasLimited: missedPeriods > maxMissedPeriods,\n    },\n  };\n}\n\nexport function getSubscriptionCycleAmount(items: TLineItemExpanded[], currencyId: string) {\n  let amount = new BN(0);\n\n  items.forEach((x) => {\n    const price = getSubscriptionItemPrice(x) as any;\n    // TODO: why use custom_amount and quoted_amount instead of the price.unit_amount?\n    const dynamicAmount =\n      price?.pricing_type === 'dynamic' ? (x as any).custom_amount || (x as any).quoted_amount : null;\n\n    if (dynamicAmount) {\n      amount = amount.add(new BN(dynamicAmount));\n      return;\n    }\n\n    amount = amount.add(new BN(getPriceUintAmountByCurrency(price, currencyId)).mul(new BN(x.quantity)));\n  });\n\n  return {\n    total: amount.toString(),\n  };\n}\n\nexport function getSubscriptionItemPrice(item: TLineItemExpanded) {\n  return item.upsell_price || item.price;\n}\n\nexport async function createProration(\n  subscription: Subscription,\n  setup: ReturnType<typeof getSubscriptionCreateSetup>,\n  anchor: number\n) {\n  const lastInvoice = await Invoice.findByPk(subscription.latest_invoice_id);\n  if (!lastInvoice) {\n    throw new Error('Subscription should have latest invoice when create proration');\n  }\n\n  const customer = await Customer.findByPk(subscription.customer_id);\n  if (!customer) {\n    throw new Error('Subscription should have customer when create proration');\n  }\n\n  // 1. get last invoice, and invoice items, filter invoice items that are in licensed recurring mode\n  const invoiceItems = await InvoiceItem.findAll({ where: { invoice_id: lastInvoice.id, proration: false } });\n  const invoiceItemsExpanded = await Price.expand(invoiceItems.map((x) => x.toJSON()));\n  const prorationItems = invoiceItemsExpanded.filter((x) => {\n    const price = getSubscriptionItemPrice(x);\n    return price.type === 'recurring' && price.recurring?.usage_type === 'licensed';\n  });\n\n  // 2. calculate proration args based on the filtered invoice items\n  const precision = 10000;\n  const isInvoicePeriodValid = lastInvoice.period_start < lastInvoice.period_end;\n  const prorationStart = isInvoicePeriodValid ? lastInvoice.period_start : subscription.current_period_start;\n  const prorationEnd = isInvoicePeriodValid ? lastInvoice.period_end : subscription.current_period_end;\n  if (anchor > prorationEnd) {\n    logger.warn('try to create proration with invalid arguments', { anchor, prorationStart, prorationEnd });\n    throw new Error('Subscription proration anchor should not be larger than prorationEnd');\n  }\n  const trialing = subscription.status === 'trialing';\n  if (trialing) {\n    return {\n      lastInvoice,\n      total: '0',\n      shouldPay: '0',\n      used: '0',\n      unused: '0',\n      prorations: [],\n      newCredit: '0',\n      appliedCredit: '0',\n      remaining: '0',\n      remainingUnused: '0',\n    };\n  }\n\n  const prorationRate = Math.ceil(((prorationEnd - anchor) / (prorationEnd - prorationStart)) * precision);\n  let unused = new BN(0);\n  const prorations = await Promise.all(\n    prorationItems.map((x: TLineItemExpanded & { [key: string]: any }) => {\n      const price = getSubscriptionItemPrice(x);\n      const unitAmount = getPriceUintAmountByCurrency(price, lastInvoice.currency_id);\n      const amount = new BN(unitAmount)\n        .mul(new BN(x.quantity))\n        .mul(new BN(prorationRate))\n        .div(new BN(precision))\n        .toString();\n      logger.info('subscription proration item', {\n        subscription: subscription.id,\n        invoice: x.invoice_id,\n        invoiceItem: x.id,\n        amount,\n      });\n      unused = unused.add(new BN(amount));\n\n      return {\n        price_id: price.id,\n        amount: `-${amount}`,\n        quantity: x.quantity,\n        // @ts-ignore\n        description: `Unused time on ${price.product.name} after ${dayjs().format('lll')}`,\n        period: {\n          start: lastInvoice.period_start,\n          end: lastInvoice.period_end,\n        },\n        proration: true,\n        proration_details: {\n          credited_items: {\n            invoice_id: lastInvoice.id,\n            // @ts-ignore\n            invoice_line_items: [x.id],\n          },\n        },\n      };\n    })\n  );\n  logger.info('subscription prorations created', {\n    subscription: subscription.id,\n    prorations,\n  });\n\n  // 5. adjust invoice total && update customer token balance\n  const total = setup.amount.setup;\n\n  // 6. calculate remaining amount\n  const refunds = await Refund.findAll({\n    where: {\n      status: { [Op.not]: 'canceled' },\n      subscription_id: subscription.id,\n      currency_id: lastInvoice?.currency_id,\n      invoice_id: lastInvoice?.id,\n    },\n  });\n  const refundAmount = refunds.reduce((acc, x) => acc.add(new BN(x.amount || '0')), new BN(0));\n\n  // 7. calculate remaining amount, default refund recurring amount\n  const calcRemaining = (amount: BN, subtract: BN) =>\n    amount.sub(subtract).lt(new BN(0)) ? '0' : amount.sub(subtract).toString();\n\n  const remaining = calcRemaining(new BN(total), refundAmount);\n  const remainingUnused = calcRemaining(unused, refundAmount);\n\n  let due = setup.amount.setup;\n  let newCredit = '0';\n  let appliedCredit = '0';\n  if (new BN(total).gte(unused)) {\n    // Proration amount is less than total, all proration are used,\n    due = new BN(total).sub(unused).toString();\n    // Besides, we need to try to apply customer credit\n    appliedCredit = customer.getBalanceToApply(subscription.currency_id, due);\n    due = new BN(due).sub(new BN(appliedCredit)).toString();\n  } else {\n    // Proration amount is greater than total, we need to increase customer credit\n    newCredit = unused.sub(new BN(total)).toString();\n    due = '0';\n  }\n\n  logger.info('subscription proration result', {\n    subscription: subscription.id,\n    prorationStart,\n    prorationEnd,\n    prorationRate,\n    unused: unused.toString(),\n    remaining,\n    remainingUnused,\n    total,\n    due,\n    newCredit,\n    appliedCredit,\n  });\n\n  return {\n    lastInvoice,\n    total,\n    due,\n    remaining,\n    remainingUnused,\n    used: new BN(lastInvoice.amount_due).sub(unused).toString(),\n    unused: unused.toString(),\n    prorations,\n    newCredit,\n    appliedCredit,\n  };\n}\n\nexport async function getSubscriptionRefundSetup(subscription: Subscription, anchor: number, currencyId?: string) {\n  const items = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n  const expanded = await Price.expand(items.map((x) => x.toJSON()));\n  const setup = getSubscriptionCreateSetup(expanded, currencyId || subscription.currency_id, 0);\n  return createProration(subscription, setup, anchor);\n}\n\nexport function shouldCancelSubscription(\n  subscription: Pick<Subscription, 'status' | 'current_period_end' | 'cancel_at' | 'cancel_at_period_end'>\n) {\n  if (['past_due', 'active', 'trialing'].includes(subscription.status)) {\n    const now = dayjs().unix();\n    if (subscription.cancel_at) {\n      if (subscription.cancel_at <= now) {\n        return true;\n      }\n    } else if (subscription.cancel_at_period_end) {\n      if (subscription.current_period_end <= now) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport async function canChangePaymentMethod(subscriptionId: string) {\n  const item = await SubscriptionItem.findOne({ where: { subscription_id: subscriptionId } });\n  const expanded = await Price.findOne({ where: { id: item!.price_id } });\n  return expanded && getPriceCurrencyOptions(expanded).length > 1;\n}\n\nexport async function expandSubscriptionItems(subscriptionId: string) {\n  const items = await SubscriptionItem.findAll({ where: { subscription_id: subscriptionId } });\n  return Price.expand(items.map((x) => x.toJSON()));\n}\n\nexport async function getUpcomingInvoiceAmount(subscriptionId: string) {\n  const subscription = await Subscription.findByPk(subscriptionId);\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  if (subscription.isActive() === false && subscription.status !== 'past_due') {\n    throw new Error(`Subscription not active for ${subscriptionId}, so usage check is skipped`);\n  }\n\n  const currency = await PaymentCurrency.findByPk(subscription.currency_id);\n\n  const items = await SubscriptionItem.findAll({ where: { subscription_id: subscriptionId } });\n  const expanded = await Price.expand(items.map((x) => x.toJSON()));\n\n  let amount = new BN(0);\n  let minExpectedAmount = new BN(0);\n  for (const item of expanded) {\n    const price = getSubscriptionItemPrice(item);\n    if (price.type === 'recurring') {\n      const unit = getPriceUintAmountByCurrency(price, subscription.currency_id);\n      if (price.recurring?.usage_type === 'licensed') {\n        amount = amount.add(new BN(unit).mul(new BN(item.quantity)));\n        minExpectedAmount = minExpectedAmount.add(new BN(unit).mul(new BN(item.quantity)));\n      }\n      if (price.recurring?.usage_type === 'metered') {\n        const rawQuantity = await UsageRecord.getSummary({\n          // @ts-ignore\n          id: item?.id as string,\n          start: subscription.current_period_start,\n          end: subscription.current_period_end,\n          method: price.recurring?.aggregate_usage as any,\n          dryRun: true,\n        });\n        // @ts-ignore\n        const quantity = price.transformQuantity(rawQuantity);\n        amount = amount.add(new BN(unit).mul(new BN(quantity)));\n        minExpectedAmount = minExpectedAmount.add(new BN(unit).mul(new BN(item.quantity)));\n      }\n    }\n  }\n\n  return {\n    amount: amount.toString(),\n    minExpectedAmount: minExpectedAmount.toString(),\n    start: subscription.current_period_start,\n    end: subscription.current_period_end,\n    currency,\n  };\n}\n\nexport async function getPastInvoicesAmount(subscriptionId: string, aggregationRule: 'sum' | 'avg' | 'max' = 'max') {\n  const subscription = await Subscription.findByPk(subscriptionId);\n  if (!subscription) {\n    throw new Error('Subscription not found');\n  }\n\n  const currency = await PaymentCurrency.findByPk(subscription.currency_id);\n\n  // 获取所有的账单周期\n  const pastInvoices = await Invoice.findAll({\n    where: {\n      subscription_id: subscriptionId,\n      currency_id: subscription.currency_id,\n      billing_reason: [\n        'subscription_create',\n        'subscription_cycle',\n        'subscription_update',\n        'subscription_recover',\n        'subscription_threshold',\n        'subscription_cancel',\n        'subscription',\n      ],\n    },\n    order: [['created_at', 'DESC']],\n  });\n\n  const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, subscription.current_period_end);\n  let start = setup.period.start - setup.cycle / 1000;\n  let end = setup.period.end - setup.cycle / 1000;\n  const createdAt = dayjs(subscription.created_at).unix();\n  const amountsByPeriod: { [key: string]: BN } = {};\n\n  while (start < end && start >= createdAt) {\n    const periodKey = `${start}-${end}`;\n    // eslint-disable-next-line @typescript-eslint/no-loop-func\n    const invoices = pastInvoices.filter((x) => x.period_start >= start && x.period_end <= end);\n    const amount = invoices.reduce((acc, x) => acc.add(new BN(x.total)), new BN(0));\n    amountsByPeriod[periodKey] = amount;\n    start -= setup.cycle / 1000;\n    end -= setup.cycle / 1000;\n  }\n\n  let result = new BN(0);\n  switch (aggregationRule) {\n    case 'sum':\n      result = Object.values(amountsByPeriod).reduce((acc, curr) => acc.add(curr), new BN(0));\n      break;\n    case 'avg':\n      result =\n        Object.values(amountsByPeriod).length > 0\n          ? Object.values(amountsByPeriod)\n              .reduce((acc, curr) => acc.add(curr), new BN(0))\n              .div(new BN(Object.values(amountsByPeriod).length))\n          : new BN(0);\n      break;\n    case 'max':\n      result =\n        Object.values(amountsByPeriod).length > 0\n          ? Object.values(amountsByPeriod).reduce((acc, curr) => (acc.gt(curr) ? acc : curr), new BN(0))\n          : new BN(0);\n      break;\n    default:\n      throw new Error('Invalid aggregation rule');\n  }\n\n  return {\n    amount: result.toString(),\n    currency,\n  };\n}\n\nexport async function finalizeSubscriptionUpdate({\n  subscription,\n  customer,\n  invoice,\n  paymentCurrency,\n  appliedCredit,\n  newCredit,\n  addedItems,\n  updatedItems,\n  deletedItems,\n  updates,\n}: {\n  subscription: Subscription;\n  customer: Customer;\n  invoice: Invoice | null;\n  paymentCurrency: PaymentCurrency;\n  appliedCredit: string;\n  newCredit: string;\n  addedItems: SubscriptionUpdateItem[];\n  updatedItems: SubscriptionUpdateItem[];\n  deletedItems: SubscriptionUpdateItem[];\n  updates: any;\n}) {\n  if (isEmpty(updates)) {\n    logger.info('subscription update aborted', { subscription: subscription.id, updates });\n    return;\n  }\n\n  logger.info('subscription update finalized', { subscription: subscription.id, updates });\n  await subscription.update({ ...updates, pending_update: null });\n\n  // update subscription items\n  for (const item of addedItems) {\n    await SubscriptionItem.create({\n      price_id: item.price_id as string,\n      quantity: item.quantity as number,\n      livemode: subscription.livemode,\n      subscription_id: subscription.id,\n      metadata: {},\n    });\n    logger.info('subscription item added on update finalize', { subscription: subscription.id, item: item.id });\n  }\n  for (const item of updatedItems) {\n    await SubscriptionItem.update(pick(item, ['quantity', 'metadata', 'billing_thresholds']), {\n      where: { id: item.id },\n    });\n    logger.info('subscription item updated on update finalize', { subscription: subscription.id, item: item.id });\n  }\n  for (const item of deletedItems) {\n    if (item.clear_usage) {\n      await UsageRecord.destroy({ where: { subscription_item_id: item.id } });\n      logger.info('subscription item usage cleared on update finalize', {\n        subscription: subscription.id,\n        item: item.id,\n      });\n    }\n    await SubscriptionItem.destroy({ where: { id: item.id } });\n    logger.info('subscription item deleted on update finalize', { subscription: subscription.id, item: item.id });\n  }\n\n  // update customer credits\n  if (appliedCredit !== '0') {\n    const creditResult = await customer.decreaseTokenBalance(paymentCurrency.id, appliedCredit);\n    if (invoice) {\n      await invoice.update({\n        starting_token_balance: creditResult.starting,\n        ending_token_balance: creditResult.ending,\n      });\n      logger.info('customer credit applied to invoice after proration', {\n        subscription: subscription.id,\n        appliedCredit,\n        creditResult,\n      });\n    }\n  }\n  if (newCredit !== '0') {\n    const creditResult = await customer.increaseTokenBalance(paymentCurrency.id, newCredit);\n    if (invoice) {\n      await invoice.update({\n        starting_token_balance: creditResult.starting,\n        ending_token_balance: creditResult.ending,\n      });\n      logger.info('subscription proration credit applied to customer', {\n        subscription: subscription.id,\n        newCredit,\n        creditResult,\n      });\n    }\n  }\n\n  // lock for next update\n  const releaseAt = subscription.current_period_end;\n  await Lock.acquire(`${subscription.id}-change-plan`, releaseAt);\n  logger.info('subscription plan change lock acquired on finalize', { subscription: subscription.id, releaseAt });\n}\n\nexport async function finalizeStripeSubscriptionUpdate({\n  subscription,\n  items,\n  updates,\n}: {\n  subscription: Subscription;\n  items: any[];\n  updates: any;\n}) {\n  if (isEmpty(updates)) {\n    logger.info('subscription update aborted', { subscription: subscription.id, updates });\n    return;\n  }\n\n  if (subscription.pending_update) {\n    // handle subscription item remove\n    // this must be done before update/create\n    const localItems = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n    const deletedItems = localItems.filter((x) => items.some((y) => y.id === x.id) === false).map((x) => x.id);\n    if (deletedItems.length) {\n      await UsageRecord.destroy({ where: { subscription_item_id: deletedItems } });\n      logger.info('subscription item usage cleared on update', { subscription: subscription.id, deletedItems });\n      await SubscriptionItem.destroy({ where: { id: deletedItems } });\n      logger.info('subscription item deleted on update', { subscription: subscription.id, deletedItems });\n    }\n\n    // handle subscription item update/create\n    for (const item of items) {\n      if (item.id) {\n        // remote item is associated with local item\n        await SubscriptionItem.update(pick(item, ['quantity', 'billing_thresholds']), { where: { id: item.id } });\n        logger.info('subscription item synced on update', { subscription: subscription.id, item });\n      } else {\n        // remote item not associated with local item\n        const created = await SubscriptionItem.create({\n          price_id: item.price_id as string,\n          quantity: (item.quantity || 1) as number,\n          livemode: subscription.livemode,\n          subscription_id: subscription.id,\n          metadata: {\n            stripe_id: item.stripe_id,\n            stripe_subscription_id: item.stripe_subscription_id,\n          },\n        });\n        logger.info('subscription item mirrored on update', { subscription: subscription.id, item });\n        const method = await PaymentMethod.findByPk(subscription.default_payment_method_id);\n        const client = method!.getStripeClient();\n        const result = await client.subscriptionItems.update(item.stripe_id, {\n          metadata: { appPid: env.appPid, id: created.id },\n        });\n        logger.info('subscription item related on mirror', { subscription: subscription.id, item, result });\n      }\n    }\n\n    const releaseAt = subscription.current_period_end;\n    await Lock.acquire(`${subscription.id}-change-plan`, releaseAt);\n    logger.info('subscription plan change lock acquired on finalize', { subscription: subscription.id, releaseAt });\n\n    createEvent('Subscription', 'customer.subscription.upgraded', subscription).catch(console.error);\n  }\n\n  logger.info('subscription update finalized', { subscription: subscription.id, updates, items });\n  await subscription.update({ ...updates, pending_update: null });\n}\n\nexport async function onSubscriptionUpdateConnected(subscriptionId: string) {\n  const subscription = await Subscription.findByPk(subscriptionId);\n  if (!subscription) {\n    return;\n  }\n\n  const now = dayjs().unix();\n  const pending = subscription.pending_update;\n  logger.info('subscription update connected', { subscription: subscription.id, pending });\n  if (pending?.updates && pending?.expires_at && pending.expires_at >= now && pending.updates?.latest_invoice_id) {\n    const paymentCurrency = await PaymentCurrency.findByPk(subscription.currency_id);\n    if (!paymentCurrency) {\n      return;\n    }\n\n    const customer = await Customer.findByPk(subscription.customer_id);\n    if (!customer) {\n      return;\n    }\n\n    const invoice = await Invoice.findByPk(pending.updates.latest_invoice_id);\n    if (!invoice) {\n      return;\n    }\n\n    await finalizeSubscriptionUpdate({\n      subscription,\n      customer,\n      invoice,\n      paymentCurrency,\n      appliedCredit: pending.appliedCredit || '0',\n      newCredit: pending.newCredit || '0',\n      addedItems: pending.addedItems || [],\n      deletedItems: pending.deletedItems || [],\n      updatedItems: pending.updatedItems || [],\n      updates: pending.updates,\n    });\n  }\n}\n\nexport async function getRemainingStakes(subscriptionIds: string[], subscriptionInitStakes: { [key: string]: string }) {\n  if (!subscriptionIds || subscriptionIds.length === 0) {\n    return '0';\n  }\n  let total = new BN('0');\n  await Promise.all(\n    subscriptionIds.map(async (subscriptionId) => {\n      const refund = await Refund.findOne({\n        where: {\n          subscription_id: subscriptionId,\n          status: {\n            [Op.not]: 'canceled',\n          },\n          type: 'stake_return',\n        },\n      });\n      if (!refund) {\n        // this subscription not return stake\n        total = total.add(new BN(subscriptionInitStakes[subscriptionId] || '0'));\n      }\n    })\n  );\n  return total.toString();\n}\n\nexport async function getSubscriptionStakeSlashSetup(\n  subscription: Subscription,\n  address: string,\n  paymentMethod: PaymentMethod,\n  paymentCurrencyId?: string\n) {\n  const lastInvoice = await Invoice.findByPk(subscription.latest_invoice_id);\n  const result = await getSubscriptionRemainingStakeSetup(\n    subscription,\n    address,\n    paymentMethod,\n    'slash',\n    paymentCurrencyId\n  );\n  return {\n    ...result,\n    lastInvoice,\n  };\n}\n\nexport async function getSubscriptionStakeReturnSetup(\n  subscription: Subscription,\n  address: string,\n  paymentMethod: PaymentMethod,\n  paymentCurrencyId?: string\n) {\n  const lastInvoice = await Invoice.findByPk(subscription.latest_invoice_id);\n  const result = await getSubscriptionRemainingStakeSetup(\n    subscription,\n    address,\n    paymentMethod,\n    'return',\n    paymentCurrencyId\n  );\n  return {\n    ...result,\n    lastInvoice,\n  };\n}\n\nexport async function getSubscriptionRemainingStakeSetup(\n  subscription: Subscription,\n  address: string,\n  paymentMethod: PaymentMethod,\n  action: 'return' | 'slash' = 'return',\n  paymentCurrencyId?: string\n) {\n  const currency = await PaymentCurrency.findByPk(paymentCurrencyId || subscription.currency_id);\n  if (!currency) {\n    return {\n      total: '0',\n      return_amount: '0',\n      sender: '',\n    };\n  }\n\n  const client = paymentMethod.getOcapClient();\n  const { state } = await client.getStakeState({ address });\n  if (!state) {\n    return {\n      total: '0',\n      return_amount: '0',\n      sender: '',\n    };\n  }\n\n  let total = new BN(state.tokens.find((x: any) => x.address === currency.contract)?.value || '0');\n  if (action === 'slash') {\n    // add revoked tokens to total\n    const revoked = state.revokedTokens?.find((x: any) => x.address === currency.contract);\n    total = total.add(new BN(revoked?.value || '0'));\n  }\n  const [summary] = await Invoice.getUncollectibleAmount({\n    subscriptionId: subscription.id,\n    currencyId: currency.id,\n    customerId: subscription.customer_id,\n  });\n  const subscriptionInitStakes = JSON.parse(state.data?.value || '{}');\n  const initStake = subscriptionInitStakes[subscription.id];\n  const uncollectibleAmountBN = new BN(summary?.[currency.id] || '0');\n  if (state.nonce) {\n    const returnStake = total.sub(uncollectibleAmountBN);\n    return {\n      total: total.toString(),\n      return_amount: returnStake.lt(new BN(0)) ? '0' : returnStake.toString(),\n      sender: state.sender,\n    };\n  }\n  const getReturnState = async () => {\n    const initStakeBN = new BN(initStake);\n    const otherSubscriptionIds = Object.keys(subscriptionInitStakes).filter(\n      (k) => k !== 'appId' && k !== subscription.id\n    );\n    const remainingStakes = await getRemainingStakes(otherSubscriptionIds, subscriptionInitStakes);\n    const actualStakeBN = new BN(total).sub(new BN(remainingStakes));\n    const minStakeBN = initStakeBN.lt(actualStakeBN) ? initStakeBN : actualStakeBN;\n    return minStakeBN.sub(uncollectibleAmountBN);\n  };\n  const returnStake = await getReturnState();\n  return {\n    total: initStake,\n    return_amount: returnStake.lt(new BN(0)) ? '0' : returnStake.toString(),\n    sender: state.sender,\n  };\n}\n\nexport async function checkRemainingStake(\n  paymentMethod: PaymentMethod,\n  paymentCurrency: PaymentCurrency,\n  address: string,\n  amount: string\n): Promise<{ enough: boolean; staked: any; revoked: any }> {\n  if (paymentMethod?.type !== 'arcblock') {\n    return {\n      enough: false,\n      staked: '0',\n      revoked: '0',\n    };\n  }\n\n  const client = paymentMethod.getOcapClient();\n  const { state } = await client.getStakeState({ address });\n  if (!state) {\n    logger.warn('getStakeState failed in checkRemainingStake', { address });\n    return {\n      enough: false,\n      staked: '0',\n      revoked: '0',\n    };\n  }\n\n  const staked = state.tokens?.find((x: any) => x.address === paymentCurrency.contract);\n  const revoked = state.revokedTokens?.find((x: any) => x.address === paymentCurrency.contract);\n  let total = new BN(0);\n  if (staked) {\n    total = total.add(new BN(staked?.value || '0'));\n  }\n  if (revoked) {\n    total = total.add(new BN(revoked?.value || '0'));\n  }\n\n  return {\n    enough: total.gte(new BN(amount || '0')),\n    staked,\n    revoked,\n  };\n}\n\n// trialing can be customized with currency_id list\nexport function getSubscriptionTrialSetup(data: Partial<SubscriptionData>, currencyId: string) {\n  let trialInDays = Number(data?.trial_period_days || 0);\n  let trialEnd = Number(data?.trial_end || 0);\n  const trialCurrencyIds = (data?.trial_currency || '').split(',').map(trim).filter(Boolean);\n  if (trialCurrencyIds.length > 0 && trialCurrencyIds.includes(currencyId) === false) {\n    trialEnd = 0;\n    trialInDays = 0;\n  }\n\n  return {\n    trialInDays,\n    trialEnd,\n  };\n}\n\nexport async function getSubscriptionStakeAddress(subscription: Subscription, customerDid: string) {\n  return (\n    subscription.payment_details?.arcblock?.staking?.address ||\n    (await getCustomerStakeAddress(customerDid, subscription.id))\n  );\n}\n\nexport async function getSubscriptionStakeCancellation(\n  subscription: Subscription,\n  paymentMethod: PaymentMethod,\n  paymentCurrency: PaymentCurrency\n): Promise<{\n  stakeReturn: boolean;\n  stakeSlash: boolean;\n  stakeEnough: boolean;\n  hasStake: boolean;\n}> {\n  const cancellation = {\n    stakeReturn: subscription.cancelation_details?.return_stake === true,\n    stakeSlash: subscription.cancelation_details?.slash_stake === true,\n    stakeEnough: false,\n    hasStake: !!subscription?.payment_details?.arcblock?.staking?.tx_hash,\n  };\n  const customerCancelRequest = subscription.cancelation_details?.reason === 'cancellation_requested';\n  if (customerCancelRequest) {\n    // cancel request from customer\n    const address = subscription?.payment_details?.arcblock?.staking?.address;\n    let stakeEnough;\n    if (address && paymentMethod) {\n      const stakeReturnResult = await getSubscriptionStakeReturnSetup(subscription, address, paymentMethod);\n      stakeEnough = await checkRemainingStake(paymentMethod, paymentCurrency, address, stakeReturnResult.return_amount);\n      cancellation.stakeEnough = stakeEnough?.enough;\n    }\n  }\n  return cancellation;\n}\n\nexport async function getSubscriptionStakeAmountSetup(\n  subscription: Subscription,\n  paymentMethod: PaymentMethod,\n  stakingTxHash?: string\n) {\n  if (paymentMethod.type !== 'arcblock') {\n    return null;\n  }\n  const txHash = stakingTxHash || subscription?.payment_details?.arcblock?.staking?.tx_hash;\n  if (!txHash) {\n    return null;\n  }\n  const client = paymentMethod.getOcapClient();\n  const { info } = await client.getTx({ hash: txHash });\n  if (!info) {\n    return null;\n  }\n  // @ts-ignore\n  const inputs = info?.tx?.itxJson?.inputs || [];\n  if (!inputs || inputs.length === 0) {\n    logger.info('getSubscriptionStakeAmountSetup failed, no inputs', { txHash, info });\n    return null;\n  }\n  const amountRes: { [key: string]: string } = {};\n  // calculate stake amount for each address\n  inputs.forEach((input: any) => {\n    const { tokens } = input;\n    tokens.forEach((token: any) => {\n      const { address, value } = token;\n      if (amountRes[address]) {\n        amountRes[address] = new BN(amountRes[address]).add(new BN(value)).toString();\n      } else {\n        amountRes[address] = new BN(value).toString();\n      }\n    });\n  });\n  logger.info('get subscription stake amount setup success', { txHash, amountRes });\n  return amountRes;\n}\n\n// check if usage report is empty\nexport async function checkUsageReportEmpty(\n  subscription: Subscription,\n  usageReportStart: number,\n  usageReportEnd: number\n) {\n  const subscriptionItems = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n  const expandedItems = await Price.expand(\n    subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n    { product: true }\n  );\n  const meteredItems = expandedItems.filter((x: any) => x?.price?.recurring?.usage_type === 'metered');\n  if (meteredItems.length === 0) {\n    return false;\n  }\n  const usageReportEmpty = await Promise.all(\n    meteredItems.map(async (x: any) => {\n      const usageRecords = await UsageRecord.findAll({\n        where: {\n          subscription_item_id: x.id,\n          billed: false,\n          timestamp: {\n            [Op.gt]: usageReportStart,\n            [Op.lte]: usageReportEnd,\n          },\n        },\n      });\n      return usageRecords.length === 0;\n    })\n  );\n  return usageReportEmpty.every(Boolean);\n}\n\nexport function getSubscriptionPaymentAddress(subscription: Subscription, paymentMethodType: string) {\n  return (\n    // @ts-ignore\n    subscription.payment_details?.[paymentMethodType]?.payer ||\n    // @ts-ignore\n    subscription.payment_settings?.payment_method_options?.[paymentMethodType]?.payer\n  );\n}\nexport async function getPaymentAmountForCycleSubscription(\n  subscription: Subscription,\n  paymentCurrency: PaymentCurrency\n) {\n  const subscriptionItems = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n  if (subscriptionItems.length === 0) {\n    logger.info('subscription items not found in getPaymentAmountForCycleSubscription', {\n      subscription: subscription.id,\n    });\n    return 0;\n  }\n  let expandedItems = await Price.expand(\n    subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n    { product: true }\n  );\n  if (expandedItems.length === 0) {\n    logger.info('expanded items not found in getPaymentAmountForCycleSubscription', {\n      subscription: subscription.id,\n    });\n    return 0;\n  }\n  const previousPeriodEnd =\n    subscription.status === 'trialing' ? subscription.trial_end : subscription.current_period_end;\n  const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, previousPeriodEnd as number);\n  // get usage summaries for this billing cycle\n  expandedItems = await Promise.all(\n    expandedItems.map(async (x: any) => {\n      // For metered billing, we need to get usage summary for this billing cycle\n      // @link https://stripe.com/docs/products-prices/pricing-models#usage-types\n      if (x.price.recurring?.usage_type === 'metered') {\n        const rawQuantity = await UsageRecord.getSummary({\n          id: x.id,\n          start: setup.period.start - setup.cycle / 1000,\n          end: setup.period.end - setup.cycle / 1000,\n          method: x.price.recurring?.aggregate_usage,\n          dryRun: true,\n        });\n        x.quantity = x.price.transformQuantity(rawQuantity);\n        // record raw quantity in metadata\n        x.metadata = x.metadata || {};\n        x.metadata.quantity = rawQuantity;\n      }\n      return x;\n    })\n  );\n  if (expandedItems.length > 0) {\n    const amount = getSubscriptionCycleAmount(expandedItems, paymentCurrency.id);\n    return +fromUnitToToken(amount?.total || '0', paymentCurrency.decimal);\n  }\n  return 0;\n}\n\nexport async function getEstimatedPaymentAmountForCycleSubscription(\n  subscription: Subscription,\n  paymentCurrency: PaymentCurrency\n): Promise<{ amount: number; estimatedByRate: boolean }> {\n  const subscriptionItems = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n  if (subscriptionItems.length === 0) {\n    logger.info('subscription items not found in getEstimatedPaymentAmountForCycleSubscription', {\n      subscription: subscription.id,\n    });\n    return { amount: 0, estimatedByRate: false };\n  }\n  let expandedItems = await Price.expand(\n    subscriptionItems.map((x) => ({ id: x.id, price_id: x.price_id, quantity: x.quantity })),\n    { product: true }\n  );\n  if (expandedItems.length === 0) {\n    logger.info('expanded items not found in getEstimatedPaymentAmountForCycleSubscription', {\n      subscription: subscription.id,\n    });\n    return { amount: 0, estimatedByRate: false };\n  }\n  const previousPeriodEnd =\n    subscription.status === 'trialing' ? subscription.trial_end : subscription.current_period_end;\n  const setup = getSubscriptionCycleSetup(subscription.pending_invoice_item_interval, previousPeriodEnd as number);\n  expandedItems = await Promise.all(\n    expandedItems.map(async (x: any) => {\n      if (x.price.recurring?.usage_type === 'metered') {\n        const rawQuantity = await UsageRecord.getSummary({\n          id: x.id,\n          start: setup.period.start - setup.cycle / 1000,\n          end: setup.period.end - setup.cycle / 1000,\n          method: x.price.recurring?.aggregate_usage,\n          dryRun: true,\n        });\n        x.quantity = x.price.transformQuantity(rawQuantity);\n        x.metadata = x.metadata || {};\n        x.metadata.quantity = rawQuantity;\n      }\n      return x;\n    })\n  );\n  if (expandedItems.length === 0) {\n    return { amount: 0, estimatedByRate: false };\n  }\n\n  let estimatedByRate = false;\n  const hasDynamicItems = expandedItems.some((item: any) => item.price?.pricing_type === 'dynamic');\n  if (hasDynamicItems) {\n    try {\n      const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n      if (!paymentMethod) {\n        throw new Error(`PaymentMethod not found in ${subscription.id}`);\n      }\n      const exchangeRateService = getExchangeRateService();\n      const rateSymbol = getExchangeRateSymbol(paymentCurrency.symbol, paymentMethod.type as any);\n      const rateResult = await exchangeRateService.getRate(rateSymbol);\n      const USD_DECIMALS = 8;\n      const rateBN = fromTokenToUnit(trimDecimals(rateResult.rate, USD_DECIMALS), USD_DECIMALS);\n\n      expandedItems = expandedItems.map((item: any) => {\n        const price = item.price;\n        if (price?.pricing_type !== 'dynamic') {\n          return item;\n        }\n        if (!price.base_amount) {\n          logger.warn('Dynamic price missing base_amount for estimate', {\n            subscriptionId: subscription.id,\n            priceId: price.id,\n          });\n          return item;\n        }\n\n        const baseAmountBN = fromTokenToUnit(trimDecimals(price.base_amount, USD_DECIMALS), USD_DECIMALS);\n        const quantityBN = new BN(item.quantity || 0);\n        const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n        const numerator = totalBaseAmountBN.mul(new BN(10).pow(new BN(paymentCurrency.decimal)));\n        const quotedAmountRaw = numerator.add(rateBN).sub(new BN(1)).div(rateBN);\n        const quotedAmount = limitTokenPrecision(quotedAmountRaw, paymentCurrency.decimal, 6);\n        estimatedByRate = true;\n        return {\n          ...item,\n          custom_amount: quotedAmount.toString(),\n          quoted_amount: quotedAmount.toString(),\n        };\n      });\n    } catch (error: any) {\n      logger.warn('Failed to estimate dynamic pricing amount for subscription', {\n        subscriptionId: subscription.id,\n        error: error?.message || error,\n      });\n    }\n  }\n\n  const amount = getSubscriptionCycleAmount(expandedItems, paymentCurrency.id);\n  return { amount: +fromUnitToToken(amount?.total || '0', paymentCurrency.decimal), estimatedByRate };\n}\n\n// check if subscription overdraft protection is enabled\nexport async function isSubscriptionOverdraftProtectionEnabled(subscription: Subscription, paymentCurrencyId?: string) {\n  try {\n    const paymentCurrency = await PaymentCurrency.findByPk(paymentCurrencyId || subscription.currency_id);\n    if (!paymentCurrency) {\n      throw new Error(`PaymentCurrency not found in ${subscription.id}`);\n    }\n    const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n    if (!paymentMethod) {\n      throw new Error(`PaymentMethod not found in ${subscription.id}`);\n    }\n\n    if (paymentMethod.type !== 'arcblock') {\n      throw new Error(`PaymentMethod type not supported in ${subscription.id}`);\n    }\n    if (!subscription.overdraft_protection) {\n      return {\n        enabled: false,\n        remaining: '0',\n        used: '0',\n        shouldPay: '0',\n        unused: '0',\n        revokedStake: '0',\n      };\n    }\n    const client = paymentMethod.getOcapClient();\n    const address = subscription?.overdraft_protection?.payment_details?.arcblock?.staking?.address;\n    if (!address) {\n      logger.info('Seems you have no staking for overdraft protection', { subscription: subscription.id });\n      return {\n        enabled: false,\n        remaining: '0',\n        used: '0',\n        shouldPay: '0',\n        unused: '0',\n        revokedStake: '0',\n      };\n    }\n    const { state } = await client.getStakeState({ address });\n    if (!state) {\n      throw new Error(`Stake state not found in ${subscription.id}`);\n    }\n    const data = JSON.parse(state.data?.value || '{}');\n    if (!data[subscription.id] && !state.nonce) {\n      throw new Error(`No staking for subscription: ${subscription.id}, address: ${address}`);\n    }\n\n    // calculate remaining stake, need to subtract refunding amount\n    let remainingStake = new BN(state.tokens.find((x: any) => x.address === paymentCurrency.contract)?.value || '0');\n    const revokedStake = new BN(\n      state.revokedTokens?.find((x: any) => x.address === paymentCurrency.contract)?.value || '0'\n    );\n\n    const refunds = await Refund.findAll({\n      where: {\n        subscription_id: subscription.id,\n        type: 'stake_return',\n        status: {\n          [Op.notIn]: ['canceled', 'succeeded'],\n        },\n        currency_id: paymentCurrency.id,\n      },\n      include: [{ model: Invoice, as: 'invoice' }],\n    });\n    const refundAmount = refunds\n      .filter((x: any) => x.invoice?.billing_reason === 'stake_overdraft_protection')\n      .reduce((acc, x) => acc.add(new BN(x.amount)), new BN(0));\n    remainingStake = remainingStake.sub(refundAmount);\n\n    const invoices = await Invoice.findAll({\n      where: {\n        subscription_id: subscription.id,\n        status: ['open', 'uncollectible'],\n        currency_id: paymentCurrency.id,\n      },\n    });\n    let usedAmount = new BN(0);\n    let dueAmount = new BN(0);\n    invoices.forEach((invoice) => {\n      usedAmount = usedAmount.add(new BN(invoice.amount_remaining));\n      if (invoice.billing_reason !== 'overdraft_protection') {\n        dueAmount = dueAmount.add(new BN(invoice.amount_remaining));\n      }\n    });\n    return {\n      enabled: subscription.overdraft_protection.enabled && usedAmount.lte(remainingStake),\n      remaining: remainingStake.toString(),\n      used: usedAmount.toString(),\n      shouldPay: dueAmount.toString(),\n      revoked: revokedStake.toString(),\n      unused: remainingStake.gte(usedAmount) ? remainingStake.sub(usedAmount).toString() : '0',\n    };\n  } catch (error) {\n    logger.error('error in isSubscriptionOverdraftProtectionEnabled', { error });\n    return {\n      enabled: false,\n      remaining: '0',\n      used: '0',\n      unused: '0',\n      shouldPay: '0',\n      revokedStake: '0',\n    };\n  }\n}\n\n// return remaining overdraft protection stake to customer\nexport async function returnOverdraftProtectionStake(\n  subscription: Subscription,\n  paymentCurrencyId?: string,\n  refundReason?: string\n) {\n  // return remaining stake to customer\n  logger.info('returnOverdraftProtectionStake', { subscription: subscription.id, paymentCurrencyId });\n  try {\n    await slashOverdraftProtectionStake(subscription, paymentCurrencyId);\n    const { unused } = await isSubscriptionOverdraftProtectionEnabled(subscription, paymentCurrencyId);\n    if (unused !== '0') {\n      // return unused stake to customer\n      const address = subscription?.overdraft_protection?.payment_details?.arcblock?.staking?.address;\n      if (!address) {\n        logger.info('Stake return skipped due to missing staking address', { subscription: subscription.id });\n        return;\n      }\n      const invoice = await Invoice.findOne({\n        where: {\n          subscription_id: subscription.id,\n          billing_reason: 'stake_overdraft_protection',\n          currency_id: paymentCurrencyId || subscription.currency_id,\n          status: 'paid',\n        },\n        order: [['created_at', 'DESC']],\n      });\n      const item = await Refund.create({\n        type: 'stake_return',\n        amount: unused,\n        description: 'stake_return_for_subscription_guard',\n        status: 'pending',\n        reason: refundReason || 'requested_by_admin',\n        subscription_id: subscription.id,\n        currency_id: paymentCurrencyId || subscription.currency_id,\n        livemode: subscription.livemode,\n        customer_id: subscription.customer_id,\n        invoice_id: invoice?.id,\n        payment_intent_id: invoice?.payment_intent_id || '',\n        payment_method_id: subscription.overdraft_protection?.payment_method_id || '',\n        starting_balance: unused,\n        ending_balance: '0',\n        attempt_count: 0,\n        attempted: false,\n        next_attempt: 0,\n        last_attempt_error: null,\n        starting_token_balance: {},\n        ending_token_balance: {},\n        payment_details: {\n          // @ts-ignore\n          arcblock: {\n            receiver:\n              subscription?.overdraft_protection?.payment_details?.arcblock?.payer ||\n              getSubscriptionPaymentAddress(subscription, 'arcblock'),\n            staking: {\n              address: address || '',\n              tx_hash: '',\n            },\n          },\n        },\n      });\n      logger.info('returnOverdraftProtectionStake Refund created', { item });\n    }\n  } catch (error) {\n    logger.error('returnOverdraftProtectionStake failed', { error });\n    throw error;\n  }\n}\n\n// slash overdraft protection stake\nexport async function slashOverdraftProtectionStake(subscription: Subscription, paymentCurrencyId?: string) {\n  const lock = getLock(\n    `slash_overdraft_protection_stake_${subscription.id}-${paymentCurrencyId || subscription.currency_id}`\n  );\n  logger.info('slashOverdraftProtectionStake', { subscription: subscription.id, paymentCurrencyId });\n  try {\n    await lock.acquire();\n    if (!subscription.overdraft_protection) {\n      logger.info('slashOverdraftProtectionStake skipped due to missing overdraft protection', {\n        subscription: subscription.id,\n      });\n      return;\n    }\n\n    const paymentCurrency = await PaymentCurrency.findByPk(paymentCurrencyId || subscription.currency_id);\n    if (!paymentCurrency) {\n      throw new Error(`PaymentCurrency not found in ${subscription.id}`);\n    }\n\n    const { used, remaining, revoked } = await isSubscriptionOverdraftProtectionEnabled(\n      subscription,\n      paymentCurrency.id\n    );\n    const remainingStake = new BN(remaining).add(new BN(revoked)).toString();\n    if (used === '0') {\n      logger.info('slashOverdraftProtectionStake skipped due to no unpaid invoices', {\n        subscription: subscription.id,\n        paymentCurrencyId: paymentCurrency.id,\n      });\n      return;\n    }\n\n    if (remainingStake === '0') {\n      logger.info('slashOverdraftProtectionStake skipped due to no remaining stake', {\n        subscription: subscription.id,\n        paymentCurrencyId: paymentCurrency.id,\n      });\n      return;\n    }\n\n    const paymentMethod = await PaymentMethod.findByPk(paymentCurrency.payment_method_id);\n    if (!paymentMethod || paymentMethod.type !== 'arcblock') {\n      throw new Error(`PaymentMethod type not supported in ${subscription.id}`);\n    }\n\n    const address = subscription?.overdraft_protection?.payment_details?.arcblock?.staking?.address;\n\n    if (!address) {\n      // no staking address\n      logger.info('Stake slashing skipped due to missing staking address', { subscription: subscription.id });\n      return;\n    }\n\n    const client = paymentMethod.getOcapClient();\n    const { state } = await client.getStakeState({ address });\n\n    if (!state || !state.data?.value) {\n      throw new Error(\n        `Stake slashing aborted due to missing staking state for subscription: ${subscription.id}, address: ${address}`\n      );\n    }\n\n    const data = JSON.parse(state.data.value || '{}');\n    if (!data[subscription.id] && !state.nonce) {\n      throw new Error(\n        `Stake slashing aborted because no staking for subscription: ${subscription.id}, address: ${address}`\n      );\n    }\n\n    const invoices = await Invoice.findAll({\n      where: {\n        subscription_id: subscription.id,\n        status: ['open', 'uncollectible'],\n        currency_id: paymentCurrency.id,\n      },\n      order: [['created_at', 'ASC']],\n    });\n\n    let slashAmount = new BN(0);\n    const slashInvoices: Invoice[] = [];\n    for (const invoice of invoices) {\n      if (!invoice.payment_intent_id) {\n        await emitAsync(\n          'invoice.queued',\n          invoice.id,\n          { invoiceId: invoice.id, retryOnError: false, justCreate: true },\n          { sync: true }\n        );\n        await invoice.reload();\n      }\n\n      const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n      if (paymentIntent) {\n        const isAlreadyPaid = paymentIntent.status === 'succeeded' && invoice.status === 'paid';\n\n        if (!isAlreadyPaid) {\n          const tmp = slashAmount.add(new BN(invoice.amount_remaining));\n          if (tmp.lte(new BN(remainingStake))) {\n            slashAmount = tmp;\n            slashInvoices.push(invoice);\n          } else {\n            break;\n          }\n        } else {\n          logger.info('PaymentIntent and Invoice already updated', {\n            subscription: subscription.id,\n            paymentIntent: paymentIntent.id,\n            invoice: invoice.id,\n          });\n        }\n      }\n    }\n\n    const slashedInvoiceIds: string[] = [];\n    const processInvoice = async (invoice: Invoice): Promise<void> => {\n      const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n      if (!paymentIntent || (paymentIntent.status === 'succeeded' && invoice.status === 'paid')) return;\n\n      try {\n        const stakeEnough = await checkRemainingStake(\n          paymentMethod,\n          paymentCurrency,\n          address,\n          invoice.amount_remaining\n        );\n        if (!stakeEnough.enough) {\n          throw new Error(`Stake slashing aborted because no enough staking for invoice: ${invoice.id}`);\n        }\n        // do the slash\n        const signed = await client.signSlashStakeTx({\n          tx: {\n            itx: {\n              address,\n              outputs: [\n                {\n                  owner: wallet.address,\n                  tokens: [{ address: paymentCurrency.contract, value: invoice.amount_remaining }],\n                },\n              ],\n              message: 'overdraft_exceeded',\n              data: {\n                typeUrl: 'json',\n                // @ts-ignore\n                value: {\n                  appId: wallet.address,\n                  reason: 'overdraft_exceeded',\n                  subscriptionId: subscription.id,\n                  invoiceId: invoice.id,\n                  paymentIntentId: paymentIntent.id,\n                },\n              },\n            },\n          },\n          wallet,\n        });\n        // @ts-ignore\n        const { buffer } = await client.encodeSlashStakeTx({ tx: signed });\n        // @ts-ignore\n        const txHash = await client.sendSlashStakeTx({ tx: signed, wallet }, await getGasPayerExtra(buffer));\n\n        await paymentIntent.update({\n          status: 'succeeded',\n          amount_received: invoice.amount_remaining,\n          capture_method: 'manual',\n          last_payment_error: null,\n          payment_details: {\n            arcblock: {\n              tx_hash: txHash,\n              payer:\n                subscription.overdraft_protection?.payment_details?.arcblock?.payer ||\n                getSubscriptionPaymentAddress(subscription, 'arcblock'),\n              type: 'slash',\n            },\n          },\n        });\n        logger.info('PaymentIntent updated after stake slash', {\n          subscription: subscription.id,\n          paymentIntent: paymentIntent.id,\n          status: 'succeeded',\n        });\n\n        await invoice.update({\n          status: 'paid',\n          paid: true,\n          amount_paid: invoice.amount_remaining,\n          amount_remaining: '0',\n          attempted: true,\n          attempt_count: invoice.attempt_count + 1,\n          status_transitions: { ...invoice.status_transitions, paid_at: dayjs().unix() },\n        });\n        logger.info('Invoice updated after stake slash', {\n          subscription: subscription.id,\n          invoice: invoice.id,\n          status: 'paid',\n        });\n        slashedInvoiceIds.push(invoice.id);\n      } catch (updateError) {\n        logger.error('stake slash failed', {\n          subscription: subscription.id,\n          invoice: invoice.id,\n          error: updateError,\n        });\n        throw updateError;\n      }\n    };\n\n    await Promise.all(slashInvoices.map(processInvoice));\n    logger.info(`${slashedInvoiceIds.length} invoices updated after stake slash`, {\n      subscription: subscription.id,\n      invoices: slashedInvoiceIds,\n      slashAmount: slashAmount.toString(),\n    });\n  } catch (error) {\n    logger.error('Error in slashOverdraftProtectionStake', { error });\n    throw error;\n  } finally {\n    lock.release();\n  }\n}\n\nexport async function getSubscriptionUnpaidInvoicesCount(subscription: Subscription) {\n  try {\n    const count = await Invoice.count({\n      where: {\n        subscription_id: subscription.id,\n        status: ['open', 'uncollectible'],\n        billing_reason: {\n          [Op.notIn]: ['overdraft_protection'],\n        },\n      },\n    });\n    return count;\n  } catch (error) {\n    logger.error('getSubscriptionUnpaidInvoicesCount failed', { error });\n    return 0;\n  }\n}\n\n/**\n * Calculate recommended recharge amount for subscription cycles\n * @param subscriptions List of subscriptions\n * @param currencyId Currency ID\n * @returns {amount: string, cycle: number, desc: string, interval: string} Recommended amount and cycle info\n */\nexport function calculateRecommendedRechargeAmount(subscriptions: any[], currencyId: string) {\n  if (!subscriptions || subscriptions.length === 0) {\n    return { amount: '0', cycle: 0, desc: 'no subscription', interval: '' };\n  }\n\n  type IntervalType = 'hour' | 'day' | 'month' | 'year';\n\n  // Group subscriptions by billing interval\n  const intervalSubscriptions: Record<IntervalType, any[]> = {\n    hour: [],\n    day: [],\n    month: [],\n    year: [],\n  };\n\n  // Classify subscriptions by interval\n  subscriptions.forEach((subscription) => {\n    if (!subscription.items?.length) return;\n\n    subscription.items.forEach((item: any) => {\n      const { price } = item;\n      if (price?.type === 'recurring' && price.recurring?.interval) {\n        const interval = price.recurring.interval as IntervalType;\n        if (Object.keys(intervalSubscriptions).includes(interval)) {\n          intervalSubscriptions[interval].push({ subscription, item, price });\n        }\n      }\n    });\n  });\n\n  const hasHourly = intervalSubscriptions.hour.length > 0;\n  const hasDaily = intervalSubscriptions.day.length > 0;\n  const hasMonthly = intervalSubscriptions.month.length > 0;\n  const hasYearly = intervalSubscriptions.year.length > 0;\n\n  // Determine recommended cycle based on subscription intervals\n  let recommendedInterval = '';\n  let cycleInSeconds = 0;\n  let desc = '';\n\n  if (hasMonthly) {\n    recommendedInterval = 'month';\n    cycleInSeconds = 30 * 24 * 60 * 60;\n    desc = 'monthly';\n  } else if ((hasHourly || hasDaily) && !hasYearly) {\n    recommendedInterval = 'week';\n    cycleInSeconds = 7 * 24 * 60 * 60;\n    desc = 'weekly';\n  } else if ((hasDaily || hasHourly) && hasYearly) {\n    recommendedInterval = 'month';\n    cycleInSeconds = 30 * 24 * 60 * 60;\n    desc = 'monthly';\n  } else if (hasYearly) {\n    recommendedInterval = 'year';\n    cycleInSeconds = 365 * 24 * 60 * 60;\n    desc = 'yearly';\n  }\n\n  let totalAmount = new BN(0);\n\n  // Calculate amount based on recommended cycle\n  subscriptions.forEach((subscription) => {\n    if (!subscription.items?.length) return;\n\n    subscription.items.forEach((item: any) => {\n      const { price } = item;\n      if (!price) return;\n\n      const unitAmount = getPriceUintAmountByCurrency(price, currencyId);\n      const quantity = item.quantity || 1;\n      let itemAmount = new BN(unitAmount).mul(new BN(quantity));\n\n      if (price.type === 'recurring' && price.recurring?.interval) {\n        const { interval } = price.recurring;\n        const intervalCount = price.recurring.interval_count || 1;\n\n        // Apply period conversion calculation\n        if (recommendedInterval === 'month') {\n          if (interval === 'hour') {\n            itemAmount = itemAmount.mul(new BN(720)).div(new BN(intervalCount));\n          } else if (interval === 'day') {\n            itemAmount = itemAmount.mul(new BN(30)).div(new BN(intervalCount));\n          } else if (interval === 'month') {\n            itemAmount = itemAmount.div(new BN(intervalCount));\n          } else if (interval === 'year') {\n            itemAmount = itemAmount.div(new BN(12 * intervalCount));\n          }\n        } else if (recommendedInterval === 'week') {\n          if (interval === 'hour') {\n            itemAmount = itemAmount.mul(new BN(168)).div(new BN(intervalCount));\n          } else if (interval === 'day') {\n            itemAmount = itemAmount.mul(new BN(7)).div(new BN(intervalCount));\n          }\n        }\n\n        totalAmount = totalAmount.add(itemAmount);\n      } else if (price.type === 'one_time') {\n        totalAmount = totalAmount.add(itemAmount);\n      }\n    });\n  });\n\n  return {\n    amount: totalAmount.toString(),\n    cycle: cycleInSeconds,\n    desc,\n    interval: recommendedInterval,\n  };\n}\n\nexport async function getMeterPriceIdsFromSubscription(subscription: Subscription): Promise<string[]> {\n  const subscriptionItems = (await SubscriptionItem.findAll({\n    where: { subscription_id: subscription.id },\n    include: [{ model: Price, as: 'price' }],\n  })) as (SubscriptionItem & { price: Price })[];\n\n  const meterItems = subscriptionItems.filter((x) => x.price.recurring?.meter_id);\n  return meterItems.map((m) => m.price.id);\n}\n","numLines":1802,"startLine":1,"totalLines":1802}}}
{"parentUuid":"1bfc443c-90fa-41d8-abbb-ca3206dfe093","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VYLTukurSwd538h9U2SWVM","type":"message","role":"assistant","content":[{"type":"text","text":"让我搜索 discount 相关的库文件："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34,"cache_creation_input_tokens":44858,"cache_read_input_tokens":50567,"cache_creation":{"ephemeral_5m_input_tokens":44858,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxsHwNS2zZ3kohsLUKw","type":"assistant","uuid":"c23a911a-cfb3-446e-9efa-4427d692fdba","timestamp":"2026-01-09T01:49:27.293Z"}
{"parentUuid":"c23a911a-cfb3-446e-9efa-4427d692fdba","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VYLTukurSwd538h9U2SWVM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018bsRNLpxzTtzeudcvbCooH","name":"Grep","input":{"pattern":"discount","path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs","output_mode":"files_with_matches"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34,"cache_creation_input_tokens":44858,"cache_read_input_tokens":50567,"cache_creation":{"ephemeral_5m_input_tokens":44858,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxsHwNS2zZ3kohsLUKw","type":"assistant","uuid":"7e9090d0-8633-47f6-9edf-fb4aeef385cf","timestamp":"2026-01-09T01:49:29.577Z"}
{"parentUuid":"7e9090d0-8633-47f6-9edf-fb4aeef385cf","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VYLTukurSwd538h9U2SWVM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014dDvgHwZh86Ttgbbp9J2d9","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice-item.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34,"cache_creation_input_tokens":44858,"cache_read_input_tokens":50567,"cache_creation":{"ephemeral_5m_input_tokens":44858,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxsHwNS2zZ3kohsLUKw","type":"assistant","uuid":"fe81bc8a-7082-4f81-9b93-f8c13e2a1ebc","timestamp":"2026-01-09T01:49:30.442Z"}
{"parentUuid":"fe81bc8a-7082-4f81-9b93-f8c13e2a1ebc","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VYLTukurSwd538h9U2SWVM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017MYpFgd6vY5vZLaW4ZLc9E","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription-item.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34,"cache_creation_input_tokens":44858,"cache_read_input_tokens":50567,"cache_creation":{"ephemeral_5m_input_tokens":44858,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxsHwNS2zZ3kohsLUKw","type":"assistant","uuid":"fd7a1f28-6aad-4078-a53e-cbdff5896721","timestamp":"2026-01-09T01:49:31.065Z"}
{"parentUuid":"fd7a1f28-6aad-4078-a53e-cbdff5896721","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01VYLTukurSwd538h9U2SWVM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BVW6MUhuk5tnWt4enEKk3e","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/discount.spec.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":34,"cache_creation_input_tokens":44858,"cache_read_input_tokens":50567,"cache_creation":{"ephemeral_5m_input_tokens":44858,"ephemeral_1h_input_tokens":0},"output_tokens":350,"service_tier":"standard"}},"requestId":"req_011CWvxsHwNS2zZ3kohsLUKw","type":"assistant","uuid":"3d5e7793-6041-49a9-8200-782a417ec143","timestamp":"2026-01-09T01:49:31.485Z"}
{"parentUuid":"3d5e7793-6041-49a9-8200-782a417ec143","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014dDvgHwZh86Ttgbbp9J2d9","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/indent */\n     2→/* eslint-disable @typescript-eslint/lines-between-class-members */\n     3→import { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n     4→\n     5→import { createIdGenerator } from '../../libs/util';\n     6→import type { DiscountAmount } from './types';\n     7→\n     8→export const nextInvoiceItemId = createIdGenerator('ii', 24);\n     9→\n    10→export type InvoiceLineItem = {\n    11→  id: string;\n    12→};\n    13→\n    14→// @link https://stripe.com/docs/api/invoiceitems\n    15→// eslint-disable-next-line prettier/prettier\n    16→export class InvoiceItem extends Model<InferAttributes<InvoiceItem>, InferCreationAttributes<InvoiceItem>> {\n    17→  declare id: CreationOptional<string>;\n    18→  declare livemode: boolean;\n    19→\n    20→  declare amount: string;\n    21→  declare quantity: number;\n    22→  declare description: string;\n    23→  declare period?: {\n    24→    start: number;\n    25→    end: number;\n    26→  };\n    27→\n    28→  declare currency_id: string;\n    29→  declare customer_id: string;\n    30→  declare price_id: string;\n    31→  declare invoice_id: string;\n    32→  declare subscription_id?: string;\n    33→  declare subscription_item_id?: string;\n    34→  declare test_clock_id?: string;\n    35→  declare tax_rate_id?: string;\n    36→\n    37→  declare discountable: boolean;\n    38→  declare discount_amounts: DiscountAmount[];\n    39→  declare discounts: string[];\n    40→\n    41→  declare proration: boolean;\n    42→  declare proration_details: {\n    43→    credited_items?: {\n    44→      invoice_id: string;\n    45→      invoice_line_items: string[];\n    46→    };\n    47→  };\n    48→\n    49→  declare metadata: Record<string, any>;\n    50→\n    51→  // TODO: following fields not supported\n    52→  // tax_amounts: any;\n    53→  // tax_rates: any;\n    54→  // unit_amount_excluding_tax: string;\n    55→\n    56→  declare created_at: CreationOptional<Date>;\n    57→  declare updated_at: CreationOptional<Date>;\n    58→\n    59→  public static readonly GENESIS_ATTRIBUTES = {\n    60→    id: {\n    61→      type: DataTypes.STRING(30),\n    62→      primaryKey: true,\n    63→      allowNull: false,\n    64→      defaultValue: nextInvoiceItemId,\n    65→    },\n    66→    livemode: {\n    67→      type: DataTypes.BOOLEAN,\n    68→      allowNull: false,\n    69→    },\n    70→    amount: {\n    71→      type: DataTypes.STRING(32),\n    72→      allowNull: false,\n    73→    },\n    74→    quantity: {\n    75→      type: DataTypes.INTEGER,\n    76→      allowNull: false,\n    77→    },\n    78→    description: {\n    79→      type: DataTypes.STRING(256),\n    80→      allowNull: false,\n    81→    },\n    82→    period: {\n    83→      type: DataTypes.JSON,\n    84→      allowNull: true,\n    85→    },\n    86→    customer_id: {\n    87→      type: DataTypes.STRING(18),\n    88→      allowNull: false,\n    89→    },\n    90→    currency_id: {\n    91→      type: DataTypes.STRING(15),\n    92→      allowNull: false,\n    93→    },\n    94→    price_id: {\n    95→      type: DataTypes.STRING(30),\n    96→      allowNull: false,\n    97→    },\n    98→    invoice_id: {\n    99→      type: DataTypes.STRING(30),\n   100→      allowNull: false,\n   101→    },\n   102→    subscription_id: {\n   103→      type: DataTypes.STRING(30),\n   104→      allowNull: true,\n   105→    },\n   106→    subscription_item_id: {\n   107→      type: DataTypes.STRING(30),\n   108→      allowNull: true,\n   109→    },\n   110→    tax_rate_id: {\n   111→      type: DataTypes.STRING(30),\n   112→      allowNull: true,\n   113→    },\n   114→    discountable: {\n   115→      type: DataTypes.BOOLEAN,\n   116→      allowNull: false,\n   117→    },\n   118→    // Dynamically generated?\n   119→    discount_amounts: {\n   120→      type: DataTypes.JSON,\n   121→      defaultValue: [],\n   122→    },\n   123→    discounts: {\n   124→      type: DataTypes.JSON,\n   125→      defaultValue: [],\n   126→    },\n   127→    proration: {\n   128→      type: DataTypes.BOOLEAN,\n   129→      defaultValue: false,\n   130→    },\n   131→    proration_details: {\n   132→      type: DataTypes.JSON,\n   133→      allowNull: true,\n   134→    },\n   135→    metadata: {\n   136→      type: DataTypes.JSON,\n   137→      defaultValue: {},\n   138→    },\n   139→    created_at: {\n   140→      type: DataTypes.DATE,\n   141→      defaultValue: DataTypes.NOW,\n   142→      allowNull: false,\n   143→    },\n   144→    updated_at: {\n   145→      type: DataTypes.DATE,\n   146→      defaultValue: DataTypes.NOW,\n   147→      allowNull: false,\n   148→    },\n   149→  };\n   150→\n   151→  public static initialize(sequelize: any) {\n   152→    this.init(InvoiceItem.GENESIS_ATTRIBUTES, {\n   153→      sequelize,\n   154→      modelName: 'InvoiceItem',\n   155→      tableName: 'invoice_items',\n   156→      createdAt: 'created_at',\n   157→      updatedAt: 'updated_at',\n   158→    });\n   159→  }\n   160→\n   161→  public static associate(models: any) {\n   162→    this.hasOne(models.PaymentCurrency, {\n   163→      sourceKey: 'currency_id',\n   164→      foreignKey: 'id',\n   165→      as: 'currency',\n   166→    });\n   167→    this.hasOne(models.Customer, {\n   168→      sourceKey: 'customer_id',\n   169→      foreignKey: 'id',\n   170→      as: 'customer',\n   171→    });\n   172→    this.hasOne(models.Price, {\n   173→      sourceKey: 'price_id',\n   174→      foreignKey: 'id',\n   175→      as: 'price',\n   176→    });\n   177→    this.hasOne(models.Invoice, {\n   178→      sourceKey: 'invoice_id',\n   179→      foreignKey: 'id',\n   180→      as: 'invoice',\n   181→    });\n   182→    this.hasOne(models.Subscription, {\n   183→      sourceKey: 'subscription_id',\n   184→      foreignKey: 'id',\n   185→      as: 'subscription',\n   186→    });\n   187→    this.hasOne(models.SubscriptionItem, {\n   188→      sourceKey: 'subscription_item_id',\n   189→      foreignKey: 'id',\n   190→      as: 'subscriptionItem',\n   191→    });\n   192→    this.hasOne(models.TaxRate, {\n   193→      sourceKey: 'tax_rate_id',\n   194→      foreignKey: 'id',\n   195→      as: 'tax_rate',\n   196→    });\n   197→  }\n   198→\n   199→  public static async isPriceUsed(priceId: string) {\n   200→    const count = await InvoiceItem.count({\n   201→      where: { price_id: priceId },\n   202→    });\n   203→\n   204→    return count > 0;\n   205→  }\n   206→}\n   207→\n   208→export type TInvoiceItem = InferAttributes<InvoiceItem>;\n   209→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"976df37d-1456-426e-b98f-0f5024d1ddbc","timestamp":"2026-01-09T01:49:31.631Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice-item.ts","content":"/* eslint-disable @typescript-eslint/indent */\n/* eslint-disable @typescript-eslint/lines-between-class-members */\nimport { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n\nimport { createIdGenerator } from '../../libs/util';\nimport type { DiscountAmount } from './types';\n\nexport const nextInvoiceItemId = createIdGenerator('ii', 24);\n\nexport type InvoiceLineItem = {\n  id: string;\n};\n\n// @link https://stripe.com/docs/api/invoiceitems\n// eslint-disable-next-line prettier/prettier\nexport class InvoiceItem extends Model<InferAttributes<InvoiceItem>, InferCreationAttributes<InvoiceItem>> {\n  declare id: CreationOptional<string>;\n  declare livemode: boolean;\n\n  declare amount: string;\n  declare quantity: number;\n  declare description: string;\n  declare period?: {\n    start: number;\n    end: number;\n  };\n\n  declare currency_id: string;\n  declare customer_id: string;\n  declare price_id: string;\n  declare invoice_id: string;\n  declare subscription_id?: string;\n  declare subscription_item_id?: string;\n  declare test_clock_id?: string;\n  declare tax_rate_id?: string;\n\n  declare discountable: boolean;\n  declare discount_amounts: DiscountAmount[];\n  declare discounts: string[];\n\n  declare proration: boolean;\n  declare proration_details: {\n    credited_items?: {\n      invoice_id: string;\n      invoice_line_items: string[];\n    };\n  };\n\n  declare metadata: Record<string, any>;\n\n  // TODO: following fields not supported\n  // tax_amounts: any;\n  // tax_rates: any;\n  // unit_amount_excluding_tax: string;\n\n  declare created_at: CreationOptional<Date>;\n  declare updated_at: CreationOptional<Date>;\n\n  public static readonly GENESIS_ATTRIBUTES = {\n    id: {\n      type: DataTypes.STRING(30),\n      primaryKey: true,\n      allowNull: false,\n      defaultValue: nextInvoiceItemId,\n    },\n    livemode: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    amount: {\n      type: DataTypes.STRING(32),\n      allowNull: false,\n    },\n    quantity: {\n      type: DataTypes.INTEGER,\n      allowNull: false,\n    },\n    description: {\n      type: DataTypes.STRING(256),\n      allowNull: false,\n    },\n    period: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    customer_id: {\n      type: DataTypes.STRING(18),\n      allowNull: false,\n    },\n    currency_id: {\n      type: DataTypes.STRING(15),\n      allowNull: false,\n    },\n    price_id: {\n      type: DataTypes.STRING(30),\n      allowNull: false,\n    },\n    invoice_id: {\n      type: DataTypes.STRING(30),\n      allowNull: false,\n    },\n    subscription_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    subscription_item_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    tax_rate_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    discountable: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    // Dynamically generated?\n    discount_amounts: {\n      type: DataTypes.JSON,\n      defaultValue: [],\n    },\n    discounts: {\n      type: DataTypes.JSON,\n      defaultValue: [],\n    },\n    proration: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: false,\n    },\n    proration_details: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    metadata: {\n      type: DataTypes.JSON,\n      defaultValue: {},\n    },\n    created_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n    updated_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n  };\n\n  public static initialize(sequelize: any) {\n    this.init(InvoiceItem.GENESIS_ATTRIBUTES, {\n      sequelize,\n      modelName: 'InvoiceItem',\n      tableName: 'invoice_items',\n      createdAt: 'created_at',\n      updatedAt: 'updated_at',\n    });\n  }\n\n  public static associate(models: any) {\n    this.hasOne(models.PaymentCurrency, {\n      sourceKey: 'currency_id',\n      foreignKey: 'id',\n      as: 'currency',\n    });\n    this.hasOne(models.Customer, {\n      sourceKey: 'customer_id',\n      foreignKey: 'id',\n      as: 'customer',\n    });\n    this.hasOne(models.Price, {\n      sourceKey: 'price_id',\n      foreignKey: 'id',\n      as: 'price',\n    });\n    this.hasOne(models.Invoice, {\n      sourceKey: 'invoice_id',\n      foreignKey: 'id',\n      as: 'invoice',\n    });\n    this.hasOne(models.Subscription, {\n      sourceKey: 'subscription_id',\n      foreignKey: 'id',\n      as: 'subscription',\n    });\n    this.hasOne(models.SubscriptionItem, {\n      sourceKey: 'subscription_item_id',\n      foreignKey: 'id',\n      as: 'subscriptionItem',\n    });\n    this.hasOne(models.TaxRate, {\n      sourceKey: 'tax_rate_id',\n      foreignKey: 'id',\n      as: 'tax_rate',\n    });\n  }\n\n  public static async isPriceUsed(priceId: string) {\n    const count = await InvoiceItem.count({\n      where: { price_id: priceId },\n    });\n\n    return count > 0;\n  }\n}\n\nexport type TInvoiceItem = InferAttributes<InvoiceItem>;\n","numLines":209,"startLine":1,"totalLines":209}}}
{"parentUuid":"976df37d-1456-426e-b98f-0f5024d1ddbc","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018bsRNLpxzTtzeudcvbCooH","type":"tool_result","content":"Found 7 files\napi/src/libs/session.ts\napi/src/libs/invoice.ts\napi/src/libs/invoice-quote.ts\napi/src/libs/discount/discount.ts\napi/src/libs/discount/redemption.ts\napi/src/libs/discount/nft.ts\napi/src/libs/discount/coupon.ts"}]},"uuid":"9d85f4e0-4d66-4881-9d05-57f5501964bd","timestamp":"2026-01-09T01:49:31.658Z","toolUseResult":{"mode":"files_with_matches","filenames":["api/src/libs/session.ts","api/src/libs/invoice.ts","api/src/libs/invoice-quote.ts","api/src/libs/discount/discount.ts","api/src/libs/discount/redemption.ts","api/src/libs/discount/nft.ts","api/src/libs/discount/coupon.ts"],"numFiles":7}}
{"parentUuid":"9d85f4e0-4d66-4881-9d05-57f5501964bd","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017MYpFgd6vY5vZLaW4ZLc9E","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/lines-between-class-members */\n     2→import { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n     3→\n     4→import { createIdGenerator } from '../../libs/util';\n     5→\n     6→export const nextSubscriptionItemId = createIdGenerator('si', 14);\n     7→\n     8→// eslint-disable-next-line prettier/prettier\n     9→export class SubscriptionItem extends Model<InferAttributes<SubscriptionItem>, InferCreationAttributes<SubscriptionItem>> {\n    10→  declare id: CreationOptional<string>;\n    11→  declare livemode: boolean;\n    12→\n    13→  // The identifier of the subscription this item belongs to.\n    14→  declare subscription_id: string;\n    15→\n    16→  // The price the customer is subscribed to.\n    17→  declare price_id: string;\n    18→\n    19→  declare quantity: number;\n    20→\n    21→  declare metadata: Record<string, any>;\n    22→\n    23→  declare billing_thresholds?: {\n    24→    usage_gte: number;\n    25→  };\n    26→\n    27→  // TODO: following fields not supported\n    28→  // tax_rates\n    29→\n    30→  declare created_at: CreationOptional<Date>;\n    31→  declare updated_at: CreationOptional<Date>;\n    32→\n    33→  public static readonly GENESIS_ATTRIBUTES = {\n    34→    id: {\n    35→      type: DataTypes.STRING(18),\n    36→      primaryKey: true,\n    37→      allowNull: false,\n    38→      defaultValue: nextSubscriptionItemId,\n    39→    },\n    40→    livemode: {\n    41→      type: DataTypes.BOOLEAN,\n    42→      allowNull: false,\n    43→    },\n    44→    subscription_id: {\n    45→      type: DataTypes.STRING(30),\n    46→      allowNull: false,\n    47→    },\n    48→    price_id: {\n    49→      type: DataTypes.STRING(30),\n    50→      allowNull: false,\n    51→    },\n    52→    quantity: {\n    53→      type: DataTypes.INTEGER,\n    54→      allowNull: true,\n    55→    },\n    56→    metadata: {\n    57→      type: DataTypes.JSON,\n    58→      allowNull: true,\n    59→    },\n    60→    billing_threshold: {\n    61→      type: DataTypes.JSON,\n    62→      allowNull: true,\n    63→    },\n    64→    created_at: {\n    65→      type: DataTypes.DATE,\n    66→      defaultValue: DataTypes.NOW,\n    67→      allowNull: false,\n    68→    },\n    69→    updated_at: {\n    70→      type: DataTypes.DATE,\n    71→      defaultValue: DataTypes.NOW,\n    72→      allowNull: false,\n    73→    },\n    74→  };\n    75→\n    76→  public static initialize(sequelize: any) {\n    77→    this.init(SubscriptionItem.GENESIS_ATTRIBUTES, {\n    78→      sequelize,\n    79→      modelName: 'SubscriptionItem',\n    80→      tableName: 'subscription_items',\n    81→      createdAt: 'created_at',\n    82→      updatedAt: 'updated_at',\n    83→    });\n    84→  }\n    85→\n    86→  public static associate(models: any) {\n    87→    this.belongsTo(models.Subscription, {\n    88→      foreignKey: 'subscription_id',\n    89→      as: 'subscription',\n    90→    });\n    91→    this.hasOne(models.Price, {\n    92→      sourceKey: 'price_id',\n    93→      foreignKey: 'id',\n    94→      as: 'price',\n    95→    });\n    96→  }\n    97→\n    98→  public static async isPriceUsed(priceId: string) {\n    99→    const count = await SubscriptionItem.count({\n   100→      where: { price_id: priceId },\n   101→    });\n   102→\n   103→    return count > 0;\n   104→  }\n   105→}\n   106→\n   107→export type TSubscriptionItem = InferAttributes<SubscriptionItem>;\n   108→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"5e60f0fc-8a58-40bc-b06c-a6761d26a649","timestamp":"2026-01-09T01:49:31.631Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription-item.ts","content":"/* eslint-disable @typescript-eslint/lines-between-class-members */\nimport { CreationOptional, DataTypes, InferAttributes, InferCreationAttributes, Model } from 'sequelize';\n\nimport { createIdGenerator } from '../../libs/util';\n\nexport const nextSubscriptionItemId = createIdGenerator('si', 14);\n\n// eslint-disable-next-line prettier/prettier\nexport class SubscriptionItem extends Model<InferAttributes<SubscriptionItem>, InferCreationAttributes<SubscriptionItem>> {\n  declare id: CreationOptional<string>;\n  declare livemode: boolean;\n\n  // The identifier of the subscription this item belongs to.\n  declare subscription_id: string;\n\n  // The price the customer is subscribed to.\n  declare price_id: string;\n\n  declare quantity: number;\n\n  declare metadata: Record<string, any>;\n\n  declare billing_thresholds?: {\n    usage_gte: number;\n  };\n\n  // TODO: following fields not supported\n  // tax_rates\n\n  declare created_at: CreationOptional<Date>;\n  declare updated_at: CreationOptional<Date>;\n\n  public static readonly GENESIS_ATTRIBUTES = {\n    id: {\n      type: DataTypes.STRING(18),\n      primaryKey: true,\n      allowNull: false,\n      defaultValue: nextSubscriptionItemId,\n    },\n    livemode: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    subscription_id: {\n      type: DataTypes.STRING(30),\n      allowNull: false,\n    },\n    price_id: {\n      type: DataTypes.STRING(30),\n      allowNull: false,\n    },\n    quantity: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    metadata: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    billing_threshold: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    created_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n    updated_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n  };\n\n  public static initialize(sequelize: any) {\n    this.init(SubscriptionItem.GENESIS_ATTRIBUTES, {\n      sequelize,\n      modelName: 'SubscriptionItem',\n      tableName: 'subscription_items',\n      createdAt: 'created_at',\n      updatedAt: 'updated_at',\n    });\n  }\n\n  public static associate(models: any) {\n    this.belongsTo(models.Subscription, {\n      foreignKey: 'subscription_id',\n      as: 'subscription',\n    });\n    this.hasOne(models.Price, {\n      sourceKey: 'price_id',\n      foreignKey: 'id',\n      as: 'price',\n    });\n  }\n\n  public static async isPriceUsed(priceId: string) {\n    const count = await SubscriptionItem.count({\n      where: { price_id: priceId },\n    });\n\n    return count > 0;\n  }\n}\n\nexport type TSubscriptionItem = InferAttributes<SubscriptionItem>;\n","numLines":108,"startLine":1,"totalLines":108}}}
{"parentUuid":"5e60f0fc-8a58-40bc-b06c-a6761d26a649","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BVW6MUhuk5tnWt4enEKk3e","type":"tool_result","content":"     1→import {\n     2→  applyDiscountsToLineItems,\n     3→  applySubscriptionDiscount,\n     4→  rollbackDiscountUsageForCheckoutSession,\n     5→} from '../../src/libs/discount/discount';\n     6→import { Coupon, Discount, CheckoutSession } from '../../src/store/models';\n     7→\n     8→// Mock logger and event emitter to keep test output clean\n     9→jest.mock('../../src/libs/logger', () => ({\n    10→  __esModule: true,\n    11→  default: {\n    12→    info: jest.fn(),\n    13→    warn: jest.fn(),\n    14→    error: jest.fn(),\n    15→    debug: jest.fn(),\n    16→  },\n    17→}));\n    18→\n    19→jest.mock('../../src/libs/event', () => ({\n    20→  emitAsync: jest.fn(),\n    21→}));\n    22→\n    23→// Mock price util so we can control unit amounts per item\n    24→jest.mock('../../src/libs/price', () => ({\n    25→  getPriceUintAmountByCurrency: (price: any, currencyId: string) => {\n    26→    if (!price) return '0';\n    27→    if (price.unit_amount_map && price.unit_amount_map[currencyId]) return String(price.unit_amount_map[currencyId]);\n    28→    if (price.unit_amount) return String(price.unit_amount);\n    29→    if (Array.isArray(price.currency_options)) {\n    30→      const opt = price.currency_options.find((c: any) => c.currency_id === currencyId);\n    31→      return String(opt?.unit_amount || '0');\n    32→    }\n    33→    return '0';\n    34→  },\n    35→}));\n    36→\n    37→describe('libs/discount/discount.ts', () => {\n    38→  const currency = { id: 'usd', decimal: 2, symbol: 'USD' } as any;\n    39→\n    40→  beforeEach(() => {\n    41→    jest.clearAllMocks();\n    42→    jest.restoreAllMocks();\n    43→  });\n    44→\n    45→  describe('applyDiscountsToLineItems - percent_off over eligible items', () => {\n    46→    it('applies percentage discount only to eligible products and returns per-item breakdown', async () => {\n    47→      const lineItems: any[] = [\n    48→        {\n    49→          id: 'li_1',\n    50→          quantity: 1,\n    51→          price: { product_id: 'p1', unit_amount_map: { usd: '100' } },\n    52→        },\n    53→        {\n    54→          id: 'li_2',\n    55→          quantity: 3,\n    56→          price: { product_id: 'p2', unit_amount_map: { usd: '100' } }, // amount 300\n    57→        },\n    58→        {\n    59→          id: 'li_3',\n    60→          quantity: 2,\n    61→          price: { product_id: 'p3', unit_amount_map: { usd: '50' } }, // ineligible\n    62→        },\n    63→      ];\n    64→\n    65→      jest.spyOn(Coupon, 'findByPk').mockResolvedValue({\n    66→        id: 'c1',\n    67→        percent_off: 50,\n    68→        amount_off: null,\n    69→        applies_to: { products: ['p1', 'p2'] },\n    70→        valid: true,\n    71→      } as any);\n    72→\n    73→      // Force coupon validation to pass\n    74→      const couponModule = await import('../../src/libs/discount/coupon');\n    75→      jest.spyOn(couponModule, 'validCoupon').mockReturnValue({ valid: true } as any);\n    76→\n    77→      const result = await applyDiscountsToLineItems({\n    78→        lineItems,\n    79→        couponId: 'c1',\n    80→        customerId: 'cust_1',\n    81→        currency,\n    82→      });\n    83→\n    84→      const { enhancedLineItems, discountSummary } = result;\n    85→      // li_1 amount=100 -> 50% => 50; li_2 amount=300 -> 150; li_3 ineligible\n    86→      const li1 = enhancedLineItems.find((x: any) => x.id === 'li_1');\n    87→      const li2 = enhancedLineItems.find((x: any) => x.id === 'li_2');\n    88→      const li3 = enhancedLineItems.find((x: any) => x.id === 'li_3');\n    89→\n    90→      expect(li1).toBeDefined();\n    91→      expect(li2).toBeDefined();\n    92→      expect(li3).toBeDefined();\n    93→      expect((li1 as any).discountable).toBe(true);\n    94→      expect((li1 as any).discount_amounts[0].amount).toBe('50');\n    95→      expect((li2 as any).discountable).toBe(true);\n    96→      expect((li2 as any).discount_amounts[0].amount).toBe('150');\n    97→      expect((li3 as any).discountable).toBe(false);\n    98→\n    99→      expect(discountSummary.appliedCoupon).toBe('c1');\n   100→      expect(discountSummary.totalDiscountAmount).toBe('200');\n   101→      // base total = 100 + 300 + 100 = 500; final = 300\n   102→      expect(discountSummary.finalTotal).toBe('300');\n   103→      expect(result.notValidReason).toBeUndefined();\n   104→    });\n   105→  });\n   106→\n   107→  describe('applyDiscountsToLineItems - amount_off distributed proportionally', () => {\n   108→    it('distributes fixed amount discount proportionally among eligible items', async () => {\n   109→      const lineItems: any[] = [\n   110→        { id: 'a', quantity: 1, price: { product_id: 'pa', unit_amount_map: { usd: '100' } } },\n   111→        { id: 'b', quantity: 3, price: { product_id: 'pb', unit_amount_map: { usd: '100' } } }, // 300\n   112→      ];\n   113→\n   114→      jest.spyOn(Coupon, 'findByPk').mockResolvedValue({\n   115→        id: 'c2',\n   116→        percent_off: 0,\n   117→        amount_off: '150',\n   118→        currency_id: 'usd',\n   119→        applies_to: { products: [] },\n   120→        valid: true,\n   121→      } as any);\n   122→\n   123→      const couponModule = await import('../../src/libs/discount/coupon');\n   124→      jest.spyOn(couponModule, 'validCoupon').mockReturnValue({ valid: true } as any);\n   125→\n   126→      const { enhancedLineItems, discountSummary } = await applyDiscountsToLineItems({\n   127→        lineItems,\n   128→        couponId: 'c2',\n   129→        customerId: 'cust_1',\n   130→        currency,\n   131→      });\n   132→\n   133→      // Total eligible = 400; adjustedDiscount=150\n   134→      // a: 100/400 * 150 = 37; b: 300/400 * 150 = 112 (integer division)\n   135→      const a = enhancedLineItems.find((x: any) => x.id === 'a');\n   136→      const b = enhancedLineItems.find((x: any) => x.id === 'b');\n   137→      expect(a).toBeDefined();\n   138→      expect(b).toBeDefined();\n   139→      expect((a as any).discount_amounts[0].amount).toBe('37');\n   140→      expect((b as any).discount_amounts[0].amount).toBe('112');\n   141→      expect(discountSummary.totalDiscountAmount).toBe('150');\n   142→      expect(discountSummary.finalTotal).toBe('250');\n   143→    });\n   144→  });\n   145→\n   146→  describe('applyDiscountsToLineItems - invalid or missing coupon', () => {\n   147→    it('returns not valid when coupon not found', async () => {\n   148→      jest.spyOn(Coupon, 'findByPk').mockResolvedValue(null as any);\n   149→      const { discountSummary, notValidReason } = await applyDiscountsToLineItems({\n   150→        lineItems: [{ id: 'x', quantity: 1, price: { product_id: 'p1', unit_amount_map: { usd: '100' } } }] as any,\n   151→        couponId: 'missing',\n   152→        customerId: 'cust_1',\n   153→        currency,\n   154→      });\n   155→      expect(discountSummary.totalDiscountAmount).toBe('0');\n   156→      expect(notValidReason).toBe('Coupon not found');\n   157→    });\n   158→\n   159→    it('returns not valid when validation fails', async () => {\n   160→      jest.spyOn(Coupon, 'findByPk').mockResolvedValue({ id: 'c3', valid: false } as any);\n   161→      const couponModule = await import('../../src/libs/discount/coupon');\n   162→      jest.spyOn(couponModule, 'validCoupon').mockReturnValue({ valid: false, reason: 'invalid' } as any);\n   163→\n   164→      const res = await applyDiscountsToLineItems({\n   165→        lineItems: [{ id: 'x', quantity: 1, price: { product_id: 'p1', unit_amount_map: { usd: '100' } } }] as any,\n   166→        couponId: 'c3',\n   167→        customerId: 'cust_1',\n   168→        currency,\n   169→      });\n   170→      expect(res.discountSummary.totalDiscountAmount).toBe('0');\n   171→      expect(res.notValidReason).toBe('invalid');\n   172→    });\n   173→  });\n   174→\n   175→  describe('applySubscriptionDiscount', () => {\n   176→    it('returns computed discount when coupon exists', async () => {\n   177→      const items: any[] = [{ id: 'a', quantity: 2, price: { product_id: 'pa', unit_amount_map: { usd: '50' } } }];\n   178→\n   179→      jest.spyOn(Coupon, 'findByPk').mockResolvedValue({\n   180→        id: 'c4',\n   181→        percent_off: 20,\n   182→        applies_to: { products: [] },\n   183→        valid: true,\n   184→      } as any);\n   185→\n   186→      const result = await applySubscriptionDiscount({\n   187→        lineItems: items as any,\n   188→        discount: { coupon_id: 'c4', id: 'd1' } as any,\n   189→        currency,\n   190→      });\n   191→\n   192→      expect(result.discountSummary.appliedCoupon).toBe('c4');\n   193→      // amount = 2*50=100; 20% => 20; final 80\n   194→      expect(result.discountSummary.totalDiscountAmount).toBe('20');\n   195→      expect(result.discountSummary.finalTotal).toBe('80');\n   196→    });\n   197→\n   198→    it('returns original items when coupon missing', async () => {\n   199→      jest.spyOn(Coupon, 'findByPk').mockResolvedValue(null as any);\n   200→      const items: any[] = [{ id: 'a', quantity: 1, price: { unit_amount_map: { usd: '100' } } }];\n   201→      const res = await applySubscriptionDiscount({\n   202→        lineItems: items as any,\n   203→        discount: { coupon_id: 'missing', id: 'd2' } as any,\n   204→        currency,\n   205→      });\n   206→      expect(res.discountSummary.totalDiscountAmount).toBe('0');\n   207→      expect((res.enhancedLineItems[0] as any).discountable).toBe(false);\n   208→      expect(res.discountSummary.finalTotal).toBe('100');\n   209→    });\n   210→  });\n   211→\n   212→  describe('rollbackDiscountUsageForCheckoutSession', () => {\n   213→    it('rolls back confirmed discounts and destroys records', async () => {\n   214→      jest.spyOn(CheckoutSession, 'findByPk').mockResolvedValue({ id: 'cs_1', status: 'open' } as any);\n   215→\n   216→      const coupon = { id: 'c1', times_redeemed: 2, update: jest.fn().mockResolvedValue(undefined) } as any;\n   217→      const pc = { id: 'pc1', times_redeemed: 3, update: jest.fn().mockResolvedValue(undefined) } as any;\n   218→\n   219→      const discounts = [\n   220→        { id: 'd1', confirmed: true, coupon, promotionCode: pc, destroy: jest.fn().mockResolvedValue(undefined) },\n   221→        { id: 'd2', confirmed: true, coupon, promotionCode: pc, destroy: jest.fn().mockResolvedValue(undefined) },\n   222→        { id: 'd3', confirmed: false, coupon, promotionCode: pc, destroy: jest.fn().mockResolvedValue(undefined) },\n   223→      ] as any;\n   224→\n   225→      jest.spyOn(Discount, 'findAll').mockResolvedValue(discounts);\n   226→\n   227→      await rollbackDiscountUsageForCheckoutSession('cs_1');\n   228→\n   229→      // For unique coupon and promotion code, update should be called once each\n   230→      expect(coupon.update).toHaveBeenCalledWith({ times_redeemed: 1, valid: true });\n   231→      expect(pc.update).toHaveBeenCalledWith({ times_redeemed: 2, active: true });\n   232→      // All discounts should be destroyed\n   233→      discounts.forEach((d: any) => expect(d.destroy).toHaveBeenCalled());\n   234→    });\n   235→\n   236→    it('early returns when session not found or completed', async () => {\n   237→      const findByPkSpy = jest.spyOn(CheckoutSession, 'findByPk');\n   238→      const discountFindAllSpy = jest.spyOn(Discount, 'findAll');\n   239→\n   240→      findByPkSpy.mockResolvedValueOnce(null as any);\n   241→      await rollbackDiscountUsageForCheckoutSession('missing');\n   242→\n   243→      findByPkSpy.mockResolvedValueOnce({ id: 'cs_2', status: 'complete' } as any);\n   244→      await rollbackDiscountUsageForCheckoutSession('cs_2');\n   245→\n   246→      // Should not query discounts in either case\n   247→      expect(discountFindAllSpy).not.toHaveBeenCalled();\n   248→    });\n   249→  });\n   250→});\n   251→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"43940c55-e164-440f-ab6d-01487cfccd63","timestamp":"2026-01-09T01:49:31.631Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/discount.spec.ts","content":"import {\n  applyDiscountsToLineItems,\n  applySubscriptionDiscount,\n  rollbackDiscountUsageForCheckoutSession,\n} from '../../src/libs/discount/discount';\nimport { Coupon, Discount, CheckoutSession } from '../../src/store/models';\n\n// Mock logger and event emitter to keep test output clean\njest.mock('../../src/libs/logger', () => ({\n  __esModule: true,\n  default: {\n    info: jest.fn(),\n    warn: jest.fn(),\n    error: jest.fn(),\n    debug: jest.fn(),\n  },\n}));\n\njest.mock('../../src/libs/event', () => ({\n  emitAsync: jest.fn(),\n}));\n\n// Mock price util so we can control unit amounts per item\njest.mock('../../src/libs/price', () => ({\n  getPriceUintAmountByCurrency: (price: any, currencyId: string) => {\n    if (!price) return '0';\n    if (price.unit_amount_map && price.unit_amount_map[currencyId]) return String(price.unit_amount_map[currencyId]);\n    if (price.unit_amount) return String(price.unit_amount);\n    if (Array.isArray(price.currency_options)) {\n      const opt = price.currency_options.find((c: any) => c.currency_id === currencyId);\n      return String(opt?.unit_amount || '0');\n    }\n    return '0';\n  },\n}));\n\ndescribe('libs/discount/discount.ts', () => {\n  const currency = { id: 'usd', decimal: 2, symbol: 'USD' } as any;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    jest.restoreAllMocks();\n  });\n\n  describe('applyDiscountsToLineItems - percent_off over eligible items', () => {\n    it('applies percentage discount only to eligible products and returns per-item breakdown', async () => {\n      const lineItems: any[] = [\n        {\n          id: 'li_1',\n          quantity: 1,\n          price: { product_id: 'p1', unit_amount_map: { usd: '100' } },\n        },\n        {\n          id: 'li_2',\n          quantity: 3,\n          price: { product_id: 'p2', unit_amount_map: { usd: '100' } }, // amount 300\n        },\n        {\n          id: 'li_3',\n          quantity: 2,\n          price: { product_id: 'p3', unit_amount_map: { usd: '50' } }, // ineligible\n        },\n      ];\n\n      jest.spyOn(Coupon, 'findByPk').mockResolvedValue({\n        id: 'c1',\n        percent_off: 50,\n        amount_off: null,\n        applies_to: { products: ['p1', 'p2'] },\n        valid: true,\n      } as any);\n\n      // Force coupon validation to pass\n      const couponModule = await import('../../src/libs/discount/coupon');\n      jest.spyOn(couponModule, 'validCoupon').mockReturnValue({ valid: true } as any);\n\n      const result = await applyDiscountsToLineItems({\n        lineItems,\n        couponId: 'c1',\n        customerId: 'cust_1',\n        currency,\n      });\n\n      const { enhancedLineItems, discountSummary } = result;\n      // li_1 amount=100 -> 50% => 50; li_2 amount=300 -> 150; li_3 ineligible\n      const li1 = enhancedLineItems.find((x: any) => x.id === 'li_1');\n      const li2 = enhancedLineItems.find((x: any) => x.id === 'li_2');\n      const li3 = enhancedLineItems.find((x: any) => x.id === 'li_3');\n\n      expect(li1).toBeDefined();\n      expect(li2).toBeDefined();\n      expect(li3).toBeDefined();\n      expect((li1 as any).discountable).toBe(true);\n      expect((li1 as any).discount_amounts[0].amount).toBe('50');\n      expect((li2 as any).discountable).toBe(true);\n      expect((li2 as any).discount_amounts[0].amount).toBe('150');\n      expect((li3 as any).discountable).toBe(false);\n\n      expect(discountSummary.appliedCoupon).toBe('c1');\n      expect(discountSummary.totalDiscountAmount).toBe('200');\n      // base total = 100 + 300 + 100 = 500; final = 300\n      expect(discountSummary.finalTotal).toBe('300');\n      expect(result.notValidReason).toBeUndefined();\n    });\n  });\n\n  describe('applyDiscountsToLineItems - amount_off distributed proportionally', () => {\n    it('distributes fixed amount discount proportionally among eligible items', async () => {\n      const lineItems: any[] = [\n        { id: 'a', quantity: 1, price: { product_id: 'pa', unit_amount_map: { usd: '100' } } },\n        { id: 'b', quantity: 3, price: { product_id: 'pb', unit_amount_map: { usd: '100' } } }, // 300\n      ];\n\n      jest.spyOn(Coupon, 'findByPk').mockResolvedValue({\n        id: 'c2',\n        percent_off: 0,\n        amount_off: '150',\n        currency_id: 'usd',\n        applies_to: { products: [] },\n        valid: true,\n      } as any);\n\n      const couponModule = await import('../../src/libs/discount/coupon');\n      jest.spyOn(couponModule, 'validCoupon').mockReturnValue({ valid: true } as any);\n\n      const { enhancedLineItems, discountSummary } = await applyDiscountsToLineItems({\n        lineItems,\n        couponId: 'c2',\n        customerId: 'cust_1',\n        currency,\n      });\n\n      // Total eligible = 400; adjustedDiscount=150\n      // a: 100/400 * 150 = 37; b: 300/400 * 150 = 112 (integer division)\n      const a = enhancedLineItems.find((x: any) => x.id === 'a');\n      const b = enhancedLineItems.find((x: any) => x.id === 'b');\n      expect(a).toBeDefined();\n      expect(b).toBeDefined();\n      expect((a as any).discount_amounts[0].amount).toBe('37');\n      expect((b as any).discount_amounts[0].amount).toBe('112');\n      expect(discountSummary.totalDiscountAmount).toBe('150');\n      expect(discountSummary.finalTotal).toBe('250');\n    });\n  });\n\n  describe('applyDiscountsToLineItems - invalid or missing coupon', () => {\n    it('returns not valid when coupon not found', async () => {\n      jest.spyOn(Coupon, 'findByPk').mockResolvedValue(null as any);\n      const { discountSummary, notValidReason } = await applyDiscountsToLineItems({\n        lineItems: [{ id: 'x', quantity: 1, price: { product_id: 'p1', unit_amount_map: { usd: '100' } } }] as any,\n        couponId: 'missing',\n        customerId: 'cust_1',\n        currency,\n      });\n      expect(discountSummary.totalDiscountAmount).toBe('0');\n      expect(notValidReason).toBe('Coupon not found');\n    });\n\n    it('returns not valid when validation fails', async () => {\n      jest.spyOn(Coupon, 'findByPk').mockResolvedValue({ id: 'c3', valid: false } as any);\n      const couponModule = await import('../../src/libs/discount/coupon');\n      jest.spyOn(couponModule, 'validCoupon').mockReturnValue({ valid: false, reason: 'invalid' } as any);\n\n      const res = await applyDiscountsToLineItems({\n        lineItems: [{ id: 'x', quantity: 1, price: { product_id: 'p1', unit_amount_map: { usd: '100' } } }] as any,\n        couponId: 'c3',\n        customerId: 'cust_1',\n        currency,\n      });\n      expect(res.discountSummary.totalDiscountAmount).toBe('0');\n      expect(res.notValidReason).toBe('invalid');\n    });\n  });\n\n  describe('applySubscriptionDiscount', () => {\n    it('returns computed discount when coupon exists', async () => {\n      const items: any[] = [{ id: 'a', quantity: 2, price: { product_id: 'pa', unit_amount_map: { usd: '50' } } }];\n\n      jest.spyOn(Coupon, 'findByPk').mockResolvedValue({\n        id: 'c4',\n        percent_off: 20,\n        applies_to: { products: [] },\n        valid: true,\n      } as any);\n\n      const result = await applySubscriptionDiscount({\n        lineItems: items as any,\n        discount: { coupon_id: 'c4', id: 'd1' } as any,\n        currency,\n      });\n\n      expect(result.discountSummary.appliedCoupon).toBe('c4');\n      // amount = 2*50=100; 20% => 20; final 80\n      expect(result.discountSummary.totalDiscountAmount).toBe('20');\n      expect(result.discountSummary.finalTotal).toBe('80');\n    });\n\n    it('returns original items when coupon missing', async () => {\n      jest.spyOn(Coupon, 'findByPk').mockResolvedValue(null as any);\n      const items: any[] = [{ id: 'a', quantity: 1, price: { unit_amount_map: { usd: '100' } } }];\n      const res = await applySubscriptionDiscount({\n        lineItems: items as any,\n        discount: { coupon_id: 'missing', id: 'd2' } as any,\n        currency,\n      });\n      expect(res.discountSummary.totalDiscountAmount).toBe('0');\n      expect((res.enhancedLineItems[0] as any).discountable).toBe(false);\n      expect(res.discountSummary.finalTotal).toBe('100');\n    });\n  });\n\n  describe('rollbackDiscountUsageForCheckoutSession', () => {\n    it('rolls back confirmed discounts and destroys records', async () => {\n      jest.spyOn(CheckoutSession, 'findByPk').mockResolvedValue({ id: 'cs_1', status: 'open' } as any);\n\n      const coupon = { id: 'c1', times_redeemed: 2, update: jest.fn().mockResolvedValue(undefined) } as any;\n      const pc = { id: 'pc1', times_redeemed: 3, update: jest.fn().mockResolvedValue(undefined) } as any;\n\n      const discounts = [\n        { id: 'd1', confirmed: true, coupon, promotionCode: pc, destroy: jest.fn().mockResolvedValue(undefined) },\n        { id: 'd2', confirmed: true, coupon, promotionCode: pc, destroy: jest.fn().mockResolvedValue(undefined) },\n        { id: 'd3', confirmed: false, coupon, promotionCode: pc, destroy: jest.fn().mockResolvedValue(undefined) },\n      ] as any;\n\n      jest.spyOn(Discount, 'findAll').mockResolvedValue(discounts);\n\n      await rollbackDiscountUsageForCheckoutSession('cs_1');\n\n      // For unique coupon and promotion code, update should be called once each\n      expect(coupon.update).toHaveBeenCalledWith({ times_redeemed: 1, valid: true });\n      expect(pc.update).toHaveBeenCalledWith({ times_redeemed: 2, active: true });\n      // All discounts should be destroyed\n      discounts.forEach((d: any) => expect(d.destroy).toHaveBeenCalled());\n    });\n\n    it('early returns when session not found or completed', async () => {\n      const findByPkSpy = jest.spyOn(CheckoutSession, 'findByPk');\n      const discountFindAllSpy = jest.spyOn(Discount, 'findAll');\n\n      findByPkSpy.mockResolvedValueOnce(null as any);\n      await rollbackDiscountUsageForCheckoutSession('missing');\n\n      findByPkSpy.mockResolvedValueOnce({ id: 'cs_2', status: 'complete' } as any);\n      await rollbackDiscountUsageForCheckoutSession('cs_2');\n\n      // Should not query discounts in either case\n      expect(discountFindAllSpy).not.toHaveBeenCalled();\n    });\n  });\n});\n","numLines":251,"startLine":1,"totalLines":251}}}
{"parentUuid":"43940c55-e164-440f-ab6d-01487cfccd63","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JcmdwfcW7HKbQZ35D7zC5x","type":"message","role":"assistant","content":[{"type":"text","text":"现在读取 discount 库文件："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8552,"cache_read_input_tokens":95425,"cache_creation":{"ephemeral_5m_input_tokens":8552,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxsxPQaUQKmUuxqQn5z","type":"assistant","uuid":"05fc90ce-b37c-4af5-934f-e5cfe6825c35","timestamp":"2026-01-09T01:49:36.674Z"}
{"parentUuid":"05fc90ce-b37c-4af5-934f-e5cfe6825c35","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JcmdwfcW7HKbQZ35D7zC5x","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014HFAxJ67JyTTMcCb2K5NFT","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/discount.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8552,"cache_read_input_tokens":95425,"cache_creation":{"ephemeral_5m_input_tokens":8552,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxsxPQaUQKmUuxqQn5z","type":"assistant","uuid":"9948ae9e-9c7e-4eb2-bccd-9f0929d7439b","timestamp":"2026-01-09T01:49:38.715Z"}
{"parentUuid":"9948ae9e-9c7e-4eb2-bccd-9f0929d7439b","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JcmdwfcW7HKbQZ35D7zC5x","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PSGbksgs5FBXYHd24dKerQ","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8552,"cache_read_input_tokens":95425,"cache_creation":{"ephemeral_5m_input_tokens":8552,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxsxPQaUQKmUuxqQn5z","type":"assistant","uuid":"094089d5-cb27-46f5-8646-f93287a37cfa","timestamp":"2026-01-09T01:49:39.101Z"}
{"parentUuid":"094089d5-cb27-46f5-8646-f93287a37cfa","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01JcmdwfcW7HKbQZ35D7zC5x","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Eja6TAoHbzB5E7zX5FjjTV","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/promotion-code.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":8552,"cache_read_input_tokens":95425,"cache_creation":{"ephemeral_5m_input_tokens":8552,"ephemeral_1h_input_tokens":0},"output_tokens":242,"service_tier":"standard"}},"requestId":"req_011CWvxsxPQaUQKmUuxqQn5z","type":"assistant","uuid":"ab336865-7799-4ef1-a951-10c15170cc0f","timestamp":"2026-01-09T01:49:39.648Z"}
{"parentUuid":"ab336865-7799-4ef1-a951-10c15170cc0f","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014HFAxJ67JyTTMcCb2K5NFT","type":"tool_result","content":"     1→import { BN } from '@ocap/util';\n     2→import { Coupon, Discount, PaymentCurrency, PromotionCode, CheckoutSession } from '../../store/models';\n     3→import type { TLineItemExpanded } from '../../store/models';\n     4→import { getPriceUintAmountByCurrency } from '../price';\n     5→import { validCoupon, checkPromotionCodeEligibility, calculateDiscountAmount } from './coupon';\n     6→import { emitAsync } from '../event';\n     7→import logger from '../logger';\n     8→\n     9→const getItemsTotalAmount = (lineItems: TLineItemExpanded[], currencyId: string, options?: { trialing?: boolean }) => {\n    10→  let totalUnitPrice = new BN(0);\n    11→\n    12→  lineItems.forEach((item) => {\n    13→    const price = item.upsell_price || item.price;\n    14→    // TODO: why use custom_amount and quoted_amount instead of the price.unit_amount?\n    15→    const dynamicAmount =\n    16→      price?.pricing_type === 'dynamic' ? (item as any).custom_amount || (item as any).quoted_amount : undefined;\n    17→    const unitPrice = getPriceUintAmountByCurrency(price, currencyId);\n    18→\n    19→    if (price?.type === 'recurring') {\n    20→      if (options?.trialing) {\n    21→        return;\n    22→      }\n    23→      if (price?.recurring?.usage_type === 'metered') {\n    24→        return;\n    25→      }\n    26→    }\n    27→\n    28→    if (dynamicAmount) {\n    29→      totalUnitPrice = totalUnitPrice.add(new BN(dynamicAmount));\n    30→      return;\n    31→    }\n    32→\n    33→    totalUnitPrice = totalUnitPrice.add(new BN(unitPrice).mul(new BN(item.quantity)));\n    34→  });\n    35→  return totalUnitPrice.toString();\n    36→};\n    37→\n    38→const getItemAmount = (item: TLineItemExpanded, currencyId: string) => {\n    39→  const price = item.upsell_price || item.price;\n    40→  const dynamicAmount =\n    41→    price?.pricing_type === 'dynamic' ? (item as any).custom_amount || (item as any).quoted_amount : undefined;\n    42→  if (dynamicAmount) {\n    43→    return new BN(dynamicAmount).toString();\n    44→  }\n    45→  const unitPrice = getPriceUintAmountByCurrency(price, currencyId);\n    46→  return new BN(unitPrice).mul(new BN(item.quantity)).toString();\n    47→};\n    48→\n    49→/**\n    50→ * Apply discounts to line items and calculate discount summary\n    51→ */\n    52→export async function applyDiscountsToLineItems({\n    53→  lineItems,\n    54→  promotionCodeId,\n    55→  couponId,\n    56→  discountId,\n    57→  customerId,\n    58→  currency,\n    59→  totalAmount,\n    60→  billingContext,\n    61→}: {\n    62→  lineItems: TLineItemExpanded[];\n    63→  promotionCodeId?: string;\n    64→  discountId?: string;\n    65→  couponId: string;\n    66→  customerId: string;\n    67→  currency: PaymentCurrency;\n    68→  totalAmount?: string; // Optional, will calculate from lineItems if not provided\n    69→  billingContext?: { trialing?: boolean };\n    70→}): Promise<{\n    71→  enhancedLineItems: (TLineItemExpanded & {\n    72→    discountable: boolean;\n    73→    discount_amounts: Array<{ amount: string; coupon: string }>;\n    74→  })[];\n    75→  discountSummary: {\n    76→    appliedCoupon: string | null;\n    77→    discountAmount: string;\n    78→    totalDiscountAmount: string;\n    79→    finalTotal: string;\n    80→  };\n    81→  notValidReason?: string;\n    82→}> {\n    83→  let discount = null;\n    84→  if (discountId) {\n    85→    discount = await Discount.findByPk(discountId);\n    86→  }\n    87→\n    88→  // 1. Calculate total amount from lineItems if not provided, considering billing context\n    89→  const baseTotal = totalAmount ?? getItemsTotalAmount(lineItems, currency.id, billingContext);\n    90→\n    91→  // 2. Get coupon (required)\n    92→  const coupon = await Coupon.findByPk(discount?.coupon_id || couponId);\n    93→  if (!coupon) {\n    94→    // 3. If couponId doesn't exist, return original items\n    95→    const enhancedLineItems = lineItems.map((item) => ({\n    96→      ...item,\n    97→      discountable: false,\n    98→      discount_amounts: [],\n    99→    }));\n   100→    return {\n   101→      enhancedLineItems,\n   102→      discountSummary: {\n   103→        appliedCoupon: null,\n   104→        discountAmount: '0',\n   105→        totalDiscountAmount: '0',\n   106→        finalTotal: baseTotal,\n   107→      },\n   108→      notValidReason: 'Coupon not found',\n   109→    };\n   110→  }\n   111→\n   112→  let isValid = false;\n   113→  let notValidReason = '';\n   114→\n   115→  // 4. Validate coupon eligibility\n   116→  if (promotionCodeId || discount?.promotion_code_id) {\n   117→    // Get promotion code and use comprehensive validation\n   118→    const promotionCode = await PromotionCode.findByPk(promotionCodeId || discount?.promotion_code_id);\n   119→    if (!promotionCode) {\n   120→      isValid = false;\n   121→    } else {\n   122→      const eligibility = await checkPromotionCodeEligibility({\n   123→        promotionCode,\n   124→        couponId,\n   125→        customerId,\n   126→        amount: baseTotal,\n   127→        currencyId: currency.id,\n   128→        lineItems,\n   129→      });\n   130→      isValid = eligibility.eligible;\n   131→      notValidReason = eligibility.reason || '';\n   132→    }\n   133→  } else {\n   134→    // Direct coupon validation\n   135→    const couponValidation = await validCoupon(coupon, lineItems);\n   136→    isValid = couponValidation.valid;\n   137→    notValidReason = couponValidation.reason || '';\n   138→  }\n   139→\n   140→  if (!isValid) {\n   141→    // Return original items if validation fails\n   142→    const enhancedLineItems = lineItems.map((item) => ({\n   143→      ...item,\n   144→      discountable: false,\n   145→      discount_amounts: [],\n   146→    }));\n   147→    return {\n   148→      enhancedLineItems,\n   149→      discountSummary: {\n   150→        appliedCoupon: null,\n   151→        discountAmount: '0',\n   152→        totalDiscountAmount: '0',\n   153→        finalTotal: baseTotal,\n   154→      },\n   155→      notValidReason,\n   156→    };\n   157→  }\n   158→\n   159→  // Use common calculation logic\n   160→  const result = calculateDiscountForLineItems({\n   161→    lineItems,\n   162→    coupon,\n   163→    discount,\n   164→    currency,\n   165→    totalAmount,\n   166→    billingContext,\n   167→  });\n   168→\n   169→  return {\n   170→    ...result,\n   171→    notValidReason: undefined, // No validation error if we reach here\n   172→  };\n   173→}\n   174→\n   175→/**\n   176→ * Common discount calculation logic\n   177→ */\n   178→function calculateDiscountForLineItems({\n   179→  lineItems,\n   180→  coupon,\n   181→  discount,\n   182→  currency,\n   183→  totalAmount,\n   184→  billingContext,\n   185→}: {\n   186→  lineItems: TLineItemExpanded[];\n   187→  coupon: Coupon;\n   188→  discount?: Discount | null;\n   189→  currency: PaymentCurrency;\n   190→  totalAmount?: string;\n   191→  billingContext?: { trialing?: boolean };\n   192→}): {\n   193→  enhancedLineItems: (TLineItemExpanded & {\n   194→    discountable: boolean;\n   195→    discount_amounts: Array<{ amount: string; coupon: string }>;\n   196→  })[];\n   197→  discountSummary: {\n   198→    appliedCoupon: string | null;\n   199→    discountAmount: string;\n   200→    totalDiscountAmount: string;\n   201→    finalTotal: string;\n   202→  };\n   203→} {\n   204→  // 1. Calculate total amount from lineItems if not provided, considering billing context\n   205→  const baseTotal = totalAmount ?? getItemsTotalAmount(lineItems, currency.id, billingContext);\n   206→\n   207→  // 2. Get all eligible items based on coupon product restrictions\n   208→  const eligibleLineItems = lineItems.filter((item) => {\n   209→    if (!coupon.applies_to?.products?.length) {\n   210→      return true; // No product restriction, all items eligible\n   211→    }\n   212→    return coupon.applies_to.products.some((productId) => item.price?.product_id === productId);\n   213→  });\n   214→\n   215→  if (eligibleLineItems.length === 0) {\n   216→    // No eligible items, return original\n   217→    const enhancedLineItems = lineItems.map((item) => ({\n   218→      ...item,\n   219→      discountable: false,\n   220→      discount_amounts: [],\n   221→    }));\n   222→    return {\n   223→      enhancedLineItems,\n   224→      discountSummary: {\n   225→        appliedCoupon: null,\n   226→        discountAmount: '0',\n   227→        totalDiscountAmount: '0',\n   228→        finalTotal: baseTotal,\n   229→      },\n   230→    };\n   231→  }\n   232→\n   233→  // 3. Calculate total eligible amount (only products that qualify for the discount)\n   234→  const totalEligibleAmount = eligibleLineItems.reduce((sum, item) => {\n   235→    const itemAmount = getItemAmount(item, currency.id);\n   236→    return new BN(sum).add(new BN(itemAmount)).toString();\n   237→  }, '0');\n   238→\n   239→  // 4. Calculate discount amount based ONLY on eligible products, not the entire cart\n   240→  const totalDiscountAmount = calculateDiscountAmount(coupon, totalEligibleAmount, currency);\n   241→\n   242→  // Ensure discount doesn't exceed base total\n   243→  const adjustedDiscountAmount = new BN(totalDiscountAmount).gt(new BN(baseTotal)) ? baseTotal : totalDiscountAmount;\n   244→\n   245→  const finalTotal = new BN(baseTotal).sub(new BN(adjustedDiscountAmount));\n   246→  const adjustedFinalTotal = finalTotal.lt(new BN('0')) ? '0' : finalTotal.toString();\n   247→\n   248→  // 5. Apply discount to line items\n   249→  const enhancedLineItems = lineItems.map((item) => {\n   250→    const isEligible = eligibleLineItems.includes(item);\n   251→\n   252→    if (!isEligible) {\n   253→      return {\n   254→        ...item,\n   255→        discountable: false,\n   256→        discount_amounts: [],\n   257→      };\n   258→    }\n   259→\n   260→    const itemAmount = getItemAmount(item, currency.id);\n   261→    let itemDiscountAmount = '0';\n   262→\n   263→    if (coupon.percent_off > 0) {\n   264→      // For percentage discounts, apply directly to each eligible item\n   265→      itemDiscountAmount = new BN(itemAmount).mul(new BN(coupon.percent_off)).div(new BN(100)).toString();\n   266→    } else if (coupon.amount_off && totalEligibleAmount !== '0') {\n   267→      // For fixed amount discounts, distribute proportionally among eligible items\n   268→      itemDiscountAmount = new BN(itemAmount)\n   269→        .mul(new BN(adjustedDiscountAmount))\n   270→        .div(new BN(totalEligibleAmount))\n   271→        .toString();\n   272→    }\n   273→\n   274→    return {\n   275→      ...item,\n   276→      discountable: true,\n   277→      discount_amounts:\n   278→        itemDiscountAmount !== '0' ? [{ amount: itemDiscountAmount, coupon: coupon.id, discount: discount?.id }] : [],\n   279→    };\n   280→  });\n   281→\n   282→  return {\n   283→    enhancedLineItems,\n   284→    discountSummary: {\n   285→      appliedCoupon: coupon.id,\n   286→      discountAmount: adjustedDiscountAmount,\n   287→      totalDiscountAmount: adjustedDiscountAmount,\n   288→      finalTotal: adjustedFinalTotal,\n   289→    },\n   290→  };\n   291→}\n   292→\n   293→/**\n   294→ * Apply discount to subscription billing cycles (skips validation for stored discounts)\n   295→ */\n   296→export async function applySubscriptionDiscount({\n   297→  lineItems,\n   298→  discount,\n   299→  currency,\n   300→  totalAmount,\n   301→  billingContext,\n   302→}: {\n   303→  lineItems: TLineItemExpanded[];\n   304→  discount: Discount;\n   305→  currency: PaymentCurrency;\n   306→  totalAmount?: string;\n   307→  billingContext?: { trialing?: boolean };\n   308→}): Promise<{\n   309→  enhancedLineItems: (TLineItemExpanded & {\n   310→    discountable: boolean;\n   311→    discount_amounts: Array<{ amount: string; coupon: string }>;\n   312→  })[];\n   313→  discountSummary: {\n   314→    appliedCoupon: string | null;\n   315→    discountAmount: string;\n   316→    totalDiscountAmount: string;\n   317→    finalTotal: string;\n   318→  };\n   319→}> {\n   320→  // Get coupon from stored discount\n   321→  const coupon = await Coupon.findByPk(discount.coupon_id);\n   322→  if (!coupon) {\n   323→    logger.error('Coupon not found for stored discount', {\n   324→      discountId: discount.id,\n   325→      couponId: discount.coupon_id,\n   326→    });\n   327→\n   328→    // Return original items if coupon is missing\n   329→    const enhancedLineItems = lineItems.map((item) => ({\n   330→      ...item,\n   331→      discountable: false,\n   332→      discount_amounts: [],\n   333→    }));\n   334→    return {\n   335→      enhancedLineItems,\n   336→      discountSummary: {\n   337→        appliedCoupon: null,\n   338→        discountAmount: '0',\n   339→        totalDiscountAmount: '0',\n   340→        finalTotal: totalAmount ?? getItemsTotalAmount(lineItems, currency.id, billingContext),\n   341→      },\n   342→    };\n   343→  }\n   344→\n   345→  // Use common calculation logic\n   346→  const result = calculateDiscountForLineItems({\n   347→    lineItems,\n   348→    coupon,\n   349→    discount,\n   350→    currency,\n   351→    totalAmount,\n   352→    billingContext,\n   353→  });\n   354→\n   355→  logger.info('Applied subscription discount', {\n   356→    discountId: discount.id,\n   357→    originalTotal: totalAmount,\n   358→    discountAmount: result.discountSummary.discountAmount,\n   359→    finalTotal: result.discountSummary.finalTotal,\n   360→  });\n   361→\n   362→  return result;\n   363→}\n   364→\n   365→async function rollbackUsageForResource<T extends Coupon | PromotionCode>(\n   366→  resource: T,\n   367→  resourceType: 'coupon' | 'promotion-code'\n   368→): Promise<void> {\n   369→  const currentUsage = resource.times_redeemed || 0;\n   370→  if (currentUsage <= 0) return;\n   371→\n   372→  if (resourceType === 'coupon') {\n   373→    await (resource as Coupon).update({\n   374→      times_redeemed: currentUsage - 1,\n   375→      valid: true,\n   376→    });\n   377→  } else {\n   378→    await (resource as PromotionCode).update({\n   379→      times_redeemed: currentUsage - 1,\n   380→      active: true,\n   381→    });\n   382→  }\n   383→\n   384→  logger.info('Updated usage for resource', {\n   385→    resourceId: resource.id,\n   386→    resourceType,\n   387→    currentUsage: currentUsage - 1,\n   388→  });\n   389→\n   390→  emitAsync('discount-status.queued', resource, resourceType, true);\n   391→}\n   392→\n   393→export async function rollbackDiscountUsageForCheckoutSession(checkoutSessionId: string): Promise<void> {\n   394→  try {\n   395→    const checkoutSession = await CheckoutSession.findByPk(checkoutSessionId);\n   396→    if (!checkoutSession) {\n   397→      logger.error('Checkout session not found', { checkoutSessionId });\n   398→      return;\n   399→    }\n   400→\n   401→    if (checkoutSession.status === 'complete') {\n   402→      logger.error('Cannot rollback completed session', { checkoutSessionId });\n   403→      return;\n   404→    }\n   405→\n   406→    const discounts = (await Discount.findAll({\n   407→      where: { checkout_session_id: checkoutSessionId },\n   408→      include: [\n   409→        { model: Coupon, as: 'coupon' },\n   410→        { model: PromotionCode, as: 'promotionCode', required: false },\n   411→      ],\n   412→    })) as (Discount & { coupon: Coupon; promotionCode?: PromotionCode })[];\n   413→\n   414→    if (discounts.length === 0) {\n   415→      logger.info('No discounts found for checkout session', { checkoutSessionId });\n   416→      return;\n   417→    }\n   418→\n   419→    const uniqueCoupons = new Map<string, Coupon>();\n   420→    const uniquePromotionCodes = new Map<string, PromotionCode>();\n   421→\n   422→    discounts.forEach((discount) => {\n   423→      if (discount.confirmed) {\n   424→        if (discount.coupon?.id && !uniqueCoupons.has(discount.coupon.id)) {\n   425→          uniqueCoupons.set(discount.coupon.id, discount.coupon);\n   426→        }\n   427→        if (discount.promotionCode?.id && !uniquePromotionCodes.has(discount.promotionCode.id)) {\n   428→          uniquePromotionCodes.set(discount.promotionCode.id, discount.promotionCode);\n   429→        }\n   430→      }\n   431→    });\n   432→\n   433→    const rollbackPromises = [\n   434→      ...Array.from(uniquePromotionCodes.values()).map((pc) => rollbackUsageForResource(pc, 'promotion-code')),\n   435→      ...Array.from(uniqueCoupons.values()).map((c) => rollbackUsageForResource(c, 'coupon')),\n   436→    ];\n   437→\n   438→    await Promise.all(rollbackPromises);\n   439→\n   440→    await Promise.all(discounts.map((discount) => discount.destroy()));\n   441→  } catch (error) {\n   442→    logger.error('Discount rollback failed', { checkoutSessionId, error: error.message });\n   443→  }\n   444→}\n   445→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"de2a5151-a37f-4a88-b5d5-3e4cd96078cd","timestamp":"2026-01-09T01:49:39.703Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/discount.ts","content":"import { BN } from '@ocap/util';\nimport { Coupon, Discount, PaymentCurrency, PromotionCode, CheckoutSession } from '../../store/models';\nimport type { TLineItemExpanded } from '../../store/models';\nimport { getPriceUintAmountByCurrency } from '../price';\nimport { validCoupon, checkPromotionCodeEligibility, calculateDiscountAmount } from './coupon';\nimport { emitAsync } from '../event';\nimport logger from '../logger';\n\nconst getItemsTotalAmount = (lineItems: TLineItemExpanded[], currencyId: string, options?: { trialing?: boolean }) => {\n  let totalUnitPrice = new BN(0);\n\n  lineItems.forEach((item) => {\n    const price = item.upsell_price || item.price;\n    // TODO: why use custom_amount and quoted_amount instead of the price.unit_amount?\n    const dynamicAmount =\n      price?.pricing_type === 'dynamic' ? (item as any).custom_amount || (item as any).quoted_amount : undefined;\n    const unitPrice = getPriceUintAmountByCurrency(price, currencyId);\n\n    if (price?.type === 'recurring') {\n      if (options?.trialing) {\n        return;\n      }\n      if (price?.recurring?.usage_type === 'metered') {\n        return;\n      }\n    }\n\n    if (dynamicAmount) {\n      totalUnitPrice = totalUnitPrice.add(new BN(dynamicAmount));\n      return;\n    }\n\n    totalUnitPrice = totalUnitPrice.add(new BN(unitPrice).mul(new BN(item.quantity)));\n  });\n  return totalUnitPrice.toString();\n};\n\nconst getItemAmount = (item: TLineItemExpanded, currencyId: string) => {\n  const price = item.upsell_price || item.price;\n  const dynamicAmount =\n    price?.pricing_type === 'dynamic' ? (item as any).custom_amount || (item as any).quoted_amount : undefined;\n  if (dynamicAmount) {\n    return new BN(dynamicAmount).toString();\n  }\n  const unitPrice = getPriceUintAmountByCurrency(price, currencyId);\n  return new BN(unitPrice).mul(new BN(item.quantity)).toString();\n};\n\n/**\n * Apply discounts to line items and calculate discount summary\n */\nexport async function applyDiscountsToLineItems({\n  lineItems,\n  promotionCodeId,\n  couponId,\n  discountId,\n  customerId,\n  currency,\n  totalAmount,\n  billingContext,\n}: {\n  lineItems: TLineItemExpanded[];\n  promotionCodeId?: string;\n  discountId?: string;\n  couponId: string;\n  customerId: string;\n  currency: PaymentCurrency;\n  totalAmount?: string; // Optional, will calculate from lineItems if not provided\n  billingContext?: { trialing?: boolean };\n}): Promise<{\n  enhancedLineItems: (TLineItemExpanded & {\n    discountable: boolean;\n    discount_amounts: Array<{ amount: string; coupon: string }>;\n  })[];\n  discountSummary: {\n    appliedCoupon: string | null;\n    discountAmount: string;\n    totalDiscountAmount: string;\n    finalTotal: string;\n  };\n  notValidReason?: string;\n}> {\n  let discount = null;\n  if (discountId) {\n    discount = await Discount.findByPk(discountId);\n  }\n\n  // 1. Calculate total amount from lineItems if not provided, considering billing context\n  const baseTotal = totalAmount ?? getItemsTotalAmount(lineItems, currency.id, billingContext);\n\n  // 2. Get coupon (required)\n  const coupon = await Coupon.findByPk(discount?.coupon_id || couponId);\n  if (!coupon) {\n    // 3. If couponId doesn't exist, return original items\n    const enhancedLineItems = lineItems.map((item) => ({\n      ...item,\n      discountable: false,\n      discount_amounts: [],\n    }));\n    return {\n      enhancedLineItems,\n      discountSummary: {\n        appliedCoupon: null,\n        discountAmount: '0',\n        totalDiscountAmount: '0',\n        finalTotal: baseTotal,\n      },\n      notValidReason: 'Coupon not found',\n    };\n  }\n\n  let isValid = false;\n  let notValidReason = '';\n\n  // 4. Validate coupon eligibility\n  if (promotionCodeId || discount?.promotion_code_id) {\n    // Get promotion code and use comprehensive validation\n    const promotionCode = await PromotionCode.findByPk(promotionCodeId || discount?.promotion_code_id);\n    if (!promotionCode) {\n      isValid = false;\n    } else {\n      const eligibility = await checkPromotionCodeEligibility({\n        promotionCode,\n        couponId,\n        customerId,\n        amount: baseTotal,\n        currencyId: currency.id,\n        lineItems,\n      });\n      isValid = eligibility.eligible;\n      notValidReason = eligibility.reason || '';\n    }\n  } else {\n    // Direct coupon validation\n    const couponValidation = await validCoupon(coupon, lineItems);\n    isValid = couponValidation.valid;\n    notValidReason = couponValidation.reason || '';\n  }\n\n  if (!isValid) {\n    // Return original items if validation fails\n    const enhancedLineItems = lineItems.map((item) => ({\n      ...item,\n      discountable: false,\n      discount_amounts: [],\n    }));\n    return {\n      enhancedLineItems,\n      discountSummary: {\n        appliedCoupon: null,\n        discountAmount: '0',\n        totalDiscountAmount: '0',\n        finalTotal: baseTotal,\n      },\n      notValidReason,\n    };\n  }\n\n  // Use common calculation logic\n  const result = calculateDiscountForLineItems({\n    lineItems,\n    coupon,\n    discount,\n    currency,\n    totalAmount,\n    billingContext,\n  });\n\n  return {\n    ...result,\n    notValidReason: undefined, // No validation error if we reach here\n  };\n}\n\n/**\n * Common discount calculation logic\n */\nfunction calculateDiscountForLineItems({\n  lineItems,\n  coupon,\n  discount,\n  currency,\n  totalAmount,\n  billingContext,\n}: {\n  lineItems: TLineItemExpanded[];\n  coupon: Coupon;\n  discount?: Discount | null;\n  currency: PaymentCurrency;\n  totalAmount?: string;\n  billingContext?: { trialing?: boolean };\n}): {\n  enhancedLineItems: (TLineItemExpanded & {\n    discountable: boolean;\n    discount_amounts: Array<{ amount: string; coupon: string }>;\n  })[];\n  discountSummary: {\n    appliedCoupon: string | null;\n    discountAmount: string;\n    totalDiscountAmount: string;\n    finalTotal: string;\n  };\n} {\n  // 1. Calculate total amount from lineItems if not provided, considering billing context\n  const baseTotal = totalAmount ?? getItemsTotalAmount(lineItems, currency.id, billingContext);\n\n  // 2. Get all eligible items based on coupon product restrictions\n  const eligibleLineItems = lineItems.filter((item) => {\n    if (!coupon.applies_to?.products?.length) {\n      return true; // No product restriction, all items eligible\n    }\n    return coupon.applies_to.products.some((productId) => item.price?.product_id === productId);\n  });\n\n  if (eligibleLineItems.length === 0) {\n    // No eligible items, return original\n    const enhancedLineItems = lineItems.map((item) => ({\n      ...item,\n      discountable: false,\n      discount_amounts: [],\n    }));\n    return {\n      enhancedLineItems,\n      discountSummary: {\n        appliedCoupon: null,\n        discountAmount: '0',\n        totalDiscountAmount: '0',\n        finalTotal: baseTotal,\n      },\n    };\n  }\n\n  // 3. Calculate total eligible amount (only products that qualify for the discount)\n  const totalEligibleAmount = eligibleLineItems.reduce((sum, item) => {\n    const itemAmount = getItemAmount(item, currency.id);\n    return new BN(sum).add(new BN(itemAmount)).toString();\n  }, '0');\n\n  // 4. Calculate discount amount based ONLY on eligible products, not the entire cart\n  const totalDiscountAmount = calculateDiscountAmount(coupon, totalEligibleAmount, currency);\n\n  // Ensure discount doesn't exceed base total\n  const adjustedDiscountAmount = new BN(totalDiscountAmount).gt(new BN(baseTotal)) ? baseTotal : totalDiscountAmount;\n\n  const finalTotal = new BN(baseTotal).sub(new BN(adjustedDiscountAmount));\n  const adjustedFinalTotal = finalTotal.lt(new BN('0')) ? '0' : finalTotal.toString();\n\n  // 5. Apply discount to line items\n  const enhancedLineItems = lineItems.map((item) => {\n    const isEligible = eligibleLineItems.includes(item);\n\n    if (!isEligible) {\n      return {\n        ...item,\n        discountable: false,\n        discount_amounts: [],\n      };\n    }\n\n    const itemAmount = getItemAmount(item, currency.id);\n    let itemDiscountAmount = '0';\n\n    if (coupon.percent_off > 0) {\n      // For percentage discounts, apply directly to each eligible item\n      itemDiscountAmount = new BN(itemAmount).mul(new BN(coupon.percent_off)).div(new BN(100)).toString();\n    } else if (coupon.amount_off && totalEligibleAmount !== '0') {\n      // For fixed amount discounts, distribute proportionally among eligible items\n      itemDiscountAmount = new BN(itemAmount)\n        .mul(new BN(adjustedDiscountAmount))\n        .div(new BN(totalEligibleAmount))\n        .toString();\n    }\n\n    return {\n      ...item,\n      discountable: true,\n      discount_amounts:\n        itemDiscountAmount !== '0' ? [{ amount: itemDiscountAmount, coupon: coupon.id, discount: discount?.id }] : [],\n    };\n  });\n\n  return {\n    enhancedLineItems,\n    discountSummary: {\n      appliedCoupon: coupon.id,\n      discountAmount: adjustedDiscountAmount,\n      totalDiscountAmount: adjustedDiscountAmount,\n      finalTotal: adjustedFinalTotal,\n    },\n  };\n}\n\n/**\n * Apply discount to subscription billing cycles (skips validation for stored discounts)\n */\nexport async function applySubscriptionDiscount({\n  lineItems,\n  discount,\n  currency,\n  totalAmount,\n  billingContext,\n}: {\n  lineItems: TLineItemExpanded[];\n  discount: Discount;\n  currency: PaymentCurrency;\n  totalAmount?: string;\n  billingContext?: { trialing?: boolean };\n}): Promise<{\n  enhancedLineItems: (TLineItemExpanded & {\n    discountable: boolean;\n    discount_amounts: Array<{ amount: string; coupon: string }>;\n  })[];\n  discountSummary: {\n    appliedCoupon: string | null;\n    discountAmount: string;\n    totalDiscountAmount: string;\n    finalTotal: string;\n  };\n}> {\n  // Get coupon from stored discount\n  const coupon = await Coupon.findByPk(discount.coupon_id);\n  if (!coupon) {\n    logger.error('Coupon not found for stored discount', {\n      discountId: discount.id,\n      couponId: discount.coupon_id,\n    });\n\n    // Return original items if coupon is missing\n    const enhancedLineItems = lineItems.map((item) => ({\n      ...item,\n      discountable: false,\n      discount_amounts: [],\n    }));\n    return {\n      enhancedLineItems,\n      discountSummary: {\n        appliedCoupon: null,\n        discountAmount: '0',\n        totalDiscountAmount: '0',\n        finalTotal: totalAmount ?? getItemsTotalAmount(lineItems, currency.id, billingContext),\n      },\n    };\n  }\n\n  // Use common calculation logic\n  const result = calculateDiscountForLineItems({\n    lineItems,\n    coupon,\n    discount,\n    currency,\n    totalAmount,\n    billingContext,\n  });\n\n  logger.info('Applied subscription discount', {\n    discountId: discount.id,\n    originalTotal: totalAmount,\n    discountAmount: result.discountSummary.discountAmount,\n    finalTotal: result.discountSummary.finalTotal,\n  });\n\n  return result;\n}\n\nasync function rollbackUsageForResource<T extends Coupon | PromotionCode>(\n  resource: T,\n  resourceType: 'coupon' | 'promotion-code'\n): Promise<void> {\n  const currentUsage = resource.times_redeemed || 0;\n  if (currentUsage <= 0) return;\n\n  if (resourceType === 'coupon') {\n    await (resource as Coupon).update({\n      times_redeemed: currentUsage - 1,\n      valid: true,\n    });\n  } else {\n    await (resource as PromotionCode).update({\n      times_redeemed: currentUsage - 1,\n      active: true,\n    });\n  }\n\n  logger.info('Updated usage for resource', {\n    resourceId: resource.id,\n    resourceType,\n    currentUsage: currentUsage - 1,\n  });\n\n  emitAsync('discount-status.queued', resource, resourceType, true);\n}\n\nexport async function rollbackDiscountUsageForCheckoutSession(checkoutSessionId: string): Promise<void> {\n  try {\n    const checkoutSession = await CheckoutSession.findByPk(checkoutSessionId);\n    if (!checkoutSession) {\n      logger.error('Checkout session not found', { checkoutSessionId });\n      return;\n    }\n\n    if (checkoutSession.status === 'complete') {\n      logger.error('Cannot rollback completed session', { checkoutSessionId });\n      return;\n    }\n\n    const discounts = (await Discount.findAll({\n      where: { checkout_session_id: checkoutSessionId },\n      include: [\n        { model: Coupon, as: 'coupon' },\n        { model: PromotionCode, as: 'promotionCode', required: false },\n      ],\n    })) as (Discount & { coupon: Coupon; promotionCode?: PromotionCode })[];\n\n    if (discounts.length === 0) {\n      logger.info('No discounts found for checkout session', { checkoutSessionId });\n      return;\n    }\n\n    const uniqueCoupons = new Map<string, Coupon>();\n    const uniquePromotionCodes = new Map<string, PromotionCode>();\n\n    discounts.forEach((discount) => {\n      if (discount.confirmed) {\n        if (discount.coupon?.id && !uniqueCoupons.has(discount.coupon.id)) {\n          uniqueCoupons.set(discount.coupon.id, discount.coupon);\n        }\n        if (discount.promotionCode?.id && !uniquePromotionCodes.has(discount.promotionCode.id)) {\n          uniquePromotionCodes.set(discount.promotionCode.id, discount.promotionCode);\n        }\n      }\n    });\n\n    const rollbackPromises = [\n      ...Array.from(uniquePromotionCodes.values()).map((pc) => rollbackUsageForResource(pc, 'promotion-code')),\n      ...Array.from(uniqueCoupons.values()).map((c) => rollbackUsageForResource(c, 'coupon')),\n    ];\n\n    await Promise.all(rollbackPromises);\n\n    await Promise.all(discounts.map((discount) => discount.destroy()));\n  } catch (error) {\n    logger.error('Discount rollback failed', { checkoutSessionId, error: error.message });\n  }\n}\n","numLines":445,"startLine":1,"totalLines":445}}}
{"parentUuid":"de2a5151-a37f-4a88-b5d5-3e4cd96078cd","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Eja6TAoHbzB5E7zX5FjjTV","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/lines-between-class-members */\n     2→import {\n     3→  CreationOptional,\n     4→  DataTypes,\n     5→  InferAttributes,\n     6→  InferCreationAttributes,\n     7→  Model,\n     8→  Op,\n     9→  FindOptions,\n    10→  WhereOptions,\n    11→} from 'sequelize';\n    12→import { fromTokenToUnit } from '@ocap/util';\n    13→\n    14→import type { LiteralUnion } from 'type-fest';\n    15→import { createIdGenerator, formatMetadata } from '../../libs/util';\n    16→import { trimDecimals } from '../../libs/math-utils';\n    17→import type { NFTConfig, Restrictions, VCConfig, VerificationType } from './types';\n    18→import type { TPaymentCurrency } from './payment-currency';\n    19→import { createEvent } from '../../libs/audit';\n    20→\n    21→const nextId = createIdGenerator('promo', 24);\n    22→\n    23→// @link https://stripe.com/docs/api/promotion_codes\n    24→// eslint-disable-next-line prettier/prettier\n    25→export class PromotionCode extends Model<InferAttributes<PromotionCode>, InferCreationAttributes<PromotionCode>> {\n    26→  declare id: CreationOptional<string>;\n    27→  declare livemode: boolean;\n    28→  declare active: boolean;\n    29→  declare locked: CreationOptional<boolean>;\n    30→\n    31→  declare code: string;\n    32→\n    33→  declare description?: string;\n    34→\n    35→  declare coupon_id: string;\n    36→\n    37→  // redeem conditions\n    38→  declare max_redemptions?: number;\n    39→  declare restrictions?: Restrictions;\n    40→  declare customer_id?: string;\n    41→\n    42→  declare times_redeemed?: number;\n    43→\n    44→  declare expires_at?: number;\n    45→  declare created_at: CreationOptional<Date>;\n    46→  declare updated_at: CreationOptional<Date>;\n    47→\n    48→  // Separated verification configurations\n    49→  declare verification_type?: VerificationType;\n    50→  declare nft_config?: NFTConfig;\n    51→  declare vc_config?: VCConfig;\n    52→  declare customer_dids?: string[];\n    53→  declare metadata?: Record<string, any>;\n    54→  declare created_via: LiteralUnion<'api' | 'dashboard' | 'portal', string>;\n    55→\n    56→  public static readonly GENESIS_ATTRIBUTES = {\n    57→    id: {\n    58→      type: DataTypes.STRING(30),\n    59→      primaryKey: true,\n    60→      allowNull: false,\n    61→      defaultValue: nextId,\n    62→    },\n    63→    livemode: {\n    64→      type: DataTypes.BOOLEAN,\n    65→      allowNull: false,\n    66→    },\n    67→    locked: {\n    68→      type: DataTypes.BOOLEAN,\n    69→      defaultValue: false,\n    70→    },\n    71→    active: {\n    72→      type: DataTypes.BOOLEAN,\n    73→      defaultValue: true,\n    74→    },\n    75→    code: {\n    76→      type: DataTypes.STRING(16),\n    77→      allowNull: false,\n    78→    },\n    79→    description: {\n    80→      type: DataTypes.TEXT,\n    81→      allowNull: true,\n    82→    },\n    83→    coupon_id: {\n    84→      type: DataTypes.STRING(30),\n    85→      allowNull: false,\n    86→    },\n    87→    max_redemptions: {\n    88→      type: DataTypes.INTEGER,\n    89→      allowNull: true,\n    90→    },\n    91→    restrictions: {\n    92→      type: DataTypes.JSON,\n    93→      defaultValue: {},\n    94→    },\n    95→    customer_id: {\n    96→      type: DataTypes.STRING(30),\n    97→      allowNull: true,\n    98→    },\n    99→    times_redeemed: {\n   100→      type: DataTypes.INTEGER,\n   101→      defaultValue: 0,\n   102→    },\n   103→    metadata: {\n   104→      type: DataTypes.JSON,\n   105→      allowNull: true,\n   106→    },\n   107→    created_via: {\n   108→      type: DataTypes.ENUM('api', 'dashboard', 'portal'),\n   109→    },\n   110→    expires_at: {\n   111→      type: DataTypes.INTEGER,\n   112→      allowNull: true,\n   113→    },\n   114→    created_at: {\n   115→      type: DataTypes.DATE,\n   116→      defaultValue: DataTypes.NOW,\n   117→      allowNull: false,\n   118→    },\n   119→    updated_at: {\n   120→      type: DataTypes.DATE,\n   121→      defaultValue: DataTypes.NOW,\n   122→      allowNull: false,\n   123→    },\n   124→  };\n   125→\n   126→  public static initialize(sequelize: any) {\n   127→    this.init(\n   128→      {\n   129→        ...PromotionCode.GENESIS_ATTRIBUTES,\n   130→        verification_type: {\n   131→          type: DataTypes.ENUM('code', 'nft', 'vc', 'user_restricted'),\n   132→          defaultValue: 'code',\n   133→          allowNull: false,\n   134→        },\n   135→        nft_config: {\n   136→          type: DataTypes.JSON,\n   137→          allowNull: true,\n   138→        },\n   139→        vc_config: {\n   140→          type: DataTypes.JSON,\n   141→          allowNull: true,\n   142→        },\n   143→        customer_dids: {\n   144→          type: DataTypes.JSON,\n   145→          allowNull: true,\n   146→        },\n   147→        metadata: {\n   148→          type: DataTypes.JSON,\n   149→          allowNull: true,\n   150→        },\n   151→      },\n   152→      {\n   153→        sequelize,\n   154→        modelName: 'PromotionCode',\n   155→        tableName: 'promotion_codes',\n   156→        createdAt: 'created_at',\n   157→        updatedAt: 'updated_at',\n   158→        hooks: {\n   159→          afterCreate: (model: PromotionCode, options) =>\n   160→            createEvent('PromotionCode', 'promotion_code.created', model, options).catch(console.error),\n   161→          afterUpdate: (model: PromotionCode, options) =>\n   162→            createEvent('PromotionCode', 'promotion_code.updated', model, options).catch(console.error),\n   163→          afterDestroy: (model: PromotionCode, options) =>\n   164→            createEvent('PromotionCode', 'promotion_code.deleted', model, options).catch(console.error),\n   165→        },\n   166→      }\n   167→    );\n   168→  }\n   169→\n   170→  public static associate(models: any) {\n   171→    this.belongsTo(models.Coupon, {\n   172→      foreignKey: 'coupon_id',\n   173→      as: 'coupon',\n   174→    });\n   175→  }\n   176→\n   177→  public static formatBeforeSave(promotionCode: Partial<TPromotionCode>) {\n   178→    if (promotionCode.metadata) {\n   179→      promotionCode.metadata = formatMetadata(promotionCode.metadata);\n   180→    }\n   181→\n   182→    if (promotionCode.max_redemptions) {\n   183→      promotionCode.max_redemptions = Number(promotionCode.max_redemptions);\n   184→    }\n   185→\n   186→    if (promotionCode.times_redeemed) {\n   187→      promotionCode.times_redeemed = Number(promotionCode.times_redeemed);\n   188→    }\n   189→\n   190→    return promotionCode;\n   191→  }\n   192→\n   193→  /**\n   194→   * Find promotion code by multiple criteria:\n   195→   * - id: promotion code ID\n   196→   * - code: promotion code string\n   197→   * - nft_address: NFT contract address (when verification_type is 'nft')\n   198→   * - vc_role: VC role (when verification_type is 'vc')\n   199→   * - userDid: user DID (when verification_type is 'user_restricted')\n   200→   */\n   201→  public static findByMultipleCriteria(\n   202→    searchValue: string,\n   203→    options: FindOptions<PromotionCode> = {},\n   204→    verificationType: VerificationType | null = null\n   205→  ) {\n   206→    const whereConditions = [{ id: searchValue }, { code: searchValue }] as WhereOptions[];\n   207→\n   208→    // Add NFT address search condition\n   209→    if (verificationType === 'nft' || !verificationType) {\n   210→      whereConditions.push({\n   211→        verification_type: 'nft',\n   212→        'nft_config.addresses': {\n   213→          [Op.contains]: [searchValue],\n   214→        },\n   215→      });\n   216→    }\n   217→\n   218→    // Add VC role search condition\n   219→    if (verificationType === 'vc' || !verificationType) {\n   220→      whereConditions.push({\n   221→        verification_type: 'vc',\n   222→        'vc_config.roles': {\n   223→          [Op.contains]: [searchValue],\n   224→        },\n   225→      });\n   226→    }\n   227→\n   228→    // Add user DID search condition\n   229→    if (verificationType === 'user_restricted' || !verificationType) {\n   230→      whereConditions.push({\n   231→        verification_type: 'user_restricted',\n   232→        customer_dids: {\n   233→          [Op.contains]: [searchValue],\n   234→        },\n   235→      });\n   236→    }\n   237→\n   238→    return this.findOne({\n   239→      where: { [Op.or]: whereConditions },\n   240→      ...options,\n   241→    });\n   242→  }\n   243→\n   244→  /**\n   245→   * Find promotion code by specific criteria type\n   246→   */\n   247→  public static findByCode(code: string, options: FindOptions<PromotionCode> = {}) {\n   248→    return this.findOne({\n   249→      where: { code },\n   250→      ...options,\n   251→    });\n   252→  }\n   253→\n   254→  public static findByNftAddress(nftAddress: string, options: FindOptions<PromotionCode> = {}) {\n   255→    return this.findOne({\n   256→      where: {\n   257→        verification_type: 'nft',\n   258→        'nft_config.addresses': {\n   259→          [Op.contains]: [nftAddress],\n   260→        },\n   261→      } as any,\n   262→      ...options,\n   263→    });\n   264→  }\n   265→\n   266→  public static findByVcRole(vcRole: string, options: FindOptions<PromotionCode> = {}) {\n   267→    return this.findOne({\n   268→      where: {\n   269→        verification_type: 'vc',\n   270→        'vc_config.roles': {\n   271→          [Op.contains]: [vcRole],\n   272→        },\n   273→      } as any,\n   274→      ...options,\n   275→    });\n   276→  }\n   277→\n   278→  public static findByUserDid(userDid: string, options: FindOptions<PromotionCode> = {}) {\n   279→    return this.findOne({\n   280→      where: {\n   281→        verification_type: 'user_restricted',\n   282→        customer_dids: {\n   283→          [Op.contains]: [userDid],\n   284→        },\n   285→      } as any,\n   286→      ...options,\n   287→    });\n   288→  }\n   289→\n   290→  /**\n   291→   * Check if promotion code is being used\n   292→   */\n   293→  public async isUsed() {\n   294→    const { Discount } = this.sequelize.models;\n   295→    const discountCount = await Discount!.count({\n   296→      where: { promotion_code_id: this.id },\n   297→    });\n   298→\n   299→    if (discountCount > 0) {\n   300→      return true;\n   301→    }\n   302→    return false;\n   303→  }\n   304→\n   305→  /**\n   306→   * Check if promotion code is valid for use\n   307→   */\n   308→  public isValid() {\n   309→    if (!this.active) {\n   310→      return { valid: false, reason: 'Promotion code is inactive' };\n   311→    }\n   312→\n   313→    if (this.expires_at && Math.floor(Date.now() / 1000) > this.expires_at) {\n   314→      return { valid: false, reason: 'Promotion code has expired' };\n   315→    }\n   316→\n   317→    if (this.max_redemptions && (this.times_redeemed ?? 0) >= this.max_redemptions) {\n   318→      return { valid: false, reason: 'Promotion code has reached maximum redemptions' };\n   319→    }\n   320→\n   321→    return { valid: true };\n   322→  }\n   323→\n   324→  /**\n   325→   * Insert promotion code with formatting\n   326→   */\n   327→  public static insert(promotionCode: Partial<TPromotionCode>) {\n   328→    const formattedData = this.formatBeforeSave({\n   329→      active: true,\n   330→      times_redeemed: 0,\n   331→      metadata: {},\n   332→      ...promotionCode,\n   333→    });\n   334→    return this.create(formattedData as any);\n   335→  }\n   336→\n   337→  /**\n   338→   * Format restrictions currency options for storage - convert unit amounts to token amounts\n   339→   */\n   340→  public static formatRestrictionsCurrencyOptions(\n   341→    restrictions: Restrictions | undefined,\n   342→    currencies: TPaymentCurrency[]\n   343→  ): Restrictions | undefined {\n   344→    if (!restrictions || !restrictions.currency_options) {\n   345→      return restrictions;\n   346→    }\n   347→\n   348→    const formatted: Record<string, { minimum_amount: string }> = {};\n   349→\n   350→    if (restrictions.minimum_amount && restrictions.minimum_amount_currency) {\n   351→      const currency = currencies.find((c) => c.id === restrictions.minimum_amount_currency);\n   352→      if (!currency) {\n   353→        throw new Error(`currency ${restrictions.minimum_amount_currency} not found or inactive`);\n   354→      }\n   355→      restrictions.minimum_amount = fromTokenToUnit(\n   356→        trimDecimals(restrictions.minimum_amount, currency.decimal),\n   357→        currency.decimal\n   358→      ).toString();\n   359→    }\n   360→\n   361→    for (const [currencyId, optionData] of Object.entries(restrictions.currency_options)) {\n   362→      const currency = currencies.find((c) => c.id === currencyId);\n   363→      if (!currency) {\n   364→        throw new Error(`currency ${currencyId} used in promotion code not found or inactive`);\n   365→      }\n   366→\n   367→      formatted[currencyId] = {\n   368→        minimum_amount: fromTokenToUnit(\n   369→          trimDecimals(optionData.minimum_amount || '0', currency.decimal),\n   370→          currency.decimal\n   371→        ).toString(),\n   372→      };\n   373→\n   374→      if (restrictions.minimum_amount && !restrictions.currency_options[currencyId]) {\n   375→        restrictions.currency_options[currencyId] = {\n   376→          minimum_amount: restrictions.minimum_amount,\n   377→        };\n   378→      }\n   379→    }\n   380→\n   381→    // Return with the correct storage format (string values)\n   382→    return {\n   383→      ...restrictions,\n   384→      currency_options: formatted,\n   385→    } as any;\n   386→  }\n   387→}\n   388→\n   389→export type TPromotionCode = InferAttributes<PromotionCode>;\n   390→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"63615719-1f58-4a22-9773-1f89431fd9b2","timestamp":"2026-01-09T01:49:39.704Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/promotion-code.ts","content":"/* eslint-disable @typescript-eslint/lines-between-class-members */\nimport {\n  CreationOptional,\n  DataTypes,\n  InferAttributes,\n  InferCreationAttributes,\n  Model,\n  Op,\n  FindOptions,\n  WhereOptions,\n} from 'sequelize';\nimport { fromTokenToUnit } from '@ocap/util';\n\nimport type { LiteralUnion } from 'type-fest';\nimport { createIdGenerator, formatMetadata } from '../../libs/util';\nimport { trimDecimals } from '../../libs/math-utils';\nimport type { NFTConfig, Restrictions, VCConfig, VerificationType } from './types';\nimport type { TPaymentCurrency } from './payment-currency';\nimport { createEvent } from '../../libs/audit';\n\nconst nextId = createIdGenerator('promo', 24);\n\n// @link https://stripe.com/docs/api/promotion_codes\n// eslint-disable-next-line prettier/prettier\nexport class PromotionCode extends Model<InferAttributes<PromotionCode>, InferCreationAttributes<PromotionCode>> {\n  declare id: CreationOptional<string>;\n  declare livemode: boolean;\n  declare active: boolean;\n  declare locked: CreationOptional<boolean>;\n\n  declare code: string;\n\n  declare description?: string;\n\n  declare coupon_id: string;\n\n  // redeem conditions\n  declare max_redemptions?: number;\n  declare restrictions?: Restrictions;\n  declare customer_id?: string;\n\n  declare times_redeemed?: number;\n\n  declare expires_at?: number;\n  declare created_at: CreationOptional<Date>;\n  declare updated_at: CreationOptional<Date>;\n\n  // Separated verification configurations\n  declare verification_type?: VerificationType;\n  declare nft_config?: NFTConfig;\n  declare vc_config?: VCConfig;\n  declare customer_dids?: string[];\n  declare metadata?: Record<string, any>;\n  declare created_via: LiteralUnion<'api' | 'dashboard' | 'portal', string>;\n\n  public static readonly GENESIS_ATTRIBUTES = {\n    id: {\n      type: DataTypes.STRING(30),\n      primaryKey: true,\n      allowNull: false,\n      defaultValue: nextId,\n    },\n    livemode: {\n      type: DataTypes.BOOLEAN,\n      allowNull: false,\n    },\n    locked: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: false,\n    },\n    active: {\n      type: DataTypes.BOOLEAN,\n      defaultValue: true,\n    },\n    code: {\n      type: DataTypes.STRING(16),\n      allowNull: false,\n    },\n    description: {\n      type: DataTypes.TEXT,\n      allowNull: true,\n    },\n    coupon_id: {\n      type: DataTypes.STRING(30),\n      allowNull: false,\n    },\n    max_redemptions: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    restrictions: {\n      type: DataTypes.JSON,\n      defaultValue: {},\n    },\n    customer_id: {\n      type: DataTypes.STRING(30),\n      allowNull: true,\n    },\n    times_redeemed: {\n      type: DataTypes.INTEGER,\n      defaultValue: 0,\n    },\n    metadata: {\n      type: DataTypes.JSON,\n      allowNull: true,\n    },\n    created_via: {\n      type: DataTypes.ENUM('api', 'dashboard', 'portal'),\n    },\n    expires_at: {\n      type: DataTypes.INTEGER,\n      allowNull: true,\n    },\n    created_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n    updated_at: {\n      type: DataTypes.DATE,\n      defaultValue: DataTypes.NOW,\n      allowNull: false,\n    },\n  };\n\n  public static initialize(sequelize: any) {\n    this.init(\n      {\n        ...PromotionCode.GENESIS_ATTRIBUTES,\n        verification_type: {\n          type: DataTypes.ENUM('code', 'nft', 'vc', 'user_restricted'),\n          defaultValue: 'code',\n          allowNull: false,\n        },\n        nft_config: {\n          type: DataTypes.JSON,\n          allowNull: true,\n        },\n        vc_config: {\n          type: DataTypes.JSON,\n          allowNull: true,\n        },\n        customer_dids: {\n          type: DataTypes.JSON,\n          allowNull: true,\n        },\n        metadata: {\n          type: DataTypes.JSON,\n          allowNull: true,\n        },\n      },\n      {\n        sequelize,\n        modelName: 'PromotionCode',\n        tableName: 'promotion_codes',\n        createdAt: 'created_at',\n        updatedAt: 'updated_at',\n        hooks: {\n          afterCreate: (model: PromotionCode, options) =>\n            createEvent('PromotionCode', 'promotion_code.created', model, options).catch(console.error),\n          afterUpdate: (model: PromotionCode, options) =>\n            createEvent('PromotionCode', 'promotion_code.updated', model, options).catch(console.error),\n          afterDestroy: (model: PromotionCode, options) =>\n            createEvent('PromotionCode', 'promotion_code.deleted', model, options).catch(console.error),\n        },\n      }\n    );\n  }\n\n  public static associate(models: any) {\n    this.belongsTo(models.Coupon, {\n      foreignKey: 'coupon_id',\n      as: 'coupon',\n    });\n  }\n\n  public static formatBeforeSave(promotionCode: Partial<TPromotionCode>) {\n    if (promotionCode.metadata) {\n      promotionCode.metadata = formatMetadata(promotionCode.metadata);\n    }\n\n    if (promotionCode.max_redemptions) {\n      promotionCode.max_redemptions = Number(promotionCode.max_redemptions);\n    }\n\n    if (promotionCode.times_redeemed) {\n      promotionCode.times_redeemed = Number(promotionCode.times_redeemed);\n    }\n\n    return promotionCode;\n  }\n\n  /**\n   * Find promotion code by multiple criteria:\n   * - id: promotion code ID\n   * - code: promotion code string\n   * - nft_address: NFT contract address (when verification_type is 'nft')\n   * - vc_role: VC role (when verification_type is 'vc')\n   * - userDid: user DID (when verification_type is 'user_restricted')\n   */\n  public static findByMultipleCriteria(\n    searchValue: string,\n    options: FindOptions<PromotionCode> = {},\n    verificationType: VerificationType | null = null\n  ) {\n    const whereConditions = [{ id: searchValue }, { code: searchValue }] as WhereOptions[];\n\n    // Add NFT address search condition\n    if (verificationType === 'nft' || !verificationType) {\n      whereConditions.push({\n        verification_type: 'nft',\n        'nft_config.addresses': {\n          [Op.contains]: [searchValue],\n        },\n      });\n    }\n\n    // Add VC role search condition\n    if (verificationType === 'vc' || !verificationType) {\n      whereConditions.push({\n        verification_type: 'vc',\n        'vc_config.roles': {\n          [Op.contains]: [searchValue],\n        },\n      });\n    }\n\n    // Add user DID search condition\n    if (verificationType === 'user_restricted' || !verificationType) {\n      whereConditions.push({\n        verification_type: 'user_restricted',\n        customer_dids: {\n          [Op.contains]: [searchValue],\n        },\n      });\n    }\n\n    return this.findOne({\n      where: { [Op.or]: whereConditions },\n      ...options,\n    });\n  }\n\n  /**\n   * Find promotion code by specific criteria type\n   */\n  public static findByCode(code: string, options: FindOptions<PromotionCode> = {}) {\n    return this.findOne({\n      where: { code },\n      ...options,\n    });\n  }\n\n  public static findByNftAddress(nftAddress: string, options: FindOptions<PromotionCode> = {}) {\n    return this.findOne({\n      where: {\n        verification_type: 'nft',\n        'nft_config.addresses': {\n          [Op.contains]: [nftAddress],\n        },\n      } as any,\n      ...options,\n    });\n  }\n\n  public static findByVcRole(vcRole: string, options: FindOptions<PromotionCode> = {}) {\n    return this.findOne({\n      where: {\n        verification_type: 'vc',\n        'vc_config.roles': {\n          [Op.contains]: [vcRole],\n        },\n      } as any,\n      ...options,\n    });\n  }\n\n  public static findByUserDid(userDid: string, options: FindOptions<PromotionCode> = {}) {\n    return this.findOne({\n      where: {\n        verification_type: 'user_restricted',\n        customer_dids: {\n          [Op.contains]: [userDid],\n        },\n      } as any,\n      ...options,\n    });\n  }\n\n  /**\n   * Check if promotion code is being used\n   */\n  public async isUsed() {\n    const { Discount } = this.sequelize.models;\n    const discountCount = await Discount!.count({\n      where: { promotion_code_id: this.id },\n    });\n\n    if (discountCount > 0) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Check if promotion code is valid for use\n   */\n  public isValid() {\n    if (!this.active) {\n      return { valid: false, reason: 'Promotion code is inactive' };\n    }\n\n    if (this.expires_at && Math.floor(Date.now() / 1000) > this.expires_at) {\n      return { valid: false, reason: 'Promotion code has expired' };\n    }\n\n    if (this.max_redemptions && (this.times_redeemed ?? 0) >= this.max_redemptions) {\n      return { valid: false, reason: 'Promotion code has reached maximum redemptions' };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Insert promotion code with formatting\n   */\n  public static insert(promotionCode: Partial<TPromotionCode>) {\n    const formattedData = this.formatBeforeSave({\n      active: true,\n      times_redeemed: 0,\n      metadata: {},\n      ...promotionCode,\n    });\n    return this.create(formattedData as any);\n  }\n\n  /**\n   * Format restrictions currency options for storage - convert unit amounts to token amounts\n   */\n  public static formatRestrictionsCurrencyOptions(\n    restrictions: Restrictions | undefined,\n    currencies: TPaymentCurrency[]\n  ): Restrictions | undefined {\n    if (!restrictions || !restrictions.currency_options) {\n      return restrictions;\n    }\n\n    const formatted: Record<string, { minimum_amount: string }> = {};\n\n    if (restrictions.minimum_amount && restrictions.minimum_amount_currency) {\n      const currency = currencies.find((c) => c.id === restrictions.minimum_amount_currency);\n      if (!currency) {\n        throw new Error(`currency ${restrictions.minimum_amount_currency} not found or inactive`);\n      }\n      restrictions.minimum_amount = fromTokenToUnit(\n        trimDecimals(restrictions.minimum_amount, currency.decimal),\n        currency.decimal\n      ).toString();\n    }\n\n    for (const [currencyId, optionData] of Object.entries(restrictions.currency_options)) {\n      const currency = currencies.find((c) => c.id === currencyId);\n      if (!currency) {\n        throw new Error(`currency ${currencyId} used in promotion code not found or inactive`);\n      }\n\n      formatted[currencyId] = {\n        minimum_amount: fromTokenToUnit(\n          trimDecimals(optionData.minimum_amount || '0', currency.decimal),\n          currency.decimal\n        ).toString(),\n      };\n\n      if (restrictions.minimum_amount && !restrictions.currency_options[currencyId]) {\n        restrictions.currency_options[currencyId] = {\n          minimum_amount: restrictions.minimum_amount,\n        };\n      }\n    }\n\n    // Return with the correct storage format (string values)\n    return {\n      ...restrictions,\n      currency_options: formatted,\n    } as any;\n  }\n}\n\nexport type TPromotionCode = InferAttributes<PromotionCode>;\n","numLines":390,"startLine":1,"totalLines":390}}}
{"parentUuid":"63615719-1f58-4a22-9773-1f89431fd9b2","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PSGbksgs5FBXYHd24dKerQ","type":"tool_result","content":"     1→import { BN, fromUnitToToken } from '@ocap/util';\n     2→\n     3→import pick from 'lodash/pick';\n     4→import {\n     5→  Coupon,\n     6→  Customer,\n     7→  Discount,\n     8→  PromotionCode,\n     9→  Subscription,\n    10→  CheckoutSession,\n    11→  PaymentCurrency,\n    12→} from '../../store/models';\n    13→import type { TLineItemExpanded } from '../../store/models';\n    14→import logger from '../logger';\n    15→import { emitAsync } from '../event';\n    16→import { formatNumber } from '../util';\n    17→\n    18→export function validCoupon(coupon: Coupon, lineItems?: TLineItemExpanded[]) {\n    19→  if (!coupon.valid) {\n    20→    return { valid: false, reason: 'This coupon is no longer available' };\n    21→  }\n    22→  if (coupon.redeem_by && Math.floor(Date.now() / 1000) > coupon.redeem_by) {\n    23→    return { valid: false, reason: 'This coupon has expired and cannot be used' };\n    24→  }\n    25→  if (coupon.max_redemptions && (coupon.times_redeemed ?? 0) >= coupon.max_redemptions) {\n    26→    return { valid: false, reason: 'This coupon has been fully redeemed and is no longer available' };\n    27→  }\n    28→  if (lineItems && lineItems.length > 0 && coupon.applies_to?.products) {\n    29→    const applicableProducts = coupon.applies_to?.products;\n    30→    if (applicableProducts && applicableProducts.length > 0) {\n    31→      const hasApplicableProduct = lineItems.some((item) => applicableProducts.includes(item.price?.product_id));\n    32→      if (!hasApplicableProduct) {\n    33→        return { valid: false, reason: 'This coupon cannot be applied to the items in your cart' };\n    34→      }\n    35→    }\n    36→  }\n    37→  return { valid: true };\n    38→}\n    39→\n    40→export async function validPromotionCode(\n    41→  promotionCode: PromotionCode,\n    42→  {\n    43→    customerId,\n    44→    amount,\n    45→    currencyId,\n    46→  }: {\n    47→    customerId?: string;\n    48→    amount?: string;\n    49→    currencyId?: string;\n    50→  }\n    51→) {\n    52→  if (!promotionCode.active) {\n    53→    return { valid: false, reason: 'This promotion code is no longer available' };\n    54→  }\n    55→  if (promotionCode.expires_at && Math.floor(Date.now() / 1000) > promotionCode.expires_at) {\n    56→    return { valid: false, reason: 'This promotion code has expired and cannot be used' };\n    57→  }\n    58→  if (promotionCode.max_redemptions && (promotionCode.times_redeemed ?? 0) >= promotionCode.max_redemptions) {\n    59→    return { valid: false, reason: 'This promotion code has been fully redeemed and is no longer available' };\n    60→  }\n    61→  if (customerId) {\n    62→    const customer = await Customer.findByPkOrDid(customerId);\n    63→    if (promotionCode.verification_type === 'user_restricted' && customer?.did) {\n    64→      if (!promotionCode.customer_dids?.includes(customer.did)) {\n    65→        return { valid: false, reason: 'This promotion code is not available for your account' };\n    66→      }\n    67→    }\n    68→    if (promotionCode.restrictions?.first_time_transaction) {\n    69→      const previousDiscounts = await Discount.count({\n    70→        where: { customer_id: customerId, coupon_id: promotionCode.coupon_id },\n    71→      });\n    72→      if (previousDiscounts > 0) {\n    73→        return { valid: false, reason: 'This promotion is only available for first-time purchases' };\n    74→      }\n    75→    }\n    76→  }\n    77→  if (\n    78→    amount &&\n    79→    currencyId &&\n    80→    (promotionCode.restrictions?.minimum_amount || promotionCode.restrictions?.currency_options?.[currencyId])\n    81→  ) {\n    82→    const minimumAmount =\n    83→      currencyId === promotionCode.restrictions?.minimum_amount_currency\n    84→        ? promotionCode.restrictions?.minimum_amount\n    85→        : promotionCode.restrictions?.currency_options?.[currencyId]?.minimum_amount;\n    86→\n    87→    const currency = await PaymentCurrency.findByPk(currencyId);\n    88→    if (minimumAmount) {\n    89→      const amountBN = new BN(amount);\n    90→      const minimumBN = new BN(minimumAmount);\n    91→      if (amountBN.lt(minimumBN)) {\n    92→        if (!currency) {\n    93→          return {\n    94→            valid: false,\n    95→            reason: 'This promotion requires a minimum purchase amount. Please add more items to your cart.',\n    96→          };\n    97→        }\n    98→        return {\n    99→          valid: false,\n   100→          reason: `This promotion requires a minimum purchase amount of ${formatNumber(fromUnitToToken(minimumBN, currency?.decimal || 2))} ${currency?.symbol}. Please add more items to your cart.`,\n   101→        };\n   102→      }\n   103→    }\n   104→  }\n   105→  return { valid: true };\n   106→}\n   107→\n   108→// Calculate actual discount amount (not the remaining amount after discount)\n   109→export function calculateDiscountAmount(\n   110→  coupon: Coupon,\n   111→  amount: string,\n   112→  currency: { id: string; decimal: number; symbol: string }\n   113→): string {\n   114→  if (coupon.percent_off > 0) {\n   115→    // Calculate percentage discount\n   116→    const discountAmount = new BN(amount).mul(new BN(coupon.percent_off)).div(new BN(100));\n   117→    return discountAmount.toString();\n   118→  }\n   119→\n   120→  if (coupon.amount_off) {\n   121→    // Calculate fixed amount discount\n   122→    const amountOff =\n   123→      coupon.currency_id === currency.id ? coupon.amount_off : coupon.currency_options?.[currency.id]?.amount_off;\n   124→\n   125→    if (amountOff) {\n   126→      // Return the smaller of discount amount or total amount\n   127→      const discountBN = new BN(amountOff);\n   128→      const totalBN = new BN(amount);\n   129→      return BN.min(discountBN, totalBN).toString();\n   130→    }\n   131→  }\n   132→\n   133→  return '0';\n   134→}\n   135→\n   136→/**\n   137→ * Lock coupon and promotion code when discount is created/applied\n   138→ */\n   139→export async function lockDiscountResources(couponId: string, promotionCodeId?: string): Promise<void> {\n   140→  try {\n   141→    // Lock the coupon\n   142→    if (couponId) {\n   143→      const coupon = await Coupon.findByPk(couponId);\n   144→      if (coupon && !coupon.locked) {\n   145→        await coupon.update({ locked: true });\n   146→        logger.info('Locked coupon when creating discount', {\n   147→          couponId,\n   148→        });\n   149→      }\n   150→    }\n   151→\n   152→    // Lock the promotion code if it exists\n   153→    if (promotionCodeId) {\n   154→      const promotionCode = await PromotionCode.findByPk(promotionCodeId);\n   155→      if (promotionCode && !promotionCode.locked) {\n   156→        await promotionCode.update({ locked: true });\n   157→        logger.info('Locked promotion code when creating discount', {\n   158→          promotionCodeId,\n   159→        });\n   160→      }\n   161→    }\n   162→  } catch (error) {\n   163→    logger.error('Error locking discount resources', {\n   164→      couponId,\n   165→      promotionCodeId,\n   166→      error: error.message,\n   167→    });\n   168→  }\n   169→}\n   170→\n   171→/**\n   172→ * Get discount records for a checkout session\n   173→ * Used when creating invoices/subscriptions to include discount information\n   174→ */\n   175→export async function getDiscountRecordsForCheckout({\n   176→  checkoutSessionId,\n   177→  customerId,\n   178→}: {\n   179→  checkoutSessionId: string;\n   180→  customerId: string;\n   181→}): Promise<{\n   182→  discountRecords: any[];\n   183→  appliedDiscounts: string[];\n   184→  discountBreakdown: Array<{ amount: string; discount: string }>;\n   185→}> {\n   186→  const discountRecords = await Discount.findAll({\n   187→    where: {\n   188→      customer_id: customerId,\n   189→      checkout_session_id: checkoutSessionId,\n   190→    },\n   191→    include: [\n   192→      { model: Coupon, as: 'coupon' },\n   193→      { model: PromotionCode, as: 'promotionCode', required: false },\n   194→    ],\n   195→  });\n   196→\n   197→  if (discountRecords.length === 0) {\n   198→    return {\n   199→      discountRecords: [],\n   200→      appliedDiscounts: [],\n   201→      discountBreakdown: [],\n   202→    };\n   203→  }\n   204→\n   205→  const appliedDiscounts = discountRecords.map((d) => d.id);\n   206→  const discountBreakdown = discountRecords.map((d) => ({\n   207→    amount: d.metadata?.discount_amount || '0',\n   208→    discount: d.id,\n   209→  }));\n   210→\n   211→  logger.info('Retrieved discount records for checkout session', {\n   212→    checkoutSessionId,\n   213→    customerId,\n   214→    recordCount: discountRecords.length,\n   215→  });\n   216→\n   217→  return {\n   218→    discountRecords,\n   219→    appliedDiscounts,\n   220→    discountBreakdown,\n   221→  };\n   222→}\n   223→\n   224→/**\n   225→ * Get existing discount records for a checkout session\n   226→ */\n   227→async function getExistingDiscountRecords(customerId: string, checkoutSessionId: string) {\n   228→  try {\n   229→    const existingDiscounts = await Discount.findAll({\n   230→      where: {\n   231→        customer_id: customerId,\n   232→        checkout_session_id: checkoutSessionId,\n   233→      },\n   234→    });\n   235→\n   236→    const existingDiscountMap = new Map();\n   237→    existingDiscounts.forEach((discount) => {\n   238→      const key = discount.subscription_id || 'no_subscription';\n   239→      existingDiscountMap.set(key, discount);\n   240→    });\n   241→\n   242→    return existingDiscountMap;\n   243→  } catch (error) {\n   244→    logger.error('Error fetching existing discount records', {\n   245→      customerId,\n   246→      checkoutSessionId,\n   247→      error: error.message,\n   248→    });\n   249→    throw new Error(`Failed to fetch existing discount records: ${error.message}`);\n   250→  }\n   251→}\n   252→\n   253→/**\n   254→ * Build base discount data from checkout session and coupon info\n   255→ */\n   256→function buildBaseDiscountData({\n   257→  checkoutSession,\n   258→  customerId,\n   259→  coupon,\n   260→  promotionCode,\n   261→  discountAmount,\n   262→  verificationData,\n   263→}: {\n   264→  checkoutSession: CheckoutSession;\n   265→  customerId: string;\n   266→  coupon: Coupon;\n   267→  promotionCode?: PromotionCode;\n   268→  discountAmount: string;\n   269→  verificationData?: any;\n   270→}) {\n   271→  const now = Math.floor(Date.now() / 1000);\n   272→  let endTime: number | undefined;\n   273→\n   274→  if (coupon.duration === 'once') {\n   275→    endTime = now + 60;\n   276→  } else if (coupon.duration === 'repeating' && coupon.duration_in_months) {\n   277→    const endDate = new Date();\n   278→    endDate.setMonth(endDate.getMonth() + coupon.duration_in_months);\n   279→    endTime = Math.floor(endDate.getTime() / 1000);\n   280→  }\n   281→\n   282→  return {\n   283→    livemode: coupon.livemode,\n   284→    coupon_id: coupon.id,\n   285→    promotion_code_id: promotionCode?.id,\n   286→    customer_id: customerId,\n   287→    checkout_session_id: checkoutSession.id,\n   288→    start: now,\n   289→    end: endTime,\n   290→    verification_method: promotionCode?.verification_type,\n   291→    verification_data: verificationData || checkoutSession.metadata?.verification_data,\n   292→    metadata: {\n   293→      discount_amount: discountAmount,\n   294→      original_amount: checkoutSession.amount_subtotal,\n   295→      final_amount: checkoutSession.amount_total,\n   296→      currency_id: checkoutSession.currency_id,\n   297→      applied_at: new Date().toISOString(),\n   298→    },\n   299→  };\n   300→}\n   301→\n   302→/**\n   303→ * Process discount record for a single subscription\n   304→ */\n   305→async function processSubscriptionDiscount({\n   306→  subscriptionId,\n   307→  baseDiscountData,\n   308→  existingDiscountMap,\n   309→  checkoutSessionId,\n   310→}: {\n   311→  subscriptionId: string;\n   312→  baseDiscountData: any;\n   313→  existingDiscountMap: Map<string, any>;\n   314→  checkoutSessionId: string;\n   315→}): Promise<{ discountRecord: Discount; shouldUpdateUsage: boolean }> {\n   316→  try {\n   317→    const existingDiscount = existingDiscountMap.get(subscriptionId);\n   318→\n   319→    if (existingDiscount) {\n   320→      const couponChanged = existingDiscount.coupon_id !== baseDiscountData.coupon_id;\n   321→      const promoChanged = existingDiscount.promotion_code_id !== baseDiscountData.promotion_code_id;\n   322→\n   323→      const updated = await existingDiscount.update({\n   324→        ...baseDiscountData,\n   325→        subscription_id: subscriptionId,\n   326→      });\n   327→\n   328→      logger.info('Upserted discount record for subscription', {\n   329→        checkoutSessionId,\n   330→        subscriptionId,\n   331→        discountId: updated.id,\n   332→        couponChanged,\n   333→        promoChanged,\n   334→      });\n   335→\n   336→      return { discountRecord: updated, shouldUpdateUsage: couponChanged || promoChanged };\n   337→    }\n   338→\n   339→    // Create new discount record\n   340→    const newDiscount = await Discount.create({\n   341→      ...baseDiscountData,\n   342→      subscription_id: subscriptionId,\n   343→      confirmed: false,\n   344→      metadata: {\n   345→        ...baseDiscountData.metadata,\n   346→        subscription_id: subscriptionId,\n   347→      },\n   348→    });\n   349→\n   350→    // Lock coupon and promotion code when discount is created\n   351→    await lockDiscountResources(baseDiscountData.coupon_id, baseDiscountData.promotion_code_id);\n   352→\n   353→    logger.info('Created new discount record for subscription', {\n   354→      checkoutSessionId,\n   355→      subscriptionId,\n   356→      discountId: newDiscount.id,\n   357→    });\n   358→\n   359→    return { discountRecord: newDiscount, shouldUpdateUsage: true };\n   360→  } catch (error) {\n   361→    logger.error('Error processing subscription discount', {\n   362→      subscriptionId,\n   363→      checkoutSessionId,\n   364→      error: error.message,\n   365→    });\n   366→    throw new Error(`Failed to process subscription discount: ${error.message}`);\n   367→  }\n   368→}\n   369→\n   370→/**\n   371→ * Process discount record for non-subscription case\n   372→ */\n   373→async function processNonSubscriptionDiscount(\n   374→  baseDiscountData: any,\n   375→  existingDiscountMap: Map<string, any>,\n   376→  checkoutSessionId: string\n   377→): Promise<{ discountRecord: Discount; shouldUpdateUsage: boolean }> {\n   378→  try {\n   379→    const existingDiscount = existingDiscountMap.get('no_subscription');\n   380→\n   381→    if (existingDiscount) {\n   382→      const couponChanged = existingDiscount.coupon_id !== baseDiscountData.coupon_id;\n   383→      const promoChanged = existingDiscount.promotion_code_id !== baseDiscountData.promotion_code_id;\n   384→\n   385→      const updated = await existingDiscount.update({\n   386→        ...baseDiscountData,\n   387→      });\n   388→\n   389→      logger.info('Upserted single discount record', {\n   390→        checkoutSessionId,\n   391→        discountId: updated.id,\n   392→        couponChanged,\n   393→        promoChanged,\n   394→      });\n   395→\n   396→      return { discountRecord: updated, shouldUpdateUsage: couponChanged || promoChanged };\n   397→    }\n   398→\n   399→    // Create new discount record\n   400→    const newDiscount = await Discount.create({\n   401→      ...baseDiscountData,\n   402→      confirmed: false,\n   403→    });\n   404→\n   405→    // Lock coupon and promotion code when discount is created\n   406→    await lockDiscountResources(baseDiscountData.coupon_id, baseDiscountData.promotion_code_id);\n   407→\n   408→    logger.info('Created new single discount record', {\n   409→      checkoutSessionId,\n   410→      discountId: newDiscount.id,\n   411→    });\n   412→\n   413→    return { discountRecord: newDiscount, shouldUpdateUsage: true };\n   414→  } catch (error) {\n   415→    logger.error('Error processing non-subscription discount', {\n   416→      checkoutSessionId,\n   417→      error: error.message,\n   418→    });\n   419→    throw new Error(`Failed to process non-subscription discount: ${error.message}`);\n   420→  }\n   421→}\n   422→\n   423→/**\n   424→ * Update usage counts for coupons and promotion codes\n   425→ * Uses checkout session ID to prevent duplicate counting when multiple subscriptions are created\n   426→ */\n   427→async function updateUsageCounts({\n   428→  coupon,\n   429→  promotionCode,\n   430→  updatedCoupons,\n   431→  updatedPromotionCodes,\n   432→  checkoutSessionId,\n   433→}: {\n   434→  coupon: Coupon;\n   435→  promotionCode?: PromotionCode;\n   436→  updatedCoupons: Set<string>;\n   437→  updatedPromotionCodes: Set<string>;\n   438→  checkoutSessionId: string;\n   439→}): Promise<void> {\n   440→  try {\n   441→    const updatePromises = [] as Array<Promise<any>>;\n   442→\n   443→    // Create unique keys based on checkout session to prevent duplicate counting\n   444→    const couponSessionKey = `${coupon.id}-${checkoutSessionId}`;\n   445→    const promotionCodeSessionKey = promotionCode ? `${promotionCode.id}-${checkoutSessionId}` : '';\n   446→\n   447→    if (!updatedCoupons.has(couponSessionKey)) {\n   448→      updatedCoupons.add(couponSessionKey);\n   449→      updatePromises.push(\n   450→        coupon.update({\n   451→          times_redeemed: (coupon.times_redeemed || 0) + 1,\n   452→        })\n   453→      );\n   454→    }\n   455→\n   456→    if (promotionCode && promotionCodeSessionKey && !updatedPromotionCodes.has(promotionCodeSessionKey)) {\n   457→      updatedPromotionCodes.add(promotionCodeSessionKey);\n   458→      updatePromises.push(\n   459→        promotionCode.update({\n   460→          times_redeemed: (promotionCode.times_redeemed || 0) + 1,\n   461→        })\n   462→      );\n   463→    }\n   464→\n   465→    await Promise.all(updatePromises);\n   466→    emitAsync('discount-status.queued', coupon, 'coupon', true);\n   467→    if (promotionCode) {\n   468→      emitAsync('discount-status.queued', promotionCode, 'promotion-code', true);\n   469→    }\n   470→\n   471→    logger.debug('Updated coupon and promotion code usage counts', {\n   472→      checkoutSessionId,\n   473→      couponId: coupon.id,\n   474→      promotionCodeId: promotionCode?.id,\n   475→    });\n   476→  } catch (error) {\n   477→    logger.error('Error updating usage counts', {\n   478→      checkoutSessionId,\n   479→      couponId: coupon.id,\n   480→      promotionCodeId: promotionCode?.id,\n   481→      error: error.message,\n   482→    });\n   483→    throw new Error(`Failed to update usage counts: ${error.message}`);\n   484→  }\n   485→}\n   486→\n   487→/**\n   488→ * Update subscription discount_id references after discount records are created/updated\n   489→ */\n   490→export async function updateSubscriptionDiscountReferences({\n   491→  discountRecords,\n   492→  subscriptionsUpdated,\n   493→}: {\n   494→  discountRecords: any[];\n   495→  subscriptionsUpdated: string[];\n   496→}): Promise<{ updatedSubscriptions: string[] }> {\n   497→  if (subscriptionsUpdated.length === 0) {\n   498→    return { updatedSubscriptions: [] };\n   499→  }\n   500→\n   501→  const updatedSubscriptions: string[] = [];\n   502→\n   503→  try {\n   504→    logger.info('Updating subscription discount_id references', {\n   505→      subscriptionsToUpdate: subscriptionsUpdated.length,\n   506→    });\n   507→\n   508→    const subscriptionUpdatePromises = subscriptionsUpdated.map(async (subscriptionId) => {\n   509→      try {\n   510→        // Find the discount record for this subscription\n   511→        const discountRecord = discountRecords.find((d) => d.subscription_id === subscriptionId);\n   512→        if (!discountRecord) {\n   513→          logger.warn('No discount record found for subscription', { subscriptionId });\n   514→          return null;\n   515→        }\n   516→\n   517→        // Update subscription with discount_id\n   518→        const [updateCount] = await Subscription.update(\n   519→          { discount_id: discountRecord.id },\n   520→          { where: { id: subscriptionId } }\n   521→        );\n   522→\n   523→        if (updateCount > 0) {\n   524→          logger.debug('Updated subscription discount_id', {\n   525→            subscriptionId,\n   526→            discountId: discountRecord.id,\n   527→          });\n   528→          return subscriptionId;\n   529→        }\n   530→\n   531→        logger.warn('Subscription not found for discount_id update', { subscriptionId });\n   532→        return null;\n   533→      } catch (error) {\n   534→        logger.error('Failed to update subscription discount_id', {\n   535→          subscriptionId,\n   536→          error: error.message,\n   537→        });\n   538→        return null;\n   539→      }\n   540→    });\n   541→\n   542→    const updateResults = await Promise.all(subscriptionUpdatePromises);\n   543→    updatedSubscriptions.push(...updateResults.filter((id) => id !== null));\n   544→\n   545→    logger.info('Completed subscription discount_id reference updates', {\n   546→      requestedUpdates: subscriptionsUpdated.length,\n   547→      successfulUpdates: updatedSubscriptions.length,\n   548→    });\n   549→\n   550→    return { updatedSubscriptions };\n   551→  } catch (error) {\n   552→    logger.error('Error updating subscription discount references', {\n   553→      subscriptionsUpdated,\n   554→      error: error.message,\n   555→    });\n   556→    throw new Error(`Failed to update subscription discount references: ${error.message}`);\n   557→  }\n   558→}\n   559→\n   560→/**\n   561→ * Create or update discount records for a completed checkout session\n   562→ * This creates/updates the actual discount records and manages usage counts\n   563→ * For subscriptions, creates separate discount records for each subscription\n   564→ * Handles deduplication and updates when coupon/promotion code changes\n   565→ */\n   566→export async function createDiscountRecordsForCheckout({\n   567→  checkoutSession,\n   568→  customerId,\n   569→  subscriptionIds = [],\n   570→}: {\n   571→  checkoutSession: any; // CheckoutSession type\n   572→  customerId: string;\n   573→  subscriptionIds?: string[];\n   574→}): Promise<{\n   575→  discountRecords: any[];\n   576→  updatedCoupons: string[];\n   577→  updatedPromotionCodes: string[];\n   578→  subscriptionsUpdated: string[];\n   579→}> {\n   580→  if (!checkoutSession.discounts?.length) {\n   581→    return { discountRecords: [], updatedCoupons: [], updatedPromotionCodes: [], subscriptionsUpdated: [] };\n   582→  }\n   583→\n   584→  logger.info('Creating/updating discount records for checkout session', {\n   585→    checkoutSessionId: checkoutSession.id,\n   586→    customerId,\n   587→    subscriptionIds,\n   588→  });\n   589→\n   590→  try {\n   591→    // Get existing discount records\n   592→    const existingDiscountMap = await getExistingDiscountRecords(customerId, checkoutSession.id);\n   593→\n   594→    const updatedCoupons = new Set<string>();\n   595→    const updatedPromotionCodes = new Set<string>();\n   596→    const allDiscountRecords: any[] = [];\n   597→    const subscriptionsUpdated: string[] = [];\n   598→\n   599→    // Process each discount configuration\n   600→    const discountProcessingPromises = checkoutSession.discounts.map(async (discount: any) => {\n   601→      const { promotion_code: promotionCodeId, coupon: couponId, discount_amount: discountAmount } = discount;\n   602→\n   603→      if (!couponId) {\n   604→        logger.warn('Incomplete discount configuration, skipping', {\n   605→          checkoutSessionId: checkoutSession.id,\n   606→          hasCoupon: !!couponId,\n   607→        });\n   608→        return null;\n   609→      }\n   610→\n   611→      try {\n   612→        // Fetch coupon and promotion code\n   613→        const [coupon, promotionCode] = await Promise.all([\n   614→          Coupon.findByPk(couponId),\n   615→          promotionCodeId ? PromotionCode.findByPk(promotionCodeId) : Promise.resolve(null),\n   616→        ]);\n   617→\n   618→        if (!coupon) {\n   619→          logger.warn('Coupon not found, skipping discount', {\n   620→            couponId,\n   621→            checkoutSessionId: checkoutSession.id,\n   622→          });\n   623→          return null;\n   624→        }\n   625→\n   626→        // Build base discount data\n   627→        const baseDiscountData = buildBaseDiscountData({\n   628→          checkoutSession,\n   629→          customerId,\n   630→          coupon,\n   631→          promotionCode: promotionCode || undefined,\n   632→          discountAmount,\n   633→          verificationData: discount.verification_data,\n   634→        });\n   635→\n   636→        const discountRecords: any[] = [];\n   637→        let shouldUpdateUsageCount = false;\n   638→        const currentSubscriptionsUpdated: string[] = [];\n   639→\n   640→        // Process subscriptions\n   641→        if (subscriptionIds.length > 0) {\n   642→          const subscriptionProcessingPromises = subscriptionIds.map(async (subscriptionId) => {\n   643→            try {\n   644→              const result = await processSubscriptionDiscount({\n   645→                subscriptionId,\n   646→                baseDiscountData,\n   647→                existingDiscountMap,\n   648→                checkoutSessionId: checkoutSession.id,\n   649→              });\n   650→\n   651→              if (result.shouldUpdateUsage) {\n   652→                currentSubscriptionsUpdated.push(subscriptionId);\n   653→              }\n   654→\n   655→              return result.discountRecord;\n   656→            } catch (error) {\n   657→              logger.error('Failed to process subscription discount, continuing with others', {\n   658→                subscriptionId,\n   659→                error: error.message,\n   660→              });\n   661→              return null;\n   662→            }\n   663→          });\n   664→\n   665→          const subscriptionResults = await Promise.all(subscriptionProcessingPromises);\n   666→          discountRecords.push(...subscriptionResults.filter((record) => record !== null));\n   667→\n   668→          if (currentSubscriptionsUpdated.length > 0) {\n   669→            shouldUpdateUsageCount = true;\n   670→          }\n   671→        } else {\n   672→          // Process non-subscription case\n   673→          try {\n   674→            const result = await processNonSubscriptionDiscount(\n   675→              baseDiscountData,\n   676→              existingDiscountMap,\n   677→              checkoutSession.id\n   678→            );\n   679→\n   680→            discountRecords.push(result.discountRecord);\n   681→            shouldUpdateUsageCount = result.shouldUpdateUsage;\n   682→          } catch (error) {\n   683→            logger.error('Failed to process non-subscription discount', {\n   684→              checkoutSessionId: checkoutSession.id,\n   685→              error: error.message,\n   686→            });\n   687→            throw error;\n   688→          }\n   689→        }\n   690→\n   691→        // Update usage counts if needed\n   692→        if (shouldUpdateUsageCount) {\n   693→          try {\n   694→            await updateUsageCounts({\n   695→              coupon,\n   696→              promotionCode: promotionCode || undefined,\n   697→              updatedCoupons,\n   698→              updatedPromotionCodes,\n   699→              checkoutSessionId: checkoutSession.id,\n   700→            });\n   701→            await Promise.all(\n   702→              discountRecords.map(async (discountRecord) => {\n   703→                await discountRecord.update({\n   704→                  confirmed: true,\n   705→                });\n   706→              })\n   707→            );\n   708→          } catch (error) {\n   709→            logger.error('Failed to update usage counts, but continuing', {\n   710→              couponId: coupon.id,\n   711→              promotionCodeId: promotionCode?.id,\n   712→              error: error.message,\n   713→            });\n   714→          }\n   715→        }\n   716→\n   717→        return {\n   718→          discountRecords,\n   719→          subscriptionsUpdated: currentSubscriptionsUpdated,\n   720→        };\n   721→      } catch (error) {\n   722→        logger.error('Error processing discount configuration, skipping', {\n   723→          couponId,\n   724→          promotionCodeId,\n   725→          checkoutSessionId: checkoutSession.id,\n   726→          error: error.message,\n   727→        });\n   728→        return null;\n   729→      }\n   730→    });\n   731→\n   732→    const processingResults = await Promise.all(discountProcessingPromises);\n   733→\n   734→    // Aggregate results\n   735→    processingResults.forEach((result) => {\n   736→      if (result) {\n   737→        allDiscountRecords.push(...result.discountRecords);\n   738→        subscriptionsUpdated.push(...result.subscriptionsUpdated);\n   739→      }\n   740→    });\n   741→\n   742→    logger.info('All discount records processed successfully', {\n   743→      checkoutSessionId: checkoutSession.id,\n   744→      customerId,\n   745→      totalRecords: allDiscountRecords.length,\n   746→      subscriptionCount: subscriptionIds.length,\n   747→      subscriptionsUpdated: subscriptionsUpdated.length,\n   748→      updatedCouponsCount: updatedCoupons.size,\n   749→      updatedPromotionCodesCount: updatedPromotionCodes.size,\n   750→    });\n   751→\n   752→    return {\n   753→      discountRecords: allDiscountRecords,\n   754→      updatedCoupons: Array.from(updatedCoupons),\n   755→      updatedPromotionCodes: Array.from(updatedPromotionCodes),\n   756→      subscriptionsUpdated,\n   757→    };\n   758→  } catch (error) {\n   759→    logger.error('Critical error processing discount records for checkout', {\n   760→      checkoutSessionId: checkoutSession.id,\n   761→      customerId,\n   762→      subscriptionIds,\n   763→      error: error.message,\n   764→    });\n   765→    throw new Error(`Failed to process discount records: ${error.message}`);\n   766→  }\n   767→}\n   768→\n   769→// Unified promotion code eligibility check\n   770→export async function checkPromotionCodeEligibility({\n   771→  promotionCode,\n   772→  couponId,\n   773→  customerId,\n   774→  amount,\n   775→  currencyId,\n   776→  lineItems = [],\n   777→}: {\n   778→  promotionCode: PromotionCode;\n   779→  couponId: string;\n   780→  customerId: string;\n   781→  amount: string;\n   782→  currencyId: string;\n   783→  lineItems?: TLineItemExpanded[];\n   784→}): Promise<{ eligible: boolean; reason?: string }> {\n   785→  // Basic promotion code checks\n   786→  if (!promotionCode.active) {\n   787→    return { eligible: false, reason: 'This promotion code is no longer available' };\n   788→  }\n   789→\n   790→  if (promotionCode.expires_at && Math.floor(Date.now() / 1000) > promotionCode.expires_at) {\n   791→    return { eligible: false, reason: 'This promotion code has expired and cannot be used' };\n   792→  }\n   793→\n   794→  if (promotionCode.max_redemptions && (promotionCode.times_redeemed ?? 0) >= promotionCode.max_redemptions) {\n   795→    return { eligible: false, reason: 'This promotion code has been fully redeemed and is no longer available' };\n   796→  }\n   797→\n   798→  // Get associated coupon and validate\n   799→  const coupon = await Coupon.findByPk(couponId);\n   800→  if (!coupon) {\n   801→    return { eligible: false, reason: 'This promotion is no longer available' };\n   802→  }\n   803→\n   804→  // Coupon validity check\n   805→  const couponValidation = validCoupon(coupon, lineItems);\n   806→  if (!couponValidation.valid) {\n   807→    return { eligible: false, reason: couponValidation.reason };\n   808→  }\n   809→\n   810→  const promotionValidation = await validPromotionCode(promotionCode, {\n   811→    customerId,\n   812→    amount,\n   813→    currencyId,\n   814→  });\n   815→  if (!promotionValidation.valid) {\n   816→    return { eligible: false, reason: promotionValidation.reason };\n   817→  }\n   818→  return { eligible: true };\n   819→}\n   820→\n   821→// Validate discount for billing cycles (subscription invoices)\n   822→export async function validateDiscountForBilling({\n   823→  discount,\n   824→}: {\n   825→  discount: Discount;\n   826→  subscriptionId?: string;\n   827→}): Promise<{ valid: boolean; reason?: string; shouldRemove?: boolean }> {\n   828→  const coupon = await Coupon.findByPk(discount.coupon_id);\n   829→  if (!coupon) {\n   830→    return {\n   831→      valid: false,\n   832→      reason: 'This discount is no longer available',\n   833→      shouldRemove: true,\n   834→    };\n   835→  }\n   836→\n   837→  const now = Math.floor(Date.now() / 1000);\n   838→\n   839→  // Check discount duration logic\n   840→  switch (coupon.duration) {\n   841→    case 'once':\n   842→      // One-time discounts should not apply to recurring billing\n   843→      return {\n   844→        valid: false,\n   845→        reason: 'One-time discount cannot be applied to subscription billing',\n   846→        shouldRemove: true,\n   847→      };\n   848→\n   849→    case 'repeating':\n   850→      if (!discount.end) {\n   851→        return {\n   852→          valid: false,\n   853→          reason: 'Repeating discount missing end date',\n   854→          shouldRemove: true,\n   855→        };\n   856→      }\n   857→\n   858→      if (now > Number(discount.end)) {\n   859→        return {\n   860→          valid: false,\n   861→          reason: 'Repeating discount has expired',\n   862→          shouldRemove: true,\n   863→        };\n   864→      }\n   865→      break;\n   866→\n   867→    case 'forever':\n   868→      // Forever discounts are always valid\n   869→      break;\n   870→\n   871→    default:\n   872→      return {\n   873→        valid: false,\n   874→        reason: `Unknown coupon duration: ${coupon.duration}`,\n   875→        shouldRemove: true,\n   876→      };\n   877→  }\n   878→\n   879→  return { valid: true };\n   880→}\n   881→\n   882→// Get all valid discounts for a subscription's billing period\n   883→export async function getValidDiscountsForSubscriptionBilling({\n   884→  subscriptionId,\n   885→  customerId,\n   886→}: {\n   887→  subscriptionId: string;\n   888→  customerId: string;\n   889→}): Promise<{\n   890→  validDiscounts: Discount[];\n   891→  expiredDiscounts: Discount[];\n   892→}> {\n   893→  const discounts = await Discount.findAll({\n   894→    where: {\n   895→      customer_id: customerId,\n   896→      subscription_id: subscriptionId,\n   897→    },\n   898→    include: [\n   899→      { model: Coupon, as: 'coupon' },\n   900→      { model: PromotionCode, as: 'promotionCode' },\n   901→    ],\n   902→  });\n   903→\n   904→  const validDiscounts: Discount[] = [];\n   905→  const expiredDiscounts: Discount[] = [];\n   906→\n   907→  logger.info('Found discounts for subscription billing', {\n   908→    subscriptionId,\n   909→    discountCount: discounts.map((d) => d.id),\n   910→  });\n   911→\n   912→  await Promise.all(\n   913→    discounts.map(async (discount) => {\n   914→      const validation = await validateDiscountForBilling({\n   915→        discount,\n   916→        subscriptionId,\n   917→      });\n   918→\n   919→      if (validation.valid) {\n   920→        validDiscounts.push(discount);\n   921→      } else {\n   922→        expiredDiscounts.push(discount);\n   923→        logger.info('Expired discount for subscription billing', {\n   924→          subscriptionId,\n   925→          discountId: discount.id,\n   926→          reason: validation.reason,\n   927→        });\n   928→      }\n   929→    })\n   930→  );\n   931→\n   932→  return { validDiscounts, expiredDiscounts };\n   933→}\n   934→\n   935→/**\n   936→ * Expand line items with complete coupon information\n   937→ * Similar to Price.expand but for coupon information\n   938→ */\n   939→export async function expandLineItemsWithCouponInfo(\n   940→  lineItems: TLineItemExpanded[],\n   941→  sessionDiscounts?: any[],\n   942→  currencyId?: string\n   943→): Promise<TLineItemExpanded[]> {\n   944→  if (!sessionDiscounts?.length) {\n   945→    return lineItems;\n   946→  }\n   947→\n   948→  const enhancedLineItems = await Promise.all(\n   949→    lineItems.map(async (item) => {\n   950→      if (!item.discount_amounts?.length) {\n   951→        return item;\n   952→      }\n   953→\n   954→      const enhancedDiscountAmounts = await Promise.all(\n   955→        item.discount_amounts.map(async (discountAmount: any) => {\n   956→          let couponInfo = null;\n   957→          let promotionCodeInfo = null;\n   958→\n   959→          // Find the discount in checkout session discounts to get IDs\n   960→          const sessionDiscount = sessionDiscounts.find((d: any) => d.coupon || d.promotion_code);\n   961→          if (sessionDiscount) {\n   962→            if (sessionDiscount.coupon) {\n   963→              const coupon = await Coupon.findByPk(sessionDiscount.coupon);\n   964→              if (coupon) {\n   965→                couponInfo = {\n   966→                  object: 'coupon',\n   967→                  id: coupon.id,\n   968→                  name: coupon.name,\n   969→                  amount_off: coupon.amount_off,\n   970→                  percent_off: coupon.percent_off,\n   971→                  currency: coupon.currency_id,\n   972→                  duration: coupon.duration,\n   973→                  duration_in_months: coupon.duration_in_months,\n   974→                  has_applies_to_products: true,\n   975→                };\n   976→              }\n   977→            }\n   978→\n   979→            if (sessionDiscount.promotion_code) {\n   980→              const promotionCode = await PromotionCode.findByPk(sessionDiscount.promotion_code);\n   981→              if (promotionCode) {\n   982→                promotionCodeInfo = {\n   983→                  object: 'promotion_code',\n   984→                  id: promotionCode.id,\n   985→                  code: promotionCode.code,\n   986→                };\n   987→              }\n   988→            }\n   989→          }\n   990→\n   991→          return {\n   992→            ...discountAmount,\n   993→            coupon: couponInfo,\n   994→            promotion_code: promotionCodeInfo,\n   995→            currency: currencyId,\n   996→          };\n   997→        })\n   998→      );\n   999→\n  1000→      return {\n  1001→        ...item,\n  1002→        discount_amounts: enhancedDiscountAmounts,\n  1003→      };\n  1004→    })\n  1005→  );\n  1006→\n  1007→  return enhancedLineItems;\n  1008→}\n  1009→\n  1010→/**\n  1011→ * Expand discounts with complete coupon and promotion code information\n  1012→ */\n  1013→export async function expandDiscountsWithDetails(discounts?: any[]): Promise<any[]> {\n  1014→  if (!discounts?.length) {\n  1015→    return [];\n  1016→  }\n  1017→\n  1018→  const enhancedDiscounts = await Promise.all(\n  1019→    discounts.map(async (discount) => {\n  1020→      let couponInfo = null;\n  1021→      let promotionCodeInfo = null;\n  1022→\n  1023→      if (discount.coupon) {\n  1024→        const coupon = await Coupon.findByPk(discount.coupon);\n  1025→        if (coupon) {\n  1026→          couponInfo = pick(coupon, [\n  1027→            'id',\n  1028→            'name',\n  1029→            'percent_off',\n  1030→            'amount_off',\n  1031→            'valid',\n  1032→            'duration',\n  1033→            'duration_in_months',\n  1034→            'currency_id',\n  1035→            'currency_options',\n  1036→          ]);\n  1037→        }\n  1038→      }\n  1039→\n  1040→      if (discount.promotion_code) {\n  1041→        const promotionCode = await PromotionCode.findByPk(discount.promotion_code);\n  1042→        if (promotionCode) {\n  1043→          promotionCodeInfo = pick(promotionCode, ['id', 'code']);\n  1044→        }\n  1045→      }\n  1046→\n  1047→      return {\n  1048→        ...discount,\n  1049→        coupon_details: couponInfo,\n  1050→        promotion_code_details: promotionCodeInfo,\n  1051→      };\n  1052→    })\n  1053→  );\n  1054→\n  1055→  return enhancedDiscounts;\n  1056→}\n  1057→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"4fb96098-eb99-48a1-a288-96ee8cc02f4c","timestamp":"2026-01-09T01:49:40.249Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts","content":"import { BN, fromUnitToToken } from '@ocap/util';\n\nimport pick from 'lodash/pick';\nimport {\n  Coupon,\n  Customer,\n  Discount,\n  PromotionCode,\n  Subscription,\n  CheckoutSession,\n  PaymentCurrency,\n} from '../../store/models';\nimport type { TLineItemExpanded } from '../../store/models';\nimport logger from '../logger';\nimport { emitAsync } from '../event';\nimport { formatNumber } from '../util';\n\nexport function validCoupon(coupon: Coupon, lineItems?: TLineItemExpanded[]) {\n  if (!coupon.valid) {\n    return { valid: false, reason: 'This coupon is no longer available' };\n  }\n  if (coupon.redeem_by && Math.floor(Date.now() / 1000) > coupon.redeem_by) {\n    return { valid: false, reason: 'This coupon has expired and cannot be used' };\n  }\n  if (coupon.max_redemptions && (coupon.times_redeemed ?? 0) >= coupon.max_redemptions) {\n    return { valid: false, reason: 'This coupon has been fully redeemed and is no longer available' };\n  }\n  if (lineItems && lineItems.length > 0 && coupon.applies_to?.products) {\n    const applicableProducts = coupon.applies_to?.products;\n    if (applicableProducts && applicableProducts.length > 0) {\n      const hasApplicableProduct = lineItems.some((item) => applicableProducts.includes(item.price?.product_id));\n      if (!hasApplicableProduct) {\n        return { valid: false, reason: 'This coupon cannot be applied to the items in your cart' };\n      }\n    }\n  }\n  return { valid: true };\n}\n\nexport async function validPromotionCode(\n  promotionCode: PromotionCode,\n  {\n    customerId,\n    amount,\n    currencyId,\n  }: {\n    customerId?: string;\n    amount?: string;\n    currencyId?: string;\n  }\n) {\n  if (!promotionCode.active) {\n    return { valid: false, reason: 'This promotion code is no longer available' };\n  }\n  if (promotionCode.expires_at && Math.floor(Date.now() / 1000) > promotionCode.expires_at) {\n    return { valid: false, reason: 'This promotion code has expired and cannot be used' };\n  }\n  if (promotionCode.max_redemptions && (promotionCode.times_redeemed ?? 0) >= promotionCode.max_redemptions) {\n    return { valid: false, reason: 'This promotion code has been fully redeemed and is no longer available' };\n  }\n  if (customerId) {\n    const customer = await Customer.findByPkOrDid(customerId);\n    if (promotionCode.verification_type === 'user_restricted' && customer?.did) {\n      if (!promotionCode.customer_dids?.includes(customer.did)) {\n        return { valid: false, reason: 'This promotion code is not available for your account' };\n      }\n    }\n    if (promotionCode.restrictions?.first_time_transaction) {\n      const previousDiscounts = await Discount.count({\n        where: { customer_id: customerId, coupon_id: promotionCode.coupon_id },\n      });\n      if (previousDiscounts > 0) {\n        return { valid: false, reason: 'This promotion is only available for first-time purchases' };\n      }\n    }\n  }\n  if (\n    amount &&\n    currencyId &&\n    (promotionCode.restrictions?.minimum_amount || promotionCode.restrictions?.currency_options?.[currencyId])\n  ) {\n    const minimumAmount =\n      currencyId === promotionCode.restrictions?.minimum_amount_currency\n        ? promotionCode.restrictions?.minimum_amount\n        : promotionCode.restrictions?.currency_options?.[currencyId]?.minimum_amount;\n\n    const currency = await PaymentCurrency.findByPk(currencyId);\n    if (minimumAmount) {\n      const amountBN = new BN(amount);\n      const minimumBN = new BN(minimumAmount);\n      if (amountBN.lt(minimumBN)) {\n        if (!currency) {\n          return {\n            valid: false,\n            reason: 'This promotion requires a minimum purchase amount. Please add more items to your cart.',\n          };\n        }\n        return {\n          valid: false,\n          reason: `This promotion requires a minimum purchase amount of ${formatNumber(fromUnitToToken(minimumBN, currency?.decimal || 2))} ${currency?.symbol}. Please add more items to your cart.`,\n        };\n      }\n    }\n  }\n  return { valid: true };\n}\n\n// Calculate actual discount amount (not the remaining amount after discount)\nexport function calculateDiscountAmount(\n  coupon: Coupon,\n  amount: string,\n  currency: { id: string; decimal: number; symbol: string }\n): string {\n  if (coupon.percent_off > 0) {\n    // Calculate percentage discount\n    const discountAmount = new BN(amount).mul(new BN(coupon.percent_off)).div(new BN(100));\n    return discountAmount.toString();\n  }\n\n  if (coupon.amount_off) {\n    // Calculate fixed amount discount\n    const amountOff =\n      coupon.currency_id === currency.id ? coupon.amount_off : coupon.currency_options?.[currency.id]?.amount_off;\n\n    if (amountOff) {\n      // Return the smaller of discount amount or total amount\n      const discountBN = new BN(amountOff);\n      const totalBN = new BN(amount);\n      return BN.min(discountBN, totalBN).toString();\n    }\n  }\n\n  return '0';\n}\n\n/**\n * Lock coupon and promotion code when discount is created/applied\n */\nexport async function lockDiscountResources(couponId: string, promotionCodeId?: string): Promise<void> {\n  try {\n    // Lock the coupon\n    if (couponId) {\n      const coupon = await Coupon.findByPk(couponId);\n      if (coupon && !coupon.locked) {\n        await coupon.update({ locked: true });\n        logger.info('Locked coupon when creating discount', {\n          couponId,\n        });\n      }\n    }\n\n    // Lock the promotion code if it exists\n    if (promotionCodeId) {\n      const promotionCode = await PromotionCode.findByPk(promotionCodeId);\n      if (promotionCode && !promotionCode.locked) {\n        await promotionCode.update({ locked: true });\n        logger.info('Locked promotion code when creating discount', {\n          promotionCodeId,\n        });\n      }\n    }\n  } catch (error) {\n    logger.error('Error locking discount resources', {\n      couponId,\n      promotionCodeId,\n      error: error.message,\n    });\n  }\n}\n\n/**\n * Get discount records for a checkout session\n * Used when creating invoices/subscriptions to include discount information\n */\nexport async function getDiscountRecordsForCheckout({\n  checkoutSessionId,\n  customerId,\n}: {\n  checkoutSessionId: string;\n  customerId: string;\n}): Promise<{\n  discountRecords: any[];\n  appliedDiscounts: string[];\n  discountBreakdown: Array<{ amount: string; discount: string }>;\n}> {\n  const discountRecords = await Discount.findAll({\n    where: {\n      customer_id: customerId,\n      checkout_session_id: checkoutSessionId,\n    },\n    include: [\n      { model: Coupon, as: 'coupon' },\n      { model: PromotionCode, as: 'promotionCode', required: false },\n    ],\n  });\n\n  if (discountRecords.length === 0) {\n    return {\n      discountRecords: [],\n      appliedDiscounts: [],\n      discountBreakdown: [],\n    };\n  }\n\n  const appliedDiscounts = discountRecords.map((d) => d.id);\n  const discountBreakdown = discountRecords.map((d) => ({\n    amount: d.metadata?.discount_amount || '0',\n    discount: d.id,\n  }));\n\n  logger.info('Retrieved discount records for checkout session', {\n    checkoutSessionId,\n    customerId,\n    recordCount: discountRecords.length,\n  });\n\n  return {\n    discountRecords,\n    appliedDiscounts,\n    discountBreakdown,\n  };\n}\n\n/**\n * Get existing discount records for a checkout session\n */\nasync function getExistingDiscountRecords(customerId: string, checkoutSessionId: string) {\n  try {\n    const existingDiscounts = await Discount.findAll({\n      where: {\n        customer_id: customerId,\n        checkout_session_id: checkoutSessionId,\n      },\n    });\n\n    const existingDiscountMap = new Map();\n    existingDiscounts.forEach((discount) => {\n      const key = discount.subscription_id || 'no_subscription';\n      existingDiscountMap.set(key, discount);\n    });\n\n    return existingDiscountMap;\n  } catch (error) {\n    logger.error('Error fetching existing discount records', {\n      customerId,\n      checkoutSessionId,\n      error: error.message,\n    });\n    throw new Error(`Failed to fetch existing discount records: ${error.message}`);\n  }\n}\n\n/**\n * Build base discount data from checkout session and coupon info\n */\nfunction buildBaseDiscountData({\n  checkoutSession,\n  customerId,\n  coupon,\n  promotionCode,\n  discountAmount,\n  verificationData,\n}: {\n  checkoutSession: CheckoutSession;\n  customerId: string;\n  coupon: Coupon;\n  promotionCode?: PromotionCode;\n  discountAmount: string;\n  verificationData?: any;\n}) {\n  const now = Math.floor(Date.now() / 1000);\n  let endTime: number | undefined;\n\n  if (coupon.duration === 'once') {\n    endTime = now + 60;\n  } else if (coupon.duration === 'repeating' && coupon.duration_in_months) {\n    const endDate = new Date();\n    endDate.setMonth(endDate.getMonth() + coupon.duration_in_months);\n    endTime = Math.floor(endDate.getTime() / 1000);\n  }\n\n  return {\n    livemode: coupon.livemode,\n    coupon_id: coupon.id,\n    promotion_code_id: promotionCode?.id,\n    customer_id: customerId,\n    checkout_session_id: checkoutSession.id,\n    start: now,\n    end: endTime,\n    verification_method: promotionCode?.verification_type,\n    verification_data: verificationData || checkoutSession.metadata?.verification_data,\n    metadata: {\n      discount_amount: discountAmount,\n      original_amount: checkoutSession.amount_subtotal,\n      final_amount: checkoutSession.amount_total,\n      currency_id: checkoutSession.currency_id,\n      applied_at: new Date().toISOString(),\n    },\n  };\n}\n\n/**\n * Process discount record for a single subscription\n */\nasync function processSubscriptionDiscount({\n  subscriptionId,\n  baseDiscountData,\n  existingDiscountMap,\n  checkoutSessionId,\n}: {\n  subscriptionId: string;\n  baseDiscountData: any;\n  existingDiscountMap: Map<string, any>;\n  checkoutSessionId: string;\n}): Promise<{ discountRecord: Discount; shouldUpdateUsage: boolean }> {\n  try {\n    const existingDiscount = existingDiscountMap.get(subscriptionId);\n\n    if (existingDiscount) {\n      const couponChanged = existingDiscount.coupon_id !== baseDiscountData.coupon_id;\n      const promoChanged = existingDiscount.promotion_code_id !== baseDiscountData.promotion_code_id;\n\n      const updated = await existingDiscount.update({\n        ...baseDiscountData,\n        subscription_id: subscriptionId,\n      });\n\n      logger.info('Upserted discount record for subscription', {\n        checkoutSessionId,\n        subscriptionId,\n        discountId: updated.id,\n        couponChanged,\n        promoChanged,\n      });\n\n      return { discountRecord: updated, shouldUpdateUsage: couponChanged || promoChanged };\n    }\n\n    // Create new discount record\n    const newDiscount = await Discount.create({\n      ...baseDiscountData,\n      subscription_id: subscriptionId,\n      confirmed: false,\n      metadata: {\n        ...baseDiscountData.metadata,\n        subscription_id: subscriptionId,\n      },\n    });\n\n    // Lock coupon and promotion code when discount is created\n    await lockDiscountResources(baseDiscountData.coupon_id, baseDiscountData.promotion_code_id);\n\n    logger.info('Created new discount record for subscription', {\n      checkoutSessionId,\n      subscriptionId,\n      discountId: newDiscount.id,\n    });\n\n    return { discountRecord: newDiscount, shouldUpdateUsage: true };\n  } catch (error) {\n    logger.error('Error processing subscription discount', {\n      subscriptionId,\n      checkoutSessionId,\n      error: error.message,\n    });\n    throw new Error(`Failed to process subscription discount: ${error.message}`);\n  }\n}\n\n/**\n * Process discount record for non-subscription case\n */\nasync function processNonSubscriptionDiscount(\n  baseDiscountData: any,\n  existingDiscountMap: Map<string, any>,\n  checkoutSessionId: string\n): Promise<{ discountRecord: Discount; shouldUpdateUsage: boolean }> {\n  try {\n    const existingDiscount = existingDiscountMap.get('no_subscription');\n\n    if (existingDiscount) {\n      const couponChanged = existingDiscount.coupon_id !== baseDiscountData.coupon_id;\n      const promoChanged = existingDiscount.promotion_code_id !== baseDiscountData.promotion_code_id;\n\n      const updated = await existingDiscount.update({\n        ...baseDiscountData,\n      });\n\n      logger.info('Upserted single discount record', {\n        checkoutSessionId,\n        discountId: updated.id,\n        couponChanged,\n        promoChanged,\n      });\n\n      return { discountRecord: updated, shouldUpdateUsage: couponChanged || promoChanged };\n    }\n\n    // Create new discount record\n    const newDiscount = await Discount.create({\n      ...baseDiscountData,\n      confirmed: false,\n    });\n\n    // Lock coupon and promotion code when discount is created\n    await lockDiscountResources(baseDiscountData.coupon_id, baseDiscountData.promotion_code_id);\n\n    logger.info('Created new single discount record', {\n      checkoutSessionId,\n      discountId: newDiscount.id,\n    });\n\n    return { discountRecord: newDiscount, shouldUpdateUsage: true };\n  } catch (error) {\n    logger.error('Error processing non-subscription discount', {\n      checkoutSessionId,\n      error: error.message,\n    });\n    throw new Error(`Failed to process non-subscription discount: ${error.message}`);\n  }\n}\n\n/**\n * Update usage counts for coupons and promotion codes\n * Uses checkout session ID to prevent duplicate counting when multiple subscriptions are created\n */\nasync function updateUsageCounts({\n  coupon,\n  promotionCode,\n  updatedCoupons,\n  updatedPromotionCodes,\n  checkoutSessionId,\n}: {\n  coupon: Coupon;\n  promotionCode?: PromotionCode;\n  updatedCoupons: Set<string>;\n  updatedPromotionCodes: Set<string>;\n  checkoutSessionId: string;\n}): Promise<void> {\n  try {\n    const updatePromises = [] as Array<Promise<any>>;\n\n    // Create unique keys based on checkout session to prevent duplicate counting\n    const couponSessionKey = `${coupon.id}-${checkoutSessionId}`;\n    const promotionCodeSessionKey = promotionCode ? `${promotionCode.id}-${checkoutSessionId}` : '';\n\n    if (!updatedCoupons.has(couponSessionKey)) {\n      updatedCoupons.add(couponSessionKey);\n      updatePromises.push(\n        coupon.update({\n          times_redeemed: (coupon.times_redeemed || 0) + 1,\n        })\n      );\n    }\n\n    if (promotionCode && promotionCodeSessionKey && !updatedPromotionCodes.has(promotionCodeSessionKey)) {\n      updatedPromotionCodes.add(promotionCodeSessionKey);\n      updatePromises.push(\n        promotionCode.update({\n          times_redeemed: (promotionCode.times_redeemed || 0) + 1,\n        })\n      );\n    }\n\n    await Promise.all(updatePromises);\n    emitAsync('discount-status.queued', coupon, 'coupon', true);\n    if (promotionCode) {\n      emitAsync('discount-status.queued', promotionCode, 'promotion-code', true);\n    }\n\n    logger.debug('Updated coupon and promotion code usage counts', {\n      checkoutSessionId,\n      couponId: coupon.id,\n      promotionCodeId: promotionCode?.id,\n    });\n  } catch (error) {\n    logger.error('Error updating usage counts', {\n      checkoutSessionId,\n      couponId: coupon.id,\n      promotionCodeId: promotionCode?.id,\n      error: error.message,\n    });\n    throw new Error(`Failed to update usage counts: ${error.message}`);\n  }\n}\n\n/**\n * Update subscription discount_id references after discount records are created/updated\n */\nexport async function updateSubscriptionDiscountReferences({\n  discountRecords,\n  subscriptionsUpdated,\n}: {\n  discountRecords: any[];\n  subscriptionsUpdated: string[];\n}): Promise<{ updatedSubscriptions: string[] }> {\n  if (subscriptionsUpdated.length === 0) {\n    return { updatedSubscriptions: [] };\n  }\n\n  const updatedSubscriptions: string[] = [];\n\n  try {\n    logger.info('Updating subscription discount_id references', {\n      subscriptionsToUpdate: subscriptionsUpdated.length,\n    });\n\n    const subscriptionUpdatePromises = subscriptionsUpdated.map(async (subscriptionId) => {\n      try {\n        // Find the discount record for this subscription\n        const discountRecord = discountRecords.find((d) => d.subscription_id === subscriptionId);\n        if (!discountRecord) {\n          logger.warn('No discount record found for subscription', { subscriptionId });\n          return null;\n        }\n\n        // Update subscription with discount_id\n        const [updateCount] = await Subscription.update(\n          { discount_id: discountRecord.id },\n          { where: { id: subscriptionId } }\n        );\n\n        if (updateCount > 0) {\n          logger.debug('Updated subscription discount_id', {\n            subscriptionId,\n            discountId: discountRecord.id,\n          });\n          return subscriptionId;\n        }\n\n        logger.warn('Subscription not found for discount_id update', { subscriptionId });\n        return null;\n      } catch (error) {\n        logger.error('Failed to update subscription discount_id', {\n          subscriptionId,\n          error: error.message,\n        });\n        return null;\n      }\n    });\n\n    const updateResults = await Promise.all(subscriptionUpdatePromises);\n    updatedSubscriptions.push(...updateResults.filter((id) => id !== null));\n\n    logger.info('Completed subscription discount_id reference updates', {\n      requestedUpdates: subscriptionsUpdated.length,\n      successfulUpdates: updatedSubscriptions.length,\n    });\n\n    return { updatedSubscriptions };\n  } catch (error) {\n    logger.error('Error updating subscription discount references', {\n      subscriptionsUpdated,\n      error: error.message,\n    });\n    throw new Error(`Failed to update subscription discount references: ${error.message}`);\n  }\n}\n\n/**\n * Create or update discount records for a completed checkout session\n * This creates/updates the actual discount records and manages usage counts\n * For subscriptions, creates separate discount records for each subscription\n * Handles deduplication and updates when coupon/promotion code changes\n */\nexport async function createDiscountRecordsForCheckout({\n  checkoutSession,\n  customerId,\n  subscriptionIds = [],\n}: {\n  checkoutSession: any; // CheckoutSession type\n  customerId: string;\n  subscriptionIds?: string[];\n}): Promise<{\n  discountRecords: any[];\n  updatedCoupons: string[];\n  updatedPromotionCodes: string[];\n  subscriptionsUpdated: string[];\n}> {\n  if (!checkoutSession.discounts?.length) {\n    return { discountRecords: [], updatedCoupons: [], updatedPromotionCodes: [], subscriptionsUpdated: [] };\n  }\n\n  logger.info('Creating/updating discount records for checkout session', {\n    checkoutSessionId: checkoutSession.id,\n    customerId,\n    subscriptionIds,\n  });\n\n  try {\n    // Get existing discount records\n    const existingDiscountMap = await getExistingDiscountRecords(customerId, checkoutSession.id);\n\n    const updatedCoupons = new Set<string>();\n    const updatedPromotionCodes = new Set<string>();\n    const allDiscountRecords: any[] = [];\n    const subscriptionsUpdated: string[] = [];\n\n    // Process each discount configuration\n    const discountProcessingPromises = checkoutSession.discounts.map(async (discount: any) => {\n      const { promotion_code: promotionCodeId, coupon: couponId, discount_amount: discountAmount } = discount;\n\n      if (!couponId) {\n        logger.warn('Incomplete discount configuration, skipping', {\n          checkoutSessionId: checkoutSession.id,\n          hasCoupon: !!couponId,\n        });\n        return null;\n      }\n\n      try {\n        // Fetch coupon and promotion code\n        const [coupon, promotionCode] = await Promise.all([\n          Coupon.findByPk(couponId),\n          promotionCodeId ? PromotionCode.findByPk(promotionCodeId) : Promise.resolve(null),\n        ]);\n\n        if (!coupon) {\n          logger.warn('Coupon not found, skipping discount', {\n            couponId,\n            checkoutSessionId: checkoutSession.id,\n          });\n          return null;\n        }\n\n        // Build base discount data\n        const baseDiscountData = buildBaseDiscountData({\n          checkoutSession,\n          customerId,\n          coupon,\n          promotionCode: promotionCode || undefined,\n          discountAmount,\n          verificationData: discount.verification_data,\n        });\n\n        const discountRecords: any[] = [];\n        let shouldUpdateUsageCount = false;\n        const currentSubscriptionsUpdated: string[] = [];\n\n        // Process subscriptions\n        if (subscriptionIds.length > 0) {\n          const subscriptionProcessingPromises = subscriptionIds.map(async (subscriptionId) => {\n            try {\n              const result = await processSubscriptionDiscount({\n                subscriptionId,\n                baseDiscountData,\n                existingDiscountMap,\n                checkoutSessionId: checkoutSession.id,\n              });\n\n              if (result.shouldUpdateUsage) {\n                currentSubscriptionsUpdated.push(subscriptionId);\n              }\n\n              return result.discountRecord;\n            } catch (error) {\n              logger.error('Failed to process subscription discount, continuing with others', {\n                subscriptionId,\n                error: error.message,\n              });\n              return null;\n            }\n          });\n\n          const subscriptionResults = await Promise.all(subscriptionProcessingPromises);\n          discountRecords.push(...subscriptionResults.filter((record) => record !== null));\n\n          if (currentSubscriptionsUpdated.length > 0) {\n            shouldUpdateUsageCount = true;\n          }\n        } else {\n          // Process non-subscription case\n          try {\n            const result = await processNonSubscriptionDiscount(\n              baseDiscountData,\n              existingDiscountMap,\n              checkoutSession.id\n            );\n\n            discountRecords.push(result.discountRecord);\n            shouldUpdateUsageCount = result.shouldUpdateUsage;\n          } catch (error) {\n            logger.error('Failed to process non-subscription discount', {\n              checkoutSessionId: checkoutSession.id,\n              error: error.message,\n            });\n            throw error;\n          }\n        }\n\n        // Update usage counts if needed\n        if (shouldUpdateUsageCount) {\n          try {\n            await updateUsageCounts({\n              coupon,\n              promotionCode: promotionCode || undefined,\n              updatedCoupons,\n              updatedPromotionCodes,\n              checkoutSessionId: checkoutSession.id,\n            });\n            await Promise.all(\n              discountRecords.map(async (discountRecord) => {\n                await discountRecord.update({\n                  confirmed: true,\n                });\n              })\n            );\n          } catch (error) {\n            logger.error('Failed to update usage counts, but continuing', {\n              couponId: coupon.id,\n              promotionCodeId: promotionCode?.id,\n              error: error.message,\n            });\n          }\n        }\n\n        return {\n          discountRecords,\n          subscriptionsUpdated: currentSubscriptionsUpdated,\n        };\n      } catch (error) {\n        logger.error('Error processing discount configuration, skipping', {\n          couponId,\n          promotionCodeId,\n          checkoutSessionId: checkoutSession.id,\n          error: error.message,\n        });\n        return null;\n      }\n    });\n\n    const processingResults = await Promise.all(discountProcessingPromises);\n\n    // Aggregate results\n    processingResults.forEach((result) => {\n      if (result) {\n        allDiscountRecords.push(...result.discountRecords);\n        subscriptionsUpdated.push(...result.subscriptionsUpdated);\n      }\n    });\n\n    logger.info('All discount records processed successfully', {\n      checkoutSessionId: checkoutSession.id,\n      customerId,\n      totalRecords: allDiscountRecords.length,\n      subscriptionCount: subscriptionIds.length,\n      subscriptionsUpdated: subscriptionsUpdated.length,\n      updatedCouponsCount: updatedCoupons.size,\n      updatedPromotionCodesCount: updatedPromotionCodes.size,\n    });\n\n    return {\n      discountRecords: allDiscountRecords,\n      updatedCoupons: Array.from(updatedCoupons),\n      updatedPromotionCodes: Array.from(updatedPromotionCodes),\n      subscriptionsUpdated,\n    };\n  } catch (error) {\n    logger.error('Critical error processing discount records for checkout', {\n      checkoutSessionId: checkoutSession.id,\n      customerId,\n      subscriptionIds,\n      error: error.message,\n    });\n    throw new Error(`Failed to process discount records: ${error.message}`);\n  }\n}\n\n// Unified promotion code eligibility check\nexport async function checkPromotionCodeEligibility({\n  promotionCode,\n  couponId,\n  customerId,\n  amount,\n  currencyId,\n  lineItems = [],\n}: {\n  promotionCode: PromotionCode;\n  couponId: string;\n  customerId: string;\n  amount: string;\n  currencyId: string;\n  lineItems?: TLineItemExpanded[];\n}): Promise<{ eligible: boolean; reason?: string }> {\n  // Basic promotion code checks\n  if (!promotionCode.active) {\n    return { eligible: false, reason: 'This promotion code is no longer available' };\n  }\n\n  if (promotionCode.expires_at && Math.floor(Date.now() / 1000) > promotionCode.expires_at) {\n    return { eligible: false, reason: 'This promotion code has expired and cannot be used' };\n  }\n\n  if (promotionCode.max_redemptions && (promotionCode.times_redeemed ?? 0) >= promotionCode.max_redemptions) {\n    return { eligible: false, reason: 'This promotion code has been fully redeemed and is no longer available' };\n  }\n\n  // Get associated coupon and validate\n  const coupon = await Coupon.findByPk(couponId);\n  if (!coupon) {\n    return { eligible: false, reason: 'This promotion is no longer available' };\n  }\n\n  // Coupon validity check\n  const couponValidation = validCoupon(coupon, lineItems);\n  if (!couponValidation.valid) {\n    return { eligible: false, reason: couponValidation.reason };\n  }\n\n  const promotionValidation = await validPromotionCode(promotionCode, {\n    customerId,\n    amount,\n    currencyId,\n  });\n  if (!promotionValidation.valid) {\n    return { eligible: false, reason: promotionValidation.reason };\n  }\n  return { eligible: true };\n}\n\n// Validate discount for billing cycles (subscription invoices)\nexport async function validateDiscountForBilling({\n  discount,\n}: {\n  discount: Discount;\n  subscriptionId?: string;\n}): Promise<{ valid: boolean; reason?: string; shouldRemove?: boolean }> {\n  const coupon = await Coupon.findByPk(discount.coupon_id);\n  if (!coupon) {\n    return {\n      valid: false,\n      reason: 'This discount is no longer available',\n      shouldRemove: true,\n    };\n  }\n\n  const now = Math.floor(Date.now() / 1000);\n\n  // Check discount duration logic\n  switch (coupon.duration) {\n    case 'once':\n      // One-time discounts should not apply to recurring billing\n      return {\n        valid: false,\n        reason: 'One-time discount cannot be applied to subscription billing',\n        shouldRemove: true,\n      };\n\n    case 'repeating':\n      if (!discount.end) {\n        return {\n          valid: false,\n          reason: 'Repeating discount missing end date',\n          shouldRemove: true,\n        };\n      }\n\n      if (now > Number(discount.end)) {\n        return {\n          valid: false,\n          reason: 'Repeating discount has expired',\n          shouldRemove: true,\n        };\n      }\n      break;\n\n    case 'forever':\n      // Forever discounts are always valid\n      break;\n\n    default:\n      return {\n        valid: false,\n        reason: `Unknown coupon duration: ${coupon.duration}`,\n        shouldRemove: true,\n      };\n  }\n\n  return { valid: true };\n}\n\n// Get all valid discounts for a subscription's billing period\nexport async function getValidDiscountsForSubscriptionBilling({\n  subscriptionId,\n  customerId,\n}: {\n  subscriptionId: string;\n  customerId: string;\n}): Promise<{\n  validDiscounts: Discount[];\n  expiredDiscounts: Discount[];\n}> {\n  const discounts = await Discount.findAll({\n    where: {\n      customer_id: customerId,\n      subscription_id: subscriptionId,\n    },\n    include: [\n      { model: Coupon, as: 'coupon' },\n      { model: PromotionCode, as: 'promotionCode' },\n    ],\n  });\n\n  const validDiscounts: Discount[] = [];\n  const expiredDiscounts: Discount[] = [];\n\n  logger.info('Found discounts for subscription billing', {\n    subscriptionId,\n    discountCount: discounts.map((d) => d.id),\n  });\n\n  await Promise.all(\n    discounts.map(async (discount) => {\n      const validation = await validateDiscountForBilling({\n        discount,\n        subscriptionId,\n      });\n\n      if (validation.valid) {\n        validDiscounts.push(discount);\n      } else {\n        expiredDiscounts.push(discount);\n        logger.info('Expired discount for subscription billing', {\n          subscriptionId,\n          discountId: discount.id,\n          reason: validation.reason,\n        });\n      }\n    })\n  );\n\n  return { validDiscounts, expiredDiscounts };\n}\n\n/**\n * Expand line items with complete coupon information\n * Similar to Price.expand but for coupon information\n */\nexport async function expandLineItemsWithCouponInfo(\n  lineItems: TLineItemExpanded[],\n  sessionDiscounts?: any[],\n  currencyId?: string\n): Promise<TLineItemExpanded[]> {\n  if (!sessionDiscounts?.length) {\n    return lineItems;\n  }\n\n  const enhancedLineItems = await Promise.all(\n    lineItems.map(async (item) => {\n      if (!item.discount_amounts?.length) {\n        return item;\n      }\n\n      const enhancedDiscountAmounts = await Promise.all(\n        item.discount_amounts.map(async (discountAmount: any) => {\n          let couponInfo = null;\n          let promotionCodeInfo = null;\n\n          // Find the discount in checkout session discounts to get IDs\n          const sessionDiscount = sessionDiscounts.find((d: any) => d.coupon || d.promotion_code);\n          if (sessionDiscount) {\n            if (sessionDiscount.coupon) {\n              const coupon = await Coupon.findByPk(sessionDiscount.coupon);\n              if (coupon) {\n                couponInfo = {\n                  object: 'coupon',\n                  id: coupon.id,\n                  name: coupon.name,\n                  amount_off: coupon.amount_off,\n                  percent_off: coupon.percent_off,\n                  currency: coupon.currency_id,\n                  duration: coupon.duration,\n                  duration_in_months: coupon.duration_in_months,\n                  has_applies_to_products: true,\n                };\n              }\n            }\n\n            if (sessionDiscount.promotion_code) {\n              const promotionCode = await PromotionCode.findByPk(sessionDiscount.promotion_code);\n              if (promotionCode) {\n                promotionCodeInfo = {\n                  object: 'promotion_code',\n                  id: promotionCode.id,\n                  code: promotionCode.code,\n                };\n              }\n            }\n          }\n\n          return {\n            ...discountAmount,\n            coupon: couponInfo,\n            promotion_code: promotionCodeInfo,\n            currency: currencyId,\n          };\n        })\n      );\n\n      return {\n        ...item,\n        discount_amounts: enhancedDiscountAmounts,\n      };\n    })\n  );\n\n  return enhancedLineItems;\n}\n\n/**\n * Expand discounts with complete coupon and promotion code information\n */\nexport async function expandDiscountsWithDetails(discounts?: any[]): Promise<any[]> {\n  if (!discounts?.length) {\n    return [];\n  }\n\n  const enhancedDiscounts = await Promise.all(\n    discounts.map(async (discount) => {\n      let couponInfo = null;\n      let promotionCodeInfo = null;\n\n      if (discount.coupon) {\n        const coupon = await Coupon.findByPk(discount.coupon);\n        if (coupon) {\n          couponInfo = pick(coupon, [\n            'id',\n            'name',\n            'percent_off',\n            'amount_off',\n            'valid',\n            'duration',\n            'duration_in_months',\n            'currency_id',\n            'currency_options',\n          ]);\n        }\n      }\n\n      if (discount.promotion_code) {\n        const promotionCode = await PromotionCode.findByPk(discount.promotion_code);\n        if (promotionCode) {\n          promotionCodeInfo = pick(promotionCode, ['id', 'code']);\n        }\n      }\n\n      return {\n        ...discount,\n        coupon_details: couponInfo,\n        promotion_code_details: promotionCodeInfo,\n      };\n    })\n  );\n\n  return enhancedDiscounts;\n}\n","numLines":1057,"startLine":1,"totalLines":1057}}}
{"parentUuid":"4fb96098-eb99-48a1-a288-96ee8cc02f4c","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"e76e6fc0-c7de-4095-8ddb-89dc409eb282","version":"2.0.76","gitBranch":"feat-quote","agentId":"a057e1b","slug":"happy-sprouting-alpaca","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01BCW39HRBTmKwVxtnY17R3h","type":"message","role":"assistant","content":[{"type":"text","text":"完美！现在我已经收集了足够的信息。让我整理一份详细的分析报告：\n\n## Payment Kit 代码库核心领域分析报告\n\n基于对 Payment Kit 代码库的深入探索，以下是四个核心领域的详细分析：\n\n---\n\n### 1. 计费系统（Invoice/Pricing）\n\n#### **数据模型**\n\n**Invoice Model** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice.ts`)\n\n核心字段：\n- **ID & 标识**: `id`, `number` (显示给客户的唯一编号)\n- **状态管理**: `status` (draft/open/void/paid/uncollectible), `paid`, `paid_out_of_band`\n- **金额字段**: \n  - `subtotal` - 小计\n  - `subtotal_excluding_tax` - 不含税小计\n  - `tax` - 税额\n  - `total` - 总计\n  - `amount_due` - 应付金额\n  - `amount_paid` - 已付金额\n  - `amount_remaining` - 剩余金额\n- **账单原因**: `billing_reason` (subscription_create/subscription_cycle/manual/recharge/auto_recharge等)\n- **折扣支持**: `discounts[]`, `total_discount_amounts[]`\n- **余额跟踪**: `starting_balance`, `ending_balance`, `starting_token_balance`, `ending_token_balance`\n- **状态转换**: `status_transitions` (finalized_at, paid_at, voided_at等)\n\n**Price Model** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/price.ts`)\n\n核心特性：\n- **定价模式**: `billing_scheme` (per_unit/tiered)\n- **价格类型**: `type` (one_time/recurring)\n- **计费方案**:\n  - 标准计费: `unit_amount`\n  - 阶梯计费: `tiers[]`, `tiers_mode` (graduated/volume)\n  - 包装计费: `transform_quantity`\n- **动态定价**: \n  - `pricing_type` (fixed/dynamic)\n  - `base_currency`, `base_amount` - 基准货币和金额\n  - `dynamic_pricing_config` - 包含 `lock_duration` (报价锁定时长)\n- **多币种支持**: `currency_options[]` - 为每种货币设置不同的单价\n\n**InvoiceItem Model** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/invoice-item.ts`)\n\n- 支持 **折扣字段**: `discountable`, `discount_amounts[]`\n- 支持 **按比例分配**: `proration`, `proration_details`\n- 税务集成: `tax_rate_id`\n- 订阅关联: `subscription_item_id`\n\n#### **业务逻辑**\n\n**核心计算逻辑** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/invoice.ts`)\n\n```typescript\n// 创建发票及明细项\nasync function createInvoiceWithItems(props: BaseInvoiceProps): Promise<{\n  invoice: Invoice;\n  items: InvoiceItem[];\n}>\n```\n\n关键功能：\n1. **自动生成发票编号**: `customer.getInvoiceNumber()`\n2. **应用客户余额**: 自动从 token balance 扣除\n3. **税务匹配**: 根据客户地址自动匹配税率\n4. **动态定价报价生成**: 为订阅发票生成价格锁定\n5. **折扣应用**: 支持 line item 级别的折扣计算\n\n```typescript\n// 获取发票应付总额（考虑动态定价）\nexport async function getInvoiceShouldPayTotal(invoice: Invoice)\n```\n\n重要边界情况：\n- 动态定价商品使用报价金额而非实时价格\n- 折扣后总额不能为负数\n- 支持使用量计费（metered billing）\n\n**发票迁移** (`migrateSubscriptionPaymentMethodInvoice`)\n- 当订阅支付方式改变时，自动作废旧发票并创建新发票\n- 仅支持预付费（licensed）订阅项\n- 不支持迁移到 Stripe\n\n#### **依赖关系**\n\n```\nInvoice\n  ├── Customer (customer_id)\n  ├── PaymentCurrency (currency_id)\n  ├── PaymentIntent (payment_intent_id)\n  ├── Subscription (subscription_id)\n  ├── CheckoutSession (checkout_session_id)\n  ├── PriceQuote (quote_id) - 动态定价\n  └── InvoiceItem[]\n      ├── Price (price_id)\n      ├── TaxRate (tax_rate_id)\n      └── SubscriptionItem (subscription_item_id)\n```\n\n---\n\n### 2. 订阅系统（Subscription）\n\n#### **数据模型**\n\n**Subscription Model** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription.ts`)\n\n核心字段：\n- **状态**: `status` (active/past_due/paused/canceled/incomplete/trialing)\n- **周期**: `current_period_start`, `current_period_end`, `billing_cycle_anchor`\n- **取消管理**: \n  - `cancel_at_period_end` - 周期结束时取消\n  - `cancel_at` - 指定时间取消\n  - `canceled_at` - 取消时间戳\n  - `cancelation_details` - 取消原因、反馈、退款选项\n- **试用期**: `trial_start`, `trial_end`, `trial_settings`\n- **过期保护**: `overdraft_protection` - Arcblock 链特有功能\n- **待处理更新**: `pending_update` - 延迟应用的订阅变更\n- **服务操作**: `service_actions[]` - 可触发的自动化操作\n\n**SubscriptionItem Model** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/subscription-item.ts`)\n- `price_id` - 关联的价格\n- `quantity` - 数量\n- `billing_thresholds` - 使用量阈值触发器\n\n#### **业务逻辑**\n\n**核心功能** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/subscription.ts`)\n\n**1. 周期计算**\n```typescript\nexport function getSubscriptionCycleSetup(\n  recurring: PriceRecurring,\n  previousPeriodEnd: number,\n  options?: { catchUp?: boolean; maxMissedPeriods?: number }\n)\n```\n- 支持自动追赶（catch-up）错过的周期\n- 限制最大追赶周期数防止过度计费\n- 返回 `missedPeriods`, `recovery` 信息\n\n**2. Staking 机制**（Arcblock 链特有）\n```typescript\n// 计算订阅质押设置\nexport function getSubscriptionStakeSetup(\n  items: TLineItemExpanded[], \n  currencyId: string, \n  billingThreshold = '0'\n)\n```\n- 区分 `licensed` 和 `metered` 质押\n- 支持多订阅共享质押\n- 质押金额计算考虑账单阈值\n\n**3. 按比例分配（Proration）**\n```typescript\nexport async function createProration(\n  subscription: Subscription,\n  setup: ReturnType<typeof getSubscriptionCreateSetup>,\n  anchor: number\n)\n```\n\n关键逻辑：\n- 仅对 `licensed` 类型的循环项目按比例退款\n- 精度设置为 10000 避免浮点数误差\n- 计算未使用时间占比：`(periodEnd - anchor) / (periodEnd - periodStart)`\n- 考虑已退款金额避免重复退款\n\n**4. Overdraft Protection**\n```typescript\nexport async function isSubscriptionOverdraftProtectionEnabled(\n  subscription: Subscription, \n  paymentCurrencyId?: string\n)\n```\n- 检查质押余额是否足够\n- 追踪已使用金额和退款中金额\n- 自动从质押中扣款（slash）支付未付发票\n\n**5. 订阅更新流程**\n```typescript\nexport async function finalizeSubscriptionUpdate({\n  subscription, customer, invoice, paymentCurrency,\n  appliedCredit, newCredit,\n  addedItems, updatedItems, deletedItems, updates\n})\n```\n\n流程：\n1. 添加新订阅项\n2. 更新现有订阅项\n3. 删除订阅项并清除使用记录\n4. 应用客户余额\n5. 锁定订阅防止并发修改\n\n#### **状态机**\n\n```\nincomplete → trialing → active → past_due → canceled\n                ↓         ↓         ↓\n              active    paused   uncollectible\n```\n\n关键转换：\n- `start()` - 激活订阅（从 incomplete 到 active/trialing）\n- `shouldCancelSubscription()` - 检查是否应该取消\n- `isConsumesCredit()` - 检查是否消耗余额（metered + meter_id）\n\n#### **重试机制**\n\n```typescript\n// 根据计费周期确定重试次数\nexport const getMaxRetryCount = (interval: string) => {\n  if (interval === 'hour') return 10;  // 34分钟\n  if (interval === 'day') return 15;   // 18小时\n  if (interval === 'week') return 18;  // 6天\n  return 20;  // 24天 (月订阅)\n}\n```\n\n---\n\n### 3. 优惠券系统（Discount/Coupon）\n\n#### **数据模型**\n\n**Coupon Model** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/coupon.ts`)\n\n核心字段：\n- **折扣方式**:\n  - `percent_off` - 百分比折扣 (0-100)\n  - `amount_off` - 固定金额折扣\n  - `currency_options` - 多币种固定折扣\n- **有效期**:\n  - `duration` (forever/once/repeating)\n  - `duration_in_months` - 重复月数\n  - `redeem_by` - 过期时间戳\n- **使用限制**:\n  - `max_redemptions` - 最大兑换次数\n  - `times_redeemed` - 已兑换次数\n  - `applies_to.products[]` - 适用产品限制\n- **状态**: `valid`, `locked`\n\n**PromotionCode Model** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/promotion-code.ts`)\n\n高级功能：\n- **验证方式**: `verification_type` (code/nft/vc/user_restricted)\n  - `code` - 普通优惠码\n  - `nft` - NFT 持有者验证\n  - `vc` - 可验证凭证（VC）角色验证\n  - `user_restricted` - 限定用户 DID 列表\n- **配置**:\n  - `nft_config.addresses[]` - NFT 合约地址列表\n  - `vc_config.roles[]` - VC 角色列表\n  - `customer_dids[]` - 允许的用户 DID\n- **限制条件**: `restrictions`\n  - `minimum_amount` - 最低消费金额\n  - `currency_options` - 不同币种的最低消费\n  - `first_time_transaction` - 仅限首次购买\n\n**Discount Model** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/discount.ts`)\n\n应用记录：\n- `coupon_id`, `promotion_code_id`\n- `customer_id`, `subscription_id`, `invoice_id`\n- `start`, `end` - 有效期\n- `confirmed` - 是否已确认（影响使用次数统计）\n- `verification_method`, `verification_data` - 验证方式和数据\n\n#### **业务逻辑**\n\n**折扣计算** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/discount.ts`)\n\n**1. 应用折扣到商品**\n```typescript\nexport async function applyDiscountsToLineItems({\n  lineItems, couponId, promotionCodeId,\n  customerId, currency, totalAmount\n})\n```\n\n计算流程：\n1. **验证优惠券**: 检查有效性、过期时间、兑换次数\n2. **筛选适用商品**: 根据 `applies_to.products` 过滤\n3. **计算总折扣**:\n   - **百分比**: `amount × percent_off / 100`\n   - **固定金额**: `min(amount_off, totalAmount)`\n4. **分配到商品**:\n   - 百分比：直接按比例应用到每个商品\n   - 固定金额：按商品金额比例分配\n\n```typescript\n// 固定金额按比例分配示例\nitemDiscountAmount = itemAmount × totalDiscount / totalEligibleAmount\n```\n\n**2. 订阅折扣验证**\n```typescript\nexport async function validateDiscountForBilling({ discount, subscriptionId })\n```\n\n持续时间规则：\n- `once` - 一次性，不适用于订阅续费\n- `repeating` - 检查是否超过 `end` 时间\n- `forever` - 永久有效\n\n**3. 优惠码验证** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/discount/coupon.ts`)\n\n```typescript\nexport async function checkPromotionCodeEligibility({\n  promotionCode, couponId, customerId,\n  amount, currencyId, lineItems\n})\n```\n\n验证链：\n1. 优惠码基本检查（active, expires_at, max_redemptions）\n2. 关联优惠券验证\n3. 特定限制：\n   - 用户限制（DID 白名单）\n   - 首次购买限制\n   - 最低消费金额\n\n**4. 使用次数管理**\n\n创建折扣记录时：\n```typescript\n// 锁定资源\nawait lockDiscountResources(couponId, promotionCodeId);\n// 增加使用次数（去重基于 checkout session）\nawait coupon.update({ times_redeemed: (coupon.times_redeemed || 0) + 1 });\n```\n\n回滚机制：\n```typescript\nexport async function rollbackDiscountUsageForCheckoutSession(checkoutSessionId)\n```\n- 仅回滚 `confirmed: true` 的记录\n- 减少使用次数\n- 销毁折扣记录\n\n#### **测试覆盖** (`~/Arcblock/payment-kit-master/blocklets/core/api/tests/libs/discount.spec.ts`)\n\n关键测试场景：\n- 百分比折扣仅应用于符合条件的产品\n- 固定金额折扣按比例分配\n- 折扣金额不超过总金额\n- 优惠券/优惠码无效时的处理\n- 回滚逻辑的正确性\n\n---\n\n### 4. 税务系统（Tax）\n\n#### **数据模型**\n\n**TaxRate Model** (`~/Arcblock/payment-kit-master/blocklets/core/api/src/store/models/tax-rate.ts`)\n\n核心字段：\n- **地理位置**:\n  - `country` - ISO 3166-1 alpha-2 国家代码\n  - `state` - 州/省/地区\n  - `postal_code` - 邮政编码（支持通配符如 \"95*\"）\n- **税务分类**: `tax_code` - 产品税码 (txcd_*)\n- **税率**: `percentage` - 税率百分比（精度到 4 位小数）\n- **显示**: `display_name`, `description`\n- **状态**: `active`, `livemode`\n\n索引优化：\n```sql\nINDEX (country)\nINDEX (country, state)\nINDEX (country, state, postal_code)\n```\n\n#### **业务逻辑**\n\n**1. 税率匹配算法** (分层评分系统)\n\n```typescript\npublic static async findMatchingRate({\n  country, state, postalCode, taxCode, livemode\n})\n```\n\n**评分规则** (字典序优先级：postal_code > state > tax_code)：\n\n每个维度的分数范围 (0-100)：\n- **100**: 精确匹配\n- **50-95**: 通配符匹配（如 \"902*\"，长度越长分数越高）\n- **10**: 通用回退（税率没有限制）\n- **5**: 双方都为空\n\n示例评分：\n```typescript\n// postal_code 匹配\nif (ratePostal === \"902*\" && normalizedPostal === \"90210\") {\n  scores.postal = 50 + 3 * 5 = 65; // prefix length = 3\n}\nif (ratePostal === normalizedPostal) {\n  scores.postal = 100;\n}\n\n// 字典序比较\nconst isBetter = \n  scores.postal > bestScore.postal ||\n  (scores.postal === bestScore.postal && scores.state > bestScore.state) ||\n  (scores.postal === bestScore.postal && \n   scores.state === bestScore.state && \n   scores.tax > bestScore.tax);\n```\n\n**重要边界情况**：\n- 国家预过滤（防止美国 90210 匹配加拿大 90210）\n- 如果税率设置了限制而客户信息缺失，则不匹配\n- 同分时选择最新创建的税率（ORDER BY updated_at DESC）\n\n**2. 税额计算**\n\n**含税总额拆分**：\n```typescript\n// 公式: tax = total × (rate / (100 + rate))\npublic static calculateTaxFromInclusive(total: string, percentage: number): string {\n  const rateBN = new BN(percentage * 100);\n  const denominator = new BN(10000).add(rateBN);\n  const taxAmount = totalBN.mul(rateBN).div(denominator);\n  return taxAmount.toString();\n}\n\n// 示例：总额 $100，税率 8.5%\n// tax = 100 × (850 / 10850) = 7.83\n// subtotal = 100 - 7.83 = 92.17\n```\n\n**按商品计税**：\n```typescript\n// 公式: tax = amount × (rate / 100)\npublic static calculateTaxForItem(amount: string, percentage: number): string {\n  const rateBN = new BN(percentage * 100);\n  const taxAmount = amountBN.mul(rateBN).div(new BN(10000));\n  return taxAmount.toString();\n}\n\n// 示例：商品 $50，税率 8.5%\n// tax = 50 × (850 / 10000) = 4.25\n```\n\n**3. 发票集成**\n\n在创建发票项时自动匹配税率：\n```typescript\n// invoice.ts - createInvoiceWithItems()\nconst taxRate = await TaxRate.findMatchingRate({\n  country: customer.address.country,\n  state: customer.address.state,\n  postalCode: customer.address.postal_code,\n  taxCode: product.tax_code,\n  livemode\n});\ntaxRateId = taxRate?.id;\n```\n\n#### **测试覆盖** (`~/Arcblock/payment-kit-master/blocklets/core/api/tests/models/tax-rate.spec.ts`)\n\n预期的测试场景（基于模型逻辑）：\n- 精确匹配优先级测试\n- 通配符邮编匹配\n- 分层评分正确性\n- 含税/不含税转换精度\n- 多商品税额汇总\n\n---\n\n### **模块依赖关系总览**\n\n```\n┌─────────────────┐\n│  CheckoutSession│\n└────────┬────────┘\n         │\n    ┌────▼─────────────────────────────────┐\n    │                                      │\n┌───▼──────┐  ┌──────────┐  ┌──────────┐  │\n│ Invoice  │  │Subscription│ │ Discount │  │\n└───┬──────┘  └─────┬─────┘  └────┬─────┘  │\n    │               │              │        │\n┌───▼──────┐  ┌─────▼─────┐  ┌────▼─────┐  │\n│InvoiceItem│ │SubsItem   │  │  Coupon  │  │\n└───┬──────┘  └─────┬─────┘  └──────────┘  │\n    │               │                       │\n┌───▼──────┐  ┌─────▼─────┐         ┌──────▼──────┐\n│  Price   │  │  Price    │         │PromotionCode│\n└───┬──────┘  └───────────┘         └─────────────┘\n    │\n┌───▼──────┐\n│ TaxRate  │\n└──────────┘\n```\n\n### **关键设计模式**\n\n1. **事件驱动**: 所有模型使用 hooks 触发审计事件\n2. **金额精度**: 全部使用字符串存储避免浮点数误差，计算使用 BN (BigNumber)\n3. **幂等性**: 关键操作使用 Lock 机制防止并发问题\n4. **软删除**: 重要记录不直接删除，使用状态标记\n5. **版本管理**: 支持 `latest_revision` 追踪变更历史\n6. **多币种**: 原生支持多币种定价和折扣\n\n### **常见边界情况处理**\n\n1. **折扣后负数**: 确保 `finalTotal ≥ 0`\n2. **除零保护**: 按比例分配时检查分母不为零\n3. **精度损失**: 使用整数运算，最后再转换单位\n4. **并发更新**: 订阅更新使用锁，发票状态检查 `isImmutable()`\n5. **循环依赖**: Proration 计算考虑已存在的退款避免重复\n6. **时区问题**: 统一使用 Unix 时间戳（秒）\n\n这套系统展现了一个成熟的支付平台应有的复杂度和健壮性，特别是对区块链支付（Arcblock）的原生支持使其在 Web3 场景中具有独特优势。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4565,"cache_creation_input_tokens":18630,"cache_read_input_tokens":103977,"cache_creation":{"ephemeral_5m_input_tokens":18630,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CWvxtaRLP13dJPxEeDT92","type":"assistant","uuid":"85fc3947-813b-4fc0-9b92-975b909017f2","timestamp":"2026-01-09T01:51:40.040Z"}
