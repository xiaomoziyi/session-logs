{"parentUuid":null,"isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","type":"user","message":{"role":"user","content":"请深入分析 Payment Kit 的完整支付流程，重点关注以下三个场景：\n\n## 场景 1: 用户停留在支付页，固定时间刷新\n需要分析：\n- Quote 刷新机制是如何触发的？\n- 刷新频率是多少？\n- 刷新时是更新现有 Quote 还是创建新 Quote？\n- 前端如何处理刷新后的数据更新？\n\n关键文件：\n- `packages/react/src/payment/form/index.tsx` - 支付表单主逻辑\n- `packages/react/src/payment/summary.tsx` - 价格摘要和刷新\n- `api/src/libs/session.ts` - enrichCheckoutSessionWithQuotes\n- `api/src/libs/quote-service.ts` - refreshQuoteWithRate\n- `api/src/routes/checkout-sessions.ts` - retrieve endpoint\n\n## 场景 2: 用户提交支付，支付流程正常\n需要分析：\n- Submit 流程的完整调用链\n- Quote 状态转换时机（active → used → paid）\n- Slippage 验证在哪些阶段执行？\n- 锁定期（quote_locked_at）的作用和时机\n\n关键文件：\n- `packages/react/src/payment/form/index.tsx` - handleSubmit\n- `api/src/routes/checkout-sessions.ts` - submit endpoint\n- `api/src/routes/connect/pay.ts` - authorize/pay\n- `api/src/libs/quote-validation.ts` - validateQuoteForPayment\n- `api/src/queues/payment.ts` - 支付队列处理\n\n## 场景 3: 汇率发生波动，交互处理\n需要分析：\n- 汇率波动时前端如何感知和处理？\n- 有哪些错误码与汇率波动相关？\n- `applyQuoteUpdate` 的触发条件和处理逻辑\n- Price update modal 何时显示？\n- 是否会阻止用户继续支付？\n\n关键文件：\n- `packages/react/src/payment/form/index.tsx` - applyQuoteUpdate, error handling\n- `api/src/routes/checkout-sessions.ts` - submit 阶段的 Quote 验证\n- `api/src/libs/quote-validation.ts` - 验证逻辑\n\n## 需要验证的 Intent 要求\n1. **报价刷新只更新 active Quote**（不创建新记录）\n2. **Submit 阶段不重算价格、不重新获取汇率**\n3. **Slippage 强约束**（`required_token ≤ max_payable_token`）\n4. **锁定期不突破用户滑点**\n5. **汇率波动时的用户体验**（是否友好、是否符合预期）\n\n请提供：\n1. 每个场景的完整流程图（代码调用链）\n2. 关键决策点和条件判断\n3. 潜在的边界情况或问题\n4. 是否符合 Intent 文档要求"},"uuid":"b8ae53e8-7a98-4ee9-b209-1333c0f36697","timestamp":"2026-01-12T15:03:08.786Z"}
{"parentUuid":"b8ae53e8-7a98-4ee9-b209-1333c0f36697","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013HQ98LqE4xnKoprD4KJU1i","type":"message","role":"assistant","content":[{"type":"text","text":"我将深入分析 Payment Kit 的完整支付流程，重点关注这三个场景。让我先读取关键文件来理解整个流程。"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":15894,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":15894,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX3gpn5cvkWXtNn8ir2MQ","type":"assistant","uuid":"437b6c2e-727f-4935-9ecc-c94d4f0f6c2c","timestamp":"2026-01-12T15:03:12.205Z"}
{"parentUuid":"437b6c2e-727f-4935-9ecc-c94d4f0f6c2c","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013HQ98LqE4xnKoprD4KJU1i","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DA6oDRHQ7S6uEHYA6tetDb","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/packages/react/src/payment/form/index.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":15894,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":15894,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX3gpn5cvkWXtNn8ir2MQ","type":"assistant","uuid":"c9983e82-5ea9-4e53-9beb-727ca84dd2ae","timestamp":"2026-01-12T15:03:12.777Z"}
{"parentUuid":"c9983e82-5ea9-4e53-9beb-727ca84dd2ae","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013HQ98LqE4xnKoprD4KJU1i","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Cwt5PxySRJRSeZXYKDuHAF","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/packages/react/src/payment/summary.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":15894,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":15894,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX3gpn5cvkWXtNn8ir2MQ","type":"assistant","uuid":"39e41d20-2956-4b46-b6ae-24d5adda812b","timestamp":"2026-01-12T15:03:13.071Z"}
{"parentUuid":"39e41d20-2956-4b46-b6ae-24d5adda812b","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013HQ98LqE4xnKoprD4KJU1i","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JFaURT6YQ6vi8Rz5fvhkcA","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":15894,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":15894,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX3gpn5cvkWXtNn8ir2MQ","type":"assistant","uuid":"cc13c198-c7f6-4e55-900b-568acbb025d2","timestamp":"2026-01-12T15:03:13.504Z"}
{"parentUuid":"cc13c198-c7f6-4e55-900b-568acbb025d2","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013HQ98LqE4xnKoprD4KJU1i","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01N4vfUfcKvX58oSa8AbmRXw","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/quote-service.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":15894,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":15894,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"}},"requestId":"req_011CX3gpn5cvkWXtNn8ir2MQ","type":"assistant","uuid":"80e95f2a-4c42-44c0-852c-6d8c0ec8e561","timestamp":"2026-01-12T15:03:13.978Z"}
{"parentUuid":"80e95f2a-4c42-44c0-852c-6d8c0ec8e561","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_013HQ98LqE4xnKoprD4KJU1i","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PvUStCKG3s9YFwZmyqceBi","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/checkout-sessions.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":15894,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":15894,"ephemeral_1h_input_tokens":0},"output_tokens":404,"service_tier":"standard"}},"requestId":"req_011CX3gpn5cvkWXtNn8ir2MQ","type":"assistant","uuid":"9b4c12fe-f4b1-429f-85dc-84015035faba","timestamp":"2026-01-12T15:03:14.349Z"}
{"parentUuid":"57995214-55c6-4563-9fbd-90972fd93f84","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01N4vfUfcKvX58oSa8AbmRXw","type":"tool_result","content":"     1→import { BN, fromTokenToUnit, fromUnitToToken } from '@ocap/util';\n     2→import crypto from 'crypto';\n     3→\n     4→import { ChainType, PaymentCurrency, PaymentMethod, Price, PriceQuote } from '../store/models';\n     5→import { getExchangeRateService } from './exchange-rate';\n     6→import logger from './logger';\n     7→import { getExchangeRateSymbol } from './exchange-rate/token-address-mapping';\n     8→import { trimDecimals, limitTokenPrecision } from './math-utils';\n     9→import { NonRetryableError } from './error';\n    10→\n    11→export interface CreateQuoteParams {\n    12→  price_id: string;\n    13→  session_id?: string;\n    14→  invoice_id?: string;\n    15→  target_currency_id: string;\n    16→  quantity: number;\n    17→  idempotency_key_salt?: string;\n    18→  slippage_percent?: number;\n    19→}\n    20→\n    21→export interface QuoteResponse {\n    22→  quote: PriceQuote;\n    23→  computed_unit_amount: string;\n    24→  expires_at: number;\n    25→}\n    26→\n    27→export interface RateResult {\n    28→  rate: string;\n    29→  provider_id: string;\n    30→  provider_name: string;\n    31→  timestamp_ms: number;\n    32→  degraded: boolean;\n    33→  degraded_reason?: string | null;\n    34→  providers?: Array<{\n    35→    provider_id: string;\n    36→    provider_name: string;\n    37→    rate: string;\n    38→    timestamp_ms: number;\n    39→    degraded: boolean;\n    40→    degraded_reason?: string;\n    41→  }>;\n    42→  consensus_method?: string;\n    43→}\n    44→\n    45→const DEFAULT_SLIPPAGE_PERCENT = 0.5;\n    46→\n    47→const normalizeSlippagePercent = (value?: number | string | null): number => {\n    48→  if (value === undefined || value === null) {\n    49→    return DEFAULT_SLIPPAGE_PERCENT;\n    50→  }\n    51→  const normalized = typeof value === 'string' ? Number(value) : value;\n    52→  if (!Number.isFinite(normalized) || normalized < 0) {\n    53→    return DEFAULT_SLIPPAGE_PERCENT;\n    54→  }\n    55→  return normalized;\n    56→};\n    57→\n    58→const resolveConsensusMethod = (rateResult: RateResult): string => {\n    59→  if (rateResult.consensus_method) {\n    60→    return rateResult.consensus_method;\n    61→  }\n    62→  if (rateResult.providers && rateResult.providers.length > 1) {\n    63→    return 'median';\n    64→  }\n    65→  return 'single';\n    66→};\n    67→\n    68→function isUniqueConstraintError(error: any): boolean {\n    69→  if (!error) {\n    70→    return false;\n    71→  }\n    72→  if (error.name === 'SequelizeUniqueConstraintError') {\n    73→    return true;\n    74→  }\n    75→  const message = String(error.message || '').toLowerCase();\n    76→  return message.includes('unique constraint') || message.includes('unique violation');\n    77→}\n    78→\n    79→/**\n    80→ * Generate idempotency key for quote\n    81→ */\n    82→function generateIdempotencyKey(params: {\n    83→  contextId: string; // session_id or invoice_id\n    84→  priceId: string;\n    85→  currencyId: string;\n    86→  quantity: number;\n    87→  baseAmount: string;\n    88→  salt?: string;\n    89→}): string {\n    90→  const { contextId, priceId, currencyId, quantity, baseAmount, salt } = params;\n    91→  const saltPart = salt ? `:${salt}` : '';\n    92→  return crypto\n    93→    .createHash('sha256')\n    94→    .update(`${contextId}:${priceId}:${currencyId}:${quantity}:${baseAmount}${saltPart}`)\n    95→    .digest('hex')\n    96→    .substring(0, 64);\n    97→}\n    98→\n    99→/**\n   100→ * Quote Service\n   101→ *\n   102→ * Handles creation and management of price quotes for dynamic pricing\n   103→ */\n   104→export class QuoteService {\n   105→  /**\n   106→   * Get or create a quote for dynamic pricing\n   107→   */\n   108→  async getOrCreateQuote(params: CreateQuoteParams): Promise<QuoteResponse> {\n   109→    const {\n   110→      price_id: priceId,\n   111→      session_id: sessionId,\n   112→      invoice_id: invoiceId,\n   113→      target_currency_id: targetCurrencyId,\n   114→      quantity,\n   115→      idempotency_key_salt: idempotencyKeySalt,\n   116→    } = params;\n   117→\n   118→    // Validate params\n   119→    if (!priceId || !targetCurrencyId || !quantity) {\n   120→      throw new NonRetryableError('INVALID_PARAMS', 'price_id, target_currency_id, and quantity are required');\n   121→    }\n   122→\n   123→    if (!sessionId && !invoiceId) {\n   124→      throw new NonRetryableError('INVALID_PARAMS', 'Either session_id or invoice_id must be provided');\n   125→    }\n   126→\n   127→    // Load price\n   128→    const price = await Price.findByPk(priceId);\n   129→    if (!price) {\n   130→      throw new NonRetryableError('PRICE_NOT_FOUND', `Price ${priceId} not found`);\n   131→    }\n   132→\n   133→    // Check if price is dynamic\n   134→    if (price.pricing_type !== 'dynamic') {\n   135→      throw new NonRetryableError('INVALID_PRICE_TYPE', `Price ${priceId} is not a dynamic price`);\n   136→    }\n   137→\n   138→    if (!price.base_currency || !price.base_amount) {\n   139→      throw new NonRetryableError('INVALID_PRICE_CONFIG', `Price ${priceId} missing base_currency or base_amount`);\n   140→    }\n   141→\n   142→    // Load target currency with payment method\n   143→    const currency = (await PaymentCurrency.findByPk(targetCurrencyId, {\n   144→      include: [{ model: PaymentMethod, as: 'payment_method' }],\n   145→    })) as PaymentCurrency & { payment_method: PaymentMethod };\n   146→\n   147→    if (!currency) {\n   148→      throw new NonRetryableError('CURRENCY_NOT_FOUND', `Currency ${targetCurrencyId} not found`);\n   149→    }\n   150→    if (currency.payment_method?.type === 'stripe') {\n   151→      throw new NonRetryableError('CURRENCY_NOT_SUPPORTED', `Currency ${targetCurrencyId} is not supported`);\n   152→    }\n   153→\n   154→    // Calculate total base amount using BN for precision\n   155→    // USD amounts are stored with 8 decimal places (e.g., \"10.50\" = $10.50)\n   156→    const USD_DECIMALS = 8;\n   157→    const baseAmountBN = fromTokenToUnit(trimDecimals(price.base_amount, USD_DECIMALS), USD_DECIMALS);\n   158→    const quantityBN = new BN(quantity);\n   159→    const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n   160→    const totalBaseAmountStr = fromUnitToToken(totalBaseAmountBN.toString(), USD_DECIMALS);\n   161→\n   162→    // Generate idempotency key\n   163→    const contextId = sessionId || invoiceId || '';\n   164→    const idempotencyKey = generateIdempotencyKey({\n   165→      contextId,\n   166→      priceId,\n   167→      currencyId: targetCurrencyId,\n   168→      quantity,\n   169→      baseAmount: totalBaseAmountStr,\n   170→      salt: idempotencyKeySalt,\n   171→    });\n   172→\n   173→    // Try to find existing active quote\n   174→    const existingQuote = await PriceQuote.findActiveQuote(idempotencyKey);\n   175→    if (existingQuote) {\n   176→      logger.debug('Reusing existing quote', {\n   177→        quoteId: existingQuote.id,\n   178→        idempotencyKey,\n   179→      });\n   180→\n   181→      return {\n   182→        quote: existingQuote,\n   183→        computed_unit_amount: existingQuote.quoted_amount,\n   184→        expires_at: existingQuote.expires_at,\n   185→      };\n   186→    }\n   187→\n   188→    const slippagePercent = normalizeSlippagePercent(params.slippage_percent);\n   189→\n   190→    // Get exchange rate\n   191→    // For ArcBlock payment method, always use ABT for exchange rate\n   192→    const exchangeRateService = getExchangeRateService();\n   193→    const rateSymbol = getExchangeRateSymbol(currency.symbol, currency.payment_method?.type as ChainType);\n   194→    const rateResult = await exchangeRateService.getRate(rateSymbol);\n   195→\n   196→    // Calculate quoted amount using pure BN arithmetic (no JS number conversion)\n   197→    // Formula: quotedAmount = ceil(totalBaseAmountBN * 10^decimals / rateBN)\n   198→    //\n   199→    // totalBaseAmountBN is already in smallest USD unit (10^8 scale)\n   200→    // rateBN is USD per token (also 10^8 scale)\n   201→    // Result: token smallest unit (10^decimals scale)\n   202→\n   203→    const rateBN = fromTokenToUnit(trimDecimals(rateResult.rate, USD_DECIMALS), USD_DECIMALS);\n   204→\n   205→    // Calculate: quotedAmount = ceil((totalBaseAmountBN * 10^decimals) / rateBN)\n   206→    const numerator = totalBaseAmountBN.mul(new BN(10).pow(new BN(currency.decimal)));\n   207→    const denominator = rateBN;\n   208→\n   209→    // Ceiling division: ceil(a/b) = (a + b - 1) / b for integers\n   210→    const quotedAmountRaw = numerator.add(denominator).sub(new BN(1)).div(denominator);\n   211→\n   212→    // Limit precision to 6 decimal places for dynamic pricing\n   213→    // This avoids meaningless precision in token amounts\n   214→    const quotedAmount = limitTokenPrecision(quotedAmountRaw, currency.decimal, 6);\n   215→\n   216→    // Calculate expiration time\n   217→    const lockDuration = price.dynamic_pricing_config?.lock_duration || 30; // Default 30 seconds\n   218→    const expiresAt = Math.floor(Date.now() / 1000) + lockDuration;\n   219→\n   220→    // Create quote\n   221→    const quotePayload = {\n   222→      price_id: priceId,\n   223→      session_id: sessionId || undefined,\n   224→      invoice_id: invoiceId || undefined,\n   225→      idempotency_key: idempotencyKey,\n   226→      base_currency: price.base_currency,\n   227→      base_amount: totalBaseAmountStr,\n   228→      target_currency_id: targetCurrencyId,\n   229→      rate_currency_symbol: currency.symbol,\n   230→      exchange_rate: rateResult.rate,\n   231→      quoted_amount: quotedAmount.toString(),\n   232→      slippage_percent: slippagePercent,\n   233→      rate_provider_id: rateResult.provider_id,\n   234→      rate_provider_name: rateResult.provider_name,\n   235→      rate_timestamp_ms: rateResult.timestamp_ms,\n   236→      expires_at: expiresAt,\n   237→      status: 'active',\n   238→      metadata: {\n   239→        calculation: {\n   240→          total_base_amount_scaled: totalBaseAmountBN.toString(),\n   241→          rate_scaled: rateBN.toString(),\n   242→          quoted_amount_unit: quotedAmount.toString(),\n   243→        },\n   244→        rounding: {\n   245→          mode: 'ceil',\n   246→          token_decimals: currency.decimal,\n   247→        },\n   248→        risk: {\n   249→          anomaly_detected: false,\n   250→          degraded: rateResult.degraded,\n   251→          degraded_reason: rateResult.degraded_reason || null,\n   252→        },\n   253→        rate: {\n   254→          consensus_method: resolveConsensusMethod(rateResult),\n   255→          providers: rateResult.providers || [],\n   256→        },\n   257→        slippage: {\n   258→          percent: slippagePercent,\n   259→        },\n   260→        context: {\n   261→          quantity,\n   262→          base_amount_per_unit: price.base_amount,\n   263→        },\n   264→      },\n   265→    };\n   266→\n   267→    // Create quote with retry logic for idempotency key collision\n   268→    const MAX_RETRIES = 3;\n   269→    let quote: PriceQuote | null = null;\n   270→    let lastError: any = null;\n   271→\n   272→    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n   273→      try {\n   274→        quote = await PriceQuote.create(quotePayload);\n   275→        break; // Success, exit loop\n   276→      } catch (error: any) {\n   277→        lastError = error;\n   278→\n   279→        if (isUniqueConstraintError(error)) {\n   280→          // Try to reuse existing quote with same idempotency key\n   281→          const existingByKey = await PriceQuote.findOne({ where: { idempotency_key: quotePayload.idempotency_key } });\n   282→          if (existingByKey && existingByKey.isActive()) {\n   283→            logger.warn('Idempotency key collision, reusing existing quote', {\n   284→              quoteId: existingByKey.id,\n   285→              idempotencyKey: quotePayload.idempotency_key,\n   286→              attempt,\n   287→            });\n   288→            return {\n   289→              quote: existingByKey,\n   290→              computed_unit_amount: existingByKey.quoted_amount,\n   291→              expires_at: existingByKey.expires_at,\n   292→            };\n   293→          }\n   294→\n   295→          // If last attempt or existing quote not found/inactive, throw error\n   296→          if (attempt >= MAX_RETRIES - 1) {\n   297→            logger.error('Max retries exceeded for quote creation in getOrCreateQuote', {\n   298→              priceId,\n   299→              currencyId: targetCurrencyId,\n   300→              attempts: attempt + 1,\n   301→              idempotencyKey: quotePayload.idempotency_key,\n   302→            });\n   303→            break; // Will throw error after loop\n   304→          }\n   305→\n   306→          // Generate new idempotency key with retry salt\n   307→          const retrySalt = `${idempotencyKeySalt || 'fallback'}:retry:${attempt}:${Date.now()}:${crypto.randomBytes(4).toString('hex')}`;\n   308→          quotePayload.idempotency_key = generateIdempotencyKey({\n   309→            contextId,\n   310→            priceId,\n   311→            currencyId: targetCurrencyId,\n   312→            quantity,\n   313→            baseAmount: totalBaseAmountStr,\n   314→            salt: retrySalt,\n   315→          });\n   316→\n   317→          logger.info('Retrying quote creation with new idempotency key', {\n   318→            priceId,\n   319→            attempt: attempt + 1,\n   320→            newIdempotencyKey: quotePayload.idempotency_key,\n   321→          });\n   322→        } else {\n   323→          // Non-idempotency error, throw immediately\n   324→          throw error;\n   325→        }\n   326→      }\n   327→    }\n   328→\n   329→    // If all retries failed, throw the last error\n   330→    if (!quote) {\n   331→      throw lastError || new Error('Failed to create quote after retries');\n   332→    }\n   333→\n   334→    logger.info('Created new quote', {\n   335→      quoteId: quote.id,\n   336→      priceId,\n   337→      currencyId: targetCurrencyId,\n   338→      baseAmount: totalBaseAmountStr,\n   339→      rate: rateResult.rate,\n   340→      quotedAmount: quotedAmount.toString(),\n   341→      expiresAt,\n   342→    });\n   343→\n   344→    return {\n   345→      quote,\n   346→      computed_unit_amount: quotedAmount.toString(),\n   347→      expires_at: expiresAt,\n   348→    };\n   349→  }\n   350→\n   351→  /**\n   352→   * Create a quote using pre-fetched exchange rate\n   353→   * This is used for batch quote creation to avoid multiple rate queries\n   354→   */\n   355→  async createQuoteWithRate(params: CreateQuoteParams & { rateResult: RateResult }): Promise<QuoteResponse> {\n   356→    const {\n   357→      price_id: priceId,\n   358→      session_id: sessionId,\n   359→      invoice_id: invoiceId,\n   360→      target_currency_id: targetCurrencyId,\n   361→      quantity,\n   362→      rateResult,\n   363→      idempotency_key_salt: idempotencyKeySalt,\n   364→      slippage_percent: slippagePercentInput,\n   365→    } = params;\n   366→\n   367→    // Validate params\n   368→    if (!priceId || !targetCurrencyId || !quantity) {\n   369→      throw new NonRetryableError('INVALID_PARAMS', 'price_id, target_currency_id, and quantity are required');\n   370→    }\n   371→\n   372→    if (!sessionId && !invoiceId) {\n   373→      throw new NonRetryableError('INVALID_PARAMS', 'Either session_id or invoice_id must be provided');\n   374→    }\n   375→\n   376→    // Load price\n   377→    const price = await Price.findByPk(priceId);\n   378→    if (!price) {\n   379→      throw new NonRetryableError('PRICE_NOT_FOUND', `Price ${priceId} not found`);\n   380→    }\n   381→\n   382→    // Check if price is dynamic\n   383→    if (price.pricing_type !== 'dynamic') {\n   384→      throw new NonRetryableError('INVALID_PRICE_TYPE', `Price ${priceId} is not a dynamic price`);\n   385→    }\n   386→\n   387→    if (!price.base_currency || !price.base_amount) {\n   388→      throw new NonRetryableError('INVALID_PRICE_CONFIG', `Price ${priceId} missing base_currency or base_amount`);\n   389→    }\n   390→\n   391→    // Load target currency\n   392→    const currency = await PaymentCurrency.findByPk(targetCurrencyId);\n   393→    if (!currency) {\n   394→      throw new NonRetryableError('CURRENCY_NOT_FOUND', `Currency ${targetCurrencyId} not found`);\n   395→    }\n   396→\n   397→    // Calculate total base amount using BN for precision\n   398→    const USD_DECIMALS = 8;\n   399→    const baseAmountBN = fromTokenToUnit(trimDecimals(price.base_amount, USD_DECIMALS), USD_DECIMALS);\n   400→    const quantityBN = new BN(quantity);\n   401→    const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n   402→    const totalBaseAmountStr = fromUnitToToken(totalBaseAmountBN.toString(), USD_DECIMALS);\n   403→\n   404→    // Generate idempotency key\n   405→    const contextId = sessionId || invoiceId || '';\n   406→    const idempotencyKey = generateIdempotencyKey({\n   407→      contextId,\n   408→      priceId,\n   409→      currencyId: targetCurrencyId,\n   410→      quantity,\n   411→      baseAmount: totalBaseAmountStr,\n   412→      salt: idempotencyKeySalt,\n   413→    });\n   414→\n   415→    // Try to find existing active quote\n   416→    const existingQuote = await PriceQuote.findActiveQuote(idempotencyKey);\n   417→    if (existingQuote) {\n   418→      logger.debug('Reusing existing quote', {\n   419→        quoteId: existingQuote.id,\n   420→        idempotencyKey,\n   421→      });\n   422→\n   423→      return {\n   424→        quote: existingQuote,\n   425→        computed_unit_amount: existingQuote.quoted_amount,\n   426→        expires_at: existingQuote.expires_at,\n   427→      };\n   428→    }\n   429→\n   430→    // Calculate quoted amount using pure BN arithmetic\n   431→    const rateBN = fromTokenToUnit(trimDecimals(rateResult.rate, USD_DECIMALS), USD_DECIMALS);\n   432→\n   433→    // Calculate: quotedAmount = ceil((totalBaseAmountBN * 10^decimals) / rateBN)\n   434→    const numerator = totalBaseAmountBN.mul(new BN(10).pow(new BN(currency.decimal)));\n   435→    const denominator = rateBN;\n   436→\n   437→    // Ceiling division: ceil(a/b) = (a + b - 1) / b\n   438→    const quotedAmountRaw = numerator.add(denominator).sub(new BN(1)).div(denominator);\n   439→\n   440→    // Limit precision to 6 decimal places for dynamic pricing\n   441→    // This avoids meaningless precision in token amounts\n   442→    const quotedAmount = limitTokenPrecision(quotedAmountRaw, currency.decimal, 6);\n   443→\n   444→    // Calculate expiration time\n   445→    const lockDuration = price.dynamic_pricing_config?.lock_duration || 30;\n   446→    const expiresAt = Math.floor(Date.now() / 1000) + lockDuration;\n   447→\n   448→    const slippagePercent = normalizeSlippagePercent(slippagePercentInput);\n   449→\n   450→    // Create quote\n   451→    const quotePayload = {\n   452→      price_id: priceId,\n   453→      session_id: sessionId || undefined,\n   454→      invoice_id: invoiceId || undefined,\n   455→      idempotency_key: idempotencyKey,\n   456→      base_currency: price.base_currency,\n   457→      base_amount: totalBaseAmountStr,\n   458→      target_currency_id: targetCurrencyId,\n   459→      rate_currency_symbol: currency.symbol,\n   460→      exchange_rate: rateResult.rate,\n   461→      quoted_amount: quotedAmount.toString(),\n   462→      slippage_percent: slippagePercent,\n   463→      rate_provider_id: rateResult.provider_id,\n   464→      rate_provider_name: rateResult.provider_name,\n   465→      rate_timestamp_ms: rateResult.timestamp_ms,\n   466→      expires_at: expiresAt,\n   467→      status: 'active',\n   468→      metadata: {\n   469→        calculation: {\n   470→          total_base_amount_scaled: totalBaseAmountBN.toString(),\n   471→          rate_scaled: rateBN.toString(),\n   472→          quoted_amount_unit: quotedAmount.toString(),\n   473→        },\n   474→        rounding: {\n   475→          mode: 'ceil',\n   476→          token_decimals: currency.decimal,\n   477→        },\n   478→        risk: {\n   479→          anomaly_detected: false,\n   480→          degraded: rateResult.degraded,\n   481→          degraded_reason: rateResult.degraded_reason || null,\n   482→        },\n   483→        rate: {\n   484→          consensus_method: resolveConsensusMethod(rateResult),\n   485→          providers: rateResult.providers || [],\n   486→        },\n   487→        slippage: {\n   488→          percent: slippagePercent,\n   489→        },\n   490→        context: {\n   491→          quantity,\n   492→          base_amount_per_unit: price.base_amount,\n   493→        },\n   494→      },\n   495→    };\n   496→\n   497→    // Create quote with retry logic for idempotency key collision\n   498→    const MAX_RETRIES = 3;\n   499→    let quote: PriceQuote | null = null;\n   500→    let lastError: any = null;\n   501→\n   502→    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n   503→      try {\n   504→        quote = await PriceQuote.create(quotePayload);\n   505→        break; // Success, exit loop\n   506→      } catch (error: any) {\n   507→        lastError = error;\n   508→\n   509→        if (isUniqueConstraintError(error)) {\n   510→          // Try to reuse existing quote with same idempotency key\n   511→          const existingByKey = await PriceQuote.findOne({ where: { idempotency_key: quotePayload.idempotency_key } });\n   512→          if (existingByKey && existingByKey.isActive()) {\n   513→            logger.warn('Idempotency key collision, reusing existing quote', {\n   514→              quoteId: existingByKey.id,\n   515→              idempotencyKey: quotePayload.idempotency_key,\n   516→              attempt,\n   517→            });\n   518→            return {\n   519→              quote: existingByKey,\n   520→              computed_unit_amount: existingByKey.quoted_amount,\n   521→              expires_at: existingByKey.expires_at,\n   522→            };\n   523→          }\n   524→\n   525→          // If last attempt or existing quote not found/inactive, throw error\n   526→          if (attempt >= MAX_RETRIES - 1) {\n   527→            logger.error('Max retries exceeded for quote creation in createQuoteWithRate', {\n   528→              priceId,\n   529→              currencyId: targetCurrencyId,\n   530→              attempts: attempt + 1,\n   531→              idempotencyKey: quotePayload.idempotency_key,\n   532→            });\n   533→            break; // Will throw error after loop\n   534→          }\n   535→\n   536→          // Generate new idempotency key with retry salt\n   537→          const retrySalt = `${idempotencyKeySalt || 'fallback'}:retry:${attempt}:${Date.now()}:${crypto.randomBytes(4).toString('hex')}`;\n   538→          quotePayload.idempotency_key = generateIdempotencyKey({\n   539→            contextId,\n   540→            priceId,\n   541→            currencyId: targetCurrencyId,\n   542→            quantity,\n   543→            baseAmount: totalBaseAmountStr,\n   544→            salt: retrySalt,\n   545→          });\n   546→\n   547→          logger.info('Retrying quote creation with new idempotency key', {\n   548→            priceId,\n   549→            attempt: attempt + 1,\n   550→            newIdempotencyKey: quotePayload.idempotency_key,\n   551→          });\n   552→        } else {\n   553→          // Non-idempotency error, throw immediately\n   554→          throw error;\n   555→        }\n   556→      }\n   557→    }\n   558→\n   559→    // If all retries failed, throw the last error\n   560→    if (!quote) {\n   561→      throw lastError || new Error('Failed to create quote after retries');\n   562→    }\n   563→\n   564→    logger.info('Created new quote with provided rate', {\n   565→      quoteId: quote.id,\n   566→      priceId,\n   567→      currencyId: targetCurrencyId,\n   568→      baseAmount: totalBaseAmountStr,\n   569→      rate: rateResult.rate,\n   570→      quotedAmount: quotedAmount.toString(),\n   571→      expiresAt,\n   572→    });\n   573→\n   574→    return {\n   575→      quote,\n   576→      computed_unit_amount: quotedAmount.toString(),\n   577→      expires_at: expiresAt,\n   578→    };\n   579→  }\n   580→\n   581→  /**\n   582→   * Refresh an existing quote in place using a pre-fetched exchange rate\n   583→   * This is used when quotes expire but we don't want to create a new quote_id\n   584→   */\n   585→  async refreshQuoteWithRate(\n   586→    params: CreateQuoteParams & { rateResult: RateResult; quote_id: string }\n   587→  ): Promise<QuoteResponse> {\n   588→    const {\n   589→      quote_id: quoteId,\n   590→      price_id: priceId,\n   591→      session_id: sessionId,\n   592→      invoice_id: invoiceId,\n   593→      target_currency_id: targetCurrencyId,\n   594→      quantity,\n   595→      rateResult,\n   596→      slippage_percent: slippagePercentInput,\n   597→    } = params;\n   598→\n   599→    const existing = await PriceQuote.findByPk(quoteId);\n   600→    if (!existing) {\n   601→      return this.createQuoteWithRate({\n   602→        price_id: priceId,\n   603→        session_id: sessionId,\n   604→        invoice_id: invoiceId,\n   605→        target_currency_id: targetCurrencyId,\n   606→        quantity,\n   607→        rateResult,\n   608→      });\n   609→    }\n   610→\n   611→    if (existing.status === 'paid' || existing.status === 'used') {\n   612→      return {\n   613→        quote: existing,\n   614→        computed_unit_amount: existing.quoted_amount,\n   615→        expires_at: existing.expires_at,\n   616→      };\n   617→    }\n   618→    if (existing.status === 'failed') {\n   619→      return this.createQuoteWithRate({\n   620→        price_id: priceId,\n   621→        session_id: sessionId,\n   622→        invoice_id: invoiceId,\n   623→        target_currency_id: targetCurrencyId,\n   624→        quantity,\n   625→        rateResult,\n   626→      });\n   627→    }\n   628→\n   629→    // Load price\n   630→    const price = await Price.findByPk(priceId);\n   631→    if (!price) {\n   632→      throw new NonRetryableError('PRICE_NOT_FOUND', `Price ${priceId} not found`);\n   633→    }\n   634→\n   635→    if (price.pricing_type !== 'dynamic') {\n   636→      throw new NonRetryableError('INVALID_PRICE_TYPE', `Price ${priceId} is not a dynamic price`);\n   637→    }\n   638→\n   639→    if (!price.base_currency || !price.base_amount) {\n   640→      throw new NonRetryableError('INVALID_PRICE_CONFIG', `Price ${priceId} missing base_currency or base_amount`);\n   641→    }\n   642→\n   643→    // Load target currency\n   644→    const currency = await PaymentCurrency.findByPk(targetCurrencyId);\n   645→    if (!currency) {\n   646→      throw new NonRetryableError('CURRENCY_NOT_FOUND', `Currency ${targetCurrencyId} not found`);\n   647→    }\n   648→\n   649→    // Calculate total base amount using BN for precision\n   650→    const USD_DECIMALS = 8;\n   651→    const baseAmountBN = fromTokenToUnit(trimDecimals(price.base_amount, USD_DECIMALS), USD_DECIMALS);\n   652→    const quantityBN = new BN(quantity);\n   653→    const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n   654→    const totalBaseAmountStr = fromUnitToToken(totalBaseAmountBN.toString(), USD_DECIMALS);\n   655→\n   656→    // Calculate quoted amount using pure BN arithmetic\n   657→    const rateBN = fromTokenToUnit(trimDecimals(rateResult.rate, USD_DECIMALS), USD_DECIMALS);\n   658→    const numerator = totalBaseAmountBN.mul(new BN(10).pow(new BN(currency.decimal)));\n   659→    const denominator = rateBN;\n   660→    const quotedAmountRaw = numerator.add(denominator).sub(new BN(1)).div(denominator);\n   661→    const quotedAmount = limitTokenPrecision(quotedAmountRaw, currency.decimal, 6);\n   662→\n   663→    // Calculate expiration time\n   664→    const lockDuration = price.dynamic_pricing_config?.lock_duration || 30;\n   665→    const expiresAt = Math.floor(Date.now() / 1000) + lockDuration;\n   666→\n   667→    const slippagePercent = normalizeSlippagePercent(slippagePercentInput);\n   668→\n   669→    await existing.update({\n   670→      base_currency: price.base_currency,\n   671→      base_amount: totalBaseAmountStr,\n   672→      target_currency_id: targetCurrencyId,\n   673→      rate_currency_symbol: currency.symbol,\n   674→      exchange_rate: rateResult.rate,\n   675→      quoted_amount: quotedAmount.toString(),\n   676→      slippage_percent: slippagePercent,\n   677→      rate_provider_id: rateResult.provider_id,\n   678→      rate_provider_name: rateResult.provider_name,\n   679→      rate_timestamp_ms: rateResult.timestamp_ms,\n   680→      expires_at: expiresAt,\n   681→      status: 'active',\n   682→      metadata: {\n   683→        calculation: {\n   684→          total_base_amount_scaled: totalBaseAmountBN.toString(),\n   685→          rate_scaled: rateBN.toString(),\n   686→          quoted_amount_unit: quotedAmount.toString(),\n   687→        },\n   688→        rounding: {\n   689→          mode: 'ceil',\n   690→          token_decimals: currency.decimal,\n   691→        },\n   692→        risk: {\n   693→          anomaly_detected: false,\n   694→          degraded: rateResult.degraded,\n   695→          degraded_reason: rateResult.degraded_reason || null,\n   696→        },\n   697→        rate: {\n   698→          consensus_method: resolveConsensusMethod(rateResult),\n   699→          providers: rateResult.providers || [],\n   700→        },\n   701→        slippage: {\n   702→          percent: slippagePercent,\n   703→        },\n   704→        context: {\n   705→          quantity,\n   706→          base_amount_per_unit: price.base_amount,\n   707→        },\n   708→      },\n   709→    });\n   710→\n   711→    return {\n   712→      quote: existing,\n   713→      computed_unit_amount: existing.quoted_amount,\n   714→      expires_at: existing.expires_at,\n   715→    };\n   716→  }\n   717→\n   718→  /**\n   719→   * Validate and consume a quote (with concurrency control)\n   720→   */\n   721→  async validateAndConsume(quoteId: string, transaction?: any): Promise<PriceQuote> {\n   722→    // Use FOR UPDATE to lock the row\n   723→    const quote = await PriceQuote.findOne({\n   724→      where: { id: quoteId },\n   725→      lock: transaction ? transaction.LOCK.UPDATE : undefined,\n   726→      transaction,\n   727→    });\n   728→\n   729→    if (!quote) {\n   730→      throw new NonRetryableError('QUOTE_NOT_FOUND', `Quote ${quoteId} not found`);\n   731→    }\n   732→\n   733→    if (!quote.isActive()) {\n   734→      throw new NonRetryableError('QUOTE_INVALID', `Quote ${quoteId} is not active or has expired`);\n   735→    }\n   736→\n   737→    // Update status to 'used'\n   738→    await quote.consume(transaction);\n   739→\n   740→    return quote;\n   741→  }\n   742→\n   743→  /**\n   744→   * Mark quote as paid\n   745→   */\n   746→  async markAsPaid(quoteId: string, transaction?: any): Promise<void> {\n   747→    const quote = await PriceQuote.findByPk(quoteId, { transaction });\n   748→    if (!quote) {\n   749→      throw new Error(`Quote ${quoteId} not found`);\n   750→    }\n   751→\n   752→    await quote.markAsPaid(transaction);\n   753→  }\n   754→\n   755→  /**\n   756→   * Mark quote as failed\n   757→   */\n   758→  async markAsFailed(quoteId: string, transaction?: any): Promise<void> {\n   759→    const quote = await PriceQuote.findByPk(quoteId, { transaction });\n   760→    if (!quote) {\n   761→      throw new Error(`Quote ${quoteId} not found`);\n   762→    }\n   763→\n   764→    await quote.markAsFailed(transaction);\n   765→  }\n   766→\n   767→  /**\n   768→   * Clean up expired quotes (for background job)\n   769→   */\n   770→  async expireOldQuotes(): Promise<number> {\n   771→    const count = await PriceQuote.expireOldQuotes();\n   772→    logger.info('Expired old quotes', { count });\n   773→    return count;\n   774→  }\n   775→}\n   776→\n   777→// Singleton instance\n   778→let serviceInstance: QuoteService | null = null;\n   779→\n   780→export function getQuoteService(): QuoteService {\n   781→  if (!serviceInstance) {\n   782→    serviceInstance = new QuoteService();\n   783→  }\n   784→  return serviceInstance;\n   785→}\n   786→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"b2aa2d44-5f70-4e74-858b-8d16bdff0df8","timestamp":"2026-01-12T15:03:15.596Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/quote-service.ts","content":"import { BN, fromTokenToUnit, fromUnitToToken } from '@ocap/util';\nimport crypto from 'crypto';\n\nimport { ChainType, PaymentCurrency, PaymentMethod, Price, PriceQuote } from '../store/models';\nimport { getExchangeRateService } from './exchange-rate';\nimport logger from './logger';\nimport { getExchangeRateSymbol } from './exchange-rate/token-address-mapping';\nimport { trimDecimals, limitTokenPrecision } from './math-utils';\nimport { NonRetryableError } from './error';\n\nexport interface CreateQuoteParams {\n  price_id: string;\n  session_id?: string;\n  invoice_id?: string;\n  target_currency_id: string;\n  quantity: number;\n  idempotency_key_salt?: string;\n  slippage_percent?: number;\n}\n\nexport interface QuoteResponse {\n  quote: PriceQuote;\n  computed_unit_amount: string;\n  expires_at: number;\n}\n\nexport interface RateResult {\n  rate: string;\n  provider_id: string;\n  provider_name: string;\n  timestamp_ms: number;\n  degraded: boolean;\n  degraded_reason?: string | null;\n  providers?: Array<{\n    provider_id: string;\n    provider_name: string;\n    rate: string;\n    timestamp_ms: number;\n    degraded: boolean;\n    degraded_reason?: string;\n  }>;\n  consensus_method?: string;\n}\n\nconst DEFAULT_SLIPPAGE_PERCENT = 0.5;\n\nconst normalizeSlippagePercent = (value?: number | string | null): number => {\n  if (value === undefined || value === null) {\n    return DEFAULT_SLIPPAGE_PERCENT;\n  }\n  const normalized = typeof value === 'string' ? Number(value) : value;\n  if (!Number.isFinite(normalized) || normalized < 0) {\n    return DEFAULT_SLIPPAGE_PERCENT;\n  }\n  return normalized;\n};\n\nconst resolveConsensusMethod = (rateResult: RateResult): string => {\n  if (rateResult.consensus_method) {\n    return rateResult.consensus_method;\n  }\n  if (rateResult.providers && rateResult.providers.length > 1) {\n    return 'median';\n  }\n  return 'single';\n};\n\nfunction isUniqueConstraintError(error: any): boolean {\n  if (!error) {\n    return false;\n  }\n  if (error.name === 'SequelizeUniqueConstraintError') {\n    return true;\n  }\n  const message = String(error.message || '').toLowerCase();\n  return message.includes('unique constraint') || message.includes('unique violation');\n}\n\n/**\n * Generate idempotency key for quote\n */\nfunction generateIdempotencyKey(params: {\n  contextId: string; // session_id or invoice_id\n  priceId: string;\n  currencyId: string;\n  quantity: number;\n  baseAmount: string;\n  salt?: string;\n}): string {\n  const { contextId, priceId, currencyId, quantity, baseAmount, salt } = params;\n  const saltPart = salt ? `:${salt}` : '';\n  return crypto\n    .createHash('sha256')\n    .update(`${contextId}:${priceId}:${currencyId}:${quantity}:${baseAmount}${saltPart}`)\n    .digest('hex')\n    .substring(0, 64);\n}\n\n/**\n * Quote Service\n *\n * Handles creation and management of price quotes for dynamic pricing\n */\nexport class QuoteService {\n  /**\n   * Get or create a quote for dynamic pricing\n   */\n  async getOrCreateQuote(params: CreateQuoteParams): Promise<QuoteResponse> {\n    const {\n      price_id: priceId,\n      session_id: sessionId,\n      invoice_id: invoiceId,\n      target_currency_id: targetCurrencyId,\n      quantity,\n      idempotency_key_salt: idempotencyKeySalt,\n    } = params;\n\n    // Validate params\n    if (!priceId || !targetCurrencyId || !quantity) {\n      throw new NonRetryableError('INVALID_PARAMS', 'price_id, target_currency_id, and quantity are required');\n    }\n\n    if (!sessionId && !invoiceId) {\n      throw new NonRetryableError('INVALID_PARAMS', 'Either session_id or invoice_id must be provided');\n    }\n\n    // Load price\n    const price = await Price.findByPk(priceId);\n    if (!price) {\n      throw new NonRetryableError('PRICE_NOT_FOUND', `Price ${priceId} not found`);\n    }\n\n    // Check if price is dynamic\n    if (price.pricing_type !== 'dynamic') {\n      throw new NonRetryableError('INVALID_PRICE_TYPE', `Price ${priceId} is not a dynamic price`);\n    }\n\n    if (!price.base_currency || !price.base_amount) {\n      throw new NonRetryableError('INVALID_PRICE_CONFIG', `Price ${priceId} missing base_currency or base_amount`);\n    }\n\n    // Load target currency with payment method\n    const currency = (await PaymentCurrency.findByPk(targetCurrencyId, {\n      include: [{ model: PaymentMethod, as: 'payment_method' }],\n    })) as PaymentCurrency & { payment_method: PaymentMethod };\n\n    if (!currency) {\n      throw new NonRetryableError('CURRENCY_NOT_FOUND', `Currency ${targetCurrencyId} not found`);\n    }\n    if (currency.payment_method?.type === 'stripe') {\n      throw new NonRetryableError('CURRENCY_NOT_SUPPORTED', `Currency ${targetCurrencyId} is not supported`);\n    }\n\n    // Calculate total base amount using BN for precision\n    // USD amounts are stored with 8 decimal places (e.g., \"10.50\" = $10.50)\n    const USD_DECIMALS = 8;\n    const baseAmountBN = fromTokenToUnit(trimDecimals(price.base_amount, USD_DECIMALS), USD_DECIMALS);\n    const quantityBN = new BN(quantity);\n    const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n    const totalBaseAmountStr = fromUnitToToken(totalBaseAmountBN.toString(), USD_DECIMALS);\n\n    // Generate idempotency key\n    const contextId = sessionId || invoiceId || '';\n    const idempotencyKey = generateIdempotencyKey({\n      contextId,\n      priceId,\n      currencyId: targetCurrencyId,\n      quantity,\n      baseAmount: totalBaseAmountStr,\n      salt: idempotencyKeySalt,\n    });\n\n    // Try to find existing active quote\n    const existingQuote = await PriceQuote.findActiveQuote(idempotencyKey);\n    if (existingQuote) {\n      logger.debug('Reusing existing quote', {\n        quoteId: existingQuote.id,\n        idempotencyKey,\n      });\n\n      return {\n        quote: existingQuote,\n        computed_unit_amount: existingQuote.quoted_amount,\n        expires_at: existingQuote.expires_at,\n      };\n    }\n\n    const slippagePercent = normalizeSlippagePercent(params.slippage_percent);\n\n    // Get exchange rate\n    // For ArcBlock payment method, always use ABT for exchange rate\n    const exchangeRateService = getExchangeRateService();\n    const rateSymbol = getExchangeRateSymbol(currency.symbol, currency.payment_method?.type as ChainType);\n    const rateResult = await exchangeRateService.getRate(rateSymbol);\n\n    // Calculate quoted amount using pure BN arithmetic (no JS number conversion)\n    // Formula: quotedAmount = ceil(totalBaseAmountBN * 10^decimals / rateBN)\n    //\n    // totalBaseAmountBN is already in smallest USD unit (10^8 scale)\n    // rateBN is USD per token (also 10^8 scale)\n    // Result: token smallest unit (10^decimals scale)\n\n    const rateBN = fromTokenToUnit(trimDecimals(rateResult.rate, USD_DECIMALS), USD_DECIMALS);\n\n    // Calculate: quotedAmount = ceil((totalBaseAmountBN * 10^decimals) / rateBN)\n    const numerator = totalBaseAmountBN.mul(new BN(10).pow(new BN(currency.decimal)));\n    const denominator = rateBN;\n\n    // Ceiling division: ceil(a/b) = (a + b - 1) / b for integers\n    const quotedAmountRaw = numerator.add(denominator).sub(new BN(1)).div(denominator);\n\n    // Limit precision to 6 decimal places for dynamic pricing\n    // This avoids meaningless precision in token amounts\n    const quotedAmount = limitTokenPrecision(quotedAmountRaw, currency.decimal, 6);\n\n    // Calculate expiration time\n    const lockDuration = price.dynamic_pricing_config?.lock_duration || 30; // Default 30 seconds\n    const expiresAt = Math.floor(Date.now() / 1000) + lockDuration;\n\n    // Create quote\n    const quotePayload = {\n      price_id: priceId,\n      session_id: sessionId || undefined,\n      invoice_id: invoiceId || undefined,\n      idempotency_key: idempotencyKey,\n      base_currency: price.base_currency,\n      base_amount: totalBaseAmountStr,\n      target_currency_id: targetCurrencyId,\n      rate_currency_symbol: currency.symbol,\n      exchange_rate: rateResult.rate,\n      quoted_amount: quotedAmount.toString(),\n      slippage_percent: slippagePercent,\n      rate_provider_id: rateResult.provider_id,\n      rate_provider_name: rateResult.provider_name,\n      rate_timestamp_ms: rateResult.timestamp_ms,\n      expires_at: expiresAt,\n      status: 'active',\n      metadata: {\n        calculation: {\n          total_base_amount_scaled: totalBaseAmountBN.toString(),\n          rate_scaled: rateBN.toString(),\n          quoted_amount_unit: quotedAmount.toString(),\n        },\n        rounding: {\n          mode: 'ceil',\n          token_decimals: currency.decimal,\n        },\n        risk: {\n          anomaly_detected: false,\n          degraded: rateResult.degraded,\n          degraded_reason: rateResult.degraded_reason || null,\n        },\n        rate: {\n          consensus_method: resolveConsensusMethod(rateResult),\n          providers: rateResult.providers || [],\n        },\n        slippage: {\n          percent: slippagePercent,\n        },\n        context: {\n          quantity,\n          base_amount_per_unit: price.base_amount,\n        },\n      },\n    };\n\n    // Create quote with retry logic for idempotency key collision\n    const MAX_RETRIES = 3;\n    let quote: PriceQuote | null = null;\n    let lastError: any = null;\n\n    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n      try {\n        quote = await PriceQuote.create(quotePayload);\n        break; // Success, exit loop\n      } catch (error: any) {\n        lastError = error;\n\n        if (isUniqueConstraintError(error)) {\n          // Try to reuse existing quote with same idempotency key\n          const existingByKey = await PriceQuote.findOne({ where: { idempotency_key: quotePayload.idempotency_key } });\n          if (existingByKey && existingByKey.isActive()) {\n            logger.warn('Idempotency key collision, reusing existing quote', {\n              quoteId: existingByKey.id,\n              idempotencyKey: quotePayload.idempotency_key,\n              attempt,\n            });\n            return {\n              quote: existingByKey,\n              computed_unit_amount: existingByKey.quoted_amount,\n              expires_at: existingByKey.expires_at,\n            };\n          }\n\n          // If last attempt or existing quote not found/inactive, throw error\n          if (attempt >= MAX_RETRIES - 1) {\n            logger.error('Max retries exceeded for quote creation in getOrCreateQuote', {\n              priceId,\n              currencyId: targetCurrencyId,\n              attempts: attempt + 1,\n              idempotencyKey: quotePayload.idempotency_key,\n            });\n            break; // Will throw error after loop\n          }\n\n          // Generate new idempotency key with retry salt\n          const retrySalt = `${idempotencyKeySalt || 'fallback'}:retry:${attempt}:${Date.now()}:${crypto.randomBytes(4).toString('hex')}`;\n          quotePayload.idempotency_key = generateIdempotencyKey({\n            contextId,\n            priceId,\n            currencyId: targetCurrencyId,\n            quantity,\n            baseAmount: totalBaseAmountStr,\n            salt: retrySalt,\n          });\n\n          logger.info('Retrying quote creation with new idempotency key', {\n            priceId,\n            attempt: attempt + 1,\n            newIdempotencyKey: quotePayload.idempotency_key,\n          });\n        } else {\n          // Non-idempotency error, throw immediately\n          throw error;\n        }\n      }\n    }\n\n    // If all retries failed, throw the last error\n    if (!quote) {\n      throw lastError || new Error('Failed to create quote after retries');\n    }\n\n    logger.info('Created new quote', {\n      quoteId: quote.id,\n      priceId,\n      currencyId: targetCurrencyId,\n      baseAmount: totalBaseAmountStr,\n      rate: rateResult.rate,\n      quotedAmount: quotedAmount.toString(),\n      expiresAt,\n    });\n\n    return {\n      quote,\n      computed_unit_amount: quotedAmount.toString(),\n      expires_at: expiresAt,\n    };\n  }\n\n  /**\n   * Create a quote using pre-fetched exchange rate\n   * This is used for batch quote creation to avoid multiple rate queries\n   */\n  async createQuoteWithRate(params: CreateQuoteParams & { rateResult: RateResult }): Promise<QuoteResponse> {\n    const {\n      price_id: priceId,\n      session_id: sessionId,\n      invoice_id: invoiceId,\n      target_currency_id: targetCurrencyId,\n      quantity,\n      rateResult,\n      idempotency_key_salt: idempotencyKeySalt,\n      slippage_percent: slippagePercentInput,\n    } = params;\n\n    // Validate params\n    if (!priceId || !targetCurrencyId || !quantity) {\n      throw new NonRetryableError('INVALID_PARAMS', 'price_id, target_currency_id, and quantity are required');\n    }\n\n    if (!sessionId && !invoiceId) {\n      throw new NonRetryableError('INVALID_PARAMS', 'Either session_id or invoice_id must be provided');\n    }\n\n    // Load price\n    const price = await Price.findByPk(priceId);\n    if (!price) {\n      throw new NonRetryableError('PRICE_NOT_FOUND', `Price ${priceId} not found`);\n    }\n\n    // Check if price is dynamic\n    if (price.pricing_type !== 'dynamic') {\n      throw new NonRetryableError('INVALID_PRICE_TYPE', `Price ${priceId} is not a dynamic price`);\n    }\n\n    if (!price.base_currency || !price.base_amount) {\n      throw new NonRetryableError('INVALID_PRICE_CONFIG', `Price ${priceId} missing base_currency or base_amount`);\n    }\n\n    // Load target currency\n    const currency = await PaymentCurrency.findByPk(targetCurrencyId);\n    if (!currency) {\n      throw new NonRetryableError('CURRENCY_NOT_FOUND', `Currency ${targetCurrencyId} not found`);\n    }\n\n    // Calculate total base amount using BN for precision\n    const USD_DECIMALS = 8;\n    const baseAmountBN = fromTokenToUnit(trimDecimals(price.base_amount, USD_DECIMALS), USD_DECIMALS);\n    const quantityBN = new BN(quantity);\n    const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n    const totalBaseAmountStr = fromUnitToToken(totalBaseAmountBN.toString(), USD_DECIMALS);\n\n    // Generate idempotency key\n    const contextId = sessionId || invoiceId || '';\n    const idempotencyKey = generateIdempotencyKey({\n      contextId,\n      priceId,\n      currencyId: targetCurrencyId,\n      quantity,\n      baseAmount: totalBaseAmountStr,\n      salt: idempotencyKeySalt,\n    });\n\n    // Try to find existing active quote\n    const existingQuote = await PriceQuote.findActiveQuote(idempotencyKey);\n    if (existingQuote) {\n      logger.debug('Reusing existing quote', {\n        quoteId: existingQuote.id,\n        idempotencyKey,\n      });\n\n      return {\n        quote: existingQuote,\n        computed_unit_amount: existingQuote.quoted_amount,\n        expires_at: existingQuote.expires_at,\n      };\n    }\n\n    // Calculate quoted amount using pure BN arithmetic\n    const rateBN = fromTokenToUnit(trimDecimals(rateResult.rate, USD_DECIMALS), USD_DECIMALS);\n\n    // Calculate: quotedAmount = ceil((totalBaseAmountBN * 10^decimals) / rateBN)\n    const numerator = totalBaseAmountBN.mul(new BN(10).pow(new BN(currency.decimal)));\n    const denominator = rateBN;\n\n    // Ceiling division: ceil(a/b) = (a + b - 1) / b\n    const quotedAmountRaw = numerator.add(denominator).sub(new BN(1)).div(denominator);\n\n    // Limit precision to 6 decimal places for dynamic pricing\n    // This avoids meaningless precision in token amounts\n    const quotedAmount = limitTokenPrecision(quotedAmountRaw, currency.decimal, 6);\n\n    // Calculate expiration time\n    const lockDuration = price.dynamic_pricing_config?.lock_duration || 30;\n    const expiresAt = Math.floor(Date.now() / 1000) + lockDuration;\n\n    const slippagePercent = normalizeSlippagePercent(slippagePercentInput);\n\n    // Create quote\n    const quotePayload = {\n      price_id: priceId,\n      session_id: sessionId || undefined,\n      invoice_id: invoiceId || undefined,\n      idempotency_key: idempotencyKey,\n      base_currency: price.base_currency,\n      base_amount: totalBaseAmountStr,\n      target_currency_id: targetCurrencyId,\n      rate_currency_symbol: currency.symbol,\n      exchange_rate: rateResult.rate,\n      quoted_amount: quotedAmount.toString(),\n      slippage_percent: slippagePercent,\n      rate_provider_id: rateResult.provider_id,\n      rate_provider_name: rateResult.provider_name,\n      rate_timestamp_ms: rateResult.timestamp_ms,\n      expires_at: expiresAt,\n      status: 'active',\n      metadata: {\n        calculation: {\n          total_base_amount_scaled: totalBaseAmountBN.toString(),\n          rate_scaled: rateBN.toString(),\n          quoted_amount_unit: quotedAmount.toString(),\n        },\n        rounding: {\n          mode: 'ceil',\n          token_decimals: currency.decimal,\n        },\n        risk: {\n          anomaly_detected: false,\n          degraded: rateResult.degraded,\n          degraded_reason: rateResult.degraded_reason || null,\n        },\n        rate: {\n          consensus_method: resolveConsensusMethod(rateResult),\n          providers: rateResult.providers || [],\n        },\n        slippage: {\n          percent: slippagePercent,\n        },\n        context: {\n          quantity,\n          base_amount_per_unit: price.base_amount,\n        },\n      },\n    };\n\n    // Create quote with retry logic for idempotency key collision\n    const MAX_RETRIES = 3;\n    let quote: PriceQuote | null = null;\n    let lastError: any = null;\n\n    for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n      try {\n        quote = await PriceQuote.create(quotePayload);\n        break; // Success, exit loop\n      } catch (error: any) {\n        lastError = error;\n\n        if (isUniqueConstraintError(error)) {\n          // Try to reuse existing quote with same idempotency key\n          const existingByKey = await PriceQuote.findOne({ where: { idempotency_key: quotePayload.idempotency_key } });\n          if (existingByKey && existingByKey.isActive()) {\n            logger.warn('Idempotency key collision, reusing existing quote', {\n              quoteId: existingByKey.id,\n              idempotencyKey: quotePayload.idempotency_key,\n              attempt,\n            });\n            return {\n              quote: existingByKey,\n              computed_unit_amount: existingByKey.quoted_amount,\n              expires_at: existingByKey.expires_at,\n            };\n          }\n\n          // If last attempt or existing quote not found/inactive, throw error\n          if (attempt >= MAX_RETRIES - 1) {\n            logger.error('Max retries exceeded for quote creation in createQuoteWithRate', {\n              priceId,\n              currencyId: targetCurrencyId,\n              attempts: attempt + 1,\n              idempotencyKey: quotePayload.idempotency_key,\n            });\n            break; // Will throw error after loop\n          }\n\n          // Generate new idempotency key with retry salt\n          const retrySalt = `${idempotencyKeySalt || 'fallback'}:retry:${attempt}:${Date.now()}:${crypto.randomBytes(4).toString('hex')}`;\n          quotePayload.idempotency_key = generateIdempotencyKey({\n            contextId,\n            priceId,\n            currencyId: targetCurrencyId,\n            quantity,\n            baseAmount: totalBaseAmountStr,\n            salt: retrySalt,\n          });\n\n          logger.info('Retrying quote creation with new idempotency key', {\n            priceId,\n            attempt: attempt + 1,\n            newIdempotencyKey: quotePayload.idempotency_key,\n          });\n        } else {\n          // Non-idempotency error, throw immediately\n          throw error;\n        }\n      }\n    }\n\n    // If all retries failed, throw the last error\n    if (!quote) {\n      throw lastError || new Error('Failed to create quote after retries');\n    }\n\n    logger.info('Created new quote with provided rate', {\n      quoteId: quote.id,\n      priceId,\n      currencyId: targetCurrencyId,\n      baseAmount: totalBaseAmountStr,\n      rate: rateResult.rate,\n      quotedAmount: quotedAmount.toString(),\n      expiresAt,\n    });\n\n    return {\n      quote,\n      computed_unit_amount: quotedAmount.toString(),\n      expires_at: expiresAt,\n    };\n  }\n\n  /**\n   * Refresh an existing quote in place using a pre-fetched exchange rate\n   * This is used when quotes expire but we don't want to create a new quote_id\n   */\n  async refreshQuoteWithRate(\n    params: CreateQuoteParams & { rateResult: RateResult; quote_id: string }\n  ): Promise<QuoteResponse> {\n    const {\n      quote_id: quoteId,\n      price_id: priceId,\n      session_id: sessionId,\n      invoice_id: invoiceId,\n      target_currency_id: targetCurrencyId,\n      quantity,\n      rateResult,\n      slippage_percent: slippagePercentInput,\n    } = params;\n\n    const existing = await PriceQuote.findByPk(quoteId);\n    if (!existing) {\n      return this.createQuoteWithRate({\n        price_id: priceId,\n        session_id: sessionId,\n        invoice_id: invoiceId,\n        target_currency_id: targetCurrencyId,\n        quantity,\n        rateResult,\n      });\n    }\n\n    if (existing.status === 'paid' || existing.status === 'used') {\n      return {\n        quote: existing,\n        computed_unit_amount: existing.quoted_amount,\n        expires_at: existing.expires_at,\n      };\n    }\n    if (existing.status === 'failed') {\n      return this.createQuoteWithRate({\n        price_id: priceId,\n        session_id: sessionId,\n        invoice_id: invoiceId,\n        target_currency_id: targetCurrencyId,\n        quantity,\n        rateResult,\n      });\n    }\n\n    // Load price\n    const price = await Price.findByPk(priceId);\n    if (!price) {\n      throw new NonRetryableError('PRICE_NOT_FOUND', `Price ${priceId} not found`);\n    }\n\n    if (price.pricing_type !== 'dynamic') {\n      throw new NonRetryableError('INVALID_PRICE_TYPE', `Price ${priceId} is not a dynamic price`);\n    }\n\n    if (!price.base_currency || !price.base_amount) {\n      throw new NonRetryableError('INVALID_PRICE_CONFIG', `Price ${priceId} missing base_currency or base_amount`);\n    }\n\n    // Load target currency\n    const currency = await PaymentCurrency.findByPk(targetCurrencyId);\n    if (!currency) {\n      throw new NonRetryableError('CURRENCY_NOT_FOUND', `Currency ${targetCurrencyId} not found`);\n    }\n\n    // Calculate total base amount using BN for precision\n    const USD_DECIMALS = 8;\n    const baseAmountBN = fromTokenToUnit(trimDecimals(price.base_amount, USD_DECIMALS), USD_DECIMALS);\n    const quantityBN = new BN(quantity);\n    const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n    const totalBaseAmountStr = fromUnitToToken(totalBaseAmountBN.toString(), USD_DECIMALS);\n\n    // Calculate quoted amount using pure BN arithmetic\n    const rateBN = fromTokenToUnit(trimDecimals(rateResult.rate, USD_DECIMALS), USD_DECIMALS);\n    const numerator = totalBaseAmountBN.mul(new BN(10).pow(new BN(currency.decimal)));\n    const denominator = rateBN;\n    const quotedAmountRaw = numerator.add(denominator).sub(new BN(1)).div(denominator);\n    const quotedAmount = limitTokenPrecision(quotedAmountRaw, currency.decimal, 6);\n\n    // Calculate expiration time\n    const lockDuration = price.dynamic_pricing_config?.lock_duration || 30;\n    const expiresAt = Math.floor(Date.now() / 1000) + lockDuration;\n\n    const slippagePercent = normalizeSlippagePercent(slippagePercentInput);\n\n    await existing.update({\n      base_currency: price.base_currency,\n      base_amount: totalBaseAmountStr,\n      target_currency_id: targetCurrencyId,\n      rate_currency_symbol: currency.symbol,\n      exchange_rate: rateResult.rate,\n      quoted_amount: quotedAmount.toString(),\n      slippage_percent: slippagePercent,\n      rate_provider_id: rateResult.provider_id,\n      rate_provider_name: rateResult.provider_name,\n      rate_timestamp_ms: rateResult.timestamp_ms,\n      expires_at: expiresAt,\n      status: 'active',\n      metadata: {\n        calculation: {\n          total_base_amount_scaled: totalBaseAmountBN.toString(),\n          rate_scaled: rateBN.toString(),\n          quoted_amount_unit: quotedAmount.toString(),\n        },\n        rounding: {\n          mode: 'ceil',\n          token_decimals: currency.decimal,\n        },\n        risk: {\n          anomaly_detected: false,\n          degraded: rateResult.degraded,\n          degraded_reason: rateResult.degraded_reason || null,\n        },\n        rate: {\n          consensus_method: resolveConsensusMethod(rateResult),\n          providers: rateResult.providers || [],\n        },\n        slippage: {\n          percent: slippagePercent,\n        },\n        context: {\n          quantity,\n          base_amount_per_unit: price.base_amount,\n        },\n      },\n    });\n\n    return {\n      quote: existing,\n      computed_unit_amount: existing.quoted_amount,\n      expires_at: existing.expires_at,\n    };\n  }\n\n  /**\n   * Validate and consume a quote (with concurrency control)\n   */\n  async validateAndConsume(quoteId: string, transaction?: any): Promise<PriceQuote> {\n    // Use FOR UPDATE to lock the row\n    const quote = await PriceQuote.findOne({\n      where: { id: quoteId },\n      lock: transaction ? transaction.LOCK.UPDATE : undefined,\n      transaction,\n    });\n\n    if (!quote) {\n      throw new NonRetryableError('QUOTE_NOT_FOUND', `Quote ${quoteId} not found`);\n    }\n\n    if (!quote.isActive()) {\n      throw new NonRetryableError('QUOTE_INVALID', `Quote ${quoteId} is not active or has expired`);\n    }\n\n    // Update status to 'used'\n    await quote.consume(transaction);\n\n    return quote;\n  }\n\n  /**\n   * Mark quote as paid\n   */\n  async markAsPaid(quoteId: string, transaction?: any): Promise<void> {\n    const quote = await PriceQuote.findByPk(quoteId, { transaction });\n    if (!quote) {\n      throw new Error(`Quote ${quoteId} not found`);\n    }\n\n    await quote.markAsPaid(transaction);\n  }\n\n  /**\n   * Mark quote as failed\n   */\n  async markAsFailed(quoteId: string, transaction?: any): Promise<void> {\n    const quote = await PriceQuote.findByPk(quoteId, { transaction });\n    if (!quote) {\n      throw new Error(`Quote ${quoteId} not found`);\n    }\n\n    await quote.markAsFailed(transaction);\n  }\n\n  /**\n   * Clean up expired quotes (for background job)\n   */\n  async expireOldQuotes(): Promise<number> {\n    const count = await PriceQuote.expireOldQuotes();\n    logger.info('Expired old quotes', { count });\n    return count;\n  }\n}\n\n// Singleton instance\nlet serviceInstance: QuoteService | null = null;\n\nexport function getQuoteService(): QuoteService {\n  if (!serviceInstance) {\n    serviceInstance = new QuoteService();\n  }\n  return serviceInstance;\n}\n","numLines":786,"startLine":1,"totalLines":786}}}
{"parentUuid":"b2aa2d44-5f70-4e74-858b-8d16bdff0df8","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JFaURT6YQ6vi8Rz5fvhkcA","type":"tool_result","content":"     1→import { env } from '@blocklet/sdk/lib/config';\n     2→import type { TransactionInput } from '@ocap/client';\n     3→import { BN, fromTokenToUnit, fromUnitToToken } from '@ocap/util';\n     4→import cloneDeep from 'lodash/cloneDeep';\n     5→import isEqual from 'lodash/isEqual';\n     6→import pAll from 'p-all';\n     7→import { omit } from 'lodash';\n     8→import dayjs from './dayjs';\n     9→import { validCoupon } from './discount/coupon';\n    10→import { getPriceUintAmountByCurrency, getPriceCurrencyOptions } from './price';\n    11→\n    12→import {\n    13→  Coupon,\n    14→  Customer,\n    15→  Invoice,\n    16→  PaymentCurrency,\n    17→  PaymentMethod,\n    18→  PriceQuote,\n    19→  SetupIntent,\n    20→  Subscription,\n    21→  SubscriptionItem,\n    22→  TPriceExpanded,\n    23→  type CheckoutSession,\n    24→  type TLineItemExpanded,\n    25→  type TPaymentCurrency,\n    26→  type TPaymentMethodExpanded,\n    27→} from '../store/models';\n    28→import { Price, Price as TPrice } from '../store/models/price';\n    29→import type { Product } from '../store/models/product';\n    30→import type {\n    31→  ChainType,\n    32→  PaymentBeneficiary,\n    33→  PriceRecurring,\n    34→  SubscriptionBillingThresholds,\n    35→} from '../store/models/types';\n    36→import { wallet } from './auth';\n    37→import logger from './logger';\n    38→import { applyDiscountsToLineItems } from './discount/discount';\n    39→import { getQuoteService, QuoteResponse } from './quote-service';\n    40→import { getExchangeRateService } from './exchange-rate';\n    41→import { getExchangeRateSymbol } from './exchange-rate/token-address-mapping';\n    42→import { trimDecimals } from './math-utils';\n    43→\n    44→export function getStatementDescriptor(items: any[]) {\n    45→  for (const item of items) {\n    46→    if (item.price?.product?.statement_descriptor) {\n    47→      return item.price?.product?.statement_descriptor;\n    48→    }\n    49→  }\n    50→\n    51→  return env.appName;\n    52→}\n    53→\n    54→export function getCheckoutMode(items: TLineItemExpanded[] = []) {\n    55→  if (items.length === 0) {\n    56→    return 'setup';\n    57→  }\n    58→\n    59→  // all metered\n    60→  if (items.every((x) => x.price.type === 'recurring' && x.price.recurring?.usage_type === 'metered')) {\n    61→    return 'setup';\n    62→  }\n    63→\n    64→  if (items.some((x) => x.price.type === 'recurring')) {\n    65→    return 'subscription';\n    66→  }\n    67→\n    68→  return 'payment';\n    69→}\n    70→\n    71→// Calculate checkout amount with optional discount processing\n    72→export async function getCheckoutAmount(\n    73→  items: TLineItemExpanded[],\n    74→  currencyId: string,\n    75→  trialing = false,\n    76→  discountConfig?: {\n    77→    promotionCodeId?: string;\n    78→    couponId?: string;\n    79→    customerId?: string;\n    80→  }\n    81→) {\n    82→  let processedItems = items;\n    83→  let renew = new BN(0);\n    84→\n    85→  if (items.find((x) => (x.upsell_price || x.price).custom_unit_amount) && items.length > 1) {\n    86→    throw new Error('Multiple items with custom unit amount are not supported');\n    87→  }\n    88→\n    89→  // Apply discounts if discount configuration is provided\n    90→  if (discountConfig?.couponId && discountConfig?.customerId) {\n    91→    try {\n    92→      const currency = await PaymentCurrency.findByPk(currencyId);\n    93→      if (currency) {\n    94→        const discountResult = await applyDiscountsToLineItems({\n    95→          lineItems: items,\n    96→          promotionCodeId: discountConfig.promotionCodeId,\n    97→          couponId: discountConfig.couponId,\n    98→          customerId: discountConfig.customerId,\n    99→          currency,\n   100→          billingContext: {\n   101→            trialing,\n   102→          },\n   103→        });\n   104→\n   105→        if (discountResult.discountSummary.appliedCoupon) {\n   106→          processedItems = discountResult.enhancedLineItems;\n   107→        }\n   108→      }\n   109→    } catch (error) {\n   110→      // If discount processing fails, continue with original items\n   111→      console.warn('Failed to apply discounts in getCheckoutAmount:', error.message);\n   112→    }\n   113→  }\n   114→\n   115→  // Use async reduce to support quote_id fallback\n   116→  const subtotal = await processedItems\n   117→    .reduce(\n   118→      async (accPromise, x) => {\n   119→        const acc = await accPromise;\n   120→\n   121→        // Priority 1: Use custom_amount if available\n   122→        if (x.custom_amount) {\n   123→          return acc.add(new BN(x.custom_amount));\n   124→        }\n   125→\n   126→        // Priority 2: If has quote_id but no custom_amount, fetch from Quote table\n   127→        if ((x as any).quote_id) {\n   128→          try {\n   129→            const quote = await PriceQuote.findByPk((x as any).quote_id);\n   130→            if (quote) {\n   131→              logger.info('Using quoted_amount from quote_id for checkout amount calculation', {\n   132→                priceId: x.price.id,\n   133→                quoteId: (x as any).quote_id,\n   134→                quotedAmount: quote.quoted_amount,\n   135→              });\n   136→              return acc.add(new BN(quote.quoted_amount));\n   137→            }\n   138→\n   139→            // Quote not found - log warning and fall through to price calculation\n   140→            logger.warn('Quote not found for quote_id in line_item', {\n   141→              priceId: x.price.id,\n   142→              quoteId: (x as any).quote_id,\n   143→            });\n   144→          } catch (error) {\n   145→            logger.error('Failed to fetch quote for quote_id', {\n   146→              priceId: x.price.id,\n   147→              quoteId: (x as any).quote_id,\n   148→              error: (error as Error).message,\n   149→            });\n   150→          }\n   151→        }\n   152→\n   153→        // Priority 3: Calculate from price (fixed pricing or quote query failed)\n   154→        const price = x.upsell_price || x.price;\n   155→        const unitPrice = getPriceUintAmountByCurrency(price, currencyId);\n   156→        if (price.custom_unit_amount) {\n   157→          if (unitPrice) {\n   158→            return acc.add(new BN(unitPrice).mul(new BN(x.quantity)));\n   159→          }\n   160→        }\n   161→\n   162→        if (price?.type === 'recurring') {\n   163→          renew = renew.add(new BN(unitPrice).mul(new BN(x.quantity)));\n   164→\n   165→          if (trialing) {\n   166→            return acc;\n   167→          }\n   168→          if (price?.recurring?.usage_type === 'metered') {\n   169→            return acc;\n   170→          }\n   171→        }\n   172→\n   173→        return acc.add(new BN(unitPrice).mul(new BN(x.quantity)));\n   174→      },\n   175→      Promise.resolve(new BN(0))\n   176→    )\n   177→    .then((bn) => bn.toString());\n   178→\n   179→  // Calculate total discount amount from processed line items\n   180→  let totalDiscountAmount = new BN(0);\n   181→  processedItems.forEach((item) => {\n   182→    if ((item as any).discount_amounts?.length > 0) {\n   183→      (item as any).discount_amounts.forEach((discountAmount: any) => {\n   184→        totalDiscountAmount = totalDiscountAmount.add(new BN(discountAmount.amount || '0'));\n   185→      });\n   186→    }\n   187→  });\n   188→\n   189→  // Ensure discount doesn't exceed subtotal\n   190→  const adjustedDiscount = totalDiscountAmount.gt(new BN(subtotal)) ? new BN(subtotal) : totalDiscountAmount;\n   191→\n   192→  const finalTotal = new BN(subtotal).sub(adjustedDiscount);\n   193→  const adjustedTotal = finalTotal.lt(new BN('0')) ? '0' : finalTotal.toString();\n   194→\n   195→  return {\n   196→    subtotal: subtotal || '0',\n   197→    total: adjustedTotal,\n   198→    renew: renew.toString() || '0',\n   199→    discount: adjustedDiscount.toString(),\n   200→    shipping: '0',\n   201→    tax: '0',\n   202→    processedItems, // Return processed items with discount information\n   203→  };\n   204→}\n   205→\n   206→export function getRecurringPeriod(recurring: PriceRecurring) {\n   207→  const { interval } = recurring || {};\n   208→  if (!interval) {\n   209→    return 0;\n   210→  }\n   211→  const count = +recurring.interval_count || 1;\n   212→  const dayInMs = 24 * 60 * 60 * 1000;\n   213→\n   214→  switch (interval) {\n   215→    case 'hour':\n   216→      return 60 * 60 * 1000;\n   217→    case 'day':\n   218→      return count * dayInMs;\n   219→    case 'week':\n   220→      return count * 7 * dayInMs;\n   221→    case 'month':\n   222→      return count * 30 * dayInMs;\n   223→    case 'year':\n   224→      return count * 365 * dayInMs;\n   225→    default:\n   226→      return 0;\n   227→  }\n   228→}\n   229→\n   230→export function expandLineItems(\n   231→  items: any[],\n   232→  products: Product[],\n   233→  prices: Price[],\n   234→  creditCurrencies?: TPaymentCurrency[]\n   235→) {\n   236→  items.forEach((item) => {\n   237→    item.price = prices.find((x) => x.id === item.price_id);\n   238→    if (item.price) {\n   239→      item.price.product = products.find((x) => x.id === item.price.product_id);\n   240→      if (item.price.product?.type === 'credit' && item.price.metadata?.credit_config) {\n   241→        item.price.credit = {\n   242→          amount: Number(item.price.metadata.credit_config.credit_amount || 0) * Number(item.quantity),\n   243→          currency_id: item.price.metadata.credit_config.currency_id,\n   244→          currency: creditCurrencies?.find((x) => x.id === item.price.metadata.credit_config.currency_id),\n   245→        };\n   246→      }\n   247→    }\n   248→  });\n   249→\n   250→  return items;\n   251→}\n   252→\n   253→export function filterCurrencies(method: TPaymentMethodExpanded, hasSelected: (currency: TPaymentCurrency) => boolean) {\n   254→  method.payment_currencies = method.payment_currencies.filter((x) => hasSelected(x));\n   255→  return method;\n   256→}\n   257→\n   258→export function getSupportedPaymentMethods(\n   259→  methods: TPaymentMethodExpanded[],\n   260→  hasSelected: (currency: TPaymentCurrency) => boolean\n   261→) {\n   262→  const filtered = cloneDeep(methods).map((x) => filterCurrencies(x, hasSelected));\n   263→  return filtered.filter((x) => x.payment_currencies.length);\n   264→}\n   265→\n   266→export function getSupportedPaymentCurrencies(items: TLineItemExpanded[]) {\n   267→  const currencies = items.reduce((acc: string[], x: any) => {\n   268→    return acc.concat(getPriceCurrencyOptions(x.price).map((c: any) => c.currency_id));\n   269→  }, []);\n   270→  return Array.from(new Set(currencies));\n   271→}\n   272→\n   273→export function isLineItemCurrencyAligned(list: TLineItemExpanded[], index: number) {\n   274→  const prices = list.map((x) => x.upsell_price || x.price);\n   275→\n   276→  const current = getPriceCurrencyOptions(prices[index] as any)\n   277→    .map((x) => x.currency_id)\n   278→    .sort();\n   279→\n   280→  for (let i = 0; i < index; i++) {\n   281→    const previous = getPriceCurrencyOptions(prices[i] as any)\n   282→      .map((x) => x.currency_id)\n   283→      .sort();\n   284→    if (isEqual(current, previous) === false) {\n   285→      return false;\n   286→    }\n   287→  }\n   288→\n   289→  return true;\n   290→}\n   291→\n   292→export function isLineItemRecurringAligned(list: TLineItemExpanded[], index: number) {\n   293→  const prices = list.map((x) => x.upsell_price || x.price);\n   294→\n   295→  if (prices[index]?.type !== 'recurring') {\n   296→    return true;\n   297→  }\n   298→\n   299→  const recurring = prices.slice(0, index).find((x) => x?.type === 'recurring')?.recurring;\n   300→  if (!recurring) {\n   301→    return true;\n   302→  }\n   303→\n   304→  return prices.slice(0, index + 1).every((x: any) => {\n   305→    if (x.type !== 'recurring') {\n   306→      return true;\n   307→    }\n   308→\n   309→    // If the interval and interval_count are different, the recurring is not aligned\n   310→    if (\n   311→      String(recurring?.interval) !== String(x.recurring?.interval) ||\n   312→      Number(recurring?.interval_count) !== Number(x.recurring?.interval_count)\n   313→    ) {\n   314→      return false;\n   315→    }\n   316→\n   317→    return true;\n   318→  });\n   319→}\n   320→\n   321→export function isLineItemAligned(list: TLineItemExpanded[], index: number) {\n   322→  const currency = isLineItemCurrencyAligned(list, index);\n   323→  const recurring = isLineItemRecurringAligned(list, index);\n   324→  return {\n   325→    currency,\n   326→    recurring,\n   327→    aligned: currency && recurring,\n   328→  };\n   329→}\n   330→\n   331→// FIXME: upsell validate https://stripe.com/docs/payments/checkout/upsells\n   332→export function canUpsell(from: TPrice, to: TPrice) {\n   333→  if (from.id === to.id) {\n   334→    return false;\n   335→  }\n   336→  if (from.product_id !== to.product_id) {\n   337→    return false;\n   338→  }\n   339→  if (to.active === false) {\n   340→    return false;\n   341→  }\n   342→  if (to.type !== 'recurring') {\n   343→    return false;\n   344→  }\n   345→\n   346→  // longer periods\n   347→  const fromPeriod = getRecurringPeriod(from.recurring as PriceRecurring);\n   348→  const toPeriod = getRecurringPeriod(to.recurring as PriceRecurring);\n   349→  if (!fromPeriod || !toPeriod) {\n   350→    return false;\n   351→  }\n   352→  if (fromPeriod >= toPeriod) {\n   353→    return false;\n   354→  }\n   355→\n   356→  // and lower prices\n   357→  const fromPrice = new BN(from.unit_amount).div(new BN(fromPeriod));\n   358→  const toPrice = new BN(to.unit_amount).div(new BN(toPeriod));\n   359→  if (fromPrice.lt(toPrice)) {\n   360→    return false;\n   361→  }\n   362→\n   363→  return true;\n   364→}\n   365→\n   366→export async function getFastCheckoutAmount({\n   367→  items,\n   368→  mode,\n   369→  currencyId,\n   370→  trialing = false,\n   371→  minimumCycle = 1,\n   372→  discountConfig,\n   373→}: {\n   374→  items: TLineItemExpanded[];\n   375→  mode: string;\n   376→  currencyId: string;\n   377→  trialing?: boolean;\n   378→  minimumCycle?: number;\n   379→  discountConfig?: {\n   380→    promotionCodeId?: string;\n   381→    couponId?: string;\n   382→    customerId?: string;\n   383→  };\n   384→}) {\n   385→  if (!minimumCycle || minimumCycle < 1) {\n   386→    // eslint-disable-next-line no-param-reassign\n   387→    minimumCycle = 1;\n   388→  }\n   389→\n   390→  const { total, renew } = await getCheckoutAmount(items, currencyId, trialing, discountConfig);\n   391→\n   392→  if (mode === 'payment' || mode === 'auto-recharge-auth') {\n   393→    return total;\n   394→  }\n   395→\n   396→  if (mode === 'setup') {\n   397→    return new BN(renew).mul(new BN(minimumCycle)).toString();\n   398→  }\n   399→\n   400→  if (mode === 'subscription') {\n   401→    return new BN(total).add(new BN(renew).mul(new BN(trialing ? minimumCycle : minimumCycle - 1))).toString();\n   402→  }\n   403→\n   404→  return '0';\n   405→}\n   406→\n   407→export function getBillingThreshold(config: Record<string, any> = {}) {\n   408→  if (config?.billing_threshold_amount) {\n   409→    const threshold = +(config.billing_threshold_amount as string);\n   410→    if (threshold > 0) {\n   411→      return threshold;\n   412→    }\n   413→  }\n   414→\n   415→  const threshold = +(process.env.PAYMENT_BILLING_THRESHOLD as string);\n   416→  if (threshold > 0) {\n   417→    return threshold;\n   418→  }\n   419→\n   420→  return 0;\n   421→}\n   422→\n   423→export function getMinStakeAmount(config: Record<string, any> = {}) {\n   424→  if (config?.min_stake_amount) {\n   425→    const threshold = +(config.min_stake_amount as string);\n   426→    if (threshold > 0) {\n   427→      return threshold;\n   428→    }\n   429→  }\n   430→\n   431→  const threshold = +(process.env.PAYMENT_MIN_STAKE_AMOUNT as string);\n   432→  if (threshold > 0) {\n   433→    return threshold;\n   434→  }\n   435→\n   436→  return 0;\n   437→}\n   438→\n   439→export function canPayWithDelegation(beneficiaries: PaymentBeneficiary[]) {\n   440→  return beneficiaries.length === 0 || beneficiaries.every((x) => x.address === wallet.address);\n   441→}\n   442→\n   443→export function createPaymentBeneficiaries(total: string, beneficiaries: PaymentBeneficiary[]) {\n   444→  if (beneficiaries.length) {\n   445→    const shares = beneficiaries.reduce((acc, x) => acc + parseInt(x.share, 10), 0);\n   446→    const result: PaymentBeneficiary[] = [];\n   447→    beneficiaries.forEach((x, i) => {\n   448→      let share = new BN(total).div(new BN(shares)).mul(new BN(x.share)).toString();\n   449→      if (i === beneficiaries.length - 1) {\n   450→        share = result.reduce((acc, d) => acc.sub(new BN(d.share)), new BN(total)).toString();\n   451→      }\n   452→\n   453→      result.push({ ...x, share });\n   454→    });\n   455→\n   456→    return result;\n   457→  }\n   458→\n   459→  return [];\n   460→}\n   461→\n   462→export function createPaymentOutput(\n   463→  total: string,\n   464→  contract: string,\n   465→  beneficiaries: PaymentBeneficiary[]\n   466→): TransactionInput[] {\n   467→  if (beneficiaries.length) {\n   468→    return beneficiaries.map((x) => ({\n   469→      owner: x.address,\n   470→      assets: [],\n   471→      tokens: [\n   472→        {\n   473→          address: contract,\n   474→          value: x.share,\n   475→        },\n   476→      ],\n   477→    }));\n   478→  }\n   479→\n   480→  return [\n   481→    {\n   482→      owner: wallet.address,\n   483→      assets: [],\n   484→      tokens: [\n   485→        {\n   486→          address: contract,\n   487→          value: total,\n   488→        },\n   489→      ],\n   490→    },\n   491→  ];\n   492→}\n   493→\n   494→export function isDonationCheckoutSession(checkoutSession: CheckoutSession): boolean {\n   495→  return (\n   496→    checkoutSession.submit_type === 'donate' ||\n   497→    checkoutSession.metadata?.type === 'donation' ||\n   498→    !!checkoutSession.metadata?.is_donation\n   499→  );\n   500→}\n   501→\n   502→/**\n   503→ * Format subscription product name based on line items\n   504→ */\n   505→export function formatSubscriptionProduct(items: TLineItemExpanded[], maxLength = 3) {\n   506→  const names = items.map((x) => x.price?.product?.name || '').filter(Boolean);\n   507→  return names.length > maxLength ? `${names.slice(0, maxLength).join(', ')} ...` : names.join(', ');\n   508→}\n   509→\n   510→/**\n   511→ * Setup subscription creation parameters\n   512→ */\n   513→export function getSubscriptionCreateSetup(\n   514→  items: TLineItemExpanded[],\n   515→  currencyId: string,\n   516→  trialInDays = 0,\n   517→  trialEnd = 0\n   518→) {\n   519→  let setup = new BN(0);\n   520→  let hasDynamicPricing = false;\n   521→\n   522→  items.forEach((x) => {\n   523→    const price = x.upsell_price || x.price;\n   524→    const unit = getPriceUintAmountByCurrency(price, currencyId);\n   525→    const amount = new BN(unit).mul(new BN(x.quantity));\n   526→\n   527→    // Check if this price uses dynamic pricing\n   528→    if (price.pricing_type === 'dynamic') {\n   529→      hasDynamicPricing = true;\n   530→    }\n   531→\n   532→    if (price.type === 'recurring') {\n   533→      if (price.recurring?.usage_type === 'licensed') {\n   534→        setup = setup.add(amount);\n   535→      }\n   536→    }\n   537→    if (price.type === 'one_time') {\n   538→      setup = setup.add(amount);\n   539→    }\n   540→  });\n   541→\n   542→  // Apply slippage protection for subscriptions with dynamic pricing\n   543→  // Authorization amount = base * (1 + 0.005) to protect against rate fluctuations\n   544→  // This ensures future auto-renewal payments won't fail due to small rate changes\n   545→  if (hasDynamicPricing && setup.gt(new BN(0))) {\n   546→    const SLIPPAGE_MULTIPLIER = new BN(1005); // 1 + 0.005 = 1.005 represented as 1005/1000\n   547→    const SLIPPAGE_DIVISOR = new BN(1000);\n   548→    setup = setup.mul(SLIPPAGE_MULTIPLIER).div(SLIPPAGE_DIVISOR);\n   549→    logger.info('Applied subscription authorization slippage protection', {\n   550→      hasDynamicPricing,\n   551→      authorizationAmount: setup.toString(),\n   552→      slippageRate: '0.5%',\n   553→    });\n   554→  }\n   555→\n   556→  const now = dayjs().unix();\n   557→  const item = items.find((x) => (x.upsell_price || x.price).type === 'recurring');\n   558→  const recurring = (item?.upsell_price || item?.price)?.recurring as PriceRecurring;\n   559→  const cycle = getRecurringPeriod(recurring);\n   560→\n   561→  let trialStartAt = 0;\n   562→  let trialEndAt = 0;\n   563→  if (+trialEnd && trialEnd > now) {\n   564→    trialStartAt = now;\n   565→    trialEndAt = trialEnd;\n   566→  } else if (trialInDays) {\n   567→    trialStartAt = now;\n   568→    trialEndAt = dayjs().add(trialInDays, 'day').unix();\n   569→  }\n   570→\n   571→  const periodStart = trialStartAt || now;\n   572→  const periodEnd = trialEndAt || dayjs().add(cycle, 'millisecond').unix();\n   573→\n   574→  return {\n   575→    recurring,\n   576→    cycle: {\n   577→      duration: cycle,\n   578→      anchor: periodEnd,\n   579→    },\n   580→    trial: {\n   581→      start: trialStartAt,\n   582→      end: trialEndAt,\n   583→    },\n   584→    period: {\n   585→      start: periodStart,\n   586→      end: periodEnd,\n   587→    },\n   588→    amount: {\n   589→      setup: setup.toString(),\n   590→    },\n   591→  };\n   592→}\n   593→\n   594→/**\n   595→ * Creates subscription groupings based on checkout session configuration\n   596→ * @param {Object} params - Parameters for subscription creation\n   597→ * @returns {Object} Created subscription information\n   598→ */\n   599→export async function createGroupSubscriptions({\n   600→  checkoutSession,\n   601→  lineItems,\n   602→  customer,\n   603→  paymentSettings,\n   604→  setupIntent,\n   605→  trialConfig = {},\n   606→}: {\n   607→  checkoutSession: CheckoutSession;\n   608→  lineItems: TLineItemExpanded[];\n   609→  customer: Customer;\n   610→  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n   611→  setupIntent: SetupIntent | null;\n   612→  trialConfig?: { trialInDays?: number; trialEnd?: number };\n   613→}) {\n   614→  const enableGrouping = checkoutSession.enable_subscription_grouping;\n   615→\n   616→  // Filter recurring items only\n   617→  const recurringItems = getRecurringLineItems(lineItems);\n   618→  if (recurringItems.length === 0) {\n   619→    logger.info('No recurring items found for subscription', {\n   620→      session: checkoutSession.id,\n   621→    });\n   622→    return { subscriptions: [], subscriptionGroups: {}, primarySubscription: null };\n   623→  }\n   624→\n   625→  try {\n   626→    // Process based on grouping mode\n   627→    if (!enableGrouping) {\n   628→      // Single subscription mode\n   629→      const result = await createSingleSubscription({\n   630→        checkoutSession,\n   631→        lineItems: recurringItems,\n   632→        customer,\n   633→        paymentSettings,\n   634→        setupIntent,\n   635→        trialConfig,\n   636→      });\n   637→      return result;\n   638→    }\n   639→    // Multiple subscriptions mode\n   640→    const result = await createMultipleSubscriptions({\n   641→      checkoutSession,\n   642→      lineItems,\n   643→      customer,\n   644→      paymentSettings,\n   645→      setupIntent,\n   646→      trialConfig,\n   647→    });\n   648→    return result;\n   649→  } catch (error) {\n   650→    logger.error('Failed to create subscriptions', {\n   651→      error: error.message,\n   652→      session: checkoutSession.id,\n   653→      stack: error.stack,\n   654→    });\n   655→    throw error;\n   656→  }\n   657→}\n   658→\n   659→/**\n   660→ * Creates a single subscription for all items\n   661→ */\n   662→async function createSingleSubscription(params: {\n   663→  checkoutSession: CheckoutSession;\n   664→  lineItems: TLineItemExpanded[];\n   665→  customer: Customer;\n   666→  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n   667→  setupIntent: SetupIntent | null;\n   668→  trialConfig?: { trialInDays?: number; trialEnd?: number };\n   669→}) {\n   670→  const { checkoutSession, lineItems, customer, paymentSettings, setupIntent, trialConfig } = params;\n   671→  const existingSubscriptionId = checkoutSession.subscription_id;\n   672→\n   673→  const subscription = await createOrUpdateSubscription({\n   674→    existingSubscriptionId,\n   675→    checkoutSession,\n   676→    lineItems,\n   677→    customer,\n   678→    paymentSettings,\n   679→    setupIntent,\n   680→    trialConfig,\n   681→  });\n   682→\n   683→  logger.info('Single subscription processed', {\n   684→    session: checkoutSession.id,\n   685→    subscription: subscription?.id,\n   686→    isNew: !existingSubscriptionId,\n   687→  });\n   688→\n   689→  return {\n   690→    subscriptions: subscription ? [subscription] : [],\n   691→    subscriptionGroups: {},\n   692→    primarySubscription: subscription,\n   693→  };\n   694→}\n   695→\n   696→/**\n   697→ * Creates multiple subscriptions grouped by price ID\n   698→ */\n   699→async function createMultipleSubscriptions(params: {\n   700→  checkoutSession: CheckoutSession;\n   701→  lineItems: TLineItemExpanded[];\n   702→  customer: Customer;\n   703→  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n   704→  setupIntent: SetupIntent | null;\n   705→  trialConfig?: { trialInDays?: number; trialEnd?: number };\n   706→}) {\n   707→  const { checkoutSession, lineItems, customer, paymentSettings, setupIntent, trialConfig } = params;\n   708→\n   709→  // Group items by price ID\n   710→  const priceGroups = groupLineItemsByPrice(lineItems);\n   711→  const existingGroups = checkoutSession.subscription_groups || {};\n   712→\n   713→  const subscriptions: any[] = [];\n   714→  const subscriptionGroups: Record<string, string> = {};\n   715→  let primarySubscription: any = null;\n   716→\n   717→  const noStake = !!checkoutSession.subscription_data?.no_stake;\n   718→  const billingThreshold = getBillingThreshold(checkoutSession.subscription_data);\n   719→  const minStakeAmount = getMinStakeAmount(checkoutSession.subscription_data);\n   720→\n   721→  // Create a task for each price group\n   722→  const tasks = Object.entries(priceGroups).map(([priceId, items], index) => async () => {\n   723→    try {\n   724→      const existingSubscriptionId = existingGroups[priceId];\n   725→      const isPrimary = index === 0;\n   726→      const subscriptionMetadata = {\n   727→        price_id: priceId,\n   728→        checkout_session_id: checkoutSession.id,\n   729→        ...(isPrimary ? { is_primary_subscription: true } : {}),\n   730→      };\n   731→\n   732→      const subscriptionItems = items;\n   733→\n   734→      // Set different stake configurations for different subscriptions\n   735→      let billingThresholds = {};\n   736→      if (isPrimary) {\n   737→        billingThresholds = {\n   738→          amount_gte: billingThreshold,\n   739→          stake_gte: minStakeAmount,\n   740→          reset_billing_cycle_anchor: false,\n   741→          no_stake: noStake,\n   742→        };\n   743→      } else {\n   744→        // if not primary subscription, set stake to 0\n   745→        billingThresholds = {\n   746→          amount_gte: 0,\n   747→          stake_gte: 0,\n   748→          reset_billing_cycle_anchor: false,\n   749→          no_stake: true,\n   750→          references_primary_stake: true,\n   751→        };\n   752→      }\n   753→\n   754→      const subscription = await createOrUpdateSubscription({\n   755→        existingSubscriptionId,\n   756→        checkoutSession,\n   757→        lineItems: subscriptionItems,\n   758→        customer,\n   759→        paymentSettings,\n   760→        setupIntent,\n   761→        trialConfig,\n   762→        metadata: subscriptionMetadata,\n   763→        billing_thresholds: billingThresholds as SubscriptionBillingThresholds,\n   764→      });\n   765→\n   766→      if (!subscription) {\n   767→        return { success: false, priceId, error: 'Failed to create subscription' };\n   768→      }\n   769→\n   770→      return { success: true, priceId, subscription, isPrimary };\n   771→    } catch (error) {\n   772→      logger.error('Failed to create subscription for price group', {\n   773→        priceId,\n   774→        error: error.message,\n   775→        session: checkoutSession.id,\n   776→        stack: error.stack,\n   777→      });\n   778→      return { success: false, priceId, error: error.message };\n   779→    }\n   780→  });\n   781→\n   782→  const results = await pAll(tasks, { concurrency: 5 });\n   783→\n   784→  results.forEach((result) => {\n   785→    if (result.success && result.subscription) {\n   786→      subscriptionGroups[result.priceId] = result.subscription.id;\n   787→      subscriptions.push(result.subscription);\n   788→      if (result.isPrimary) {\n   789→        primarySubscription = result.subscription;\n   790→      }\n   791→    }\n   792→  });\n   793→\n   794→  return {\n   795→    subscriptions,\n   796→    subscriptionGroups,\n   797→    primarySubscription,\n   798→  };\n   799→}\n   800→\n   801→/**\n   802→ * Core logic for creating or updating a single subscription\n   803→ */\n   804→async function createOrUpdateSubscription(params: {\n   805→  existingSubscriptionId?: string | null;\n   806→  checkoutSession: CheckoutSession;\n   807→  lineItems: TLineItemExpanded[];\n   808→  customer: Customer;\n   809→  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n   810→  setupIntent: SetupIntent | null;\n   811→  trialConfig?: { trialInDays?: number; trialEnd?: number };\n   812→  metadata?: Record<string, any>;\n   813→  billing_thresholds?: SubscriptionBillingThresholds;\n   814→}): Promise<any> {\n   815→  const {\n   816→    existingSubscriptionId,\n   817→    checkoutSession,\n   818→    lineItems,\n   819→    customer,\n   820→    paymentSettings,\n   821→    setupIntent,\n   822→    trialConfig = {},\n   823→    metadata = {},\n   824→    billing_thresholds: billingThresholds,\n   825→  } = params;\n   826→\n   827→  const { trialInDays = 0, trialEnd = 0 } = trialConfig;\n   828→  const { method: paymentMethod, currency: paymentCurrency } = paymentSettings;\n   829→\n   830→  try {\n   831→    const itemsSubscriptionData = mergeSubscriptionDataFromLineItems(lineItems);\n   832→    let subscription = null;\n   833→    const setup = getSubscriptionCreateSetup(lineItems, paymentCurrency.id, trialInDays, trialEnd);\n   834→\n   835→    if (existingSubscriptionId) {\n   836→      subscription = await Subscription.findByPk(existingSubscriptionId);\n   837→    }\n   838→\n   839→    if (subscription) {\n   840→      // Validate subscription status\n   841→      if (subscription.status !== 'incomplete') {\n   842→        throw new Error(`Subscription ${subscription.id} status not incomplete: ${subscription.status}`);\n   843→      }\n   844→\n   845→      const billingCycleAnchor =\n   846→        itemsSubscriptionData?.billing_cycle_anchor ||\n   847→        checkoutSession.subscription_data?.billing_cycle_anchor ||\n   848→        setup.cycle.anchor;\n   849→\n   850→      // Update existing subscription\n   851→      subscription = await subscription.update({\n   852→        currency_id: paymentCurrency.id,\n   853→        customer_id: customer.id,\n   854→        default_payment_method_id: paymentMethod.id,\n   855→        current_period_start: setup.period.start,\n   856→        current_period_end: setup.period.end,\n   857→        billing_cycle_anchor: billingCycleAnchor,\n   858→        trial_end: setup.trial.end,\n   859→        trial_start: setup.trial.start,\n   860→        pending_invoice_item_interval: setup.recurring,\n   861→        pending_setup_intent: setupIntent?.id,\n   862→      });\n   863→\n   864→      logger.info('Subscription updated', {\n   865→        session: checkoutSession.id,\n   866→        subscription: subscription.id,\n   867→      });\n   868→\n   869→      // Rebuild subscription items\n   870→      await SubscriptionItem.destroy({ where: { subscription_id: subscription.id } });\n   871→      await createSubscriptionItems(subscription.id, lineItems, checkoutSession, itemsSubscriptionData);\n   872→\n   873→      // Update invoice customer if needed\n   874→      const invoice = await Invoice.findByPk(subscription.latest_invoice_id);\n   875→      if (invoice && invoice.customer_id !== customer.id) {\n   876→        await invoice.update({ customer_id: customer.id });\n   877→      }\n   878→    } else {\n   879→      // Create new subscription\n   880→      const recoveredFromId =\n   881→        itemsSubscriptionData.recovered_from || checkoutSession.subscription_data?.recovered_from || '';\n   882→      const recoveredFrom = recoveredFromId ? await Subscription.findByPk(recoveredFromId) : null;\n   883→\n   884→      const safeMetadata = {\n   885→        ...(checkoutSession.subscription_data?.notification_settings\n   886→          ? {\n   887→              notification_settings: checkoutSession.subscription_data.notification_settings,\n   888→            }\n   889→          : {}),\n   890→        ...omit(checkoutSession.metadata || {}, ['days_until_due', 'days_until_cancel', 'page_info']),\n   891→        ...(itemsSubscriptionData.metadata || {}),\n   892→        ...metadata,\n   893→      };\n   894→\n   895→      const subscriptionData = {\n   896→        ...checkoutSession.subscription_data,\n   897→        ...itemsSubscriptionData,\n   898→      };\n   899→\n   900→      const subscriptionBillingThresholds = billingThresholds || {\n   901→        amount_gte: getBillingThreshold(subscriptionData),\n   902→        stake_gte: getMinStakeAmount(subscriptionData),\n   903→        reset_billing_cycle_anchor: false,\n   904→        no_stake: subscriptionData.no_stake,\n   905→      };\n   906→\n   907→      subscription = await Subscription.create({\n   908→        livemode: !!checkoutSession.livemode,\n   909→        currency_id: paymentCurrency.id,\n   910→        customer_id: customer.id,\n   911→        status: 'incomplete',\n   912→        current_period_start: setup.period.start,\n   913→        current_period_end: setup.period.end,\n   914→        // FIXME: billing_cycle_anchor implementation is not aligned with stripe\n   915→        billing_cycle_anchor: subscriptionData.billing_cycle_anchor || setup.cycle.anchor,\n   916→        start_date: dayjs().unix(),\n   917→        trial_end: setup.trial.end,\n   918→        trial_start: setup.trial.start,\n   919→        trial_settings: {\n   920→          end_behavior: {\n   921→            missing_payment_method: 'create_invoice',\n   922→          },\n   923→        },\n   924→        billing_thresholds: subscriptionBillingThresholds,\n   925→        pending_invoice_item_interval: setup.recurring,\n   926→        pending_setup_intent: setupIntent?.id,\n   927→        default_payment_method_id: paymentMethod.id,\n   928→        cancel_at_period_end: false,\n   929→        collection_method: 'charge_automatically',\n   930→        description: subscriptionData.description || formatSubscriptionProduct(lineItems),\n   931→        proration_behavior: subscriptionData.proration_behavior || 'none',\n   932→        payment_behavior: 'default_incomplete',\n   933→        days_until_due: subscriptionData.days_until_due,\n   934→        days_until_cancel: subscriptionData.days_until_cancel,\n   935→        recovered_from: recoveredFrom?.id,\n   936→        metadata: safeMetadata,\n   937→        service_actions: subscriptionData.service_actions || [],\n   938→      });\n   939→\n   940→      logger.info('Subscription created', {\n   941→        session: checkoutSession.id,\n   942→        subscription: subscription.id,\n   943→      });\n   944→\n   945→      // Create subscription items with item-specific metadata\n   946→      await createSubscriptionItems(subscription.id, lineItems, checkoutSession, itemsSubscriptionData);\n   947→    }\n   948→\n   949→    return subscription;\n   950→  } catch (error) {\n   951→    logger.error('Failed in createOrUpdateSubscription', {\n   952→      existingSubscriptionId,\n   953→      error: error.message,\n   954→      stack: error.stack,\n   955→      session: checkoutSession.id,\n   956→    });\n   957→    throw error;\n   958→  }\n   959→}\n   960→\n   961→/**\n   962→ * Creates subscription items for a subscription\n   963→ */\n   964→async function createSubscriptionItems(\n   965→  subscriptionId: string,\n   966→  lineItems: TLineItemExpanded[],\n   967→  checkoutSession: CheckoutSession,\n   968→  itemsSubscriptionData: Record<string, any>\n   969→) {\n   970→  try {\n   971→    const metadata = {\n   972→      ...(itemsSubscriptionData?.metadata || {}),\n   973→      ...(checkoutSession.metadata || {}),\n   974→    };\n   975→\n   976→    const subItems = await Promise.all(\n   977→      lineItems.map((item) =>\n   978→        SubscriptionItem.create({\n   979→          livemode: !!checkoutSession.livemode,\n   980→          subscription_id: subscriptionId,\n   981→          price_id: item.upsell_price_id || item.price_id,\n   982→          quantity: item.quantity,\n   983→          metadata,\n   984→        })\n   985→      )\n   986→    );\n   987→\n   988→    logger.info('Subscription items created', {\n   989→      session: checkoutSession.id,\n   990→      subscription: subscriptionId,\n   991→      items: subItems.map((x) => x.id),\n   992→    });\n   993→\n   994→    return subItems;\n   995→  } catch (error) {\n   996→    logger.error('Failed to create subscription items', {\n   997→      subscriptionId,\n   998→      error: error.message,\n   999→      stack: error.stack,\n  1000→      session: checkoutSession.id,\n  1001→    });\n  1002→    throw error;\n  1003→  }\n  1004→}\n  1005→\n  1006→/**\n  1007→ * Groups line items by price ID\n  1008→ */\n  1009→function groupLineItemsByPrice(lineItems: TLineItemExpanded[]): Record<string, TLineItemExpanded[]> {\n  1010→  const groups: Record<string, TLineItemExpanded[]> = {};\n  1011→  const recurringLineItems = getRecurringLineItems(lineItems);\n  1012→\n  1013→  recurringLineItems.forEach((item) => {\n  1014→    const priceId = item.upsell_price_id || item.price_id;\n  1015→    if (!groups[priceId]) {\n  1016→      groups[priceId] = [];\n  1017→    }\n  1018→    groups[priceId].push(item);\n  1019→  });\n  1020→\n  1021→  return groups;\n  1022→}\n  1023→\n  1024→export function getCheckoutSessionSubscriptionIds(checkoutSession: CheckoutSession) {\n  1025→  const enableGrouping = checkoutSession.enable_subscription_grouping;\n  1026→  if (!enableGrouping && checkoutSession.subscription_id) {\n  1027→    return [checkoutSession.subscription_id];\n  1028→  }\n  1029→  return Object.values(checkoutSession.subscription_groups || {}).filter(Boolean);\n  1030→}\n  1031→\n  1032→export function getOneTimeLineItems(lineItems: TLineItemExpanded[]) {\n  1033→  return lineItems.filter((item) => item.price?.type === 'one_time');\n  1034→}\n  1035→\n  1036→export function getRecurringLineItems(lineItems: TLineItemExpanded[]) {\n  1037→  return lineItems.filter((item) => item.price?.type === 'recurring');\n  1038→}\n  1039→\n  1040→export function mergeSubscriptionDataFromLineItems(lineItems: TLineItemExpanded[]): Record<string, any> {\n  1041→  if (lineItems.length === 0) {\n  1042→    return {};\n  1043→  }\n  1044→  const mergedData: Record<string, any> = {};\n  1045→  const mergedMetadata: Record<string, any> = {};\n  1046→  lineItems.forEach((item: TLineItemExpanded) => {\n  1047→    const subData = (item.subscription_data || {}) as any;\n  1048→    if (subData.metadata) {\n  1049→      Object.assign(mergedMetadata, subData.metadata);\n  1050→    }\n  1051→    Object.entries(subData).forEach(([key, value]) => {\n  1052→      if (key !== 'metadata') {\n  1053→        mergedData[key] = value;\n  1054→      }\n  1055→    });\n  1056→  });\n  1057→\n  1058→  if (Object.keys(mergedMetadata).length > 0) {\n  1059→    mergedData.metadata = mergedMetadata;\n  1060→  }\n  1061→\n  1062→  return mergedData;\n  1063→}\n  1064→\n  1065→/**\n  1066→ * Get line items related to a specific subscription\n  1067→ * @param subscription The subscription object\n  1068→ * @param lineItems All line items from checkout session\n  1069→ * @param primarySubscription Optional primary subscription to check one-time items\n  1070→ * @returns Line items associated with the subscription\n  1071→ */\n  1072→export async function getSubscriptionLineItems(\n  1073→  subscription: Subscription,\n  1074→  lineItems: TLineItemExpanded[],\n  1075→  primarySubscription?: Subscription\n  1076→): Promise<TLineItemExpanded[]> {\n  1077→  const subscriptionItems = await SubscriptionItem.findAll({\n  1078→    where: { subscription_id: subscription.id },\n  1079→  });\n  1080→\n  1081→  let subItems = lineItems.filter((x) =>\n  1082→    subscriptionItems.some((y) => y.price_id === x.price_id || y.price_id === x.upsell_price_id)\n  1083→  );\n  1084→\n  1085→  // Add one-time items if this is the primary subscription\n  1086→  if (primarySubscription && subscription.id === primarySubscription.id) {\n  1087→    subItems = [...subItems, ...getOneTimeLineItems(lineItems)];\n  1088→  }\n  1089→\n  1090→  return subItems;\n  1091→}\n  1092→\n  1093→export function isCreditMetered(price: TPrice | TPriceExpanded) {\n  1094→  return price.type === 'recurring' && price.recurring?.usage_type === 'metered' && !!price.recurring?.meter_id;\n  1095→}\n  1096→\n  1097→export function isCreditMeteredLineItems(lineItems: TLineItemExpanded[]) {\n  1098→  return lineItems.every((item) => item.price && isCreditMetered(item.price));\n  1099→}\n  1100→\n  1101→export function validateStripePaymentAmounts(amount: string, currency: PaymentCurrency) {\n  1102→  const minAmountInUnits = fromTokenToUnit(0.5, currency.decimal);\n  1103→  return new BN(amount).gte(new BN(minAmountInUnits)); // 0.5 USD\n  1104→}\n  1105→\n  1106→/**\n  1107→ * Validates payment amounts meet minimum requirements\n  1108→ * @param lineItems Line items to validate\n  1109→ * @param currencyId Currency ID for validation\n  1110→ * @param mode Checkout mode\n  1111→ * @returns Validation result with error message if any\n  1112→ */\n  1113→export async function validatePaymentAmounts(\n  1114→  lineItems: TLineItemExpanded[],\n  1115→  currency: PaymentCurrency,\n  1116→  checkoutSession: CheckoutSession\n  1117→): Promise<{ valid: boolean; error?: string }> {\n  1118→  const enableGrouping = checkoutSession.enable_subscription_grouping;\n  1119→  const oneTimeItems = getOneTimeLineItems(lineItems);\n  1120→  const recurringItems = getRecurringLineItems(lineItems);\n  1121→\n  1122→  // Check for mixed pricing types (fixed + dynamic)\n  1123→  const hasDynamicPricing = lineItems.some((item) => {\n  1124→    const price = item.upsell_price || item.price;\n  1125→    return (price as any)?.pricing_type === 'dynamic';\n  1126→  });\n  1127→\n  1128→  const hasFixedPricing = lineItems.some((item) => {\n  1129→    const price = item.upsell_price || item.price;\n  1130→    return !(price as any)?.pricing_type || (price as any)?.pricing_type === 'fixed';\n  1131→  });\n  1132→\n  1133→  if (hasDynamicPricing && hasFixedPricing) {\n  1134→    return {\n  1135→      valid: false,\n  1136→      error: 'Cannot mix fixed pricing and dynamic pricing in the same checkout session',\n  1137→    };\n  1138→  }\n  1139→\n  1140→  const minAmountInUnits = fromTokenToUnit(0.5, currency.decimal);\n  1141→\n  1142→  // Case 1: All one-time items - validate total payment amount\n  1143→  if (recurringItems.length === 0 && oneTimeItems.length > 0) {\n  1144→    const { total } = await getCheckoutAmount(lineItems, currency.id);\n  1145→    if (new BN(total).lt(new BN(minAmountInUnits))) {\n  1146→      return {\n  1147→        valid: false,\n  1148→        error: 'Total payment amount must be greater or equal to 0.5 USD',\n  1149→      };\n  1150→    }\n  1151→    return { valid: true };\n  1152→  }\n  1153→\n  1154→  // Case 2: Mixed or subscription only - validate subscription pricing\n  1155→  if (recurringItems.length > 0) {\n  1156→    if (enableGrouping) {\n  1157→      // When grouping is enabled, validate each subscription product's unit price\n  1158→      const priceGroups = groupLineItemsByPrice(lineItems);\n  1159→\n  1160→      for (const [priceId, items] of Object.entries(priceGroups)) {\n  1161→        // Calculate total unit price for this subscription product\n  1162→        let totalUnitPrice = new BN(0);\n  1163→\n  1164→        items.forEach((item) => {\n  1165→          const price = item.upsell_price || item.price;\n  1166→          const unitPrice = getPriceUintAmountByCurrency(price, currency.id);\n  1167→          totalUnitPrice = totalUnitPrice.add(new BN(unitPrice).mul(new BN(item.quantity)));\n  1168→        });\n  1169→\n  1170→        if (totalUnitPrice.lt(new BN(minAmountInUnits))) {\n  1171→          const productName = items[0]?.price?.product?.name || `Product ${priceId}`;\n  1172→          return {\n  1173→            valid: false,\n  1174→            error: `product \"${productName}\" unit price must be greater or equal to 0.5 USD`,\n  1175→          };\n  1176→        }\n  1177→      }\n  1178→    } else {\n  1179→      // When grouping is disabled, validate total subscription amount\n  1180→      const { renew } = await getCheckoutAmount(lineItems, currency.id);\n  1181→      if (new BN(renew).lt(new BN(minAmountInUnits))) {\n  1182→        return {\n  1183→          valid: false,\n  1184→          error: 'Total subscription amount must be greater or equal to 0.5 USD',\n  1185→        };\n  1186→      }\n  1187→    }\n  1188→  }\n  1189→\n  1190→  return { valid: true };\n  1191→}\n  1192→\n  1193→/**\n  1194→ * Process discount application for checkout session data\n  1195→ * Validates coupon existence and basic validity, calculates discount amounts\n  1196→ * Customer-specific validations are done later during checkout submission\n  1197→ */\n  1198→export async function processCheckoutSessionDiscounts(\n  1199→  checkoutData: {\n  1200→    currency_id: string;\n  1201→    amount_total: string;\n  1202→    line_items?: any[];\n  1203→  },\n  1204→  discounts: Array<{ coupon: string }>\n  1205→): Promise<\n  1206→  Array<{\n  1207→    coupon: string;\n  1208→    verification_method: string;\n  1209→  }>\n  1210→> {\n  1211→  if (!discounts || !Array.isArray(discounts) || discounts.length === 0) {\n  1212→    return [];\n  1213→  }\n  1214→\n  1215→  // Get currency for discount calculations\n  1216→  const currency = await PaymentCurrency.findByPk(checkoutData.currency_id);\n  1217→  if (!currency) {\n  1218→    throw new Error('Currency not found');\n  1219→  }\n  1220→\n  1221→  const processedDiscounts: Array<{\n  1222→    coupon: string;\n  1223→    verification_method: string;\n  1224→  }> = [];\n  1225→\n  1226→  const expandedItems = await Price.expand(checkoutData.line_items || [], { product: true, upsell: true });\n  1227→\n  1228→  // Process discounts concurrently for better performance\n  1229→  const discountProcessingTasks = discounts.map((discountSpec, index) => async () => {\n  1230→    if (!discountSpec.coupon) {\n  1231→      throw new Error(`Coupon ID is required for discount at index ${index}`);\n  1232→    }\n  1233→\n  1234→    const coupon = await Coupon.findByPk(discountSpec.coupon);\n  1235→    if (!coupon) {\n  1236→      throw new Error(`Coupon '${discountSpec.coupon}' not found`);\n  1237→    }\n  1238→\n  1239→    // Validate coupon basic validity\n  1240→    const couponValidation = validCoupon(coupon, expandedItems as TLineItemExpanded[]);\n  1241→    if (!couponValidation.valid) {\n  1242→      throw new Error(`Coupon '${discountSpec.coupon}' is not valid: ${couponValidation.reason}`);\n  1243→    }\n  1244→    return {\n  1245→      coupon: coupon.id,\n  1246→      verification_method: 'direct',\n  1247→    };\n  1248→  });\n  1249→\n  1250→  const processedDiscountsArray = await pAll(discountProcessingTasks, { concurrency: 5 });\n  1251→  processedDiscounts.push(...processedDiscountsArray);\n  1252→\n  1253→  return processedDiscounts;\n  1254→}\n  1255→\n  1256→/**\n  1257→ * Recalculate checkout session amounts with applied discounts\n  1258→ */\n  1259→export async function getCheckoutSessionAmounts(checkoutSession: CheckoutSession) {\n  1260→  const { discounts } = checkoutSession;\n  1261→\n  1262→  // Ensure we always have safe default values\n  1263→  const safeSubtotal = checkoutSession.amount_subtotal || '0';\n  1264→  const safeTotal = checkoutSession.amount_total || '0';\n  1265→  const safeTotalDetails = checkoutSession.total_details || {\n  1266→    amount_discount: '0',\n  1267→    amount_shipping: '0',\n  1268→    amount_tax: '0',\n  1269→  };\n  1270→\n  1271→  // If no discounts, return current amounts with safe defaults\n  1272→  if (!discounts || discounts.length === 0) {\n  1273→    return {\n  1274→      amount_subtotal: safeSubtotal,\n  1275→      amount_total: safeTotal,\n  1276→      total_details: {\n  1277→        amount_discount: safeTotalDetails.amount_discount || '0',\n  1278→        amount_shipping: safeTotalDetails.amount_shipping || '0',\n  1279→        amount_tax: safeTotalDetails.amount_tax || '0',\n  1280→      },\n  1281→    };\n  1282→  }\n  1283→\n  1284→  const originalTotal = safeTotal;\n  1285→  let totalDiscountAmount = new BN('0');\n  1286→\n  1287→  // Calculate discount for each coupon\n  1288→  const discountPromises = discounts.map(async (discount) => {\n  1289→    if (!discount.coupon) {\n  1290→      return new BN('0');\n  1291→    }\n  1292→\n  1293→    const coupon = await Coupon.findByPk(discount.coupon);\n  1294→\n  1295→    if (!coupon || !coupon.valid) {\n  1296→      return new BN('0');\n  1297→    }\n  1298→\n  1299→    let discountAmount = new BN('0');\n  1300→    const baseAmount = new BN(originalTotal);\n  1301→\n  1302→    if (coupon.percent_off > 0) {\n  1303→      // Percentage discount\n  1304→      discountAmount = baseAmount.mul(new BN(coupon.percent_off)).div(new BN(100));\n  1305→    } else if (coupon.amount_off && new BN(coupon.amount_off).gt(new BN('0'))) {\n  1306→      // Fixed amount discount\n  1307→      discountAmount = new BN(coupon.amount_off);\n  1308→    }\n  1309→\n  1310→    // Ensure discount doesn't exceed original amount\n  1311→    if (discountAmount.gt(baseAmount)) {\n  1312→      discountAmount = baseAmount;\n  1313→    }\n  1314→\n  1315→    return discountAmount;\n  1316→  });\n  1317→\n  1318→  const discountAmounts = await Promise.all(discountPromises);\n  1319→  totalDiscountAmount = discountAmounts.reduce((sum: BN, amount: BN) => sum.add(amount), new BN('0'));\n  1320→\n  1321→  // Ensure total discount doesn't exceed original amount\n  1322→  if (totalDiscountAmount.gt(new BN(originalTotal))) {\n  1323→    totalDiscountAmount = new BN(originalTotal);\n  1324→  }\n  1325→\n  1326→  const finalTotal = new BN(originalTotal).sub(totalDiscountAmount);\n  1327→  // Ensure total doesn't go below 0\n  1328→  const adjustedTotal = finalTotal.lt(new BN('0')) ? '0' : finalTotal.toString();\n  1329→\n  1330→  return {\n  1331→    amount_subtotal: safeSubtotal,\n  1332→    amount_total: adjustedTotal,\n  1333→    total_details: {\n  1334→      amount_discount: totalDiscountAmount.toString(),\n  1335→      amount_shipping: safeTotalDetails.amount_shipping || '0',\n  1336→      amount_tax: safeTotalDetails.amount_tax || '0',\n  1337→    },\n  1338→    discounts,\n  1339→  };\n  1340→}\n  1341→\n  1342→const USD_DECIMALS = 8;\n  1343→const QUOTE_LOCK_DURATION_SECONDS = 180;\n  1344→function calculateTotalBaseAmount(baseAmount: string, quantity: number): string {\n  1345→  const baseAmountBN = fromTokenToUnit(trimDecimals(baseAmount, USD_DECIMALS), USD_DECIMALS);\n  1346→  const quantityBN = new BN(quantity);\n  1347→  const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n  1348→  return fromUnitToToken(totalBaseAmountBN.toString(), USD_DECIMALS);\n  1349→}\n  1350→\n  1351→/**\n  1352→ * Enrich checkout session with dynamic pricing quotes\n  1353→ * For each dynamic price, create or reuse a quote and attach quote info to line items\n  1354→ *\n  1355→ * @param options.skipGeneration - If true, only fetch existing quotes via quote_id, don't generate new ones\n  1356→ */\n  1357→export async function enrichCheckoutSessionWithQuotes(\n  1358→  checkoutSession: CheckoutSession,\n  1359→  lineItems: TLineItemExpanded[],\n  1360→  currencyId: string,\n  1361→  options: { skipGeneration?: boolean; forceRefresh?: boolean } = {}\n  1362→): Promise<{\n  1363→  lineItems: TLineItemExpanded[];\n  1364→  quotes: Record<\n  1365→    string,\n  1366→    {\n  1367→      quote_id: string;\n  1368→      expires_at: number;\n  1369→      quoted_amount: string;\n  1370→      exchange_rate?: string;\n  1371→      rate_provider_name?: string;\n  1372→      rate_provider_id?: string;\n  1373→    }\n  1374→  >;\n  1375→  rateUnavailable?: boolean;\n  1376→  rateError?: string;\n  1377→  regenerated?: boolean;\n  1378→  refreshed?: boolean;\n  1379→}> {\n  1380→  const { skipGeneration = false, forceRefresh = false } = options;\n  1381→  const quoteService = getQuoteService();\n  1382→\n  1383→  const quotes: Record<\n  1384→    string,\n  1385→    {\n  1386→      quote_id: string;\n  1387→      expires_at: number;\n  1388→      quoted_amount: string;\n  1389→      exchange_rate: string;\n  1390→      rate_provider_name: string;\n  1391→      rate_provider_id: string;\n  1392→    }\n  1393→  > = {};\n  1394→\n  1395→  // First, check if line_items already have quote_id references\n  1396→  // If so, fetch quote data from PriceQuote table and check if expired\n  1397→  const lineItemsWithQuoteIds = lineItems.filter((item) => (item as any).quote_id);\n  1398→  const now = Math.floor(Date.now() / 1000);\n  1399→  const quoteLockedAt = checkoutSession.metadata?.quote_locked_at;\n  1400→  const lockStart =\n  1401→    typeof quoteLockedAt === 'number'\n  1402→      ? quoteLockedAt\n  1403→      : typeof quoteLockedAt === 'string'\n  1404→        ? Number(quoteLockedAt)\n  1405→        : null;\n  1406→  const lockActive = Number.isFinite(lockStart) && now - (lockStart as number) < QUOTE_LOCK_DURATION_SECONDS;\n  1407→  const slippagePercentValue = Number((checkoutSession as any).slippage_percent);\n  1408→  const slippagePercent = Number.isFinite(slippagePercentValue) ? slippagePercentValue : 0.5;\n  1409→  const quotesById = new Map<string, PriceQuote>();\n  1410→  const refreshQuoteIds = new Set<string>();\n  1411→  let hasExpiredQuotes = false;\n  1412→  let hasStaleQuotes = false;\n  1413→  let hasMissingQuotes = false;\n  1414→  let regenerated = false;\n  1415→  let createdNewQuotes = false;\n  1416→  const applyQuoteToItem = (item: TLineItemExpanded, quote: PriceQuote) => {\n  1417→    (item as any).custom_amount = quote.quoted_amount;\n  1418→    (item as any).quoted_amount = quote.quoted_amount;\n  1419→    (item as any).quote_id = quote.id;\n  1420→    (item as any).exchange_rate = quote.exchange_rate;\n  1421→    (item as any).rate_provider_name = quote.rate_provider_name;\n  1422→    (item as any).rate_provider_id = quote.rate_provider_id;\n  1423→    (item as any).rate_timestamp_ms = quote.rate_timestamp_ms;\n  1424→    (item as any).expires_at = quote.expires_at;\n  1425→\n  1426→    const quoteKey = `${item.price.id}_${currencyId}`;\n  1427→    quotes[quoteKey] = {\n  1428→      quote_id: quote.id,\n  1429→      expires_at: quote.expires_at,\n  1430→      quoted_amount: quote.quoted_amount,\n  1431→      exchange_rate: quote.exchange_rate,\n  1432→      rate_provider_name: quote.rate_provider_name,\n  1433→      rate_provider_id: quote.rate_provider_id,\n  1434→    };\n  1435→  };\n  1436→\n  1437→  if (lineItemsWithQuoteIds.length > 0) {\n  1438→    const quoteIds = Array.from(new Set(lineItemsWithQuoteIds.map((item) => (item as any).quote_id).filter(Boolean)));\n  1439→    const existingQuotes = await PriceQuote.findAll({\n  1440→      where: { id: quoteIds },\n  1441→    });\n  1442→\n  1443→    existingQuotes.forEach((quote) => {\n  1444→      quotesById.set(quote.id, quote);\n  1445→    });\n  1446→    if (existingQuotes.length !== quoteIds.length) {\n  1447→      hasMissingQuotes = true;\n  1448→      logger.warn('Some quote references are missing from database', {\n  1449→        sessionId: checkoutSession.id,\n  1450→        totalQuoteIds: quoteIds.length,\n  1451→        foundQuotes: existingQuotes.length,\n  1452→      });\n  1453→    }\n  1454→\n  1455→    lineItemsWithQuoteIds.forEach((item) => {\n  1456→      const quoteId = (item as any).quote_id;\n  1457→      const quote = quotesById.get(quoteId);\n  1458→      if (!quote) {\n  1459→        if (!skipGeneration) {\n  1460→          refreshQuoteIds.add(quoteId);\n  1461→        }\n  1462→        return;\n  1463→      }\n  1464→\n  1465→      const isCommitted = quote.status === 'used' || quote.status === 'paid';\n  1466→      if (isCommitted) {\n  1467→        applyQuoteToItem(item, quote);\n  1468→        return;\n  1469→      }\n  1470→\n  1471→      if (forceRefresh && !skipGeneration) {\n  1472→        if (!lockActive) {\n  1473→          refreshQuoteIds.add(quoteId);\n  1474→          logger.info('Force refresh quote for checkout session', {\n  1475→            sessionId: checkoutSession.id,\n  1476→            quoteId,\n  1477→          });\n  1478→        } else {\n  1479→          logger.info('Skip force refresh due to active quote lock', {\n  1480→            sessionId: checkoutSession.id,\n  1481→            quoteId,\n  1482→          });\n  1483→        }\n  1484→        return;\n  1485→      }\n  1486→\n  1487→      const price = (item.upsell_price || item.price) as any;\n  1488→      if (\n  1489→        !skipGeneration &&\n  1490→        !lockActive &&\n  1491→        quote.status !== 'paid' &&\n  1492→        price?.pricing_type === 'dynamic' &&\n  1493→        price?.base_amount\n  1494→      ) {\n  1495→        const expectedBaseAmount = calculateTotalBaseAmount(price.base_amount, Number(item.quantity || 0));\n  1496→        const expectedTrimmed = trimDecimals(expectedBaseAmount, USD_DECIMALS);\n  1497→        const quoteTrimmed = trimDecimals(quote.base_amount || '0', USD_DECIMALS);\n  1498→        if (quoteTrimmed !== expectedTrimmed) {\n  1499→          hasStaleQuotes = true;\n  1500→          refreshQuoteIds.add(quoteId);\n  1501→          logger.info('Detected quote base_amount mismatch, will refresh quote', {\n  1502→            sessionId: checkoutSession.id,\n  1503→            quoteId,\n  1504→            priceId: item.price_id || item.price?.id,\n  1505→            expectedBaseAmount: expectedTrimmed,\n  1506→            quoteBaseAmount: quoteTrimmed,\n  1507→            quantity: item.quantity,\n  1508→          });\n  1509→          return;\n  1510→        }\n  1511→      }\n  1512→\n  1513→      const isExpired = quote.status !== 'paid' && (quote.expires_at < now || quote.status === 'expired');\n  1514→      if (!skipGeneration && !lockActive && isExpired) {\n  1515→        hasExpiredQuotes = true;\n  1516→        refreshQuoteIds.add(quoteId);\n  1517→        logger.info('Detected expired quote', {\n  1518→          sessionId: checkoutSession.id,\n  1519→          expiredQuoteId: quote.id,\n  1520→          expiresAt: new Date(quote.expires_at * 1000).toISOString(),\n  1521→          now: new Date(now * 1000).toISOString(),\n  1522→        });\n  1523→        return;\n  1524→      }\n  1525→\n  1526→      const isInactive = quote.status !== 'active' && quote.status !== 'paid';\n  1527→      if (!skipGeneration && !lockActive && isInactive) {\n  1528→        hasExpiredQuotes = true;\n  1529→        refreshQuoteIds.add(quoteId);\n  1530→        logger.info('Detected inactive quote, will refresh', {\n  1531→          sessionId: checkoutSession.id,\n  1532→          quoteId: quote.id,\n  1533→          status: quote.status,\n  1534→        });\n  1535→        return;\n  1536→      }\n  1537→\n  1538→      // Use existing quotes (either not expired, or skipGeneration)\n  1539→      applyQuoteToItem(item, quote);\n  1540→    });\n  1541→\n  1542→    logger.info('Processed existing quotes from database', {\n  1543→      sessionId: checkoutSession.id,\n  1544→      totalQuoteIds: lineItemsWithQuoteIds.length,\n  1545→      foundQuotes: quotesById.size,\n  1546→      hasExpiredQuotes,\n  1547→      hasStaleQuotes,\n  1548→      hasMissingQuotes,\n  1549→      skipGeneration,\n  1550→      refreshQuotes: refreshQuoteIds.size,\n  1551→    });\n  1552→\n  1553→    if (skipGeneration || refreshQuoteIds.size === 0) {\n  1554→      return { lineItems, quotes, refreshed: false };\n  1555→    }\n  1556→  }\n  1557→\n  1558→  // Find all dynamic pricing items that need new quotes or refresh\n  1559→  const dynamicItems = lineItems.filter(\n  1560→    (item) =>\n  1561→      item.price.pricing_type === 'dynamic' &&\n  1562→      ((item as any).quote_id ? refreshQuoteIds.has((item as any).quote_id) : true)\n  1563→  );\n  1564→\n  1565→  // If no dynamic items need new quotes, return early\n  1566→  if (dynamicItems.length === 0) {\n  1567→    return { lineItems, quotes, refreshed: false };\n  1568→  }\n  1569→\n  1570→  // If skipGeneration is enabled, don't generate new quotes for items without quote_id\n  1571→  // This is used for submitted/completed checkout sessions where we only want to use existing quotes\n  1572→  if (skipGeneration) {\n  1573→    logger.info('Skipping quote generation for dynamic items (skipGeneration enabled)', {\n  1574→      sessionId: checkoutSession.id,\n  1575→      dynamicItemsWithoutQuotes: dynamicItems.length,\n  1576→    });\n  1577→    return { lineItems, quotes, refreshed: false };\n  1578→  }\n  1579→\n  1580→  // Fetch exchange rate once for all dynamic items (they all use the same target currency)\n  1581→  const currency = (await PaymentCurrency.findByPk(currencyId, {\n  1582→    include: [{ model: PaymentMethod, as: 'payment_method' }],\n  1583→  })) as PaymentCurrency & { payment_method: PaymentMethod };\n  1584→  if (!currency) {\n  1585→    throw new Error(`Currency ${currencyId} not found`);\n  1586→  }\n  1587→\n  1588→  if (currency.payment_method?.type === 'stripe') {\n  1589→    return { lineItems, quotes, refreshed: false };\n  1590→  }\n  1591→\n  1592→  const exchangeRateService = getExchangeRateService();\n  1593→\n  1594→  // Try to get exchange rate, but don't block checkout if unavailable\n  1595→  let rateResult;\n  1596→  try {\n  1597→    // For ArcBlock payment method, always use ABT for exchange rate\n  1598→    // For other methods, use the currency's symbol\n  1599→    const rateSymbol = getExchangeRateSymbol(currency.symbol, currency.payment_method?.type as ChainType);\n  1600→    rateResult = await exchangeRateService.getRate(rateSymbol);\n  1601→  } catch (error: any) {\n  1602→    logger.warn('Exchange rate unavailable for checkout session', {\n  1603→      checkoutSessionId: checkoutSession.id,\n  1604→      currencyId,\n  1605→      currencySymbol: currency.symbol,\n  1606→      error: error.message,\n  1607→    });\n  1608→\n  1609→    // Return without quotes, frontend will show warning\n  1610→    return {\n  1611→      lineItems,\n  1612→      quotes: {},\n  1613→      rateUnavailable: true,\n  1614→      rateError: error.message || 'Exchange rate service unavailable',\n  1615→      refreshed: false,\n  1616→    };\n  1617→  }\n  1618→\n  1619→  logger.info('Fetched exchange rate for batch quote creation', {\n  1620→    currencyId,\n  1621→    currencySymbol: currency.symbol,\n  1622→    rate: rateResult.rate,\n  1623→    provider: rateResult.provider_name,\n  1624→    dynamicItemsCount: dynamicItems.length,\n  1625→  });\n  1626→\n  1627→  // Create or refresh quotes for dynamic items using the same exchange rate\n  1628→  const quoteResults = await Promise.all(\n  1629→    dynamicItems.map(async (item) => {\n  1630→      const { price, quantity } = item;\n  1631→\n  1632→      try {\n  1633→        const quoteId = (item as any).quote_id;\n  1634→        let quoteResponse: QuoteResponse;\n  1635→\n  1636→        if (quoteId && quotesById.get(quoteId)) {\n  1637→          quoteResponse = await quoteService.refreshQuoteWithRate({\n  1638→            quote_id: quoteId,\n  1639→            price_id: price.id,\n  1640→            session_id: checkoutSession.id,\n  1641→            target_currency_id: currencyId,\n  1642→            quantity,\n  1643→            rateResult,\n  1644→            slippage_percent: slippagePercent,\n  1645→          });\n  1646→        } else {\n  1647→          quoteResponse = await quoteService.createQuoteWithRate({\n  1648→            price_id: price.id,\n  1649→            session_id: checkoutSession.id,\n  1650→            target_currency_id: currencyId,\n  1651→            quantity,\n  1652→            rateResult,\n  1653→            slippage_percent: slippagePercent,\n  1654→          });\n  1655→          createdNewQuotes = true;\n  1656→        }\n  1657→\n  1658→        return {\n  1659→          item,\n  1660→          quoteResponse,\n  1661→        };\n  1662→      } catch (error) {\n  1663→        const errorMessage = error instanceof Error ? error.message : String(error);\n  1664→        logger.error('Failed to create quote for dynamic price', {\n  1665→          priceId: price.id,\n  1666→          checkoutSessionId: checkoutSession.id,\n  1667→          currencyId,\n  1668→          errorMessage,\n  1669→          errorName: (error as any)?.name,\n  1670→        });\n  1671→        throw error;\n  1672→      }\n  1673→    })\n  1674→  );\n  1675→\n  1676→  // Build quote map for quick lookup\n  1677→  const quoteByPriceId = new Map<string, (typeof quoteResults)[0]>();\n  1678→  quoteResults.forEach((result) => {\n  1679→    quoteByPriceId.set(result.item.price.id, result);\n  1680→  });\n  1681→\n  1682→  // Extract quote info helper\n  1683→  const extractQuoteInfo = (quoteResponse: QuoteResponse) => ({\n  1684→    quote_id: quoteResponse.quote.id,\n  1685→    expires_at: quoteResponse.expires_at,\n  1686→    quoted_amount: quoteResponse.computed_unit_amount,\n  1687→    exchange_rate: quoteResponse.quote.exchange_rate,\n  1688→    rate_provider_name: quoteResponse.quote.rate_provider_name,\n  1689→    rate_provider_id: quoteResponse.quote.rate_provider_id,\n  1690→    rate_timestamp_ms: quoteResponse.quote.rate_timestamp_ms,\n  1691→  });\n  1692→\n  1693→  // Build quotes object\n  1694→  quoteResults.forEach((result) => {\n  1695→    const quoteKey = `${result.item.price.id}_${currencyId}`;\n  1696→    quotes[quoteKey] = extractQuoteInfo(result.quoteResponse);\n  1697→  });\n  1698→\n  1699→  regenerated = createdNewQuotes;\n  1700→  const refreshed = refreshQuoteIds.size > 0 || createdNewQuotes;\n  1701→\n  1702→  // Enrich line items with quote information\n  1703→  const enrichedLineItems = lineItems.map((item) => {\n  1704→    const quoteInfo = quoteByPriceId.get(item.price.id);\n  1705→    if (!quoteInfo) {\n  1706→      return item;\n  1707→    }\n  1708→\n  1709→    const quoteData = extractQuoteInfo(quoteInfo.quoteResponse);\n  1710→    return {\n  1711→      ...item,\n  1712→      ...quoteData,\n  1713→      custom_amount: quoteInfo.quoteResponse.computed_unit_amount,\n  1714→    };\n  1715→  });\n  1716→\n  1717→  return {\n  1718→    lineItems: enrichedLineItems,\n  1719→    quotes,\n  1720→    regenerated,\n  1721→    refreshed,\n  1722→  };\n  1723→}\n  1724→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"d54aca07-77cb-4d5f-ba01-c062d2aace7e","timestamp":"2026-01-12T15:03:15.609Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/session.ts","content":"import { env } from '@blocklet/sdk/lib/config';\nimport type { TransactionInput } from '@ocap/client';\nimport { BN, fromTokenToUnit, fromUnitToToken } from '@ocap/util';\nimport cloneDeep from 'lodash/cloneDeep';\nimport isEqual from 'lodash/isEqual';\nimport pAll from 'p-all';\nimport { omit } from 'lodash';\nimport dayjs from './dayjs';\nimport { validCoupon } from './discount/coupon';\nimport { getPriceUintAmountByCurrency, getPriceCurrencyOptions } from './price';\n\nimport {\n  Coupon,\n  Customer,\n  Invoice,\n  PaymentCurrency,\n  PaymentMethod,\n  PriceQuote,\n  SetupIntent,\n  Subscription,\n  SubscriptionItem,\n  TPriceExpanded,\n  type CheckoutSession,\n  type TLineItemExpanded,\n  type TPaymentCurrency,\n  type TPaymentMethodExpanded,\n} from '../store/models';\nimport { Price, Price as TPrice } from '../store/models/price';\nimport type { Product } from '../store/models/product';\nimport type {\n  ChainType,\n  PaymentBeneficiary,\n  PriceRecurring,\n  SubscriptionBillingThresholds,\n} from '../store/models/types';\nimport { wallet } from './auth';\nimport logger from './logger';\nimport { applyDiscountsToLineItems } from './discount/discount';\nimport { getQuoteService, QuoteResponse } from './quote-service';\nimport { getExchangeRateService } from './exchange-rate';\nimport { getExchangeRateSymbol } from './exchange-rate/token-address-mapping';\nimport { trimDecimals } from './math-utils';\n\nexport function getStatementDescriptor(items: any[]) {\n  for (const item of items) {\n    if (item.price?.product?.statement_descriptor) {\n      return item.price?.product?.statement_descriptor;\n    }\n  }\n\n  return env.appName;\n}\n\nexport function getCheckoutMode(items: TLineItemExpanded[] = []) {\n  if (items.length === 0) {\n    return 'setup';\n  }\n\n  // all metered\n  if (items.every((x) => x.price.type === 'recurring' && x.price.recurring?.usage_type === 'metered')) {\n    return 'setup';\n  }\n\n  if (items.some((x) => x.price.type === 'recurring')) {\n    return 'subscription';\n  }\n\n  return 'payment';\n}\n\n// Calculate checkout amount with optional discount processing\nexport async function getCheckoutAmount(\n  items: TLineItemExpanded[],\n  currencyId: string,\n  trialing = false,\n  discountConfig?: {\n    promotionCodeId?: string;\n    couponId?: string;\n    customerId?: string;\n  }\n) {\n  let processedItems = items;\n  let renew = new BN(0);\n\n  if (items.find((x) => (x.upsell_price || x.price).custom_unit_amount) && items.length > 1) {\n    throw new Error('Multiple items with custom unit amount are not supported');\n  }\n\n  // Apply discounts if discount configuration is provided\n  if (discountConfig?.couponId && discountConfig?.customerId) {\n    try {\n      const currency = await PaymentCurrency.findByPk(currencyId);\n      if (currency) {\n        const discountResult = await applyDiscountsToLineItems({\n          lineItems: items,\n          promotionCodeId: discountConfig.promotionCodeId,\n          couponId: discountConfig.couponId,\n          customerId: discountConfig.customerId,\n          currency,\n          billingContext: {\n            trialing,\n          },\n        });\n\n        if (discountResult.discountSummary.appliedCoupon) {\n          processedItems = discountResult.enhancedLineItems;\n        }\n      }\n    } catch (error) {\n      // If discount processing fails, continue with original items\n      console.warn('Failed to apply discounts in getCheckoutAmount:', error.message);\n    }\n  }\n\n  // Use async reduce to support quote_id fallback\n  const subtotal = await processedItems\n    .reduce(\n      async (accPromise, x) => {\n        const acc = await accPromise;\n\n        // Priority 1: Use custom_amount if available\n        if (x.custom_amount) {\n          return acc.add(new BN(x.custom_amount));\n        }\n\n        // Priority 2: If has quote_id but no custom_amount, fetch from Quote table\n        if ((x as any).quote_id) {\n          try {\n            const quote = await PriceQuote.findByPk((x as any).quote_id);\n            if (quote) {\n              logger.info('Using quoted_amount from quote_id for checkout amount calculation', {\n                priceId: x.price.id,\n                quoteId: (x as any).quote_id,\n                quotedAmount: quote.quoted_amount,\n              });\n              return acc.add(new BN(quote.quoted_amount));\n            }\n\n            // Quote not found - log warning and fall through to price calculation\n            logger.warn('Quote not found for quote_id in line_item', {\n              priceId: x.price.id,\n              quoteId: (x as any).quote_id,\n            });\n          } catch (error) {\n            logger.error('Failed to fetch quote for quote_id', {\n              priceId: x.price.id,\n              quoteId: (x as any).quote_id,\n              error: (error as Error).message,\n            });\n          }\n        }\n\n        // Priority 3: Calculate from price (fixed pricing or quote query failed)\n        const price = x.upsell_price || x.price;\n        const unitPrice = getPriceUintAmountByCurrency(price, currencyId);\n        if (price.custom_unit_amount) {\n          if (unitPrice) {\n            return acc.add(new BN(unitPrice).mul(new BN(x.quantity)));\n          }\n        }\n\n        if (price?.type === 'recurring') {\n          renew = renew.add(new BN(unitPrice).mul(new BN(x.quantity)));\n\n          if (trialing) {\n            return acc;\n          }\n          if (price?.recurring?.usage_type === 'metered') {\n            return acc;\n          }\n        }\n\n        return acc.add(new BN(unitPrice).mul(new BN(x.quantity)));\n      },\n      Promise.resolve(new BN(0))\n    )\n    .then((bn) => bn.toString());\n\n  // Calculate total discount amount from processed line items\n  let totalDiscountAmount = new BN(0);\n  processedItems.forEach((item) => {\n    if ((item as any).discount_amounts?.length > 0) {\n      (item as any).discount_amounts.forEach((discountAmount: any) => {\n        totalDiscountAmount = totalDiscountAmount.add(new BN(discountAmount.amount || '0'));\n      });\n    }\n  });\n\n  // Ensure discount doesn't exceed subtotal\n  const adjustedDiscount = totalDiscountAmount.gt(new BN(subtotal)) ? new BN(subtotal) : totalDiscountAmount;\n\n  const finalTotal = new BN(subtotal).sub(adjustedDiscount);\n  const adjustedTotal = finalTotal.lt(new BN('0')) ? '0' : finalTotal.toString();\n\n  return {\n    subtotal: subtotal || '0',\n    total: adjustedTotal,\n    renew: renew.toString() || '0',\n    discount: adjustedDiscount.toString(),\n    shipping: '0',\n    tax: '0',\n    processedItems, // Return processed items with discount information\n  };\n}\n\nexport function getRecurringPeriod(recurring: PriceRecurring) {\n  const { interval } = recurring || {};\n  if (!interval) {\n    return 0;\n  }\n  const count = +recurring.interval_count || 1;\n  const dayInMs = 24 * 60 * 60 * 1000;\n\n  switch (interval) {\n    case 'hour':\n      return 60 * 60 * 1000;\n    case 'day':\n      return count * dayInMs;\n    case 'week':\n      return count * 7 * dayInMs;\n    case 'month':\n      return count * 30 * dayInMs;\n    case 'year':\n      return count * 365 * dayInMs;\n    default:\n      return 0;\n  }\n}\n\nexport function expandLineItems(\n  items: any[],\n  products: Product[],\n  prices: Price[],\n  creditCurrencies?: TPaymentCurrency[]\n) {\n  items.forEach((item) => {\n    item.price = prices.find((x) => x.id === item.price_id);\n    if (item.price) {\n      item.price.product = products.find((x) => x.id === item.price.product_id);\n      if (item.price.product?.type === 'credit' && item.price.metadata?.credit_config) {\n        item.price.credit = {\n          amount: Number(item.price.metadata.credit_config.credit_amount || 0) * Number(item.quantity),\n          currency_id: item.price.metadata.credit_config.currency_id,\n          currency: creditCurrencies?.find((x) => x.id === item.price.metadata.credit_config.currency_id),\n        };\n      }\n    }\n  });\n\n  return items;\n}\n\nexport function filterCurrencies(method: TPaymentMethodExpanded, hasSelected: (currency: TPaymentCurrency) => boolean) {\n  method.payment_currencies = method.payment_currencies.filter((x) => hasSelected(x));\n  return method;\n}\n\nexport function getSupportedPaymentMethods(\n  methods: TPaymentMethodExpanded[],\n  hasSelected: (currency: TPaymentCurrency) => boolean\n) {\n  const filtered = cloneDeep(methods).map((x) => filterCurrencies(x, hasSelected));\n  return filtered.filter((x) => x.payment_currencies.length);\n}\n\nexport function getSupportedPaymentCurrencies(items: TLineItemExpanded[]) {\n  const currencies = items.reduce((acc: string[], x: any) => {\n    return acc.concat(getPriceCurrencyOptions(x.price).map((c: any) => c.currency_id));\n  }, []);\n  return Array.from(new Set(currencies));\n}\n\nexport function isLineItemCurrencyAligned(list: TLineItemExpanded[], index: number) {\n  const prices = list.map((x) => x.upsell_price || x.price);\n\n  const current = getPriceCurrencyOptions(prices[index] as any)\n    .map((x) => x.currency_id)\n    .sort();\n\n  for (let i = 0; i < index; i++) {\n    const previous = getPriceCurrencyOptions(prices[i] as any)\n      .map((x) => x.currency_id)\n      .sort();\n    if (isEqual(current, previous) === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isLineItemRecurringAligned(list: TLineItemExpanded[], index: number) {\n  const prices = list.map((x) => x.upsell_price || x.price);\n\n  if (prices[index]?.type !== 'recurring') {\n    return true;\n  }\n\n  const recurring = prices.slice(0, index).find((x) => x?.type === 'recurring')?.recurring;\n  if (!recurring) {\n    return true;\n  }\n\n  return prices.slice(0, index + 1).every((x: any) => {\n    if (x.type !== 'recurring') {\n      return true;\n    }\n\n    // If the interval and interval_count are different, the recurring is not aligned\n    if (\n      String(recurring?.interval) !== String(x.recurring?.interval) ||\n      Number(recurring?.interval_count) !== Number(x.recurring?.interval_count)\n    ) {\n      return false;\n    }\n\n    return true;\n  });\n}\n\nexport function isLineItemAligned(list: TLineItemExpanded[], index: number) {\n  const currency = isLineItemCurrencyAligned(list, index);\n  const recurring = isLineItemRecurringAligned(list, index);\n  return {\n    currency,\n    recurring,\n    aligned: currency && recurring,\n  };\n}\n\n// FIXME: upsell validate https://stripe.com/docs/payments/checkout/upsells\nexport function canUpsell(from: TPrice, to: TPrice) {\n  if (from.id === to.id) {\n    return false;\n  }\n  if (from.product_id !== to.product_id) {\n    return false;\n  }\n  if (to.active === false) {\n    return false;\n  }\n  if (to.type !== 'recurring') {\n    return false;\n  }\n\n  // longer periods\n  const fromPeriod = getRecurringPeriod(from.recurring as PriceRecurring);\n  const toPeriod = getRecurringPeriod(to.recurring as PriceRecurring);\n  if (!fromPeriod || !toPeriod) {\n    return false;\n  }\n  if (fromPeriod >= toPeriod) {\n    return false;\n  }\n\n  // and lower prices\n  const fromPrice = new BN(from.unit_amount).div(new BN(fromPeriod));\n  const toPrice = new BN(to.unit_amount).div(new BN(toPeriod));\n  if (fromPrice.lt(toPrice)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport async function getFastCheckoutAmount({\n  items,\n  mode,\n  currencyId,\n  trialing = false,\n  minimumCycle = 1,\n  discountConfig,\n}: {\n  items: TLineItemExpanded[];\n  mode: string;\n  currencyId: string;\n  trialing?: boolean;\n  minimumCycle?: number;\n  discountConfig?: {\n    promotionCodeId?: string;\n    couponId?: string;\n    customerId?: string;\n  };\n}) {\n  if (!minimumCycle || minimumCycle < 1) {\n    // eslint-disable-next-line no-param-reassign\n    minimumCycle = 1;\n  }\n\n  const { total, renew } = await getCheckoutAmount(items, currencyId, trialing, discountConfig);\n\n  if (mode === 'payment' || mode === 'auto-recharge-auth') {\n    return total;\n  }\n\n  if (mode === 'setup') {\n    return new BN(renew).mul(new BN(minimumCycle)).toString();\n  }\n\n  if (mode === 'subscription') {\n    return new BN(total).add(new BN(renew).mul(new BN(trialing ? minimumCycle : minimumCycle - 1))).toString();\n  }\n\n  return '0';\n}\n\nexport function getBillingThreshold(config: Record<string, any> = {}) {\n  if (config?.billing_threshold_amount) {\n    const threshold = +(config.billing_threshold_amount as string);\n    if (threshold > 0) {\n      return threshold;\n    }\n  }\n\n  const threshold = +(process.env.PAYMENT_BILLING_THRESHOLD as string);\n  if (threshold > 0) {\n    return threshold;\n  }\n\n  return 0;\n}\n\nexport function getMinStakeAmount(config: Record<string, any> = {}) {\n  if (config?.min_stake_amount) {\n    const threshold = +(config.min_stake_amount as string);\n    if (threshold > 0) {\n      return threshold;\n    }\n  }\n\n  const threshold = +(process.env.PAYMENT_MIN_STAKE_AMOUNT as string);\n  if (threshold > 0) {\n    return threshold;\n  }\n\n  return 0;\n}\n\nexport function canPayWithDelegation(beneficiaries: PaymentBeneficiary[]) {\n  return beneficiaries.length === 0 || beneficiaries.every((x) => x.address === wallet.address);\n}\n\nexport function createPaymentBeneficiaries(total: string, beneficiaries: PaymentBeneficiary[]) {\n  if (beneficiaries.length) {\n    const shares = beneficiaries.reduce((acc, x) => acc + parseInt(x.share, 10), 0);\n    const result: PaymentBeneficiary[] = [];\n    beneficiaries.forEach((x, i) => {\n      let share = new BN(total).div(new BN(shares)).mul(new BN(x.share)).toString();\n      if (i === beneficiaries.length - 1) {\n        share = result.reduce((acc, d) => acc.sub(new BN(d.share)), new BN(total)).toString();\n      }\n\n      result.push({ ...x, share });\n    });\n\n    return result;\n  }\n\n  return [];\n}\n\nexport function createPaymentOutput(\n  total: string,\n  contract: string,\n  beneficiaries: PaymentBeneficiary[]\n): TransactionInput[] {\n  if (beneficiaries.length) {\n    return beneficiaries.map((x) => ({\n      owner: x.address,\n      assets: [],\n      tokens: [\n        {\n          address: contract,\n          value: x.share,\n        },\n      ],\n    }));\n  }\n\n  return [\n    {\n      owner: wallet.address,\n      assets: [],\n      tokens: [\n        {\n          address: contract,\n          value: total,\n        },\n      ],\n    },\n  ];\n}\n\nexport function isDonationCheckoutSession(checkoutSession: CheckoutSession): boolean {\n  return (\n    checkoutSession.submit_type === 'donate' ||\n    checkoutSession.metadata?.type === 'donation' ||\n    !!checkoutSession.metadata?.is_donation\n  );\n}\n\n/**\n * Format subscription product name based on line items\n */\nexport function formatSubscriptionProduct(items: TLineItemExpanded[], maxLength = 3) {\n  const names = items.map((x) => x.price?.product?.name || '').filter(Boolean);\n  return names.length > maxLength ? `${names.slice(0, maxLength).join(', ')} ...` : names.join(', ');\n}\n\n/**\n * Setup subscription creation parameters\n */\nexport function getSubscriptionCreateSetup(\n  items: TLineItemExpanded[],\n  currencyId: string,\n  trialInDays = 0,\n  trialEnd = 0\n) {\n  let setup = new BN(0);\n  let hasDynamicPricing = false;\n\n  items.forEach((x) => {\n    const price = x.upsell_price || x.price;\n    const unit = getPriceUintAmountByCurrency(price, currencyId);\n    const amount = new BN(unit).mul(new BN(x.quantity));\n\n    // Check if this price uses dynamic pricing\n    if (price.pricing_type === 'dynamic') {\n      hasDynamicPricing = true;\n    }\n\n    if (price.type === 'recurring') {\n      if (price.recurring?.usage_type === 'licensed') {\n        setup = setup.add(amount);\n      }\n    }\n    if (price.type === 'one_time') {\n      setup = setup.add(amount);\n    }\n  });\n\n  // Apply slippage protection for subscriptions with dynamic pricing\n  // Authorization amount = base * (1 + 0.005) to protect against rate fluctuations\n  // This ensures future auto-renewal payments won't fail due to small rate changes\n  if (hasDynamicPricing && setup.gt(new BN(0))) {\n    const SLIPPAGE_MULTIPLIER = new BN(1005); // 1 + 0.005 = 1.005 represented as 1005/1000\n    const SLIPPAGE_DIVISOR = new BN(1000);\n    setup = setup.mul(SLIPPAGE_MULTIPLIER).div(SLIPPAGE_DIVISOR);\n    logger.info('Applied subscription authorization slippage protection', {\n      hasDynamicPricing,\n      authorizationAmount: setup.toString(),\n      slippageRate: '0.5%',\n    });\n  }\n\n  const now = dayjs().unix();\n  const item = items.find((x) => (x.upsell_price || x.price).type === 'recurring');\n  const recurring = (item?.upsell_price || item?.price)?.recurring as PriceRecurring;\n  const cycle = getRecurringPeriod(recurring);\n\n  let trialStartAt = 0;\n  let trialEndAt = 0;\n  if (+trialEnd && trialEnd > now) {\n    trialStartAt = now;\n    trialEndAt = trialEnd;\n  } else if (trialInDays) {\n    trialStartAt = now;\n    trialEndAt = dayjs().add(trialInDays, 'day').unix();\n  }\n\n  const periodStart = trialStartAt || now;\n  const periodEnd = trialEndAt || dayjs().add(cycle, 'millisecond').unix();\n\n  return {\n    recurring,\n    cycle: {\n      duration: cycle,\n      anchor: periodEnd,\n    },\n    trial: {\n      start: trialStartAt,\n      end: trialEndAt,\n    },\n    period: {\n      start: periodStart,\n      end: periodEnd,\n    },\n    amount: {\n      setup: setup.toString(),\n    },\n  };\n}\n\n/**\n * Creates subscription groupings based on checkout session configuration\n * @param {Object} params - Parameters for subscription creation\n * @returns {Object} Created subscription information\n */\nexport async function createGroupSubscriptions({\n  checkoutSession,\n  lineItems,\n  customer,\n  paymentSettings,\n  setupIntent,\n  trialConfig = {},\n}: {\n  checkoutSession: CheckoutSession;\n  lineItems: TLineItemExpanded[];\n  customer: Customer;\n  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n  setupIntent: SetupIntent | null;\n  trialConfig?: { trialInDays?: number; trialEnd?: number };\n}) {\n  const enableGrouping = checkoutSession.enable_subscription_grouping;\n\n  // Filter recurring items only\n  const recurringItems = getRecurringLineItems(lineItems);\n  if (recurringItems.length === 0) {\n    logger.info('No recurring items found for subscription', {\n      session: checkoutSession.id,\n    });\n    return { subscriptions: [], subscriptionGroups: {}, primarySubscription: null };\n  }\n\n  try {\n    // Process based on grouping mode\n    if (!enableGrouping) {\n      // Single subscription mode\n      const result = await createSingleSubscription({\n        checkoutSession,\n        lineItems: recurringItems,\n        customer,\n        paymentSettings,\n        setupIntent,\n        trialConfig,\n      });\n      return result;\n    }\n    // Multiple subscriptions mode\n    const result = await createMultipleSubscriptions({\n      checkoutSession,\n      lineItems,\n      customer,\n      paymentSettings,\n      setupIntent,\n      trialConfig,\n    });\n    return result;\n  } catch (error) {\n    logger.error('Failed to create subscriptions', {\n      error: error.message,\n      session: checkoutSession.id,\n      stack: error.stack,\n    });\n    throw error;\n  }\n}\n\n/**\n * Creates a single subscription for all items\n */\nasync function createSingleSubscription(params: {\n  checkoutSession: CheckoutSession;\n  lineItems: TLineItemExpanded[];\n  customer: Customer;\n  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n  setupIntent: SetupIntent | null;\n  trialConfig?: { trialInDays?: number; trialEnd?: number };\n}) {\n  const { checkoutSession, lineItems, customer, paymentSettings, setupIntent, trialConfig } = params;\n  const existingSubscriptionId = checkoutSession.subscription_id;\n\n  const subscription = await createOrUpdateSubscription({\n    existingSubscriptionId,\n    checkoutSession,\n    lineItems,\n    customer,\n    paymentSettings,\n    setupIntent,\n    trialConfig,\n  });\n\n  logger.info('Single subscription processed', {\n    session: checkoutSession.id,\n    subscription: subscription?.id,\n    isNew: !existingSubscriptionId,\n  });\n\n  return {\n    subscriptions: subscription ? [subscription] : [],\n    subscriptionGroups: {},\n    primarySubscription: subscription,\n  };\n}\n\n/**\n * Creates multiple subscriptions grouped by price ID\n */\nasync function createMultipleSubscriptions(params: {\n  checkoutSession: CheckoutSession;\n  lineItems: TLineItemExpanded[];\n  customer: Customer;\n  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n  setupIntent: SetupIntent | null;\n  trialConfig?: { trialInDays?: number; trialEnd?: number };\n}) {\n  const { checkoutSession, lineItems, customer, paymentSettings, setupIntent, trialConfig } = params;\n\n  // Group items by price ID\n  const priceGroups = groupLineItemsByPrice(lineItems);\n  const existingGroups = checkoutSession.subscription_groups || {};\n\n  const subscriptions: any[] = [];\n  const subscriptionGroups: Record<string, string> = {};\n  let primarySubscription: any = null;\n\n  const noStake = !!checkoutSession.subscription_data?.no_stake;\n  const billingThreshold = getBillingThreshold(checkoutSession.subscription_data);\n  const minStakeAmount = getMinStakeAmount(checkoutSession.subscription_data);\n\n  // Create a task for each price group\n  const tasks = Object.entries(priceGroups).map(([priceId, items], index) => async () => {\n    try {\n      const existingSubscriptionId = existingGroups[priceId];\n      const isPrimary = index === 0;\n      const subscriptionMetadata = {\n        price_id: priceId,\n        checkout_session_id: checkoutSession.id,\n        ...(isPrimary ? { is_primary_subscription: true } : {}),\n      };\n\n      const subscriptionItems = items;\n\n      // Set different stake configurations for different subscriptions\n      let billingThresholds = {};\n      if (isPrimary) {\n        billingThresholds = {\n          amount_gte: billingThreshold,\n          stake_gte: minStakeAmount,\n          reset_billing_cycle_anchor: false,\n          no_stake: noStake,\n        };\n      } else {\n        // if not primary subscription, set stake to 0\n        billingThresholds = {\n          amount_gte: 0,\n          stake_gte: 0,\n          reset_billing_cycle_anchor: false,\n          no_stake: true,\n          references_primary_stake: true,\n        };\n      }\n\n      const subscription = await createOrUpdateSubscription({\n        existingSubscriptionId,\n        checkoutSession,\n        lineItems: subscriptionItems,\n        customer,\n        paymentSettings,\n        setupIntent,\n        trialConfig,\n        metadata: subscriptionMetadata,\n        billing_thresholds: billingThresholds as SubscriptionBillingThresholds,\n      });\n\n      if (!subscription) {\n        return { success: false, priceId, error: 'Failed to create subscription' };\n      }\n\n      return { success: true, priceId, subscription, isPrimary };\n    } catch (error) {\n      logger.error('Failed to create subscription for price group', {\n        priceId,\n        error: error.message,\n        session: checkoutSession.id,\n        stack: error.stack,\n      });\n      return { success: false, priceId, error: error.message };\n    }\n  });\n\n  const results = await pAll(tasks, { concurrency: 5 });\n\n  results.forEach((result) => {\n    if (result.success && result.subscription) {\n      subscriptionGroups[result.priceId] = result.subscription.id;\n      subscriptions.push(result.subscription);\n      if (result.isPrimary) {\n        primarySubscription = result.subscription;\n      }\n    }\n  });\n\n  return {\n    subscriptions,\n    subscriptionGroups,\n    primarySubscription,\n  };\n}\n\n/**\n * Core logic for creating or updating a single subscription\n */\nasync function createOrUpdateSubscription(params: {\n  existingSubscriptionId?: string | null;\n  checkoutSession: CheckoutSession;\n  lineItems: TLineItemExpanded[];\n  customer: Customer;\n  paymentSettings: { method: PaymentMethod; currency: PaymentCurrency };\n  setupIntent: SetupIntent | null;\n  trialConfig?: { trialInDays?: number; trialEnd?: number };\n  metadata?: Record<string, any>;\n  billing_thresholds?: SubscriptionBillingThresholds;\n}): Promise<any> {\n  const {\n    existingSubscriptionId,\n    checkoutSession,\n    lineItems,\n    customer,\n    paymentSettings,\n    setupIntent,\n    trialConfig = {},\n    metadata = {},\n    billing_thresholds: billingThresholds,\n  } = params;\n\n  const { trialInDays = 0, trialEnd = 0 } = trialConfig;\n  const { method: paymentMethod, currency: paymentCurrency } = paymentSettings;\n\n  try {\n    const itemsSubscriptionData = mergeSubscriptionDataFromLineItems(lineItems);\n    let subscription = null;\n    const setup = getSubscriptionCreateSetup(lineItems, paymentCurrency.id, trialInDays, trialEnd);\n\n    if (existingSubscriptionId) {\n      subscription = await Subscription.findByPk(existingSubscriptionId);\n    }\n\n    if (subscription) {\n      // Validate subscription status\n      if (subscription.status !== 'incomplete') {\n        throw new Error(`Subscription ${subscription.id} status not incomplete: ${subscription.status}`);\n      }\n\n      const billingCycleAnchor =\n        itemsSubscriptionData?.billing_cycle_anchor ||\n        checkoutSession.subscription_data?.billing_cycle_anchor ||\n        setup.cycle.anchor;\n\n      // Update existing subscription\n      subscription = await subscription.update({\n        currency_id: paymentCurrency.id,\n        customer_id: customer.id,\n        default_payment_method_id: paymentMethod.id,\n        current_period_start: setup.period.start,\n        current_period_end: setup.period.end,\n        billing_cycle_anchor: billingCycleAnchor,\n        trial_end: setup.trial.end,\n        trial_start: setup.trial.start,\n        pending_invoice_item_interval: setup.recurring,\n        pending_setup_intent: setupIntent?.id,\n      });\n\n      logger.info('Subscription updated', {\n        session: checkoutSession.id,\n        subscription: subscription.id,\n      });\n\n      // Rebuild subscription items\n      await SubscriptionItem.destroy({ where: { subscription_id: subscription.id } });\n      await createSubscriptionItems(subscription.id, lineItems, checkoutSession, itemsSubscriptionData);\n\n      // Update invoice customer if needed\n      const invoice = await Invoice.findByPk(subscription.latest_invoice_id);\n      if (invoice && invoice.customer_id !== customer.id) {\n        await invoice.update({ customer_id: customer.id });\n      }\n    } else {\n      // Create new subscription\n      const recoveredFromId =\n        itemsSubscriptionData.recovered_from || checkoutSession.subscription_data?.recovered_from || '';\n      const recoveredFrom = recoveredFromId ? await Subscription.findByPk(recoveredFromId) : null;\n\n      const safeMetadata = {\n        ...(checkoutSession.subscription_data?.notification_settings\n          ? {\n              notification_settings: checkoutSession.subscription_data.notification_settings,\n            }\n          : {}),\n        ...omit(checkoutSession.metadata || {}, ['days_until_due', 'days_until_cancel', 'page_info']),\n        ...(itemsSubscriptionData.metadata || {}),\n        ...metadata,\n      };\n\n      const subscriptionData = {\n        ...checkoutSession.subscription_data,\n        ...itemsSubscriptionData,\n      };\n\n      const subscriptionBillingThresholds = billingThresholds || {\n        amount_gte: getBillingThreshold(subscriptionData),\n        stake_gte: getMinStakeAmount(subscriptionData),\n        reset_billing_cycle_anchor: false,\n        no_stake: subscriptionData.no_stake,\n      };\n\n      subscription = await Subscription.create({\n        livemode: !!checkoutSession.livemode,\n        currency_id: paymentCurrency.id,\n        customer_id: customer.id,\n        status: 'incomplete',\n        current_period_start: setup.period.start,\n        current_period_end: setup.period.end,\n        // FIXME: billing_cycle_anchor implementation is not aligned with stripe\n        billing_cycle_anchor: subscriptionData.billing_cycle_anchor || setup.cycle.anchor,\n        start_date: dayjs().unix(),\n        trial_end: setup.trial.end,\n        trial_start: setup.trial.start,\n        trial_settings: {\n          end_behavior: {\n            missing_payment_method: 'create_invoice',\n          },\n        },\n        billing_thresholds: subscriptionBillingThresholds,\n        pending_invoice_item_interval: setup.recurring,\n        pending_setup_intent: setupIntent?.id,\n        default_payment_method_id: paymentMethod.id,\n        cancel_at_period_end: false,\n        collection_method: 'charge_automatically',\n        description: subscriptionData.description || formatSubscriptionProduct(lineItems),\n        proration_behavior: subscriptionData.proration_behavior || 'none',\n        payment_behavior: 'default_incomplete',\n        days_until_due: subscriptionData.days_until_due,\n        days_until_cancel: subscriptionData.days_until_cancel,\n        recovered_from: recoveredFrom?.id,\n        metadata: safeMetadata,\n        service_actions: subscriptionData.service_actions || [],\n      });\n\n      logger.info('Subscription created', {\n        session: checkoutSession.id,\n        subscription: subscription.id,\n      });\n\n      // Create subscription items with item-specific metadata\n      await createSubscriptionItems(subscription.id, lineItems, checkoutSession, itemsSubscriptionData);\n    }\n\n    return subscription;\n  } catch (error) {\n    logger.error('Failed in createOrUpdateSubscription', {\n      existingSubscriptionId,\n      error: error.message,\n      stack: error.stack,\n      session: checkoutSession.id,\n    });\n    throw error;\n  }\n}\n\n/**\n * Creates subscription items for a subscription\n */\nasync function createSubscriptionItems(\n  subscriptionId: string,\n  lineItems: TLineItemExpanded[],\n  checkoutSession: CheckoutSession,\n  itemsSubscriptionData: Record<string, any>\n) {\n  try {\n    const metadata = {\n      ...(itemsSubscriptionData?.metadata || {}),\n      ...(checkoutSession.metadata || {}),\n    };\n\n    const subItems = await Promise.all(\n      lineItems.map((item) =>\n        SubscriptionItem.create({\n          livemode: !!checkoutSession.livemode,\n          subscription_id: subscriptionId,\n          price_id: item.upsell_price_id || item.price_id,\n          quantity: item.quantity,\n          metadata,\n        })\n      )\n    );\n\n    logger.info('Subscription items created', {\n      session: checkoutSession.id,\n      subscription: subscriptionId,\n      items: subItems.map((x) => x.id),\n    });\n\n    return subItems;\n  } catch (error) {\n    logger.error('Failed to create subscription items', {\n      subscriptionId,\n      error: error.message,\n      stack: error.stack,\n      session: checkoutSession.id,\n    });\n    throw error;\n  }\n}\n\n/**\n * Groups line items by price ID\n */\nfunction groupLineItemsByPrice(lineItems: TLineItemExpanded[]): Record<string, TLineItemExpanded[]> {\n  const groups: Record<string, TLineItemExpanded[]> = {};\n  const recurringLineItems = getRecurringLineItems(lineItems);\n\n  recurringLineItems.forEach((item) => {\n    const priceId = item.upsell_price_id || item.price_id;\n    if (!groups[priceId]) {\n      groups[priceId] = [];\n    }\n    groups[priceId].push(item);\n  });\n\n  return groups;\n}\n\nexport function getCheckoutSessionSubscriptionIds(checkoutSession: CheckoutSession) {\n  const enableGrouping = checkoutSession.enable_subscription_grouping;\n  if (!enableGrouping && checkoutSession.subscription_id) {\n    return [checkoutSession.subscription_id];\n  }\n  return Object.values(checkoutSession.subscription_groups || {}).filter(Boolean);\n}\n\nexport function getOneTimeLineItems(lineItems: TLineItemExpanded[]) {\n  return lineItems.filter((item) => item.price?.type === 'one_time');\n}\n\nexport function getRecurringLineItems(lineItems: TLineItemExpanded[]) {\n  return lineItems.filter((item) => item.price?.type === 'recurring');\n}\n\nexport function mergeSubscriptionDataFromLineItems(lineItems: TLineItemExpanded[]): Record<string, any> {\n  if (lineItems.length === 0) {\n    return {};\n  }\n  const mergedData: Record<string, any> = {};\n  const mergedMetadata: Record<string, any> = {};\n  lineItems.forEach((item: TLineItemExpanded) => {\n    const subData = (item.subscription_data || {}) as any;\n    if (subData.metadata) {\n      Object.assign(mergedMetadata, subData.metadata);\n    }\n    Object.entries(subData).forEach(([key, value]) => {\n      if (key !== 'metadata') {\n        mergedData[key] = value;\n      }\n    });\n  });\n\n  if (Object.keys(mergedMetadata).length > 0) {\n    mergedData.metadata = mergedMetadata;\n  }\n\n  return mergedData;\n}\n\n/**\n * Get line items related to a specific subscription\n * @param subscription The subscription object\n * @param lineItems All line items from checkout session\n * @param primarySubscription Optional primary subscription to check one-time items\n * @returns Line items associated with the subscription\n */\nexport async function getSubscriptionLineItems(\n  subscription: Subscription,\n  lineItems: TLineItemExpanded[],\n  primarySubscription?: Subscription\n): Promise<TLineItemExpanded[]> {\n  const subscriptionItems = await SubscriptionItem.findAll({\n    where: { subscription_id: subscription.id },\n  });\n\n  let subItems = lineItems.filter((x) =>\n    subscriptionItems.some((y) => y.price_id === x.price_id || y.price_id === x.upsell_price_id)\n  );\n\n  // Add one-time items if this is the primary subscription\n  if (primarySubscription && subscription.id === primarySubscription.id) {\n    subItems = [...subItems, ...getOneTimeLineItems(lineItems)];\n  }\n\n  return subItems;\n}\n\nexport function isCreditMetered(price: TPrice | TPriceExpanded) {\n  return price.type === 'recurring' && price.recurring?.usage_type === 'metered' && !!price.recurring?.meter_id;\n}\n\nexport function isCreditMeteredLineItems(lineItems: TLineItemExpanded[]) {\n  return lineItems.every((item) => item.price && isCreditMetered(item.price));\n}\n\nexport function validateStripePaymentAmounts(amount: string, currency: PaymentCurrency) {\n  const minAmountInUnits = fromTokenToUnit(0.5, currency.decimal);\n  return new BN(amount).gte(new BN(minAmountInUnits)); // 0.5 USD\n}\n\n/**\n * Validates payment amounts meet minimum requirements\n * @param lineItems Line items to validate\n * @param currencyId Currency ID for validation\n * @param mode Checkout mode\n * @returns Validation result with error message if any\n */\nexport async function validatePaymentAmounts(\n  lineItems: TLineItemExpanded[],\n  currency: PaymentCurrency,\n  checkoutSession: CheckoutSession\n): Promise<{ valid: boolean; error?: string }> {\n  const enableGrouping = checkoutSession.enable_subscription_grouping;\n  const oneTimeItems = getOneTimeLineItems(lineItems);\n  const recurringItems = getRecurringLineItems(lineItems);\n\n  // Check for mixed pricing types (fixed + dynamic)\n  const hasDynamicPricing = lineItems.some((item) => {\n    const price = item.upsell_price || item.price;\n    return (price as any)?.pricing_type === 'dynamic';\n  });\n\n  const hasFixedPricing = lineItems.some((item) => {\n    const price = item.upsell_price || item.price;\n    return !(price as any)?.pricing_type || (price as any)?.pricing_type === 'fixed';\n  });\n\n  if (hasDynamicPricing && hasFixedPricing) {\n    return {\n      valid: false,\n      error: 'Cannot mix fixed pricing and dynamic pricing in the same checkout session',\n    };\n  }\n\n  const minAmountInUnits = fromTokenToUnit(0.5, currency.decimal);\n\n  // Case 1: All one-time items - validate total payment amount\n  if (recurringItems.length === 0 && oneTimeItems.length > 0) {\n    const { total } = await getCheckoutAmount(lineItems, currency.id);\n    if (new BN(total).lt(new BN(minAmountInUnits))) {\n      return {\n        valid: false,\n        error: 'Total payment amount must be greater or equal to 0.5 USD',\n      };\n    }\n    return { valid: true };\n  }\n\n  // Case 2: Mixed or subscription only - validate subscription pricing\n  if (recurringItems.length > 0) {\n    if (enableGrouping) {\n      // When grouping is enabled, validate each subscription product's unit price\n      const priceGroups = groupLineItemsByPrice(lineItems);\n\n      for (const [priceId, items] of Object.entries(priceGroups)) {\n        // Calculate total unit price for this subscription product\n        let totalUnitPrice = new BN(0);\n\n        items.forEach((item) => {\n          const price = item.upsell_price || item.price;\n          const unitPrice = getPriceUintAmountByCurrency(price, currency.id);\n          totalUnitPrice = totalUnitPrice.add(new BN(unitPrice).mul(new BN(item.quantity)));\n        });\n\n        if (totalUnitPrice.lt(new BN(minAmountInUnits))) {\n          const productName = items[0]?.price?.product?.name || `Product ${priceId}`;\n          return {\n            valid: false,\n            error: `product \"${productName}\" unit price must be greater or equal to 0.5 USD`,\n          };\n        }\n      }\n    } else {\n      // When grouping is disabled, validate total subscription amount\n      const { renew } = await getCheckoutAmount(lineItems, currency.id);\n      if (new BN(renew).lt(new BN(minAmountInUnits))) {\n        return {\n          valid: false,\n          error: 'Total subscription amount must be greater or equal to 0.5 USD',\n        };\n      }\n    }\n  }\n\n  return { valid: true };\n}\n\n/**\n * Process discount application for checkout session data\n * Validates coupon existence and basic validity, calculates discount amounts\n * Customer-specific validations are done later during checkout submission\n */\nexport async function processCheckoutSessionDiscounts(\n  checkoutData: {\n    currency_id: string;\n    amount_total: string;\n    line_items?: any[];\n  },\n  discounts: Array<{ coupon: string }>\n): Promise<\n  Array<{\n    coupon: string;\n    verification_method: string;\n  }>\n> {\n  if (!discounts || !Array.isArray(discounts) || discounts.length === 0) {\n    return [];\n  }\n\n  // Get currency for discount calculations\n  const currency = await PaymentCurrency.findByPk(checkoutData.currency_id);\n  if (!currency) {\n    throw new Error('Currency not found');\n  }\n\n  const processedDiscounts: Array<{\n    coupon: string;\n    verification_method: string;\n  }> = [];\n\n  const expandedItems = await Price.expand(checkoutData.line_items || [], { product: true, upsell: true });\n\n  // Process discounts concurrently for better performance\n  const discountProcessingTasks = discounts.map((discountSpec, index) => async () => {\n    if (!discountSpec.coupon) {\n      throw new Error(`Coupon ID is required for discount at index ${index}`);\n    }\n\n    const coupon = await Coupon.findByPk(discountSpec.coupon);\n    if (!coupon) {\n      throw new Error(`Coupon '${discountSpec.coupon}' not found`);\n    }\n\n    // Validate coupon basic validity\n    const couponValidation = validCoupon(coupon, expandedItems as TLineItemExpanded[]);\n    if (!couponValidation.valid) {\n      throw new Error(`Coupon '${discountSpec.coupon}' is not valid: ${couponValidation.reason}`);\n    }\n    return {\n      coupon: coupon.id,\n      verification_method: 'direct',\n    };\n  });\n\n  const processedDiscountsArray = await pAll(discountProcessingTasks, { concurrency: 5 });\n  processedDiscounts.push(...processedDiscountsArray);\n\n  return processedDiscounts;\n}\n\n/**\n * Recalculate checkout session amounts with applied discounts\n */\nexport async function getCheckoutSessionAmounts(checkoutSession: CheckoutSession) {\n  const { discounts } = checkoutSession;\n\n  // Ensure we always have safe default values\n  const safeSubtotal = checkoutSession.amount_subtotal || '0';\n  const safeTotal = checkoutSession.amount_total || '0';\n  const safeTotalDetails = checkoutSession.total_details || {\n    amount_discount: '0',\n    amount_shipping: '0',\n    amount_tax: '0',\n  };\n\n  // If no discounts, return current amounts with safe defaults\n  if (!discounts || discounts.length === 0) {\n    return {\n      amount_subtotal: safeSubtotal,\n      amount_total: safeTotal,\n      total_details: {\n        amount_discount: safeTotalDetails.amount_discount || '0',\n        amount_shipping: safeTotalDetails.amount_shipping || '0',\n        amount_tax: safeTotalDetails.amount_tax || '0',\n      },\n    };\n  }\n\n  const originalTotal = safeTotal;\n  let totalDiscountAmount = new BN('0');\n\n  // Calculate discount for each coupon\n  const discountPromises = discounts.map(async (discount) => {\n    if (!discount.coupon) {\n      return new BN('0');\n    }\n\n    const coupon = await Coupon.findByPk(discount.coupon);\n\n    if (!coupon || !coupon.valid) {\n      return new BN('0');\n    }\n\n    let discountAmount = new BN('0');\n    const baseAmount = new BN(originalTotal);\n\n    if (coupon.percent_off > 0) {\n      // Percentage discount\n      discountAmount = baseAmount.mul(new BN(coupon.percent_off)).div(new BN(100));\n    } else if (coupon.amount_off && new BN(coupon.amount_off).gt(new BN('0'))) {\n      // Fixed amount discount\n      discountAmount = new BN(coupon.amount_off);\n    }\n\n    // Ensure discount doesn't exceed original amount\n    if (discountAmount.gt(baseAmount)) {\n      discountAmount = baseAmount;\n    }\n\n    return discountAmount;\n  });\n\n  const discountAmounts = await Promise.all(discountPromises);\n  totalDiscountAmount = discountAmounts.reduce((sum: BN, amount: BN) => sum.add(amount), new BN('0'));\n\n  // Ensure total discount doesn't exceed original amount\n  if (totalDiscountAmount.gt(new BN(originalTotal))) {\n    totalDiscountAmount = new BN(originalTotal);\n  }\n\n  const finalTotal = new BN(originalTotal).sub(totalDiscountAmount);\n  // Ensure total doesn't go below 0\n  const adjustedTotal = finalTotal.lt(new BN('0')) ? '0' : finalTotal.toString();\n\n  return {\n    amount_subtotal: safeSubtotal,\n    amount_total: adjustedTotal,\n    total_details: {\n      amount_discount: totalDiscountAmount.toString(),\n      amount_shipping: safeTotalDetails.amount_shipping || '0',\n      amount_tax: safeTotalDetails.amount_tax || '0',\n    },\n    discounts,\n  };\n}\n\nconst USD_DECIMALS = 8;\nconst QUOTE_LOCK_DURATION_SECONDS = 180;\nfunction calculateTotalBaseAmount(baseAmount: string, quantity: number): string {\n  const baseAmountBN = fromTokenToUnit(trimDecimals(baseAmount, USD_DECIMALS), USD_DECIMALS);\n  const quantityBN = new BN(quantity);\n  const totalBaseAmountBN = baseAmountBN.mul(quantityBN);\n  return fromUnitToToken(totalBaseAmountBN.toString(), USD_DECIMALS);\n}\n\n/**\n * Enrich checkout session with dynamic pricing quotes\n * For each dynamic price, create or reuse a quote and attach quote info to line items\n *\n * @param options.skipGeneration - If true, only fetch existing quotes via quote_id, don't generate new ones\n */\nexport async function enrichCheckoutSessionWithQuotes(\n  checkoutSession: CheckoutSession,\n  lineItems: TLineItemExpanded[],\n  currencyId: string,\n  options: { skipGeneration?: boolean; forceRefresh?: boolean } = {}\n): Promise<{\n  lineItems: TLineItemExpanded[];\n  quotes: Record<\n    string,\n    {\n      quote_id: string;\n      expires_at: number;\n      quoted_amount: string;\n      exchange_rate?: string;\n      rate_provider_name?: string;\n      rate_provider_id?: string;\n    }\n  >;\n  rateUnavailable?: boolean;\n  rateError?: string;\n  regenerated?: boolean;\n  refreshed?: boolean;\n}> {\n  const { skipGeneration = false, forceRefresh = false } = options;\n  const quoteService = getQuoteService();\n\n  const quotes: Record<\n    string,\n    {\n      quote_id: string;\n      expires_at: number;\n      quoted_amount: string;\n      exchange_rate: string;\n      rate_provider_name: string;\n      rate_provider_id: string;\n    }\n  > = {};\n\n  // First, check if line_items already have quote_id references\n  // If so, fetch quote data from PriceQuote table and check if expired\n  const lineItemsWithQuoteIds = lineItems.filter((item) => (item as any).quote_id);\n  const now = Math.floor(Date.now() / 1000);\n  const quoteLockedAt = checkoutSession.metadata?.quote_locked_at;\n  const lockStart =\n    typeof quoteLockedAt === 'number'\n      ? quoteLockedAt\n      : typeof quoteLockedAt === 'string'\n        ? Number(quoteLockedAt)\n        : null;\n  const lockActive = Number.isFinite(lockStart) && now - (lockStart as number) < QUOTE_LOCK_DURATION_SECONDS;\n  const slippagePercentValue = Number((checkoutSession as any).slippage_percent);\n  const slippagePercent = Number.isFinite(slippagePercentValue) ? slippagePercentValue : 0.5;\n  const quotesById = new Map<string, PriceQuote>();\n  const refreshQuoteIds = new Set<string>();\n  let hasExpiredQuotes = false;\n  let hasStaleQuotes = false;\n  let hasMissingQuotes = false;\n  let regenerated = false;\n  let createdNewQuotes = false;\n  const applyQuoteToItem = (item: TLineItemExpanded, quote: PriceQuote) => {\n    (item as any).custom_amount = quote.quoted_amount;\n    (item as any).quoted_amount = quote.quoted_amount;\n    (item as any).quote_id = quote.id;\n    (item as any).exchange_rate = quote.exchange_rate;\n    (item as any).rate_provider_name = quote.rate_provider_name;\n    (item as any).rate_provider_id = quote.rate_provider_id;\n    (item as any).rate_timestamp_ms = quote.rate_timestamp_ms;\n    (item as any).expires_at = quote.expires_at;\n\n    const quoteKey = `${item.price.id}_${currencyId}`;\n    quotes[quoteKey] = {\n      quote_id: quote.id,\n      expires_at: quote.expires_at,\n      quoted_amount: quote.quoted_amount,\n      exchange_rate: quote.exchange_rate,\n      rate_provider_name: quote.rate_provider_name,\n      rate_provider_id: quote.rate_provider_id,\n    };\n  };\n\n  if (lineItemsWithQuoteIds.length > 0) {\n    const quoteIds = Array.from(new Set(lineItemsWithQuoteIds.map((item) => (item as any).quote_id).filter(Boolean)));\n    const existingQuotes = await PriceQuote.findAll({\n      where: { id: quoteIds },\n    });\n\n    existingQuotes.forEach((quote) => {\n      quotesById.set(quote.id, quote);\n    });\n    if (existingQuotes.length !== quoteIds.length) {\n      hasMissingQuotes = true;\n      logger.warn('Some quote references are missing from database', {\n        sessionId: checkoutSession.id,\n        totalQuoteIds: quoteIds.length,\n        foundQuotes: existingQuotes.length,\n      });\n    }\n\n    lineItemsWithQuoteIds.forEach((item) => {\n      const quoteId = (item as any).quote_id;\n      const quote = quotesById.get(quoteId);\n      if (!quote) {\n        if (!skipGeneration) {\n          refreshQuoteIds.add(quoteId);\n        }\n        return;\n      }\n\n      const isCommitted = quote.status === 'used' || quote.status === 'paid';\n      if (isCommitted) {\n        applyQuoteToItem(item, quote);\n        return;\n      }\n\n      if (forceRefresh && !skipGeneration) {\n        if (!lockActive) {\n          refreshQuoteIds.add(quoteId);\n          logger.info('Force refresh quote for checkout session', {\n            sessionId: checkoutSession.id,\n            quoteId,\n          });\n        } else {\n          logger.info('Skip force refresh due to active quote lock', {\n            sessionId: checkoutSession.id,\n            quoteId,\n          });\n        }\n        return;\n      }\n\n      const price = (item.upsell_price || item.price) as any;\n      if (\n        !skipGeneration &&\n        !lockActive &&\n        quote.status !== 'paid' &&\n        price?.pricing_type === 'dynamic' &&\n        price?.base_amount\n      ) {\n        const expectedBaseAmount = calculateTotalBaseAmount(price.base_amount, Number(item.quantity || 0));\n        const expectedTrimmed = trimDecimals(expectedBaseAmount, USD_DECIMALS);\n        const quoteTrimmed = trimDecimals(quote.base_amount || '0', USD_DECIMALS);\n        if (quoteTrimmed !== expectedTrimmed) {\n          hasStaleQuotes = true;\n          refreshQuoteIds.add(quoteId);\n          logger.info('Detected quote base_amount mismatch, will refresh quote', {\n            sessionId: checkoutSession.id,\n            quoteId,\n            priceId: item.price_id || item.price?.id,\n            expectedBaseAmount: expectedTrimmed,\n            quoteBaseAmount: quoteTrimmed,\n            quantity: item.quantity,\n          });\n          return;\n        }\n      }\n\n      const isExpired = quote.status !== 'paid' && (quote.expires_at < now || quote.status === 'expired');\n      if (!skipGeneration && !lockActive && isExpired) {\n        hasExpiredQuotes = true;\n        refreshQuoteIds.add(quoteId);\n        logger.info('Detected expired quote', {\n          sessionId: checkoutSession.id,\n          expiredQuoteId: quote.id,\n          expiresAt: new Date(quote.expires_at * 1000).toISOString(),\n          now: new Date(now * 1000).toISOString(),\n        });\n        return;\n      }\n\n      const isInactive = quote.status !== 'active' && quote.status !== 'paid';\n      if (!skipGeneration && !lockActive && isInactive) {\n        hasExpiredQuotes = true;\n        refreshQuoteIds.add(quoteId);\n        logger.info('Detected inactive quote, will refresh', {\n          sessionId: checkoutSession.id,\n          quoteId: quote.id,\n          status: quote.status,\n        });\n        return;\n      }\n\n      // Use existing quotes (either not expired, or skipGeneration)\n      applyQuoteToItem(item, quote);\n    });\n\n    logger.info('Processed existing quotes from database', {\n      sessionId: checkoutSession.id,\n      totalQuoteIds: lineItemsWithQuoteIds.length,\n      foundQuotes: quotesById.size,\n      hasExpiredQuotes,\n      hasStaleQuotes,\n      hasMissingQuotes,\n      skipGeneration,\n      refreshQuotes: refreshQuoteIds.size,\n    });\n\n    if (skipGeneration || refreshQuoteIds.size === 0) {\n      return { lineItems, quotes, refreshed: false };\n    }\n  }\n\n  // Find all dynamic pricing items that need new quotes or refresh\n  const dynamicItems = lineItems.filter(\n    (item) =>\n      item.price.pricing_type === 'dynamic' &&\n      ((item as any).quote_id ? refreshQuoteIds.has((item as any).quote_id) : true)\n  );\n\n  // If no dynamic items need new quotes, return early\n  if (dynamicItems.length === 0) {\n    return { lineItems, quotes, refreshed: false };\n  }\n\n  // If skipGeneration is enabled, don't generate new quotes for items without quote_id\n  // This is used for submitted/completed checkout sessions where we only want to use existing quotes\n  if (skipGeneration) {\n    logger.info('Skipping quote generation for dynamic items (skipGeneration enabled)', {\n      sessionId: checkoutSession.id,\n      dynamicItemsWithoutQuotes: dynamicItems.length,\n    });\n    return { lineItems, quotes, refreshed: false };\n  }\n\n  // Fetch exchange rate once for all dynamic items (they all use the same target currency)\n  const currency = (await PaymentCurrency.findByPk(currencyId, {\n    include: [{ model: PaymentMethod, as: 'payment_method' }],\n  })) as PaymentCurrency & { payment_method: PaymentMethod };\n  if (!currency) {\n    throw new Error(`Currency ${currencyId} not found`);\n  }\n\n  if (currency.payment_method?.type === 'stripe') {\n    return { lineItems, quotes, refreshed: false };\n  }\n\n  const exchangeRateService = getExchangeRateService();\n\n  // Try to get exchange rate, but don't block checkout if unavailable\n  let rateResult;\n  try {\n    // For ArcBlock payment method, always use ABT for exchange rate\n    // For other methods, use the currency's symbol\n    const rateSymbol = getExchangeRateSymbol(currency.symbol, currency.payment_method?.type as ChainType);\n    rateResult = await exchangeRateService.getRate(rateSymbol);\n  } catch (error: any) {\n    logger.warn('Exchange rate unavailable for checkout session', {\n      checkoutSessionId: checkoutSession.id,\n      currencyId,\n      currencySymbol: currency.symbol,\n      error: error.message,\n    });\n\n    // Return without quotes, frontend will show warning\n    return {\n      lineItems,\n      quotes: {},\n      rateUnavailable: true,\n      rateError: error.message || 'Exchange rate service unavailable',\n      refreshed: false,\n    };\n  }\n\n  logger.info('Fetched exchange rate for batch quote creation', {\n    currencyId,\n    currencySymbol: currency.symbol,\n    rate: rateResult.rate,\n    provider: rateResult.provider_name,\n    dynamicItemsCount: dynamicItems.length,\n  });\n\n  // Create or refresh quotes for dynamic items using the same exchange rate\n  const quoteResults = await Promise.all(\n    dynamicItems.map(async (item) => {\n      const { price, quantity } = item;\n\n      try {\n        const quoteId = (item as any).quote_id;\n        let quoteResponse: QuoteResponse;\n\n        if (quoteId && quotesById.get(quoteId)) {\n          quoteResponse = await quoteService.refreshQuoteWithRate({\n            quote_id: quoteId,\n            price_id: price.id,\n            session_id: checkoutSession.id,\n            target_currency_id: currencyId,\n            quantity,\n            rateResult,\n            slippage_percent: slippagePercent,\n          });\n        } else {\n          quoteResponse = await quoteService.createQuoteWithRate({\n            price_id: price.id,\n            session_id: checkoutSession.id,\n            target_currency_id: currencyId,\n            quantity,\n            rateResult,\n            slippage_percent: slippagePercent,\n          });\n          createdNewQuotes = true;\n        }\n\n        return {\n          item,\n          quoteResponse,\n        };\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        logger.error('Failed to create quote for dynamic price', {\n          priceId: price.id,\n          checkoutSessionId: checkoutSession.id,\n          currencyId,\n          errorMessage,\n          errorName: (error as any)?.name,\n        });\n        throw error;\n      }\n    })\n  );\n\n  // Build quote map for quick lookup\n  const quoteByPriceId = new Map<string, (typeof quoteResults)[0]>();\n  quoteResults.forEach((result) => {\n    quoteByPriceId.set(result.item.price.id, result);\n  });\n\n  // Extract quote info helper\n  const extractQuoteInfo = (quoteResponse: QuoteResponse) => ({\n    quote_id: quoteResponse.quote.id,\n    expires_at: quoteResponse.expires_at,\n    quoted_amount: quoteResponse.computed_unit_amount,\n    exchange_rate: quoteResponse.quote.exchange_rate,\n    rate_provider_name: quoteResponse.quote.rate_provider_name,\n    rate_provider_id: quoteResponse.quote.rate_provider_id,\n    rate_timestamp_ms: quoteResponse.quote.rate_timestamp_ms,\n  });\n\n  // Build quotes object\n  quoteResults.forEach((result) => {\n    const quoteKey = `${result.item.price.id}_${currencyId}`;\n    quotes[quoteKey] = extractQuoteInfo(result.quoteResponse);\n  });\n\n  regenerated = createdNewQuotes;\n  const refreshed = refreshQuoteIds.size > 0 || createdNewQuotes;\n\n  // Enrich line items with quote information\n  const enrichedLineItems = lineItems.map((item) => {\n    const quoteInfo = quoteByPriceId.get(item.price.id);\n    if (!quoteInfo) {\n      return item;\n    }\n\n    const quoteData = extractQuoteInfo(quoteInfo.quoteResponse);\n    return {\n      ...item,\n      ...quoteData,\n      custom_amount: quoteInfo.quoteResponse.computed_unit_amount,\n    };\n  });\n\n  return {\n    lineItems: enrichedLineItems,\n    quotes,\n    regenerated,\n    refreshed,\n  };\n}\n","numLines":1724,"startLine":1,"totalLines":1724}}}
{"parentUuid":"d54aca07-77cb-4d5f-ba01-c062d2aace7e","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"File content (43826 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content.","is_error":true,"tool_use_id":"toolu_01PvUStCKG3s9YFwZmyqceBi"}]},"uuid":"ead430b2-37bb-4bcc-90a5-23d9470de045","timestamp":"2026-01-12T15:03:15.807Z","toolUseResult":"Error: File content (43826 tokens) exceeds maximum allowed tokens (25000). Please use offset and limit parameters to read specific portions of the file, or use the GrepTool to search for specific content."}
{"parentUuid":"ead430b2-37bb-4bcc-90a5-23d9470de045","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Cwt5PxySRJRSeZXYKDuHAF","type":"tool_result","content":"     1→/* eslint-disable @typescript-eslint/indent */\n     2→import { useLocaleContext } from '@arcblock/ux/lib/Locale/context';\n     3→import type {\n     4→  DonationSettings,\n     5→  TCheckoutSession,\n     6→  TLineItemExpanded,\n     7→  TPaymentCurrency,\n     8→  TPaymentIntent,\n     9→  TPaymentMethodExpanded,\n    10→} from '@blocklet/payment-types';\n    11→import { HelpOutline, Close, LocalOffer } from '@mui/icons-material';\n    12→import { Box, Divider, Fade, Grow, Stack, Tooltip, Typography, Collapse, IconButton, Button } from '@mui/material';\n    13→import type { IconButtonProps } from '@mui/material';\n    14→import { BN, fromTokenToUnit, fromUnitToToken } from '@ocap/util';\n    15→import { useRequest, useSetState } from 'ahooks';\n    16→import noop from 'lodash/noop';\n    17→import useBus from 'use-bus';\n    18→import ExpandMoreIcon from '@mui/icons-material/ExpandMore';\n    19→import { styled } from '@mui/material/styles';\n    20→import { useEffect, useMemo, useRef, useState } from 'react';\n    21→import Status from '../components/status';\n    22→import api from '../libs/api';\n    23→import {\n    24→  formatAmount,\n    25→  formatCheckoutHeadlines,\n    26→  getPriceUintAmountByCurrency,\n    27→  formatCouponTerms,\n    28→  formatNumber,\n    29→  formatDynamicPrice,\n    30→  findCurrency,\n    31→  formatExchangeRate,\n    32→  formatToDatetime,\n    33→  formatUsdAmount,\n    34→  getUsdAmountFromBaseAmount,\n    35→  getUsdAmountFromTokenUnits,\n    36→} from '../libs/util';\n    37→import PaymentAmount from './amount';\n    38→import ProductDonation from './product-donation';\n    39→import ProductItem from './product-item';\n    40→import Livemode from '../components/livemode';\n    41→import QuoteDetailsPanel from '../components/quote-details-panel';\n    42→import { usePaymentContext } from '../contexts/payment';\n    43→import { useMobile } from '../hooks/mobile';\n    44→import LoadingButton from '../components/loading-button';\n    45→import PromotionCode from '../components/promotion-code';\n    46→import DynamicPricingUnavailable from '../components/dynamic-pricing-unavailable';\n    47→\n    48→// const shake = keyframes`\n    49→//   0% {\n    50→//     transform: rotate(0deg);\n    51→//   }\n    52→//   25% {\n    53→//     transform: rotate(2deg);\n    54→//   }\n    55→//   50% {\n    56→//     transform: rotate(0eg);\n    57→//   }\n    58→//   75% {\n    59→//     transform: rotate(-2deg);\n    60→//   }\n    61→//   100% {\n    62→//     transform: rotate(0deg);\n    63→//   }\n    64→// `;\n    65→\n    66→interface ExpandMoreProps extends IconButtonProps {\n    67→  expand: boolean;\n    68→}\n    69→\n    70→const ExpandMore = styled((props: ExpandMoreProps) => {\n    71→  const { expand, ...other } = props;\n    72→  return <IconButton {...other} />;\n    73→})(({ theme, expand }) => ({\n    74→  transform: !expand ? 'rotate(0deg)' : 'rotate(180deg)',\n    75→  marginLeft: 'auto',\n    76→  transition: theme.transitions.create('transform', {\n    77→    duration: theme.transitions.duration.shortest,\n    78→  }),\n    79→}));\n    80→\n    81→const USD_ANCHOR_DECIMALS = 8;\n    82→\n    83→type Props = {\n    84→  items: TLineItemExpanded[];\n    85→  currency: TPaymentCurrency;\n    86→  trialInDays: number;\n    87→  trialEnd?: number;\n    88→  billingThreshold: number;\n    89→  showStaking?: boolean;\n    90→  onUpsell?: Function;\n    91→  onDownsell?: Function;\n    92→  onQuantityChange?: Function;\n    93→  onChangeAmount?: Function;\n    94→  onApplyCrossSell?: Function;\n    95→  onCancelCrossSell?: Function;\n    96→  checkoutSessionId?: string;\n    97→  crossSellBehavior?: string;\n    98→  donationSettings?: DonationSettings; // only include backend part\n    99→  action?: string;\n   100→  completed?: boolean;\n   101→  checkoutSession?: TCheckoutSession;\n   102→  paymentIntent?: TPaymentIntent | null;\n   103→  onPromotionUpdate?: () => void;\n   104→  paymentMethods?: TPaymentMethodExpanded[];\n   105→  showFeatures?: boolean;\n   106→  rateUnavailable?: boolean; // Flag for exchange rate unavailability\n   107→  rateError?: string; // Error message when rate is unavailable\n   108→  onQuoteExpired?: (forceRefresh?: boolean) => void;\n   109→  liveRate?: {\n   110→    rate?: string;\n   111→    provider_id?: string;\n   112→    provider_name?: string;\n   113→    base_currency?: string;\n   114→    timestamp_ms?: number;\n   115→  };\n   116→};\n   117→\n   118→async function fetchCrossSell(id: string, skipError = true) {\n   119→  try {\n   120→    const { data } = await api.get(`/api/checkout-sessions/${id}/cross-sell?skipError=${skipError}`);\n   121→    if (!data.error) {\n   122→      return data;\n   123→    }\n   124→\n   125→    return null;\n   126→  } catch (err) {\n   127→    return null;\n   128→  }\n   129→}\n   130→\n   131→function getStakingSetup(items: TLineItemExpanded[], currency: TPaymentCurrency, billingThreshold = 0) {\n   132→  const staking = {\n   133→    licensed: new BN(0),\n   134→    metered: new BN(0),\n   135→  };\n   136→\n   137→  const recurringItems = items\n   138→    .map((x) => x.upsell_price || x.price)\n   139→    .filter((x) => x.type === 'recurring' && x.recurring);\n   140→\n   141→  if (recurringItems.length > 0) {\n   142→    if (+billingThreshold) {\n   143→      return fromTokenToUnit(billingThreshold, currency.decimal).toString();\n   144→    }\n   145→\n   146→    items.forEach((x) => {\n   147→      const price = x.upsell_price || x.price;\n   148→      const unit = getPriceUintAmountByCurrency(price, currency);\n   149→      const amount = new BN(unit).mul(new BN(x.quantity));\n   150→      if (price.type === 'recurring' && price.recurring) {\n   151→        if (price.recurring.usage_type === 'licensed') {\n   152→          staking.licensed = staking.licensed.add(amount);\n   153→        }\n   154→        if (price.recurring.usage_type === 'metered') {\n   155→          staking.metered = staking.metered.add(amount);\n   156→        }\n   157→      }\n   158→    });\n   159→\n   160→    return staking.licensed.add(staking.metered).toString();\n   161→  }\n   162→\n   163→  return '0';\n   164→}\n   165→\n   166→export default function PaymentSummary({\n   167→  items,\n   168→  currency,\n   169→  trialInDays,\n   170→  billingThreshold,\n   171→  onUpsell = noop,\n   172→  onDownsell = noop,\n   173→  onQuantityChange = noop,\n   174→  onApplyCrossSell = noop,\n   175→  onCancelCrossSell = noop,\n   176→  onChangeAmount = noop,\n   177→  checkoutSessionId = '',\n   178→  crossSellBehavior = '',\n   179→  showStaking = false,\n   180→  donationSettings = undefined,\n   181→  action = '',\n   182→  trialEnd = 0,\n   183→  completed = false,\n   184→  checkoutSession = undefined,\n   185→  paymentIntent = undefined,\n   186→  paymentMethods = [],\n   187→  onPromotionUpdate = noop,\n   188→  showFeatures = false,\n   189→  rateUnavailable = false,\n   190→  rateError = undefined,\n   191→  onQuoteExpired = undefined,\n   192→  liveRate = undefined,\n   193→  ...rest\n   194→}: Props) {\n   195→  const { t, locale } = useLocaleContext();\n   196→  const { isMobile } = useMobile();\n   197→  const { paymentState, ...settings } = usePaymentContext();\n   198→  const [state, setState] = useSetState({ loading: false, shake: false, expanded: items?.length < 3 });\n   199→  const { data, runAsync } = useRequest((skipError) =>\n   200→    checkoutSessionId ? fetchCrossSell(checkoutSessionId, skipError) : Promise.resolve(null)\n   201→  );\n   202→\n   203→  const sessionDiscounts = (checkoutSession as any)?.discounts || [];\n   204→  const allowPromotionCodes = !!checkoutSession?.allow_promotion_codes;\n   205→  const hasDiscounts = sessionDiscounts?.length > 0;\n   206→\n   207→  const discountCurrency =\n   208→    paymentMethods && checkoutSession\n   209→      ? (findCurrency(\n   210→          paymentMethods as TPaymentMethodExpanded[],\n   211→          hasDiscounts ? checkoutSession?.currency_id || currency.id : (currency.id as string)\n   212→        ) as TPaymentCurrency) || settings.settings?.baseCurrency\n   213→      : currency;\n   214→\n   215→  const hasDynamicPricing = useMemo(\n   216→    () => items.some((item) => ((item.upsell_price || item.price) as any)?.pricing_type === 'dynamic'),\n   217→    [items]\n   218→  );\n   219→\n   220→  const headlines = formatCheckoutHeadlines(items, discountCurrency, { trialEnd, trialInDays }, locale);\n   221→  const staking = showStaking ? getStakingSetup(items, discountCurrency, billingThreshold) : '0';\n   222→  const headlineAmountDisplay = useMemo(() => {\n   223→    if (!hasDynamicPricing) {\n   224→      return headlines.amount;\n   225→    }\n   226→    if (!headlines.amount.includes(discountCurrency.symbol)) {\n   227→      return headlines.amount;\n   228→    }\n   229→    const formatted = formatDynamicPrice(headlines.actualAmount, true, 6);\n   230→    return `${formatted} ${discountCurrency.symbol}`;\n   231→  }, [headlines.amount, headlines.actualAmount, discountCurrency.symbol, hasDynamicPricing]);\n   232→\n   233→  const getAppliedPromotionCodes = () => {\n   234→    if (!sessionDiscounts?.length) return [];\n   235→\n   236→    return sessionDiscounts.map((discount: any) => ({\n   237→      id: discount.promotion_code || discount.coupon,\n   238→      code: discount.verification_data?.code || 'APPLIED',\n   239→      discount_amount: discount.discount_amount,\n   240→    }));\n   241→  };\n   242→\n   243→  const handlePromotionUpdate = () => {\n   244→    onPromotionUpdate?.();\n   245→  };\n   246→\n   247→  const handleRemovePromotion = async (sessionId: string) => {\n   248→    // Prevent removing promotion during payment process\n   249→    if (paymentState.paying || paymentState.stripePaying) {\n   250→      return;\n   251→    }\n   252→    try {\n   253→      await api.delete(`/api/checkout-sessions/${sessionId}/remove-promotion`);\n   254→      onPromotionUpdate?.();\n   255→    } catch (err: any) {\n   256→      console.error('Failed to remove promotion code:', err);\n   257→    }\n   258→  };\n   259→\n   260→  const discountAmount = new BN(checkoutSession?.total_details?.amount_discount || '0');\n   261→\n   262→  const subtotalAmountUnit = new BN(fromTokenToUnit(headlines.actualAmount, discountCurrency?.decimal))\n   263→    .add(new BN(staking))\n   264→    .toString();\n   265→  const subtotalAmount = fromUnitToToken(subtotalAmountUnit, discountCurrency?.decimal);\n   266→\n   267→  const totalAmountUnit = new BN(subtotalAmountUnit).sub(discountAmount).toString();\n   268→  const totalAmountValue = fromUnitToToken(totalAmountUnit, discountCurrency?.decimal);\n   269→  const totalAmount = formatDynamicPrice(totalAmountValue, hasDynamicPricing, 6);\n   270→  const subtotalDisplay = formatDynamicPrice(subtotalAmount, hasDynamicPricing, 6);\n   271→\n   272→  const quoteMeta = useMemo(() => {\n   273→    if (!items?.length || !hasDynamicPricing) {\n   274→      return null;\n   275→    }\n   276→    let exchangeRate: string | null = null;\n   277→    let baseCurrency: string | null = null;\n   278→    let expiresAt: number | null = null;\n   279→    let providerName: string | null = null;\n   280→    let providerId: string | null = null;\n   281→    let rateTimestampMs: number | null = null;\n   282→    let slippagePercent: number | null = null;\n   283→\n   284→    items.forEach((item) => {\n   285→      const price = item.upsell_price || item.price;\n   286→      const rate = (item as any)?.exchange_rate;\n   287→      if (!exchangeRate && rate) {\n   288→        exchangeRate = rate;\n   289→      }\n   290→      const base = (price as any)?.base_currency;\n   291→      if (!baseCurrency && base) {\n   292→        baseCurrency = base;\n   293→      }\n   294→      const expires = (item as any)?.expires_at;\n   295→      if (expires) {\n   296→        expiresAt = expiresAt === null ? expires : Math.min(expiresAt, expires);\n   297→      }\n   298→      const itemProviderName = (item as any)?.rate_provider_name;\n   299→      if (!providerName && itemProviderName) {\n   300→        providerName = itemProviderName;\n   301→      }\n   302→      const itemProviderId = (item as any)?.rate_provider_id;\n   303→      if (!providerId && itemProviderId) {\n   304→        providerId = itemProviderId;\n   305→      }\n   306→      const itemRateTimestamp = (item as any)?.rate_timestamp_ms;\n   307→      if (!rateTimestampMs && Number.isFinite(Number(itemRateTimestamp))) {\n   308→        rateTimestampMs = Number(itemRateTimestamp);\n   309→      }\n   310→      const itemSlippage = (item as any)?.slippage_percent;\n   311→      if (slippagePercent === null && Number.isFinite(Number(itemSlippage))) {\n   312→        slippagePercent = Number(itemSlippage);\n   313→      }\n   314→    });\n   315→\n   316→    return {\n   317→      exchangeRate,\n   318→      baseCurrency: baseCurrency || 'USD',\n   319→      expiresAt,\n   320→      providerName,\n   321→      providerId,\n   322→      rateTimestampMs,\n   323→      slippagePercent,\n   324→    };\n   325→  }, [items, hasDynamicPricing]);\n   326→  const rateInfo = useMemo(\n   327→    () => ({\n   328→      exchangeRate: liveRate?.rate || quoteMeta?.exchangeRate || null,\n   329→      baseCurrency: liveRate?.base_currency || quoteMeta?.baseCurrency || 'USD',\n   330→      providerName: liveRate?.provider_name || quoteMeta?.providerName || null,\n   331→      providerId: liveRate?.provider_id || quoteMeta?.providerId || null,\n   332→      timestampMs: liveRate?.timestamp_ms || quoteMeta?.rateTimestampMs || null,\n   333→    }),\n   334→    [liveRate, quoteMeta]\n   335→  );\n   336→  const rateDisplay = useMemo(() => {\n   337→    if (!rateInfo.exchangeRate) {\n   338→      return null;\n   339→    }\n   340→    const formattedRate = formatExchangeRate(rateInfo.exchangeRate);\n   341→    if (!formattedRate) {\n   342→      return null;\n   343→    }\n   344→    if (rateInfo.baseCurrency === 'USD') {\n   345→      return `$${formattedRate}`;\n   346→    }\n   347→    return `${formattedRate} ${rateInfo.baseCurrency}`;\n   348→  }, [rateInfo]);\n   349→\n   350→  const quoteLockedAt = useMemo(() => {\n   351→    if (paymentIntent?.quote_locked_at) {\n   352→      const lockedAtMs = new Date(paymentIntent.quote_locked_at).getTime();\n   353→      if (Number.isFinite(lockedAtMs)) {\n   354→        return Math.floor(lockedAtMs / 1000);\n   355→      }\n   356→    }\n   357→    const metaLockedAt = checkoutSession?.metadata?.quote_locked_at;\n   358→    if (typeof metaLockedAt === 'number') {\n   359→      return metaLockedAt;\n   360→    }\n   361→    if (typeof metaLockedAt === 'string') {\n   362→      const parsed = Number(metaLockedAt);\n   363→      if (Number.isFinite(parsed)) {\n   364→        return parsed;\n   365→      }\n   366→    }\n   367→    return null;\n   368→  }, [paymentIntent?.quote_locked_at, checkoutSession?.metadata?.quote_locked_at]);\n   369→\n   370→  const expiredHandledRef = useRef(false);\n   371→  const [quoteRefreshing, setQuoteRefreshing] = useState(false);\n   372→\n   373→  // Check if quote is expired (no timer needed, static check)\n   374→  useEffect(() => {\n   375→    if (completed || expiredHandledRef.current) {\n   376→      return;\n   377→    }\n   378→    const currentTime = Math.floor(Date.now() / 1000);\n   379→    const quoteRemaining = quoteMeta?.expiresAt ? Math.max(0, quoteMeta.expiresAt - currentTime) : 0;\n   380→    const lockRemaining = quoteLockedAt ? Math.max(0, quoteLockedAt + 180 - currentTime) : 0;\n   381→    const hasExpiry = !!quoteMeta?.expiresAt;\n   382→\n   383→    const lockActive = lockRemaining > 0;\n   384→    if (hasExpiry && !lockActive && quoteRemaining <= 0) {\n   385→      expiredHandledRef.current = true;\n   386→      onQuoteExpired?.();\n   387→    }\n   388→  }, [quoteMeta?.expiresAt, quoteLockedAt, completed, onQuoteExpired]);\n   389→\n   390→  const handleQuoteRefresh = async () => {\n   391→    if (!onQuoteExpired || quoteRefreshing) {\n   392→      return;\n   393→    }\n   394→    setQuoteRefreshing(true);\n   395→    try {\n   396→      await onQuoteExpired(true);\n   397→    } finally {\n   398→      setQuoteRefreshing(false);\n   399→    }\n   400→  };\n   401→\n   402→  const itemUsdReferences = useMemo(() => {\n   403→    if (!hasDynamicPricing) {\n   404→      return [];\n   405→    }\n   406→    return items.map((item) => {\n   407→      const price = item.upsell_price || item.price;\n   408→      const baseAmount = (price as any)?.base_amount;\n   409→      const hasBaseAmount = baseAmount !== undefined && baseAmount !== null;\n   410→      if (hasBaseAmount) {\n   411→        return getUsdAmountFromBaseAmount(baseAmount, item.quantity || 0);\n   412→      }\n   413→      const exchangeRate = (item as any)?.exchange_rate;\n   414→      const quotedAmount = (item as any)?.quoted_amount;\n   415→      if (!exchangeRate || !quotedAmount) {\n   416→        return null;\n   417→      }\n   418→      return getUsdAmountFromTokenUnits(new BN(quotedAmount), discountCurrency.decimal, exchangeRate);\n   419→    });\n   420→  }, [items, discountCurrency, hasDynamicPricing]);\n   421→  const totalUsdFromItems = useMemo(() => {\n   422→    const usdValues = itemUsdReferences.filter((value): value is string => Boolean(value));\n   423→    if (!usdValues.length) {\n   424→      return null;\n   425→    }\n   426→    const sumUnit = usdValues.reduce(\n   427→      (acc, value) => acc.add(new BN(fromTokenToUnit(value, USD_ANCHOR_DECIMALS))),\n   428→      new BN(0)\n   429→    );\n   430→    return fromUnitToToken(sumUnit.toString(), USD_ANCHOR_DECIMALS);\n   431→  }, [itemUsdReferences]);\n   432→  const totalUsdReference = totalUsdFromItems;\n   433→  const totalUsdDisplay = useMemo(() => formatUsdAmount(totalUsdReference, locale), [totalUsdReference, locale]);\n   434→\n   435→  // Calculate price lock status based on timestamp (no timer needed)\n   436→  const isPriceLocked = useMemo(() => {\n   437→    if (!quoteLockedAt) return false;\n   438→    const currentTime = Math.floor(Date.now() / 1000);\n   439→    const lockRemaining = quoteLockedAt + 180 - currentTime;\n   440→    return lockRemaining > 0;\n   441→  }, [quoteLockedAt]);\n   442→\n   443→  const lockExpired = useMemo(() => {\n   444→    if (!quoteLockedAt) return false;\n   445→    const currentTime = Math.floor(Date.now() / 1000);\n   446→    const lockRemaining = quoteLockedAt + 180 - currentTime;\n   447→    return lockRemaining <= 0;\n   448→  }, [quoteLockedAt]);\n   449→\n   450→  const detailFallback = '—';\n   451→\n   452→  const providerDisplay = useMemo(() => {\n   453→    if (!rateInfo.providerName && !rateInfo.providerId) {\n   454→      return detailFallback;\n   455→    }\n   456→    if (rateInfo.providerName && rateInfo.providerId) {\n   457→      return `${rateInfo.providerName} (${rateInfo.providerId})`;\n   458→    }\n   459→    return rateInfo.providerName || rateInfo.providerId || detailFallback;\n   460→  }, [rateInfo.providerName, rateInfo.providerId]);\n   461→\n   462→  const quoteDetailRows = useMemo(() => {\n   463→    if (!hasDynamicPricing || !rateDisplay) {\n   464→      return [];\n   465→    }\n   466→    const updatedAt = rateInfo.timestampMs ? formatToDatetime(rateInfo.timestampMs, locale) : detailFallback;\n   467→\n   468→    // Get slippage percent from quoteMeta, checkoutSession, or use default 0.5%\n   469→    let slippageValue = quoteMeta?.slippagePercent;\n   470→    if (slippageValue === null || slippageValue === undefined) {\n   471→      slippageValue = (checkoutSession as any)?.slippage_percent;\n   472→    }\n   473→    if (slippageValue === null || slippageValue === undefined) {\n   474→      slippageValue = 0.5; // default value\n   475→    }\n   476→    const slippageDisplay = `${slippageValue}%`;\n   477→\n   478→    return [\n   479→      { label: t('payment.checkout.quote.detailProvider'), value: providerDisplay },\n   480→      { label: t('payment.checkout.quote.detailUpdatedAt'), value: updatedAt },\n   481→      { label: t('payment.checkout.quote.detailPriceImpact'), value: detailFallback },\n   482→      { label: t('payment.checkout.quote.detailSlippage'), value: slippageDisplay },\n   483→    ];\n   484→  }, [hasDynamicPricing, rateDisplay, providerDisplay, rateInfo.timestampMs, locale, t, quoteMeta, checkoutSession]);\n   485→\n   486→  useBus(\n   487→    'error.REQUIRE_CROSS_SELL',\n   488→    () => {\n   489→      setState({ shake: true });\n   490→      setTimeout(() => {\n   491→        setState({ shake: false });\n   492→      }, 1000);\n   493→    },\n   494→    []\n   495→  );\n   496→\n   497→  const handleUpsell = async (from: string, to: string) => {\n   498→    await onUpsell!(from, to);\n   499→    runAsync(false);\n   500→  };\n   501→\n   502→  const handleQuantityChange = async (itemId: string, quantity: number) => {\n   503→    await onQuantityChange!(itemId, quantity);\n   504→    runAsync(false);\n   505→  };\n   506→\n   507→  const handleDownsell = async (from: string) => {\n   508→    await onDownsell!(from);\n   509→    runAsync(false);\n   510→  };\n   511→\n   512→  const handleApplyCrossSell = async () => {\n   513→    if (data) {\n   514→      try {\n   515→        setState({ loading: true });\n   516→        await onApplyCrossSell!(data.id);\n   517→      } catch (err) {\n   518→        console.error(err);\n   519→      } finally {\n   520→        setState({ loading: false });\n   521→      }\n   522→    }\n   523→  };\n   524→\n   525→  const handleCancelCrossSell = async () => {\n   526→    try {\n   527→      setState({ loading: true });\n   528→      await onCancelCrossSell!();\n   529→    } catch (err) {\n   530→      console.error(err);\n   531→    } finally {\n   532→      setState({ loading: false });\n   533→    }\n   534→  };\n   535→\n   536→  const hasSubTotal = +staking > 0 || allowPromotionCodes;\n   537→  const ProductCardList = (\n   538→    <Stack\n   539→      className=\"cko-product-list\"\n   540→      sx={{\n   541→        flex: '0 1 auto',\n   542→        overflow: 'auto',\n   543→      }}>\n   544→      <Stack spacing={{ xs: 1, sm: 2 }}>\n   545→        {items.map((x: TLineItemExpanded) =>\n   546→          x.price.custom_unit_amount && onChangeAmount && donationSettings ? (\n   547→            <ProductDonation\n   548→              key={`${x.price_id}-${discountCurrency.id}`}\n   549→              item={x}\n   550→              settings={donationSettings}\n   551→              onChange={onChangeAmount}\n   552→              currency={discountCurrency}\n   553→            />\n   554→          ) : (\n   555→            <ProductItem\n   556→              key={`${x.price_id}-${discountCurrency.id}`}\n   557→              item={x}\n   558→              items={items}\n   559→              trialInDays={trialInDays}\n   560→              trialEnd={trialEnd}\n   561→              currency={discountCurrency}\n   562→              exchangeRate={quoteMeta?.exchangeRate}\n   563→              onUpsell={handleUpsell}\n   564→              onDownsell={handleDownsell}\n   565→              adjustableQuantity={x.adjustable_quantity}\n   566→              completed={completed}\n   567→              showFeatures={showFeatures}\n   568→              onQuantityChange={handleQuantityChange}>\n   569→              {x.cross_sell && (\n   570→                <Stack\n   571→                  direction=\"row\"\n   572→                  sx={{\n   573→                    alignItems: 'center',\n   574→                    justifyContent: 'space-between',\n   575→                    width: 1,\n   576→                  }}>\n   577→                  <Typography />\n   578→                  <LoadingButton\n   579→                    size=\"small\"\n   580→                    loadingPosition=\"end\"\n   581→                    endIcon={null}\n   582→                    color=\"error\"\n   583→                    variant=\"text\"\n   584→                    loading={state.loading}\n   585→                    onClick={handleCancelCrossSell}>\n   586→                    {t('payment.checkout.cross_sell.remove')}\n   587→                  </LoadingButton>\n   588→                </Stack>\n   589→              )}\n   590→            </ProductItem>\n   591→          )\n   592→        )}\n   593→      </Stack>\n   594→      {data && items.some((x) => x.price_id === data.id) === false && (\n   595→        <Grow in>\n   596→          <Stack\n   597→            sx={{\n   598→              mt: 1,\n   599→            }}>\n   600→            <ProductItem\n   601→              item={{ quantity: 1, price: data, price_id: data.id, cross_sell: true } as TLineItemExpanded}\n   602→              items={items}\n   603→              trialInDays={trialInDays}\n   604→              currency={discountCurrency}\n   605→              trialEnd={trialEnd}\n   606→              exchangeRate={quoteMeta?.exchangeRate}\n   607→              onUpsell={noop}\n   608→              onDownsell={noop}>\n   609→              <Stack\n   610→                direction=\"row\"\n   611→                sx={{\n   612→                  alignItems: 'center',\n   613→                  justifyContent: 'space-between',\n   614→                  width: 1,\n   615→                }}>\n   616→                <Typography>\n   617→                  {crossSellBehavior === 'required' && (\n   618→                    <Status label={t('payment.checkout.required')} color=\"info\" variant=\"outlined\" sx={{ mr: 1 }} />\n   619→                  )}\n   620→                </Typography>\n   621→                <LoadingButton\n   622→                  size=\"small\"\n   623→                  loadingPosition=\"end\"\n   624→                  endIcon={null}\n   625→                  color={crossSellBehavior === 'required' ? 'info' : 'info'}\n   626→                  variant={crossSellBehavior === 'required' ? 'text' : 'text'}\n   627→                  loading={state.loading}\n   628→                  onClick={handleApplyCrossSell}>\n   629→                  {t('payment.checkout.cross_sell.add')}\n   630→                </LoadingButton>\n   631→              </Stack>\n   632→            </ProductItem>\n   633→          </Stack>\n   634→        </Grow>\n   635→      )}\n   636→    </Stack>\n   637→  );\n   638→  return (\n   639→    <Fade in>\n   640→      <Stack className=\"cko-product\" direction=\"column\" {...rest}>\n   641→        <Box\n   642→          sx={{\n   643→            display: 'flex',\n   644→            alignItems: 'center',\n   645→            mb: 2.5,\n   646→          }}>\n   647→          <Typography\n   648→            title={t('payment.checkout.orderSummary')}\n   649→            sx={{\n   650→              color: 'text.primary',\n   651→              fontSize: {\n   652→                xs: '18px',\n   653→                md: '24px',\n   654→              },\n   655→              fontWeight: '700',\n   656→              lineHeight: '32px',\n   657→            }}>\n   658→            {action || t('payment.checkout.orderSummary')}\n   659→          </Typography>\n   660→          {!settings.livemode && <Livemode />}\n   661→        </Box>\n   662→        {/* Show warning if exchange rate is unavailable */}\n   663→        {hasDynamicPricing && rateUnavailable && <DynamicPricingUnavailable error={rateError} sx={{ mb: 2 }} />}\n   664→        {isMobile && !donationSettings ? (\n   665→          <>\n   666→            <Stack\n   667→              onClick={() => setState({ expanded: !state.expanded })}\n   668→              sx={{\n   669→                justifyContent: 'space-between',\n   670→                flexDirection: 'row',\n   671→                alignItems: 'center',\n   672→                mb: 1.5,\n   673→              }}>\n   674→              <Typography>{t('payment.checkout.productListTotal', { total: items.length })}</Typography>\n   675→              <ExpandMore expand={state.expanded} aria-expanded={state.expanded} aria-label=\"show more\">\n   676→                <ExpandMoreIcon />\n   677→              </ExpandMore>\n   678→            </Stack>\n   679→            <Collapse in={state.expanded || !isMobile} timeout=\"auto\" unmountOnExit>\n   680→              {ProductCardList}\n   681→            </Collapse>\n   682→          </>\n   683→        ) : (\n   684→          ProductCardList\n   685→        )}\n   686→        <Divider sx={{ mt: 2.5, mb: 2.5 }} />\n   687→        {+staking > 0 && (\n   688→          <Stack spacing={1}>\n   689→            <Stack\n   690→              direction=\"row\"\n   691→              spacing={1}\n   692→              sx={{\n   693→                justifyContent: 'space-between',\n   694→                alignItems: 'center',\n   695→              }}>\n   696→              <Stack\n   697→                direction=\"row\"\n   698→                spacing={0.5}\n   699→                sx={{\n   700→                  alignItems: 'center',\n   701→                }}>\n   702→                <Typography sx={{ color: 'text.secondary' }}>{t('payment.checkout.paymentRequired')}</Typography>\n   703→                <Tooltip title={t('payment.checkout.stakingConfirm')} placement=\"top\" sx={{ maxWidth: '150px' }}>\n   704→                  <HelpOutline fontSize=\"small\" sx={{ color: 'text.lighter' }} />\n   705→                </Tooltip>\n   706→              </Stack>\n   707→              <Typography>{headlineAmountDisplay}</Typography>\n   708→            </Stack>\n   709→            <Stack\n   710→              direction=\"row\"\n   711→              spacing={1}\n   712→              sx={{\n   713→                justifyContent: 'space-between',\n   714→                alignItems: 'center',\n   715→              }}>\n   716→              <Stack\n   717→                direction=\"row\"\n   718→                spacing={0.5}\n   719→                sx={{\n   720→                  alignItems: 'center',\n   721→                }}>\n   722→                <Typography sx={{ color: 'text.secondary' }}>{t('payment.checkout.staking.title')}</Typography>\n   723→                <Tooltip title={t('payment.checkout.staking.tooltip')} placement=\"top\" sx={{ maxWidth: '150px' }}>\n   724→                  <HelpOutline fontSize=\"small\" sx={{ color: 'text.lighter' }} />\n   725→                </Tooltip>\n   726→              </Stack>\n   727→              <Typography>\n   728→                {formatAmount(staking, discountCurrency.decimal)} {discountCurrency.symbol}\n   729→              </Typography>\n   730→            </Stack>\n   731→          </Stack>\n   732→        )}\n   733→        {(allowPromotionCodes || hasDiscounts) && (\n   734→          <Stack\n   735→            direction=\"row\"\n   736→            spacing={1}\n   737→            sx={{\n   738→              justifyContent: 'space-between',\n   739→              alignItems: 'center',\n   740→              ...(+staking > 0 && {\n   741→                borderTop: '1px solid',\n   742→                borderColor: 'divider',\n   743→                pt: 1,\n   744→                mt: 1,\n   745→              }),\n   746→            }}>\n   747→            <Typography className=\"base-label\">{t('common.subtotal')}</Typography>\n   748→            <Typography>\n   749→              {subtotalDisplay} {discountCurrency.symbol}\n   750→            </Typography>\n   751→          </Stack>\n   752→        )}\n   753→        {/* Promotion Code Section - only show add button if no discounts applied */}\n   754→        {allowPromotionCodes && !hasDiscounts && (\n   755→          <Box sx={{ mt: 1 }}>\n   756→            <PromotionCode\n   757→              checkoutSessionId={checkoutSession.id}\n   758→              initialAppliedCodes={getAppliedPromotionCodes()}\n   759→              disabled={completed}\n   760→              onUpdate={handlePromotionUpdate}\n   761→              currencyId={currency.id}\n   762→            />\n   763→          </Box>\n   764→        )}\n   765→\n   766→        {/* Promotion Code Details */}\n   767→        {hasDiscounts && (\n   768→          <Box>\n   769→            {sessionDiscounts.map((discount: any) => {\n   770→              const promotionCodeInfo = discount.promotion_code_details;\n   771→              const couponInfo = discount.coupon_details;\n   772→              const discountDescription = couponInfo ? formatCouponTerms(couponInfo, discountCurrency, locale) : '';\n   773→              const notSupported = discountDescription === t('payment.checkout.coupon.noDiscount');\n   774→\n   775→              return (\n   776→                <Stack key={discount.promotion_code || discount.coupon || `discount-${discount.discount_amount}`}>\n   777→                  <Stack\n   778→                    direction=\"row\"\n   779→                    spacing={1}\n   780→                    sx={{\n   781→                      justifyContent: 'space-between',\n   782→                      alignItems: 'center',\n   783→                    }}>\n   784→                    <Stack\n   785→                      direction=\"row\"\n   786→                      spacing={1}\n   787→                      sx={{\n   788→                        alignItems: 'center',\n   789→                        backgroundColor: 'grey.100',\n   790→                        width: 'fit-content',\n   791→                        px: 1,\n   792→                        py: 1,\n   793→                        borderRadius: 1,\n   794→                      }}>\n   795→                      <Typography\n   796→                        sx={{\n   797→                          fontWeight: 'medium',\n   798→                          display: 'flex',\n   799→                          alignItems: 'center',\n   800→                          gap: 0.5,\n   801→                        }}>\n   802→                        <LocalOffer sx={{ color: 'warning.main', fontSize: 'small' }} />\n   803→                        {promotionCodeInfo?.code || discount.verification_data?.code || t('payment.checkout.discount')}\n   804→                      </Typography>\n   805→                      {!completed && (\n   806→                        <Button\n   807→                          size=\"small\"\n   808→                          disabled={paymentState.paying || paymentState.stripePaying}\n   809→                          onClick={() => handleRemovePromotion(checkoutSessionId)}\n   810→                          sx={{\n   811→                            minWidth: 'auto',\n   812→                            width: 16,\n   813→                            height: 16,\n   814→                            color: 'text.secondary',\n   815→                            '&.Mui-disabled': {\n   816→                              color: 'text.disabled',\n   817→                            },\n   818→                          }}>\n   819→                          <Close sx={{ fontSize: 14 }} />\n   820→                        </Button>\n   821→                      )}\n   822→                    </Stack>\n   823→                    <Typography sx={{ color: 'text.secondary' }}>\n   824→                      -{formatAmount(discount.discount_amount || '0', discountCurrency.decimal)}{' '}\n   825→                      {discountCurrency.symbol}\n   826→                    </Typography>\n   827→                  </Stack>\n   828→                  {/* Show discount description */}\n   829→                  {discountDescription && (\n   830→                    <Typography\n   831→                      sx={{\n   832→                        fontSize: 'small',\n   833→                        color: notSupported ? 'error.main' : 'text.secondary',\n   834→                        mt: 0.5,\n   835→                      }}>\n   836→                      {discountDescription}\n   837→                    </Typography>\n   838→                  )}\n   839→                </Stack>\n   840→              );\n   841→            })}\n   842→          </Box>\n   843→        )}\n   844→        {hasSubTotal && <Divider sx={{ my: 1 }} />}\n   845→        <Stack\n   846→          sx={{\n   847→            display: 'flex',\n   848→            justifyContent: 'space-between',\n   849→            flexDirection: 'row',\n   850→            alignItems: 'flex-start',\n   851→            width: '100%',\n   852→          }}>\n   853→          <Box className=\"base-label\">{t('common.total')}</Box>\n   854→          <Stack sx={{ alignItems: 'flex-end' }}>\n   855→            <PaymentAmount amount={`${totalAmount} ${discountCurrency.symbol}`} sx={{ fontSize: '16px' }} />\n   856→            {hasDynamicPricing &&\n   857→              (totalUsdDisplay ? (\n   858→                <Typography sx={{ fontSize: '0.7875rem', color: 'text.lighter' }}>≈ ${totalUsdDisplay}</Typography>\n   859→              ) : (\n   860→                <Tooltip title={t('payment.checkout.quote.referenceUnavailable')} placement=\"top\">\n   861→                  <Box component=\"span\">\n   862→                    <Typography sx={{ fontSize: '0.7875rem', color: 'text.lighter' }}>≈ —</Typography>\n   863→                  </Box>\n   864→                </Tooltip>\n   865→              ))}\n   866→            {hasDynamicPricing && rateDisplay && (\n   867→              <QuoteDetailsPanel\n   868→                rateLine={t('payment.checkout.quote.rateLine', { symbol: discountCurrency.symbol, rate: rateDisplay })}\n   869→                rows={quoteDetailRows}\n   870→                refreshLabel={t('payment.checkout.quote.detailRefresh')}\n   871→                onRefresh={handleQuoteRefresh}\n   872→                refreshing={quoteRefreshing}\n   873→                disableRefresh={isPriceLocked}\n   874→              />\n   875→            )}\n   876→            {hasDynamicPricing && lockExpired && (\n   877→              <Typography sx={{ fontSize: '0.75rem', color: 'warning.main', mt: 0.25 }}>\n   878→                {t('payment.checkout.quote.lockExpired')}\n   879→              </Typography>\n   880→            )}\n   881→          </Stack>\n   882→        </Stack>\n   883→        {headlines.then && headlines.showThen && (\n   884→          <Typography\n   885→            component=\"div\"\n   886→            sx={{ fontSize: '0.7875rem', color: 'text.lighter', textAlign: 'right', margin: '-2px 0 8px' }}>\n   887→            {headlines.then}\n   888→          </Typography>\n   889→        )}\n   890→      </Stack>\n   891→    </Fade>\n   892→  );\n   893→}\n   894→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"51e321e8-2664-4e53-8c45-296eaac7947f","timestamp":"2026-01-12T15:03:16.270Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/packages/react/src/payment/summary.tsx","content":"/* eslint-disable @typescript-eslint/indent */\nimport { useLocaleContext } from '@arcblock/ux/lib/Locale/context';\nimport type {\n  DonationSettings,\n  TCheckoutSession,\n  TLineItemExpanded,\n  TPaymentCurrency,\n  TPaymentIntent,\n  TPaymentMethodExpanded,\n} from '@blocklet/payment-types';\nimport { HelpOutline, Close, LocalOffer } from '@mui/icons-material';\nimport { Box, Divider, Fade, Grow, Stack, Tooltip, Typography, Collapse, IconButton, Button } from '@mui/material';\nimport type { IconButtonProps } from '@mui/material';\nimport { BN, fromTokenToUnit, fromUnitToToken } from '@ocap/util';\nimport { useRequest, useSetState } from 'ahooks';\nimport noop from 'lodash/noop';\nimport useBus from 'use-bus';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport { styled } from '@mui/material/styles';\nimport { useEffect, useMemo, useRef, useState } from 'react';\nimport Status from '../components/status';\nimport api from '../libs/api';\nimport {\n  formatAmount,\n  formatCheckoutHeadlines,\n  getPriceUintAmountByCurrency,\n  formatCouponTerms,\n  formatNumber,\n  formatDynamicPrice,\n  findCurrency,\n  formatExchangeRate,\n  formatToDatetime,\n  formatUsdAmount,\n  getUsdAmountFromBaseAmount,\n  getUsdAmountFromTokenUnits,\n} from '../libs/util';\nimport PaymentAmount from './amount';\nimport ProductDonation from './product-donation';\nimport ProductItem from './product-item';\nimport Livemode from '../components/livemode';\nimport QuoteDetailsPanel from '../components/quote-details-panel';\nimport { usePaymentContext } from '../contexts/payment';\nimport { useMobile } from '../hooks/mobile';\nimport LoadingButton from '../components/loading-button';\nimport PromotionCode from '../components/promotion-code';\nimport DynamicPricingUnavailable from '../components/dynamic-pricing-unavailable';\n\n// const shake = keyframes`\n//   0% {\n//     transform: rotate(0deg);\n//   }\n//   25% {\n//     transform: rotate(2deg);\n//   }\n//   50% {\n//     transform: rotate(0eg);\n//   }\n//   75% {\n//     transform: rotate(-2deg);\n//   }\n//   100% {\n//     transform: rotate(0deg);\n//   }\n// `;\n\ninterface ExpandMoreProps extends IconButtonProps {\n  expand: boolean;\n}\n\nconst ExpandMore = styled((props: ExpandMoreProps) => {\n  const { expand, ...other } = props;\n  return <IconButton {...other} />;\n})(({ theme, expand }) => ({\n  transform: !expand ? 'rotate(0deg)' : 'rotate(180deg)',\n  marginLeft: 'auto',\n  transition: theme.transitions.create('transform', {\n    duration: theme.transitions.duration.shortest,\n  }),\n}));\n\nconst USD_ANCHOR_DECIMALS = 8;\n\ntype Props = {\n  items: TLineItemExpanded[];\n  currency: TPaymentCurrency;\n  trialInDays: number;\n  trialEnd?: number;\n  billingThreshold: number;\n  showStaking?: boolean;\n  onUpsell?: Function;\n  onDownsell?: Function;\n  onQuantityChange?: Function;\n  onChangeAmount?: Function;\n  onApplyCrossSell?: Function;\n  onCancelCrossSell?: Function;\n  checkoutSessionId?: string;\n  crossSellBehavior?: string;\n  donationSettings?: DonationSettings; // only include backend part\n  action?: string;\n  completed?: boolean;\n  checkoutSession?: TCheckoutSession;\n  paymentIntent?: TPaymentIntent | null;\n  onPromotionUpdate?: () => void;\n  paymentMethods?: TPaymentMethodExpanded[];\n  showFeatures?: boolean;\n  rateUnavailable?: boolean; // Flag for exchange rate unavailability\n  rateError?: string; // Error message when rate is unavailable\n  onQuoteExpired?: (forceRefresh?: boolean) => void;\n  liveRate?: {\n    rate?: string;\n    provider_id?: string;\n    provider_name?: string;\n    base_currency?: string;\n    timestamp_ms?: number;\n  };\n};\n\nasync function fetchCrossSell(id: string, skipError = true) {\n  try {\n    const { data } = await api.get(`/api/checkout-sessions/${id}/cross-sell?skipError=${skipError}`);\n    if (!data.error) {\n      return data;\n    }\n\n    return null;\n  } catch (err) {\n    return null;\n  }\n}\n\nfunction getStakingSetup(items: TLineItemExpanded[], currency: TPaymentCurrency, billingThreshold = 0) {\n  const staking = {\n    licensed: new BN(0),\n    metered: new BN(0),\n  };\n\n  const recurringItems = items\n    .map((x) => x.upsell_price || x.price)\n    .filter((x) => x.type === 'recurring' && x.recurring);\n\n  if (recurringItems.length > 0) {\n    if (+billingThreshold) {\n      return fromTokenToUnit(billingThreshold, currency.decimal).toString();\n    }\n\n    items.forEach((x) => {\n      const price = x.upsell_price || x.price;\n      const unit = getPriceUintAmountByCurrency(price, currency);\n      const amount = new BN(unit).mul(new BN(x.quantity));\n      if (price.type === 'recurring' && price.recurring) {\n        if (price.recurring.usage_type === 'licensed') {\n          staking.licensed = staking.licensed.add(amount);\n        }\n        if (price.recurring.usage_type === 'metered') {\n          staking.metered = staking.metered.add(amount);\n        }\n      }\n    });\n\n    return staking.licensed.add(staking.metered).toString();\n  }\n\n  return '0';\n}\n\nexport default function PaymentSummary({\n  items,\n  currency,\n  trialInDays,\n  billingThreshold,\n  onUpsell = noop,\n  onDownsell = noop,\n  onQuantityChange = noop,\n  onApplyCrossSell = noop,\n  onCancelCrossSell = noop,\n  onChangeAmount = noop,\n  checkoutSessionId = '',\n  crossSellBehavior = '',\n  showStaking = false,\n  donationSettings = undefined,\n  action = '',\n  trialEnd = 0,\n  completed = false,\n  checkoutSession = undefined,\n  paymentIntent = undefined,\n  paymentMethods = [],\n  onPromotionUpdate = noop,\n  showFeatures = false,\n  rateUnavailable = false,\n  rateError = undefined,\n  onQuoteExpired = undefined,\n  liveRate = undefined,\n  ...rest\n}: Props) {\n  const { t, locale } = useLocaleContext();\n  const { isMobile } = useMobile();\n  const { paymentState, ...settings } = usePaymentContext();\n  const [state, setState] = useSetState({ loading: false, shake: false, expanded: items?.length < 3 });\n  const { data, runAsync } = useRequest((skipError) =>\n    checkoutSessionId ? fetchCrossSell(checkoutSessionId, skipError) : Promise.resolve(null)\n  );\n\n  const sessionDiscounts = (checkoutSession as any)?.discounts || [];\n  const allowPromotionCodes = !!checkoutSession?.allow_promotion_codes;\n  const hasDiscounts = sessionDiscounts?.length > 0;\n\n  const discountCurrency =\n    paymentMethods && checkoutSession\n      ? (findCurrency(\n          paymentMethods as TPaymentMethodExpanded[],\n          hasDiscounts ? checkoutSession?.currency_id || currency.id : (currency.id as string)\n        ) as TPaymentCurrency) || settings.settings?.baseCurrency\n      : currency;\n\n  const hasDynamicPricing = useMemo(\n    () => items.some((item) => ((item.upsell_price || item.price) as any)?.pricing_type === 'dynamic'),\n    [items]\n  );\n\n  const headlines = formatCheckoutHeadlines(items, discountCurrency, { trialEnd, trialInDays }, locale);\n  const staking = showStaking ? getStakingSetup(items, discountCurrency, billingThreshold) : '0';\n  const headlineAmountDisplay = useMemo(() => {\n    if (!hasDynamicPricing) {\n      return headlines.amount;\n    }\n    if (!headlines.amount.includes(discountCurrency.symbol)) {\n      return headlines.amount;\n    }\n    const formatted = formatDynamicPrice(headlines.actualAmount, true, 6);\n    return `${formatted} ${discountCurrency.symbol}`;\n  }, [headlines.amount, headlines.actualAmount, discountCurrency.symbol, hasDynamicPricing]);\n\n  const getAppliedPromotionCodes = () => {\n    if (!sessionDiscounts?.length) return [];\n\n    return sessionDiscounts.map((discount: any) => ({\n      id: discount.promotion_code || discount.coupon,\n      code: discount.verification_data?.code || 'APPLIED',\n      discount_amount: discount.discount_amount,\n    }));\n  };\n\n  const handlePromotionUpdate = () => {\n    onPromotionUpdate?.();\n  };\n\n  const handleRemovePromotion = async (sessionId: string) => {\n    // Prevent removing promotion during payment process\n    if (paymentState.paying || paymentState.stripePaying) {\n      return;\n    }\n    try {\n      await api.delete(`/api/checkout-sessions/${sessionId}/remove-promotion`);\n      onPromotionUpdate?.();\n    } catch (err: any) {\n      console.error('Failed to remove promotion code:', err);\n    }\n  };\n\n  const discountAmount = new BN(checkoutSession?.total_details?.amount_discount || '0');\n\n  const subtotalAmountUnit = new BN(fromTokenToUnit(headlines.actualAmount, discountCurrency?.decimal))\n    .add(new BN(staking))\n    .toString();\n  const subtotalAmount = fromUnitToToken(subtotalAmountUnit, discountCurrency?.decimal);\n\n  const totalAmountUnit = new BN(subtotalAmountUnit).sub(discountAmount).toString();\n  const totalAmountValue = fromUnitToToken(totalAmountUnit, discountCurrency?.decimal);\n  const totalAmount = formatDynamicPrice(totalAmountValue, hasDynamicPricing, 6);\n  const subtotalDisplay = formatDynamicPrice(subtotalAmount, hasDynamicPricing, 6);\n\n  const quoteMeta = useMemo(() => {\n    if (!items?.length || !hasDynamicPricing) {\n      return null;\n    }\n    let exchangeRate: string | null = null;\n    let baseCurrency: string | null = null;\n    let expiresAt: number | null = null;\n    let providerName: string | null = null;\n    let providerId: string | null = null;\n    let rateTimestampMs: number | null = null;\n    let slippagePercent: number | null = null;\n\n    items.forEach((item) => {\n      const price = item.upsell_price || item.price;\n      const rate = (item as any)?.exchange_rate;\n      if (!exchangeRate && rate) {\n        exchangeRate = rate;\n      }\n      const base = (price as any)?.base_currency;\n      if (!baseCurrency && base) {\n        baseCurrency = base;\n      }\n      const expires = (item as any)?.expires_at;\n      if (expires) {\n        expiresAt = expiresAt === null ? expires : Math.min(expiresAt, expires);\n      }\n      const itemProviderName = (item as any)?.rate_provider_name;\n      if (!providerName && itemProviderName) {\n        providerName = itemProviderName;\n      }\n      const itemProviderId = (item as any)?.rate_provider_id;\n      if (!providerId && itemProviderId) {\n        providerId = itemProviderId;\n      }\n      const itemRateTimestamp = (item as any)?.rate_timestamp_ms;\n      if (!rateTimestampMs && Number.isFinite(Number(itemRateTimestamp))) {\n        rateTimestampMs = Number(itemRateTimestamp);\n      }\n      const itemSlippage = (item as any)?.slippage_percent;\n      if (slippagePercent === null && Number.isFinite(Number(itemSlippage))) {\n        slippagePercent = Number(itemSlippage);\n      }\n    });\n\n    return {\n      exchangeRate,\n      baseCurrency: baseCurrency || 'USD',\n      expiresAt,\n      providerName,\n      providerId,\n      rateTimestampMs,\n      slippagePercent,\n    };\n  }, [items, hasDynamicPricing]);\n  const rateInfo = useMemo(\n    () => ({\n      exchangeRate: liveRate?.rate || quoteMeta?.exchangeRate || null,\n      baseCurrency: liveRate?.base_currency || quoteMeta?.baseCurrency || 'USD',\n      providerName: liveRate?.provider_name || quoteMeta?.providerName || null,\n      providerId: liveRate?.provider_id || quoteMeta?.providerId || null,\n      timestampMs: liveRate?.timestamp_ms || quoteMeta?.rateTimestampMs || null,\n    }),\n    [liveRate, quoteMeta]\n  );\n  const rateDisplay = useMemo(() => {\n    if (!rateInfo.exchangeRate) {\n      return null;\n    }\n    const formattedRate = formatExchangeRate(rateInfo.exchangeRate);\n    if (!formattedRate) {\n      return null;\n    }\n    if (rateInfo.baseCurrency === 'USD') {\n      return `$${formattedRate}`;\n    }\n    return `${formattedRate} ${rateInfo.baseCurrency}`;\n  }, [rateInfo]);\n\n  const quoteLockedAt = useMemo(() => {\n    if (paymentIntent?.quote_locked_at) {\n      const lockedAtMs = new Date(paymentIntent.quote_locked_at).getTime();\n      if (Number.isFinite(lockedAtMs)) {\n        return Math.floor(lockedAtMs / 1000);\n      }\n    }\n    const metaLockedAt = checkoutSession?.metadata?.quote_locked_at;\n    if (typeof metaLockedAt === 'number') {\n      return metaLockedAt;\n    }\n    if (typeof metaLockedAt === 'string') {\n      const parsed = Number(metaLockedAt);\n      if (Number.isFinite(parsed)) {\n        return parsed;\n      }\n    }\n    return null;\n  }, [paymentIntent?.quote_locked_at, checkoutSession?.metadata?.quote_locked_at]);\n\n  const expiredHandledRef = useRef(false);\n  const [quoteRefreshing, setQuoteRefreshing] = useState(false);\n\n  // Check if quote is expired (no timer needed, static check)\n  useEffect(() => {\n    if (completed || expiredHandledRef.current) {\n      return;\n    }\n    const currentTime = Math.floor(Date.now() / 1000);\n    const quoteRemaining = quoteMeta?.expiresAt ? Math.max(0, quoteMeta.expiresAt - currentTime) : 0;\n    const lockRemaining = quoteLockedAt ? Math.max(0, quoteLockedAt + 180 - currentTime) : 0;\n    const hasExpiry = !!quoteMeta?.expiresAt;\n\n    const lockActive = lockRemaining > 0;\n    if (hasExpiry && !lockActive && quoteRemaining <= 0) {\n      expiredHandledRef.current = true;\n      onQuoteExpired?.();\n    }\n  }, [quoteMeta?.expiresAt, quoteLockedAt, completed, onQuoteExpired]);\n\n  const handleQuoteRefresh = async () => {\n    if (!onQuoteExpired || quoteRefreshing) {\n      return;\n    }\n    setQuoteRefreshing(true);\n    try {\n      await onQuoteExpired(true);\n    } finally {\n      setQuoteRefreshing(false);\n    }\n  };\n\n  const itemUsdReferences = useMemo(() => {\n    if (!hasDynamicPricing) {\n      return [];\n    }\n    return items.map((item) => {\n      const price = item.upsell_price || item.price;\n      const baseAmount = (price as any)?.base_amount;\n      const hasBaseAmount = baseAmount !== undefined && baseAmount !== null;\n      if (hasBaseAmount) {\n        return getUsdAmountFromBaseAmount(baseAmount, item.quantity || 0);\n      }\n      const exchangeRate = (item as any)?.exchange_rate;\n      const quotedAmount = (item as any)?.quoted_amount;\n      if (!exchangeRate || !quotedAmount) {\n        return null;\n      }\n      return getUsdAmountFromTokenUnits(new BN(quotedAmount), discountCurrency.decimal, exchangeRate);\n    });\n  }, [items, discountCurrency, hasDynamicPricing]);\n  const totalUsdFromItems = useMemo(() => {\n    const usdValues = itemUsdReferences.filter((value): value is string => Boolean(value));\n    if (!usdValues.length) {\n      return null;\n    }\n    const sumUnit = usdValues.reduce(\n      (acc, value) => acc.add(new BN(fromTokenToUnit(value, USD_ANCHOR_DECIMALS))),\n      new BN(0)\n    );\n    return fromUnitToToken(sumUnit.toString(), USD_ANCHOR_DECIMALS);\n  }, [itemUsdReferences]);\n  const totalUsdReference = totalUsdFromItems;\n  const totalUsdDisplay = useMemo(() => formatUsdAmount(totalUsdReference, locale), [totalUsdReference, locale]);\n\n  // Calculate price lock status based on timestamp (no timer needed)\n  const isPriceLocked = useMemo(() => {\n    if (!quoteLockedAt) return false;\n    const currentTime = Math.floor(Date.now() / 1000);\n    const lockRemaining = quoteLockedAt + 180 - currentTime;\n    return lockRemaining > 0;\n  }, [quoteLockedAt]);\n\n  const lockExpired = useMemo(() => {\n    if (!quoteLockedAt) return false;\n    const currentTime = Math.floor(Date.now() / 1000);\n    const lockRemaining = quoteLockedAt + 180 - currentTime;\n    return lockRemaining <= 0;\n  }, [quoteLockedAt]);\n\n  const detailFallback = '—';\n\n  const providerDisplay = useMemo(() => {\n    if (!rateInfo.providerName && !rateInfo.providerId) {\n      return detailFallback;\n    }\n    if (rateInfo.providerName && rateInfo.providerId) {\n      return `${rateInfo.providerName} (${rateInfo.providerId})`;\n    }\n    return rateInfo.providerName || rateInfo.providerId || detailFallback;\n  }, [rateInfo.providerName, rateInfo.providerId]);\n\n  const quoteDetailRows = useMemo(() => {\n    if (!hasDynamicPricing || !rateDisplay) {\n      return [];\n    }\n    const updatedAt = rateInfo.timestampMs ? formatToDatetime(rateInfo.timestampMs, locale) : detailFallback;\n\n    // Get slippage percent from quoteMeta, checkoutSession, or use default 0.5%\n    let slippageValue = quoteMeta?.slippagePercent;\n    if (slippageValue === null || slippageValue === undefined) {\n      slippageValue = (checkoutSession as any)?.slippage_percent;\n    }\n    if (slippageValue === null || slippageValue === undefined) {\n      slippageValue = 0.5; // default value\n    }\n    const slippageDisplay = `${slippageValue}%`;\n\n    return [\n      { label: t('payment.checkout.quote.detailProvider'), value: providerDisplay },\n      { label: t('payment.checkout.quote.detailUpdatedAt'), value: updatedAt },\n      { label: t('payment.checkout.quote.detailPriceImpact'), value: detailFallback },\n      { label: t('payment.checkout.quote.detailSlippage'), value: slippageDisplay },\n    ];\n  }, [hasDynamicPricing, rateDisplay, providerDisplay, rateInfo.timestampMs, locale, t, quoteMeta, checkoutSession]);\n\n  useBus(\n    'error.REQUIRE_CROSS_SELL',\n    () => {\n      setState({ shake: true });\n      setTimeout(() => {\n        setState({ shake: false });\n      }, 1000);\n    },\n    []\n  );\n\n  const handleUpsell = async (from: string, to: string) => {\n    await onUpsell!(from, to);\n    runAsync(false);\n  };\n\n  const handleQuantityChange = async (itemId: string, quantity: number) => {\n    await onQuantityChange!(itemId, quantity);\n    runAsync(false);\n  };\n\n  const handleDownsell = async (from: string) => {\n    await onDownsell!(from);\n    runAsync(false);\n  };\n\n  const handleApplyCrossSell = async () => {\n    if (data) {\n      try {\n        setState({ loading: true });\n        await onApplyCrossSell!(data.id);\n      } catch (err) {\n        console.error(err);\n      } finally {\n        setState({ loading: false });\n      }\n    }\n  };\n\n  const handleCancelCrossSell = async () => {\n    try {\n      setState({ loading: true });\n      await onCancelCrossSell!();\n    } catch (err) {\n      console.error(err);\n    } finally {\n      setState({ loading: false });\n    }\n  };\n\n  const hasSubTotal = +staking > 0 || allowPromotionCodes;\n  const ProductCardList = (\n    <Stack\n      className=\"cko-product-list\"\n      sx={{\n        flex: '0 1 auto',\n        overflow: 'auto',\n      }}>\n      <Stack spacing={{ xs: 1, sm: 2 }}>\n        {items.map((x: TLineItemExpanded) =>\n          x.price.custom_unit_amount && onChangeAmount && donationSettings ? (\n            <ProductDonation\n              key={`${x.price_id}-${discountCurrency.id}`}\n              item={x}\n              settings={donationSettings}\n              onChange={onChangeAmount}\n              currency={discountCurrency}\n            />\n          ) : (\n            <ProductItem\n              key={`${x.price_id}-${discountCurrency.id}`}\n              item={x}\n              items={items}\n              trialInDays={trialInDays}\n              trialEnd={trialEnd}\n              currency={discountCurrency}\n              exchangeRate={quoteMeta?.exchangeRate}\n              onUpsell={handleUpsell}\n              onDownsell={handleDownsell}\n              adjustableQuantity={x.adjustable_quantity}\n              completed={completed}\n              showFeatures={showFeatures}\n              onQuantityChange={handleQuantityChange}>\n              {x.cross_sell && (\n                <Stack\n                  direction=\"row\"\n                  sx={{\n                    alignItems: 'center',\n                    justifyContent: 'space-between',\n                    width: 1,\n                  }}>\n                  <Typography />\n                  <LoadingButton\n                    size=\"small\"\n                    loadingPosition=\"end\"\n                    endIcon={null}\n                    color=\"error\"\n                    variant=\"text\"\n                    loading={state.loading}\n                    onClick={handleCancelCrossSell}>\n                    {t('payment.checkout.cross_sell.remove')}\n                  </LoadingButton>\n                </Stack>\n              )}\n            </ProductItem>\n          )\n        )}\n      </Stack>\n      {data && items.some((x) => x.price_id === data.id) === false && (\n        <Grow in>\n          <Stack\n            sx={{\n              mt: 1,\n            }}>\n            <ProductItem\n              item={{ quantity: 1, price: data, price_id: data.id, cross_sell: true } as TLineItemExpanded}\n              items={items}\n              trialInDays={trialInDays}\n              currency={discountCurrency}\n              trialEnd={trialEnd}\n              exchangeRate={quoteMeta?.exchangeRate}\n              onUpsell={noop}\n              onDownsell={noop}>\n              <Stack\n                direction=\"row\"\n                sx={{\n                  alignItems: 'center',\n                  justifyContent: 'space-between',\n                  width: 1,\n                }}>\n                <Typography>\n                  {crossSellBehavior === 'required' && (\n                    <Status label={t('payment.checkout.required')} color=\"info\" variant=\"outlined\" sx={{ mr: 1 }} />\n                  )}\n                </Typography>\n                <LoadingButton\n                  size=\"small\"\n                  loadingPosition=\"end\"\n                  endIcon={null}\n                  color={crossSellBehavior === 'required' ? 'info' : 'info'}\n                  variant={crossSellBehavior === 'required' ? 'text' : 'text'}\n                  loading={state.loading}\n                  onClick={handleApplyCrossSell}>\n                  {t('payment.checkout.cross_sell.add')}\n                </LoadingButton>\n              </Stack>\n            </ProductItem>\n          </Stack>\n        </Grow>\n      )}\n    </Stack>\n  );\n  return (\n    <Fade in>\n      <Stack className=\"cko-product\" direction=\"column\" {...rest}>\n        <Box\n          sx={{\n            display: 'flex',\n            alignItems: 'center',\n            mb: 2.5,\n          }}>\n          <Typography\n            title={t('payment.checkout.orderSummary')}\n            sx={{\n              color: 'text.primary',\n              fontSize: {\n                xs: '18px',\n                md: '24px',\n              },\n              fontWeight: '700',\n              lineHeight: '32px',\n            }}>\n            {action || t('payment.checkout.orderSummary')}\n          </Typography>\n          {!settings.livemode && <Livemode />}\n        </Box>\n        {/* Show warning if exchange rate is unavailable */}\n        {hasDynamicPricing && rateUnavailable && <DynamicPricingUnavailable error={rateError} sx={{ mb: 2 }} />}\n        {isMobile && !donationSettings ? (\n          <>\n            <Stack\n              onClick={() => setState({ expanded: !state.expanded })}\n              sx={{\n                justifyContent: 'space-between',\n                flexDirection: 'row',\n                alignItems: 'center',\n                mb: 1.5,\n              }}>\n              <Typography>{t('payment.checkout.productListTotal', { total: items.length })}</Typography>\n              <ExpandMore expand={state.expanded} aria-expanded={state.expanded} aria-label=\"show more\">\n                <ExpandMoreIcon />\n              </ExpandMore>\n            </Stack>\n            <Collapse in={state.expanded || !isMobile} timeout=\"auto\" unmountOnExit>\n              {ProductCardList}\n            </Collapse>\n          </>\n        ) : (\n          ProductCardList\n        )}\n        <Divider sx={{ mt: 2.5, mb: 2.5 }} />\n        {+staking > 0 && (\n          <Stack spacing={1}>\n            <Stack\n              direction=\"row\"\n              spacing={1}\n              sx={{\n                justifyContent: 'space-between',\n                alignItems: 'center',\n              }}>\n              <Stack\n                direction=\"row\"\n                spacing={0.5}\n                sx={{\n                  alignItems: 'center',\n                }}>\n                <Typography sx={{ color: 'text.secondary' }}>{t('payment.checkout.paymentRequired')}</Typography>\n                <Tooltip title={t('payment.checkout.stakingConfirm')} placement=\"top\" sx={{ maxWidth: '150px' }}>\n                  <HelpOutline fontSize=\"small\" sx={{ color: 'text.lighter' }} />\n                </Tooltip>\n              </Stack>\n              <Typography>{headlineAmountDisplay}</Typography>\n            </Stack>\n            <Stack\n              direction=\"row\"\n              spacing={1}\n              sx={{\n                justifyContent: 'space-between',\n                alignItems: 'center',\n              }}>\n              <Stack\n                direction=\"row\"\n                spacing={0.5}\n                sx={{\n                  alignItems: 'center',\n                }}>\n                <Typography sx={{ color: 'text.secondary' }}>{t('payment.checkout.staking.title')}</Typography>\n                <Tooltip title={t('payment.checkout.staking.tooltip')} placement=\"top\" sx={{ maxWidth: '150px' }}>\n                  <HelpOutline fontSize=\"small\" sx={{ color: 'text.lighter' }} />\n                </Tooltip>\n              </Stack>\n              <Typography>\n                {formatAmount(staking, discountCurrency.decimal)} {discountCurrency.symbol}\n              </Typography>\n            </Stack>\n          </Stack>\n        )}\n        {(allowPromotionCodes || hasDiscounts) && (\n          <Stack\n            direction=\"row\"\n            spacing={1}\n            sx={{\n              justifyContent: 'space-between',\n              alignItems: 'center',\n              ...(+staking > 0 && {\n                borderTop: '1px solid',\n                borderColor: 'divider',\n                pt: 1,\n                mt: 1,\n              }),\n            }}>\n            <Typography className=\"base-label\">{t('common.subtotal')}</Typography>\n            <Typography>\n              {subtotalDisplay} {discountCurrency.symbol}\n            </Typography>\n          </Stack>\n        )}\n        {/* Promotion Code Section - only show add button if no discounts applied */}\n        {allowPromotionCodes && !hasDiscounts && (\n          <Box sx={{ mt: 1 }}>\n            <PromotionCode\n              checkoutSessionId={checkoutSession.id}\n              initialAppliedCodes={getAppliedPromotionCodes()}\n              disabled={completed}\n              onUpdate={handlePromotionUpdate}\n              currencyId={currency.id}\n            />\n          </Box>\n        )}\n\n        {/* Promotion Code Details */}\n        {hasDiscounts && (\n          <Box>\n            {sessionDiscounts.map((discount: any) => {\n              const promotionCodeInfo = discount.promotion_code_details;\n              const couponInfo = discount.coupon_details;\n              const discountDescription = couponInfo ? formatCouponTerms(couponInfo, discountCurrency, locale) : '';\n              const notSupported = discountDescription === t('payment.checkout.coupon.noDiscount');\n\n              return (\n                <Stack key={discount.promotion_code || discount.coupon || `discount-${discount.discount_amount}`}>\n                  <Stack\n                    direction=\"row\"\n                    spacing={1}\n                    sx={{\n                      justifyContent: 'space-between',\n                      alignItems: 'center',\n                    }}>\n                    <Stack\n                      direction=\"row\"\n                      spacing={1}\n                      sx={{\n                        alignItems: 'center',\n                        backgroundColor: 'grey.100',\n                        width: 'fit-content',\n                        px: 1,\n                        py: 1,\n                        borderRadius: 1,\n                      }}>\n                      <Typography\n                        sx={{\n                          fontWeight: 'medium',\n                          display: 'flex',\n                          alignItems: 'center',\n                          gap: 0.5,\n                        }}>\n                        <LocalOffer sx={{ color: 'warning.main', fontSize: 'small' }} />\n                        {promotionCodeInfo?.code || discount.verification_data?.code || t('payment.checkout.discount')}\n                      </Typography>\n                      {!completed && (\n                        <Button\n                          size=\"small\"\n                          disabled={paymentState.paying || paymentState.stripePaying}\n                          onClick={() => handleRemovePromotion(checkoutSessionId)}\n                          sx={{\n                            minWidth: 'auto',\n                            width: 16,\n                            height: 16,\n                            color: 'text.secondary',\n                            '&.Mui-disabled': {\n                              color: 'text.disabled',\n                            },\n                          }}>\n                          <Close sx={{ fontSize: 14 }} />\n                        </Button>\n                      )}\n                    </Stack>\n                    <Typography sx={{ color: 'text.secondary' }}>\n                      -{formatAmount(discount.discount_amount || '0', discountCurrency.decimal)}{' '}\n                      {discountCurrency.symbol}\n                    </Typography>\n                  </Stack>\n                  {/* Show discount description */}\n                  {discountDescription && (\n                    <Typography\n                      sx={{\n                        fontSize: 'small',\n                        color: notSupported ? 'error.main' : 'text.secondary',\n                        mt: 0.5,\n                      }}>\n                      {discountDescription}\n                    </Typography>\n                  )}\n                </Stack>\n              );\n            })}\n          </Box>\n        )}\n        {hasSubTotal && <Divider sx={{ my: 1 }} />}\n        <Stack\n          sx={{\n            display: 'flex',\n            justifyContent: 'space-between',\n            flexDirection: 'row',\n            alignItems: 'flex-start',\n            width: '100%',\n          }}>\n          <Box className=\"base-label\">{t('common.total')}</Box>\n          <Stack sx={{ alignItems: 'flex-end' }}>\n            <PaymentAmount amount={`${totalAmount} ${discountCurrency.symbol}`} sx={{ fontSize: '16px' }} />\n            {hasDynamicPricing &&\n              (totalUsdDisplay ? (\n                <Typography sx={{ fontSize: '0.7875rem', color: 'text.lighter' }}>≈ ${totalUsdDisplay}</Typography>\n              ) : (\n                <Tooltip title={t('payment.checkout.quote.referenceUnavailable')} placement=\"top\">\n                  <Box component=\"span\">\n                    <Typography sx={{ fontSize: '0.7875rem', color: 'text.lighter' }}>≈ —</Typography>\n                  </Box>\n                </Tooltip>\n              ))}\n            {hasDynamicPricing && rateDisplay && (\n              <QuoteDetailsPanel\n                rateLine={t('payment.checkout.quote.rateLine', { symbol: discountCurrency.symbol, rate: rateDisplay })}\n                rows={quoteDetailRows}\n                refreshLabel={t('payment.checkout.quote.detailRefresh')}\n                onRefresh={handleQuoteRefresh}\n                refreshing={quoteRefreshing}\n                disableRefresh={isPriceLocked}\n              />\n            )}\n            {hasDynamicPricing && lockExpired && (\n              <Typography sx={{ fontSize: '0.75rem', color: 'warning.main', mt: 0.25 }}>\n                {t('payment.checkout.quote.lockExpired')}\n              </Typography>\n            )}\n          </Stack>\n        </Stack>\n        {headlines.then && headlines.showThen && (\n          <Typography\n            component=\"div\"\n            sx={{ fontSize: '0.7875rem', color: 'text.lighter', textAlign: 'right', margin: '-2px 0 8px' }}>\n            {headlines.then}\n          </Typography>\n        )}\n      </Stack>\n    </Fade>\n  );\n}\n","numLines":894,"startLine":1,"totalLines":894}}}
{"parentUuid":"51e321e8-2664-4e53-8c45-296eaac7947f","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01ACyXqt4VQwGZKBbUkguwST","type":"message","role":"assistant","content":[{"type":"text","text":"让我继续读取剩余的关键文件："}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":33403,"cache_creation_input_tokens":34599,"cache_read_input_tokens":15894,"cache_creation":{"ephemeral_5m_input_tokens":34599,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3gqJxVPvYSCMPhjoifS","type":"assistant","uuid":"5f30e36d-b501-4a7d-b2c3-a37f799ef97a","timestamp":"2026-01-12T15:03:22.381Z"}
{"parentUuid":"5f30e36d-b501-4a7d-b2c3-a37f799ef97a","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01ACyXqt4VQwGZKBbUkguwST","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TMqqUcRExuPuLXGAQ271Vh","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/quote-validation.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":33403,"cache_creation_input_tokens":34599,"cache_read_input_tokens":15894,"cache_creation":{"ephemeral_5m_input_tokens":34599,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3gqJxVPvYSCMPhjoifS","type":"assistant","uuid":"86dc2e74-12a8-4248-8009-1f3204c78959","timestamp":"2026-01-12T15:03:23.911Z"}
{"parentUuid":"86dc2e74-12a8-4248-8009-1f3204c78959","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01ACyXqt4VQwGZKBbUkguwST","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XWeUxWDcxt4VE3tko81e5x","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":33403,"cache_creation_input_tokens":34599,"cache_read_input_tokens":15894,"cache_creation":{"ephemeral_5m_input_tokens":34599,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3gqJxVPvYSCMPhjoifS","type":"assistant","uuid":"319b6ae1-a06d-494f-a056-06dc14b2b2ed","timestamp":"2026-01-12T15:03:24.169Z"}
{"parentUuid":"319b6ae1-a06d-494f-a056-06dc14b2b2ed","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01ACyXqt4VQwGZKBbUkguwST","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FWtv1mXxcvzBwBcZDn1KiE","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/payment.ts","limit":500}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":33403,"cache_creation_input_tokens":34599,"cache_read_input_tokens":15894,"cache_creation":{"ephemeral_5m_input_tokens":34599,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"}},"requestId":"req_011CX3gqJxVPvYSCMPhjoifS","type":"assistant","uuid":"0715de8b-2ffc-424e-9736-cae1131896df","timestamp":"2026-01-12T15:03:24.950Z"}
{"parentUuid":"0715de8b-2ffc-424e-9736-cae1131896df","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","message":{"model":"claude-sonnet-4-5-20250929","id":"msg_01ACyXqt4VQwGZKBbUkguwST","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01R18CndJ9crJNMaX9Cctqbc","name":"Read","input":{"file_path":"~/Arcblock/payment-kit-master/packages/react/src/components/quote-lock-banner.tsx"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":33403,"cache_creation_input_tokens":34599,"cache_read_input_tokens":15894,"cache_creation":{"ephemeral_5m_input_tokens":34599,"ephemeral_1h_input_tokens":0},"output_tokens":328,"service_tier":"standard"}},"requestId":"req_011CX3gqJxVPvYSCMPhjoifS","type":"assistant","uuid":"cc57c870-9451-4c81-9661-2695e5a27983","timestamp":"2026-01-12T15:03:25.701Z"}
{"parentUuid":"cc57c870-9451-4c81-9661-2695e5a27983","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TMqqUcRExuPuLXGAQ271Vh","type":"tool_result","content":"     1→import { BN } from '@ocap/util';\n     2→\n     3→import { PriceQuote } from '../store/models/price-quote';\n     4→import { InvoiceItem, Invoice, PaymentIntent } from '../store/models';\n     5→import logger from './logger';\n     6→\n     7→export interface QuoteValidationResult {\n     8→  valid: boolean;\n     9→  quoteId?: string;\n    10→  reason?: string;\n    11→  action: 'allow' | 'require_manual_review' | 'reject';\n    12→}\n    13→\n    14→const SLIPPAGE_BPS_BASE = new BN(10000);\n    15→\n    16→const normalizeSlippagePercent = (value: unknown): number | null => {\n    17→  if (value === null || value === undefined) {\n    18→    return null;\n    19→  }\n    20→  const parsed = typeof value === 'string' ? Number(value) : Number(value);\n    21→  if (!Number.isFinite(parsed) || parsed < 0) {\n    22→    return null;\n    23→  }\n    24→  return parsed;\n    25→};\n    26→\n    27→const resolveQuoteMaxPayableToken = (quote: PriceQuote): string | null => {\n    28→  const direct = quote.max_payable_token ?? (quote.metadata as any)?.slippage?.max_payable_token;\n    29→  if (direct) {\n    30→    return direct;\n    31→  }\n    32→  if (!quote.quoted_amount) {\n    33→    return null;\n    34→  }\n    35→  const slippagePercent = normalizeSlippagePercent(\n    36→    quote.slippage_percent ?? (quote.metadata as any)?.slippage?.percent\n    37→  );\n    38→  if (slippagePercent === null) {\n    39→    return quote.quoted_amount;\n    40→  }\n    41→  const slippageBps = Math.round(slippagePercent * 100);\n    42→  const multiplier = SLIPPAGE_BPS_BASE.add(new BN(slippageBps));\n    43→  const quotedAmountUnit = new BN(quote.quoted_amount);\n    44→  return quotedAmountUnit\n    45→    .mul(multiplier)\n    46→    .add(SLIPPAGE_BPS_BASE.sub(new BN(1)))\n    47→    .div(SLIPPAGE_BPS_BASE)\n    48→    .toString();\n    49→};\n    50→\n    51→const resolveMaxPayableTotal = async (params: {\n    52→  invoiceId?: string;\n    53→  quotes: PriceQuote[];\n    54→}): Promise<BN | null> => {\n    55→  const { invoiceId, quotes } = params;\n    56→  if (!invoiceId || quotes.length === 0) {\n    57→    if (quotes.length === 0) {\n    58→      return null;\n    59→    }\n    60→    return quotes.reduce((sum, quote) => {\n    61→      const maxPayable = resolveQuoteMaxPayableToken(quote) || quote.quoted_amount || '0';\n    62→      return sum.add(new BN(maxPayable));\n    63→    }, new BN(0));\n    64→  }\n    65→\n    66→  const invoiceItems = await InvoiceItem.findAll({ where: { invoice_id: invoiceId } });\n    67→  if (!invoiceItems.length) {\n    68→    return null;\n    69→  }\n    70→  const quotesById = new Map(quotes.map((quote) => [quote.id, quote]));\n    71→  let total = new BN(0);\n    72→  invoiceItems.forEach((item) => {\n    73→    const quoteId = item.metadata?.quote_id;\n    74→    const quote = quoteId ? quotesById.get(quoteId) : undefined;\n    75→    if (quote) {\n    76→      const maxPayable = resolveQuoteMaxPayableToken(quote) || quote.quoted_amount || '0';\n    77→      total = total.add(new BN(maxPayable));\n    78→      return;\n    79→    }\n    80→    if (item.amount) {\n    81→      total = total.add(new BN(item.amount));\n    82→    }\n    83→  });\n    84→  return total;\n    85→};\n    86→\n    87→/**\n    88→ * Validate quote status before processing on-chain payment\n    89→ * This function ensures that payments are only processed for active quotes\n    90→ *\n    91→ * P0 CRITICAL: This prevents silent success when users pay after quote expiration\n    92→ *\n    93→ * @param checkoutSessionId - Optional checkout session ID\n    94→ * @param invoiceId - Optional invoice ID\n    95→ * @returns Validation result with recommended action\n    96→ */\n    97→export async function validateQuoteForPayment(params: {\n    98→  checkoutSessionId?: string;\n    99→  invoiceId?: string;\n   100→  amount?: string;\n   101→}): Promise<QuoteValidationResult> {\n   102→  const { checkoutSessionId, invoiceId, amount } = params;\n   103→\n   104→  // Get quotes associated with this payment\n   105→  const quotes = await findRelatedQuotes({ checkoutSessionId, invoiceId });\n   106→\n   107→  if (quotes.length === 0) {\n   108→    // No quotes found - this is a fixed-price payment, allow it\n   109→    return {\n   110→      valid: true,\n   111→      action: 'allow',\n   112→    };\n   113→  }\n   114→\n   115→  // Check all quotes\n   116→  const now = Math.floor(Date.now() / 1000);\n   117→  const expiredQuotes: PriceQuote[] = [];\n   118→  const usedQuotes: PriceQuote[] = [];\n   119→  const activeQuotes: PriceQuote[] = [];\n   120→\n   121→  for (const quote of quotes) {\n   122→    if (quote.status === 'paid') {\n   123→      usedQuotes.push(quote);\n   124→    } else if (quote.expires_at < now || quote.status === 'expired') {\n   125→      expiredQuotes.push(quote);\n   126→    } else if (quote.status === 'used') {\n   127→      usedQuotes.push(quote);\n   128→    } else if (quote.status === 'active') {\n   129→      activeQuotes.push(quote);\n   130→    }\n   131→  }\n   132→\n   133→  // Case 1: Some quotes are expired - require manual review\n   134→  if (expiredQuotes.length > 0) {\n   135→    logger.error('CRITICAL: Payment attempt with expired quote', {\n   136→      checkoutSessionId,\n   137→      invoiceId,\n   138→      expiredQuoteIds: expiredQuotes.map((q) => q.id),\n   139→      expiredAt: expiredQuotes.map((q) => new Date(q.expires_at * 1000).toISOString()),\n   140→      now: new Date(now * 1000).toISOString(),\n   141→    });\n   142→\n   143→    // Log to audit system for tracking\n   144→    // This should trigger manual review process\n   145→    const expiredQuote = expiredQuotes[0]!; // Safe: we're inside length > 0 check\n   146→    return {\n   147→      valid: false,\n   148→      quoteId: expiredQuote.id,\n   149→      reason: `Quote expired at ${new Date(expiredQuote.expires_at * 1000).toISOString()}. Current time: ${new Date(now * 1000).toISOString()}`,\n   150→      action: 'require_manual_review',\n   151→    };\n   152→  }\n   153→\n   154→  if (amount && quotes.length > 0) {\n   155→    const maxPayableTotal = await resolveMaxPayableTotal({ invoiceId, quotes });\n   156→    if (maxPayableTotal) {\n   157→      const amountBN = new BN(amount);\n   158→      if (amountBN.gt(maxPayableTotal)) {\n   159→        logger.error('Payment exceeds max payable token limit', {\n   160→          checkoutSessionId,\n   161→          invoiceId,\n   162→          amount,\n   163→          maxPayableTotal: maxPayableTotal.toString(),\n   164→          quoteIds: quotes.map((q) => q.id),\n   165→        });\n   166→        return {\n   167→          valid: false,\n   168→          reason: `QUOTE_MAX_PAYABLE_EXCEEDED: amount ${amount} > max ${maxPayableTotal.toString()}`,\n   169→          action: 'reject',\n   170→        };\n   171→      }\n   172→    }\n   173→  }\n   174→\n   175→  // Case 2: All quotes are already used/paid - need to check if this is a duplicate payment\n   176→  if (usedQuotes.length === quotes.length) {\n   177→    // Check if this is a legitimate payment (quotes consumed during submit, but payment not yet completed)\n   178→    // or a duplicate payment (payment already succeeded)\n   179→    let isLegitimatePayment = true;\n   180→\n   181→    if (invoiceId) {\n   182→      const invoice = await Invoice.findByPk(invoiceId);\n   183→\n   184→      // If invoice is already paid, this is a duplicate payment\n   185→      if (invoice?.status === 'paid') {\n   186→        isLegitimatePayment = false;\n   187→      } else if (invoice?.payment_intent_id) {\n   188→        // Check payment intent status\n   189→        const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n   190→        // If payment intent already succeeded, this is a duplicate payment\n   191→        if (paymentIntent?.status === 'succeeded') {\n   192→          isLegitimatePayment = false;\n   193→        }\n   194→      }\n   195→    }\n   196→\n   197→    if (!isLegitimatePayment) {\n   198→      logger.warn('All quotes already used and payment already completed - duplicate payment', {\n   199→        checkoutSessionId,\n   200→        invoiceId,\n   201→        quoteIds: usedQuotes.map((q) => q.id),\n   202→      });\n   203→\n   204→      return {\n   205→        valid: false,\n   206→        reason: 'All associated quotes have already been used and payment completed',\n   207→        action: 'reject',\n   208→      };\n   209→    }\n   210→\n   211→    // Quotes are 'used' but payment not yet completed - this is the normal submit → pay flow\n   212→    logger.info('Quotes are used but payment not completed - allowing payment', {\n   213→      checkoutSessionId,\n   214→      invoiceId,\n   215→      quoteIds: usedQuotes.map((q) => q.id),\n   216→    });\n   217→\n   218→    // Allow the payment to proceed with the used quotes\n   219→    return {\n   220→      valid: true,\n   221→      quoteId: usedQuotes[0]?.id,\n   222→      action: 'allow',\n   223→    };\n   224→  }\n   225→\n   226→  // Case 3: All quotes are active - proceed with payment\n   227→  if (activeQuotes.length === quotes.length && activeQuotes.length > 0) {\n   228→    const activeQuote = activeQuotes[0]!; // Safe: we're inside length > 0 check\n   229→    return {\n   230→      valid: true,\n   231→      quoteId: activeQuote.id,\n   232→      action: 'allow',\n   233→    };\n   234→  }\n   235→\n   236→  // Case 4: Mixed state - require manual review\n   237→  logger.warn('Mixed quote states detected', {\n   238→    checkoutSessionId,\n   239→    invoiceId,\n   240→    activeCount: activeQuotes.length,\n   241→    usedCount: usedQuotes.length,\n   242→    expiredCount: expiredQuotes.length,\n   243→  });\n   244→\n   245→  return {\n   246→    valid: false,\n   247→    reason: 'Mixed quote states detected - manual review required',\n   248→    action: 'require_manual_review',\n   249→  };\n   250→}\n   251→\n   252→/**\n   253→ * Find all quotes related to a checkout session or invoice\n   254→ */\n   255→async function findRelatedQuotes(params: { checkoutSessionId?: string; invoiceId?: string }): Promise<PriceQuote[]> {\n   256→  const { checkoutSessionId, invoiceId } = params;\n   257→  const quotes: PriceQuote[] = [];\n   258→\n   259→  if (checkoutSessionId) {\n   260→    // Find quotes associated with checkout session\n   261→    const sessionQuotes = await PriceQuote.findAll({\n   262→      where: { session_id: checkoutSessionId },\n   263→    });\n   264→    quotes.push(...sessionQuotes);\n   265→  }\n   266→\n   267→  if (invoiceId) {\n   268→    // Find quotes associated with invoice\n   269→    const invoiceQuotes = await PriceQuote.findAll({\n   270→      where: { invoice_id: invoiceId },\n   271→    });\n   272→    quotes.push(...invoiceQuotes);\n   273→\n   274→    // Also check invoice items metadata for quote references\n   275→    const invoiceItems = await InvoiceItem.findAll({\n   276→      where: { invoice_id: invoiceId },\n   277→    });\n   278→\n   279→    for (const item of invoiceItems) {\n   280→      const quoteId = item.metadata?.quote_id;\n   281→      if (quoteId && typeof quoteId === 'string') {\n   282→        const quote = await PriceQuote.findByPk(quoteId);\n   283→        if (quote) {\n   284→          quotes.push(quote);\n   285→        }\n   286→      }\n   287→    }\n   288→  }\n   289→\n   290→  // Deduplicate quotes\n   291→  const uniqueQuotes = Array.from(new Map(quotes.map((q) => [q.id, q])).values());\n   292→\n   293→  return uniqueQuotes;\n   294→}\n   295→\n   296→/**\n   297→ * Handle payment with expired quote\n   298→ * This function should be called when a payment arrives after quote expiration\n   299→ *\n   300→ * P0 CRITICAL: This ensures funds are not lost and proper procedures are followed\n   301→ *\n   302→ * @param params - Payment details\n   303→ * @returns Action taken\n   304→ */\n   305→export async function handleExpiredQuotePayment(params: {\n   306→  quoteId: string;\n   307→  checkoutSessionId?: string;\n   308→  invoiceId?: string;\n   309→  paymentIntentId?: string;\n   310→  amount: string;\n   311→  currencyId: string;\n   312→  txHash?: string;\n   313→}): Promise<{\n   314→  action: 'held_for_review' | 'refund_initiated';\n   315→  message: string;\n   316→}> {\n   317→  const { quoteId, checkoutSessionId, invoiceId, paymentIntentId, amount, currencyId, txHash } = params;\n   318→\n   319→  logger.error('Payment received with expired quote - initiating review process', {\n   320→    quoteId,\n   321→    checkoutSessionId,\n   322→    invoiceId,\n   323→    paymentIntentId,\n   324→    amount,\n   325→    currencyId,\n   326→    txHash,\n   327→    timestamp: new Date().toISOString(),\n   328→  });\n   329→\n   330→  // TODO: Integrate with your manual review / dispute resolution system\n   331→  // Options:\n   332→  // 1. Hold payment for manual review\n   333→  // 2. Automatically refund\n   334→  // 3. Create a new quote at current rate and ask customer to confirm\n   335→  // 4. Create support ticket\n   336→\n   337→  // For now, mark payment as requiring manual review\n   338→  // This prevents silent success and ensures proper handling\n   339→\n   340→  return {\n   341→    action: 'held_for_review',\n   342→    message: `Payment held for manual review due to expired quote. Quote ID: ${quoteId}`,\n   343→  };\n   344→}\n   345→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"7836d358-7740-45b7-8951-1e4d4434cb54","timestamp":"2026-01-12T15:03:25.768Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/libs/quote-validation.ts","content":"import { BN } from '@ocap/util';\n\nimport { PriceQuote } from '../store/models/price-quote';\nimport { InvoiceItem, Invoice, PaymentIntent } from '../store/models';\nimport logger from './logger';\n\nexport interface QuoteValidationResult {\n  valid: boolean;\n  quoteId?: string;\n  reason?: string;\n  action: 'allow' | 'require_manual_review' | 'reject';\n}\n\nconst SLIPPAGE_BPS_BASE = new BN(10000);\n\nconst normalizeSlippagePercent = (value: unknown): number | null => {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  const parsed = typeof value === 'string' ? Number(value) : Number(value);\n  if (!Number.isFinite(parsed) || parsed < 0) {\n    return null;\n  }\n  return parsed;\n};\n\nconst resolveQuoteMaxPayableToken = (quote: PriceQuote): string | null => {\n  const direct = quote.max_payable_token ?? (quote.metadata as any)?.slippage?.max_payable_token;\n  if (direct) {\n    return direct;\n  }\n  if (!quote.quoted_amount) {\n    return null;\n  }\n  const slippagePercent = normalizeSlippagePercent(\n    quote.slippage_percent ?? (quote.metadata as any)?.slippage?.percent\n  );\n  if (slippagePercent === null) {\n    return quote.quoted_amount;\n  }\n  const slippageBps = Math.round(slippagePercent * 100);\n  const multiplier = SLIPPAGE_BPS_BASE.add(new BN(slippageBps));\n  const quotedAmountUnit = new BN(quote.quoted_amount);\n  return quotedAmountUnit\n    .mul(multiplier)\n    .add(SLIPPAGE_BPS_BASE.sub(new BN(1)))\n    .div(SLIPPAGE_BPS_BASE)\n    .toString();\n};\n\nconst resolveMaxPayableTotal = async (params: {\n  invoiceId?: string;\n  quotes: PriceQuote[];\n}): Promise<BN | null> => {\n  const { invoiceId, quotes } = params;\n  if (!invoiceId || quotes.length === 0) {\n    if (quotes.length === 0) {\n      return null;\n    }\n    return quotes.reduce((sum, quote) => {\n      const maxPayable = resolveQuoteMaxPayableToken(quote) || quote.quoted_amount || '0';\n      return sum.add(new BN(maxPayable));\n    }, new BN(0));\n  }\n\n  const invoiceItems = await InvoiceItem.findAll({ where: { invoice_id: invoiceId } });\n  if (!invoiceItems.length) {\n    return null;\n  }\n  const quotesById = new Map(quotes.map((quote) => [quote.id, quote]));\n  let total = new BN(0);\n  invoiceItems.forEach((item) => {\n    const quoteId = item.metadata?.quote_id;\n    const quote = quoteId ? quotesById.get(quoteId) : undefined;\n    if (quote) {\n      const maxPayable = resolveQuoteMaxPayableToken(quote) || quote.quoted_amount || '0';\n      total = total.add(new BN(maxPayable));\n      return;\n    }\n    if (item.amount) {\n      total = total.add(new BN(item.amount));\n    }\n  });\n  return total;\n};\n\n/**\n * Validate quote status before processing on-chain payment\n * This function ensures that payments are only processed for active quotes\n *\n * P0 CRITICAL: This prevents silent success when users pay after quote expiration\n *\n * @param checkoutSessionId - Optional checkout session ID\n * @param invoiceId - Optional invoice ID\n * @returns Validation result with recommended action\n */\nexport async function validateQuoteForPayment(params: {\n  checkoutSessionId?: string;\n  invoiceId?: string;\n  amount?: string;\n}): Promise<QuoteValidationResult> {\n  const { checkoutSessionId, invoiceId, amount } = params;\n\n  // Get quotes associated with this payment\n  const quotes = await findRelatedQuotes({ checkoutSessionId, invoiceId });\n\n  if (quotes.length === 0) {\n    // No quotes found - this is a fixed-price payment, allow it\n    return {\n      valid: true,\n      action: 'allow',\n    };\n  }\n\n  // Check all quotes\n  const now = Math.floor(Date.now() / 1000);\n  const expiredQuotes: PriceQuote[] = [];\n  const usedQuotes: PriceQuote[] = [];\n  const activeQuotes: PriceQuote[] = [];\n\n  for (const quote of quotes) {\n    if (quote.status === 'paid') {\n      usedQuotes.push(quote);\n    } else if (quote.expires_at < now || quote.status === 'expired') {\n      expiredQuotes.push(quote);\n    } else if (quote.status === 'used') {\n      usedQuotes.push(quote);\n    } else if (quote.status === 'active') {\n      activeQuotes.push(quote);\n    }\n  }\n\n  // Case 1: Some quotes are expired - require manual review\n  if (expiredQuotes.length > 0) {\n    logger.error('CRITICAL: Payment attempt with expired quote', {\n      checkoutSessionId,\n      invoiceId,\n      expiredQuoteIds: expiredQuotes.map((q) => q.id),\n      expiredAt: expiredQuotes.map((q) => new Date(q.expires_at * 1000).toISOString()),\n      now: new Date(now * 1000).toISOString(),\n    });\n\n    // Log to audit system for tracking\n    // This should trigger manual review process\n    const expiredQuote = expiredQuotes[0]!; // Safe: we're inside length > 0 check\n    return {\n      valid: false,\n      quoteId: expiredQuote.id,\n      reason: `Quote expired at ${new Date(expiredQuote.expires_at * 1000).toISOString()}. Current time: ${new Date(now * 1000).toISOString()}`,\n      action: 'require_manual_review',\n    };\n  }\n\n  if (amount && quotes.length > 0) {\n    const maxPayableTotal = await resolveMaxPayableTotal({ invoiceId, quotes });\n    if (maxPayableTotal) {\n      const amountBN = new BN(amount);\n      if (amountBN.gt(maxPayableTotal)) {\n        logger.error('Payment exceeds max payable token limit', {\n          checkoutSessionId,\n          invoiceId,\n          amount,\n          maxPayableTotal: maxPayableTotal.toString(),\n          quoteIds: quotes.map((q) => q.id),\n        });\n        return {\n          valid: false,\n          reason: `QUOTE_MAX_PAYABLE_EXCEEDED: amount ${amount} > max ${maxPayableTotal.toString()}`,\n          action: 'reject',\n        };\n      }\n    }\n  }\n\n  // Case 2: All quotes are already used/paid - need to check if this is a duplicate payment\n  if (usedQuotes.length === quotes.length) {\n    // Check if this is a legitimate payment (quotes consumed during submit, but payment not yet completed)\n    // or a duplicate payment (payment already succeeded)\n    let isLegitimatePayment = true;\n\n    if (invoiceId) {\n      const invoice = await Invoice.findByPk(invoiceId);\n\n      // If invoice is already paid, this is a duplicate payment\n      if (invoice?.status === 'paid') {\n        isLegitimatePayment = false;\n      } else if (invoice?.payment_intent_id) {\n        // Check payment intent status\n        const paymentIntent = await PaymentIntent.findByPk(invoice.payment_intent_id);\n        // If payment intent already succeeded, this is a duplicate payment\n        if (paymentIntent?.status === 'succeeded') {\n          isLegitimatePayment = false;\n        }\n      }\n    }\n\n    if (!isLegitimatePayment) {\n      logger.warn('All quotes already used and payment already completed - duplicate payment', {\n        checkoutSessionId,\n        invoiceId,\n        quoteIds: usedQuotes.map((q) => q.id),\n      });\n\n      return {\n        valid: false,\n        reason: 'All associated quotes have already been used and payment completed',\n        action: 'reject',\n      };\n    }\n\n    // Quotes are 'used' but payment not yet completed - this is the normal submit → pay flow\n    logger.info('Quotes are used but payment not completed - allowing payment', {\n      checkoutSessionId,\n      invoiceId,\n      quoteIds: usedQuotes.map((q) => q.id),\n    });\n\n    // Allow the payment to proceed with the used quotes\n    return {\n      valid: true,\n      quoteId: usedQuotes[0]?.id,\n      action: 'allow',\n    };\n  }\n\n  // Case 3: All quotes are active - proceed with payment\n  if (activeQuotes.length === quotes.length && activeQuotes.length > 0) {\n    const activeQuote = activeQuotes[0]!; // Safe: we're inside length > 0 check\n    return {\n      valid: true,\n      quoteId: activeQuote.id,\n      action: 'allow',\n    };\n  }\n\n  // Case 4: Mixed state - require manual review\n  logger.warn('Mixed quote states detected', {\n    checkoutSessionId,\n    invoiceId,\n    activeCount: activeQuotes.length,\n    usedCount: usedQuotes.length,\n    expiredCount: expiredQuotes.length,\n  });\n\n  return {\n    valid: false,\n    reason: 'Mixed quote states detected - manual review required',\n    action: 'require_manual_review',\n  };\n}\n\n/**\n * Find all quotes related to a checkout session or invoice\n */\nasync function findRelatedQuotes(params: { checkoutSessionId?: string; invoiceId?: string }): Promise<PriceQuote[]> {\n  const { checkoutSessionId, invoiceId } = params;\n  const quotes: PriceQuote[] = [];\n\n  if (checkoutSessionId) {\n    // Find quotes associated with checkout session\n    const sessionQuotes = await PriceQuote.findAll({\n      where: { session_id: checkoutSessionId },\n    });\n    quotes.push(...sessionQuotes);\n  }\n\n  if (invoiceId) {\n    // Find quotes associated with invoice\n    const invoiceQuotes = await PriceQuote.findAll({\n      where: { invoice_id: invoiceId },\n    });\n    quotes.push(...invoiceQuotes);\n\n    // Also check invoice items metadata for quote references\n    const invoiceItems = await InvoiceItem.findAll({\n      where: { invoice_id: invoiceId },\n    });\n\n    for (const item of invoiceItems) {\n      const quoteId = item.metadata?.quote_id;\n      if (quoteId && typeof quoteId === 'string') {\n        const quote = await PriceQuote.findByPk(quoteId);\n        if (quote) {\n          quotes.push(quote);\n        }\n      }\n    }\n  }\n\n  // Deduplicate quotes\n  const uniqueQuotes = Array.from(new Map(quotes.map((q) => [q.id, q])).values());\n\n  return uniqueQuotes;\n}\n\n/**\n * Handle payment with expired quote\n * This function should be called when a payment arrives after quote expiration\n *\n * P0 CRITICAL: This ensures funds are not lost and proper procedures are followed\n *\n * @param params - Payment details\n * @returns Action taken\n */\nexport async function handleExpiredQuotePayment(params: {\n  quoteId: string;\n  checkoutSessionId?: string;\n  invoiceId?: string;\n  paymentIntentId?: string;\n  amount: string;\n  currencyId: string;\n  txHash?: string;\n}): Promise<{\n  action: 'held_for_review' | 'refund_initiated';\n  message: string;\n}> {\n  const { quoteId, checkoutSessionId, invoiceId, paymentIntentId, amount, currencyId, txHash } = params;\n\n  logger.error('Payment received with expired quote - initiating review process', {\n    quoteId,\n    checkoutSessionId,\n    invoiceId,\n    paymentIntentId,\n    amount,\n    currencyId,\n    txHash,\n    timestamp: new Date().toISOString(),\n  });\n\n  // TODO: Integrate with your manual review / dispute resolution system\n  // Options:\n  // 1. Hold payment for manual review\n  // 2. Automatically refund\n  // 3. Create a new quote at current rate and ask customer to confirm\n  // 4. Create support ticket\n\n  // For now, mark payment as requiring manual review\n  // This prevents silent success and ensures proper handling\n\n  return {\n    action: 'held_for_review',\n    message: `Payment held for manual review due to expired quote. Quote ID: ${quoteId}`,\n  };\n}\n","numLines":345,"startLine":1,"totalLines":345}}}
{"parentUuid":"7836d358-7740-45b7-8951-1e4d4434cb54","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XWeUxWDcxt4VE3tko81e5x","type":"tool_result","content":"     1→import type { Transaction, TransferV3Tx } from '@ocap/client';\n     2→import { toBase58 } from '@ocap/util';\n     3→import { fromAddress } from '@ocap/wallet';\n     4→\n     5→import { encodeTransferItx } from '../../integrations/ethereum/token';\n     6→import { executeEvmTransaction, waitForEvmTxConfirm } from '../../integrations/ethereum/tx';\n     7→import { CallbackArgs, ethWallet } from '../../libs/auth';\n     8→import logger from '../../libs/logger';\n     9→import { getGasPayerExtra } from '../../libs/payment';\n    10→import { createPaymentOutput } from '../../libs/session';\n    11→import { getTxMetadata } from '../../libs/util';\n    12→import { handlePaymentSucceed } from '../../queues/payment';\n    13→import { ensureInvoiceForCheckout, ensurePaymentIntent, getAuthPrincipalClaim } from './shared';\n    14→import { EVMChainType } from '../../store/models';\n    15→import { EVM_CHAIN_TYPES } from '../../libs/constants';\n    16→import { validateQuoteForPayment, handleExpiredQuotePayment } from '../../libs/quote-validation';\n    17→\n    18→export default {\n    19→  action: 'payment',\n    20→  authPrincipal: false,\n    21→\n    22→  claims: {\n    23→    authPrincipal: async ({ extraParams }: CallbackArgs) => {\n    24→      const { paymentMethod } = await ensurePaymentIntent(extraParams.checkoutSessionId, '', true);\n    25→      return getAuthPrincipalClaim(paymentMethod, 'pay');\n    26→    },\n    27→  },\n    28→\n    29→  onConnect: async (args: CallbackArgs) => {\n    30→    const { userDid, userPk, extraParams } = args;\n    31→    const { checkoutSessionId, connectedDid, sessionUserDid } = extraParams;\n    32→    const { paymentIntent, paymentCurrency, paymentMethod } = await ensurePaymentIntent(\n    33→      checkoutSessionId,\n    34→      connectedDid || sessionUserDid || userDid\n    35→    );\n    36→    if (!paymentIntent) {\n    37→      throw new Error('Payment intent not found');\n    38→    }\n    39→\n    40→    if (paymentMethod.type === 'arcblock') {\n    41→      const tokens = [{ address: paymentCurrency.contract as string, value: paymentIntent.amount }];\n    42→      // @ts-ignore\n    43→      const itx: TransferV3Tx = {\n    44→        outputs: createPaymentOutput(\n    45→          paymentIntent.amount,\n    46→          paymentCurrency.contract as string,\n    47→          paymentIntent.beneficiaries || []\n    48→        ),\n    49→        data: getTxMetadata({\n    50→          paymentIntentId: paymentIntent.id,\n    51→          checkoutSessionId,\n    52→        }),\n    53→      };\n    54→\n    55→      return {\n    56→        prepareTx: {\n    57→          type: 'TransferV3Tx',\n    58→          description: 'Approve the transfer to complete payment',\n    59→          partialTx: { from: userDid, pk: userPk, itx },\n    60→          requirement: { tokens },\n    61→          chainInfo: {\n    62→            host: paymentMethod.settings?.arcblock?.api_host as string,\n    63→            id: paymentMethod.settings?.arcblock?.chain_id as string,\n    64→          },\n    65→        },\n    66→      };\n    67→    }\n    68→\n    69→    if (EVM_CHAIN_TYPES.includes(paymentMethod.type)) {\n    70→      return {\n    71→        signature: {\n    72→          type: 'eth:transaction',\n    73→          data: toBase58(\n    74→            Buffer.from(\n    75→              JSON.stringify({\n    76→                network: paymentMethod.settings[paymentMethod.type as EVMChainType]?.chain_id,\n    77→                tx: encodeTransferItx(ethWallet.address, paymentIntent.amount, paymentCurrency.contract),\n    78→              }),\n    79→              'utf-8'\n    80→            )\n    81→          ),\n    82→        },\n    83→      };\n    84→    }\n    85→\n    86→    throw new Error(`Payment method ${paymentMethod.type} not supported`);\n    87→  },\n    88→\n    89→  onAuth: async (args: CallbackArgs) => {\n    90→    const { request, userDid, claims, extraParams } = args;\n    91→    const { checkoutSessionId, connectedDid, sessionUserDid } = extraParams;\n    92→    const { checkoutSession, customer, paymentIntent, paymentMethod } = await ensurePaymentIntent(\n    93→      checkoutSessionId,\n    94→      connectedDid || sessionUserDid || userDid\n    95→    );\n    96→    if (!paymentIntent) {\n    97→      throw new Error('Payment intent not found');\n    98→    }\n    99→\n   100→    await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n   101→\n   102→    const preQuoteValidation = await validateQuoteForPayment({\n   103→      checkoutSessionId: checkoutSession?.id,\n   104→      invoiceId: paymentIntent.invoice_id,\n   105→      amount: paymentIntent.amount,\n   106→    });\n   107→\n   108→    if (!preQuoteValidation.valid) {\n   109→      const errorCode = preQuoteValidation.action === 'require_manual_review' ? 'quote_expired' : 'quote_validation_failed';\n   110→      logger.error('Payment blocked due to quote validation before submit', {\n   111→        paymentIntentId: paymentIntent.id,\n   112→        quoteId: preQuoteValidation.quoteId,\n   113→        reason: preQuoteValidation.reason,\n   114→      });\n   115→      await paymentIntent.update({\n   116→        status: 'requires_action',\n   117→        last_payment_error: {\n   118→          type: 'validation_error',\n   119→          code: errorCode,\n   120→          message: preQuoteValidation.reason || 'Quote validation failed',\n   121→        },\n   122→      });\n   123→      throw new Error(`Payment validation failed: ${preQuoteValidation.reason}`);\n   124→    }\n   125→\n   126→    if (paymentMethod.type === 'arcblock') {\n   127→      try {\n   128→        await paymentIntent.update({ status: 'processing' });\n   129→        const client = paymentMethod.getOcapClient();\n   130→        const claim = claims.find((x) => x.type === 'prepareTx');\n   131→\n   132→        const tx: Partial<Transaction> = client.decodeTx(claim.finalTx);\n   133→        if (claim.delegator && claim.from) {\n   134→          tx.delegator = claim.delegator;\n   135→          tx.from = claim.from;\n   136→        }\n   137→\n   138→        // @ts-ignore\n   139→        const { buffer } = await client.encodeTransferV3Tx({ tx });\n   140→        const txHash = await client.sendTransferV3Tx(\n   141→          // @ts-ignore\n   142→          { tx, wallet: fromAddress(userDid) },\n   143→          await getGasPayerExtra(buffer, client.pickGasPayerHeaders(request))\n   144→        );\n   145→\n   146→        const quoteValidation = await validateQuoteForPayment({\n   147→          checkoutSessionId: checkoutSession?.id,\n   148→          invoiceId: paymentIntent.invoice_id,\n   149→          amount: paymentIntent.amount,\n   150→        });\n   151→\n   152→        if (!quoteValidation.valid) {\n   153→          if (quoteValidation.action === 'reject') {\n   154→            // Reject the payment - mark as failed\n   155→            logger.error('Payment rejected due to quote validation', {\n   156→              paymentIntentId: paymentIntent.id,\n   157→              quoteId: quoteValidation.quoteId,\n   158→              reason: quoteValidation.reason,\n   159→              txHash,\n   160→            });\n   161→            await paymentIntent.update({\n   162→              status: 'requires_action',\n   163→              last_payment_error: {\n   164→                type: 'validation_error',\n   165→                code: 'quote_validation_failed',\n   166→                message: quoteValidation.reason || 'Quote validation failed',\n   167→              },\n   168→            });\n   169→            throw new Error(`Payment validation failed: ${quoteValidation.reason}`);\n   170→          }\n   171→\n   172→          if (quoteValidation.action === 'require_manual_review') {\n   173→            // Hold for manual review\n   174→            logger.error('Payment requires manual review due to expired quote', {\n   175→              paymentIntentId: paymentIntent.id,\n   176→              quoteId: quoteValidation.quoteId,\n   177→              reason: quoteValidation.reason,\n   178→              txHash,\n   179→            });\n   180→\n   181→            await handleExpiredQuotePayment({\n   182→              quoteId: quoteValidation.quoteId!,\n   183→              checkoutSessionId: checkoutSession?.id,\n   184→              invoiceId: paymentIntent.invoice_id,\n   185→              paymentIntentId: paymentIntent.id,\n   186→              amount: paymentIntent.amount,\n   187→              currencyId: paymentIntent.currency_id,\n   188→              txHash,\n   189→            });\n   190→\n   191→            await paymentIntent.update({\n   192→              status: 'requires_action',\n   193→              last_payment_error: {\n   194→                type: 'validation_error',\n   195→                code: 'quote_expired',\n   196→                message: quoteValidation.reason || 'Quote expired - manual review required',\n   197→              },\n   198→              metadata: {\n   199→                ...paymentIntent.metadata,\n   200→                quote_validation: {\n   201→                  status: 'expired',\n   202→                  quoteId: quoteValidation.quoteId,\n   203→                  reason: quoteValidation.reason,\n   204→                  held_for_review: true,\n   205→                },\n   206→              },\n   207→            });\n   208→            throw new Error(`Payment held for manual review: ${quoteValidation.reason}`);\n   209→          }\n   210→        }\n   211→\n   212→        await paymentIntent.update({\n   213→          status: 'succeeded',\n   214→          amount_received: paymentIntent.amount,\n   215→          last_payment_error: null,\n   216→          payment_details: {\n   217→            [paymentMethod.type]: {\n   218→              tx_hash: txHash,\n   219→              payer: userDid,\n   220→              type: 'transfer',\n   221→            },\n   222→          },\n   223→        });\n   224→\n   225→        await handlePaymentSucceed(paymentIntent);\n   226→\n   227→        return { hash: txHash };\n   228→      } catch (err) {\n   229→        console.error(err);\n   230→        logger.error('Failed to finalize paymentIntent on arcblock', { paymentIntent: paymentIntent.id, error: err });\n   231→        await paymentIntent.update({ status: 'requires_capture' });\n   232→        throw err;\n   233→      }\n   234→    }\n   235→\n   236→    if (EVM_CHAIN_TYPES.includes(paymentMethod.type)) {\n   237→      try {\n   238→        await paymentIntent.update({ status: 'processing' });\n   239→\n   240→        const paymentDetails = await executeEvmTransaction('transfer', userDid, claims, paymentMethod);\n   241→        waitForEvmTxConfirm(\n   242→          paymentMethod.getEvmClient(),\n   243→          Number(paymentDetails.block_height),\n   244→          paymentMethod.confirmation.block\n   245→        )\n   246→          .then(async () => {\n   247→            const quoteValidation = await validateQuoteForPayment({\n   248→              checkoutSessionId: checkoutSession?.id,\n   249→              invoiceId: paymentIntent.invoice_id,\n   250→            });\n   251→\n   252→            if (!quoteValidation.valid) {\n   253→              if (quoteValidation.action === 'reject') {\n   254→                // Reject the payment - mark as failed\n   255→                logger.error('Payment rejected due to quote validation', {\n   256→                  paymentIntentId: paymentIntent.id,\n   257→                  quoteId: quoteValidation.quoteId,\n   258→                  reason: quoteValidation.reason,\n   259→                  txHash: paymentDetails.tx_hash,\n   260→                });\n   261→                await paymentIntent.update({\n   262→                  status: 'requires_action',\n   263→                  last_payment_error: {\n   264→                    type: 'validation_error',\n   265→                    code: 'quote_validation_failed',\n   266→                    message: quoteValidation.reason || 'Quote validation failed',\n   267→                  },\n   268→                });\n   269→                return;\n   270→              }\n   271→\n   272→              if (quoteValidation.action === 'require_manual_review') {\n   273→                // Hold for manual review\n   274→                logger.error('Payment requires manual review due to expired quote', {\n   275→                  paymentIntentId: paymentIntent.id,\n   276→                  quoteId: quoteValidation.quoteId,\n   277→                  reason: quoteValidation.reason,\n   278→                  txHash: paymentDetails.tx_hash,\n   279→                });\n   280→\n   281→                await handleExpiredQuotePayment({\n   282→                  quoteId: quoteValidation.quoteId!,\n   283→                  checkoutSessionId: checkoutSession?.id,\n   284→                  invoiceId: paymentIntent.invoice_id,\n   285→                  paymentIntentId: paymentIntent.id,\n   286→                  amount: paymentIntent.amount,\n   287→                  currencyId: paymentIntent.currency_id,\n   288→                  txHash: paymentDetails.tx_hash,\n   289→                });\n   290→\n   291→                await paymentIntent.update({\n   292→                  status: 'requires_action',\n   293→                  last_payment_error: {\n   294→                    type: 'validation_error',\n   295→                    code: 'quote_expired',\n   296→                    message: quoteValidation.reason || 'Quote expired - manual review required',\n   297→                  },\n   298→                  metadata: {\n   299→                    ...paymentIntent.metadata,\n   300→                    quote_validation: {\n   301→                      status: 'expired',\n   302→                      quoteId: quoteValidation.quoteId,\n   303→                      reason: quoteValidation.reason,\n   304→                      held_for_review: true,\n   305→                    },\n   306→                  },\n   307→                });\n   308→                return;\n   309→              }\n   310→            }\n   311→\n   312→            await paymentIntent.update({\n   313→              status: 'succeeded',\n   314→              amount_received: paymentIntent.amount,\n   315→              last_payment_error: null,\n   316→              payment_details: { [paymentMethod.type]: paymentDetails },\n   317→            });\n   318→            await handlePaymentSucceed(paymentIntent);\n   319→          })\n   320→          .catch(console.error);\n   321→\n   322→        return { hash: paymentDetails.tx_hash };\n   323→      } catch (err) {\n   324→        console.error(err);\n   325→        logger.error(`Failed to finalize paymentIntent on ${paymentMethod.type}`, {\n   326→          paymentIntent: paymentIntent.id,\n   327→          error: err,\n   328→        });\n   329→        await paymentIntent.update({ status: 'requires_capture' });\n   330→        throw err;\n   331→      }\n   332→    }\n   333→\n   334→    throw new Error(`Payment method ${paymentMethod.type} not supported`);\n   335→  },\n   336→};\n   337→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"33fb73ba-93af-4a38-bbcd-7cd92d7864b8","timestamp":"2026-01-12T15:03:25.768Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/routes/connect/pay.ts","content":"import type { Transaction, TransferV3Tx } from '@ocap/client';\nimport { toBase58 } from '@ocap/util';\nimport { fromAddress } from '@ocap/wallet';\n\nimport { encodeTransferItx } from '../../integrations/ethereum/token';\nimport { executeEvmTransaction, waitForEvmTxConfirm } from '../../integrations/ethereum/tx';\nimport { CallbackArgs, ethWallet } from '../../libs/auth';\nimport logger from '../../libs/logger';\nimport { getGasPayerExtra } from '../../libs/payment';\nimport { createPaymentOutput } from '../../libs/session';\nimport { getTxMetadata } from '../../libs/util';\nimport { handlePaymentSucceed } from '../../queues/payment';\nimport { ensureInvoiceForCheckout, ensurePaymentIntent, getAuthPrincipalClaim } from './shared';\nimport { EVMChainType } from '../../store/models';\nimport { EVM_CHAIN_TYPES } from '../../libs/constants';\nimport { validateQuoteForPayment, handleExpiredQuotePayment } from '../../libs/quote-validation';\n\nexport default {\n  action: 'payment',\n  authPrincipal: false,\n\n  claims: {\n    authPrincipal: async ({ extraParams }: CallbackArgs) => {\n      const { paymentMethod } = await ensurePaymentIntent(extraParams.checkoutSessionId, '', true);\n      return getAuthPrincipalClaim(paymentMethod, 'pay');\n    },\n  },\n\n  onConnect: async (args: CallbackArgs) => {\n    const { userDid, userPk, extraParams } = args;\n    const { checkoutSessionId, connectedDid, sessionUserDid } = extraParams;\n    const { paymentIntent, paymentCurrency, paymentMethod } = await ensurePaymentIntent(\n      checkoutSessionId,\n      connectedDid || sessionUserDid || userDid\n    );\n    if (!paymentIntent) {\n      throw new Error('Payment intent not found');\n    }\n\n    if (paymentMethod.type === 'arcblock') {\n      const tokens = [{ address: paymentCurrency.contract as string, value: paymentIntent.amount }];\n      // @ts-ignore\n      const itx: TransferV3Tx = {\n        outputs: createPaymentOutput(\n          paymentIntent.amount,\n          paymentCurrency.contract as string,\n          paymentIntent.beneficiaries || []\n        ),\n        data: getTxMetadata({\n          paymentIntentId: paymentIntent.id,\n          checkoutSessionId,\n        }),\n      };\n\n      return {\n        prepareTx: {\n          type: 'TransferV3Tx',\n          description: 'Approve the transfer to complete payment',\n          partialTx: { from: userDid, pk: userPk, itx },\n          requirement: { tokens },\n          chainInfo: {\n            host: paymentMethod.settings?.arcblock?.api_host as string,\n            id: paymentMethod.settings?.arcblock?.chain_id as string,\n          },\n        },\n      };\n    }\n\n    if (EVM_CHAIN_TYPES.includes(paymentMethod.type)) {\n      return {\n        signature: {\n          type: 'eth:transaction',\n          data: toBase58(\n            Buffer.from(\n              JSON.stringify({\n                network: paymentMethod.settings[paymentMethod.type as EVMChainType]?.chain_id,\n                tx: encodeTransferItx(ethWallet.address, paymentIntent.amount, paymentCurrency.contract),\n              }),\n              'utf-8'\n            )\n          ),\n        },\n      };\n    }\n\n    throw new Error(`Payment method ${paymentMethod.type} not supported`);\n  },\n\n  onAuth: async (args: CallbackArgs) => {\n    const { request, userDid, claims, extraParams } = args;\n    const { checkoutSessionId, connectedDid, sessionUserDid } = extraParams;\n    const { checkoutSession, customer, paymentIntent, paymentMethod } = await ensurePaymentIntent(\n      checkoutSessionId,\n      connectedDid || sessionUserDid || userDid\n    );\n    if (!paymentIntent) {\n      throw new Error('Payment intent not found');\n    }\n\n    await ensureInvoiceForCheckout({ checkoutSession, customer, paymentIntent });\n\n    const preQuoteValidation = await validateQuoteForPayment({\n      checkoutSessionId: checkoutSession?.id,\n      invoiceId: paymentIntent.invoice_id,\n      amount: paymentIntent.amount,\n    });\n\n    if (!preQuoteValidation.valid) {\n      const errorCode = preQuoteValidation.action === 'require_manual_review' ? 'quote_expired' : 'quote_validation_failed';\n      logger.error('Payment blocked due to quote validation before submit', {\n        paymentIntentId: paymentIntent.id,\n        quoteId: preQuoteValidation.quoteId,\n        reason: preQuoteValidation.reason,\n      });\n      await paymentIntent.update({\n        status: 'requires_action',\n        last_payment_error: {\n          type: 'validation_error',\n          code: errorCode,\n          message: preQuoteValidation.reason || 'Quote validation failed',\n        },\n      });\n      throw new Error(`Payment validation failed: ${preQuoteValidation.reason}`);\n    }\n\n    if (paymentMethod.type === 'arcblock') {\n      try {\n        await paymentIntent.update({ status: 'processing' });\n        const client = paymentMethod.getOcapClient();\n        const claim = claims.find((x) => x.type === 'prepareTx');\n\n        const tx: Partial<Transaction> = client.decodeTx(claim.finalTx);\n        if (claim.delegator && claim.from) {\n          tx.delegator = claim.delegator;\n          tx.from = claim.from;\n        }\n\n        // @ts-ignore\n        const { buffer } = await client.encodeTransferV3Tx({ tx });\n        const txHash = await client.sendTransferV3Tx(\n          // @ts-ignore\n          { tx, wallet: fromAddress(userDid) },\n          await getGasPayerExtra(buffer, client.pickGasPayerHeaders(request))\n        );\n\n        const quoteValidation = await validateQuoteForPayment({\n          checkoutSessionId: checkoutSession?.id,\n          invoiceId: paymentIntent.invoice_id,\n          amount: paymentIntent.amount,\n        });\n\n        if (!quoteValidation.valid) {\n          if (quoteValidation.action === 'reject') {\n            // Reject the payment - mark as failed\n            logger.error('Payment rejected due to quote validation', {\n              paymentIntentId: paymentIntent.id,\n              quoteId: quoteValidation.quoteId,\n              reason: quoteValidation.reason,\n              txHash,\n            });\n            await paymentIntent.update({\n              status: 'requires_action',\n              last_payment_error: {\n                type: 'validation_error',\n                code: 'quote_validation_failed',\n                message: quoteValidation.reason || 'Quote validation failed',\n              },\n            });\n            throw new Error(`Payment validation failed: ${quoteValidation.reason}`);\n          }\n\n          if (quoteValidation.action === 'require_manual_review') {\n            // Hold for manual review\n            logger.error('Payment requires manual review due to expired quote', {\n              paymentIntentId: paymentIntent.id,\n              quoteId: quoteValidation.quoteId,\n              reason: quoteValidation.reason,\n              txHash,\n            });\n\n            await handleExpiredQuotePayment({\n              quoteId: quoteValidation.quoteId!,\n              checkoutSessionId: checkoutSession?.id,\n              invoiceId: paymentIntent.invoice_id,\n              paymentIntentId: paymentIntent.id,\n              amount: paymentIntent.amount,\n              currencyId: paymentIntent.currency_id,\n              txHash,\n            });\n\n            await paymentIntent.update({\n              status: 'requires_action',\n              last_payment_error: {\n                type: 'validation_error',\n                code: 'quote_expired',\n                message: quoteValidation.reason || 'Quote expired - manual review required',\n              },\n              metadata: {\n                ...paymentIntent.metadata,\n                quote_validation: {\n                  status: 'expired',\n                  quoteId: quoteValidation.quoteId,\n                  reason: quoteValidation.reason,\n                  held_for_review: true,\n                },\n              },\n            });\n            throw new Error(`Payment held for manual review: ${quoteValidation.reason}`);\n          }\n        }\n\n        await paymentIntent.update({\n          status: 'succeeded',\n          amount_received: paymentIntent.amount,\n          last_payment_error: null,\n          payment_details: {\n            [paymentMethod.type]: {\n              tx_hash: txHash,\n              payer: userDid,\n              type: 'transfer',\n            },\n          },\n        });\n\n        await handlePaymentSucceed(paymentIntent);\n\n        return { hash: txHash };\n      } catch (err) {\n        console.error(err);\n        logger.error('Failed to finalize paymentIntent on arcblock', { paymentIntent: paymentIntent.id, error: err });\n        await paymentIntent.update({ status: 'requires_capture' });\n        throw err;\n      }\n    }\n\n    if (EVM_CHAIN_TYPES.includes(paymentMethod.type)) {\n      try {\n        await paymentIntent.update({ status: 'processing' });\n\n        const paymentDetails = await executeEvmTransaction('transfer', userDid, claims, paymentMethod);\n        waitForEvmTxConfirm(\n          paymentMethod.getEvmClient(),\n          Number(paymentDetails.block_height),\n          paymentMethod.confirmation.block\n        )\n          .then(async () => {\n            const quoteValidation = await validateQuoteForPayment({\n              checkoutSessionId: checkoutSession?.id,\n              invoiceId: paymentIntent.invoice_id,\n            });\n\n            if (!quoteValidation.valid) {\n              if (quoteValidation.action === 'reject') {\n                // Reject the payment - mark as failed\n                logger.error('Payment rejected due to quote validation', {\n                  paymentIntentId: paymentIntent.id,\n                  quoteId: quoteValidation.quoteId,\n                  reason: quoteValidation.reason,\n                  txHash: paymentDetails.tx_hash,\n                });\n                await paymentIntent.update({\n                  status: 'requires_action',\n                  last_payment_error: {\n                    type: 'validation_error',\n                    code: 'quote_validation_failed',\n                    message: quoteValidation.reason || 'Quote validation failed',\n                  },\n                });\n                return;\n              }\n\n              if (quoteValidation.action === 'require_manual_review') {\n                // Hold for manual review\n                logger.error('Payment requires manual review due to expired quote', {\n                  paymentIntentId: paymentIntent.id,\n                  quoteId: quoteValidation.quoteId,\n                  reason: quoteValidation.reason,\n                  txHash: paymentDetails.tx_hash,\n                });\n\n                await handleExpiredQuotePayment({\n                  quoteId: quoteValidation.quoteId!,\n                  checkoutSessionId: checkoutSession?.id,\n                  invoiceId: paymentIntent.invoice_id,\n                  paymentIntentId: paymentIntent.id,\n                  amount: paymentIntent.amount,\n                  currencyId: paymentIntent.currency_id,\n                  txHash: paymentDetails.tx_hash,\n                });\n\n                await paymentIntent.update({\n                  status: 'requires_action',\n                  last_payment_error: {\n                    type: 'validation_error',\n                    code: 'quote_expired',\n                    message: quoteValidation.reason || 'Quote expired - manual review required',\n                  },\n                  metadata: {\n                    ...paymentIntent.metadata,\n                    quote_validation: {\n                      status: 'expired',\n                      quoteId: quoteValidation.quoteId,\n                      reason: quoteValidation.reason,\n                      held_for_review: true,\n                    },\n                  },\n                });\n                return;\n              }\n            }\n\n            await paymentIntent.update({\n              status: 'succeeded',\n              amount_received: paymentIntent.amount,\n              last_payment_error: null,\n              payment_details: { [paymentMethod.type]: paymentDetails },\n            });\n            await handlePaymentSucceed(paymentIntent);\n          })\n          .catch(console.error);\n\n        return { hash: paymentDetails.tx_hash };\n      } catch (err) {\n        console.error(err);\n        logger.error(`Failed to finalize paymentIntent on ${paymentMethod.type}`, {\n          paymentIntent: paymentIntent.id,\n          error: err,\n        });\n        await paymentIntent.update({ status: 'requires_capture' });\n        throw err;\n      }\n    }\n\n    throw new Error(`Payment method ${paymentMethod.type} not supported`);\n  },\n};\n","numLines":337,"startLine":1,"totalLines":337}}}
{"parentUuid":"33fb73ba-93af-4a38-bbcd-7cd92d7864b8","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FWtv1mXxcvzBwBcZDn1KiE","type":"tool_result","content":"     1→import isEmpty from 'lodash/isEmpty';\n     2→\n     3→import { BN } from '@ocap/util';\n     4→import pAll from 'p-all';\n     5→import { ensureStakedForGas } from '../integrations/arcblock/stake';\n     6→import { transferErc20FromUser } from '../integrations/ethereum/token';\n     7→import { createEvent } from '../libs/audit';\n     8→import { blocklet, wallet } from '../libs/auth';\n     9→import dayjs from '../libs/dayjs';\n    10→import CustomError from '../libs/error';\n    11→import { events } from '../libs/event';\n    12→import logger from '../libs/logger';\n    13→import { getGasPayerExtra, isDelegationSufficientForPayment, checkDepositVaultAmount } from '../libs/payment';\n    14→import { validateQuoteForPayment, handleExpiredQuotePayment } from '../libs/quote-validation';\n    15→import {\n    16→  checkRemainingStake,\n    17→  getDaysUntilCancel,\n    18→  getDaysUntilDue,\n    19→  getDueUnit,\n    20→  getMaxRetryCount,\n    21→  getMinRetryMail,\n    22→  getSubscriptionStakeAddress,\n    23→  isSubscriptionOverdraftProtectionEnabled,\n    24→  shouldCancelSubscription,\n    25→} from '../libs/subscription';\n    26→import { MAX_RETRY_COUNT, MIN_RETRY_MAIL, getNextRetry } from '../libs/util';\n    27→import { CheckoutSession } from '../store/models/checkout-session';\n    28→import { Customer } from '../store/models/customer';\n    29→import { Invoice } from '../store/models/invoice';\n    30→\n    31→import { PaymentCurrency } from '../store/models/payment-currency';\n    32→import { PaymentIntent } from '../store/models/payment-intent';\n    33→import { PaymentMethod } from '../store/models/payment-method';\n    34→import { Payout } from '../store/models/payout';\n    35→import { Price } from '../store/models/price';\n    36→\n    37→import { Subscription } from '../store/models/subscription';\n    38→import { SubscriptionItem } from '../store/models/subscription-item';\n    39→import type { EVMChainType, PaymentError, PaymentSettings } from '../store/models/types';\n    40→import { notificationQueue } from './notification';\n    41→import { ensureOverdraftProtectionInvoiceAndItems } from '../libs/invoice';\n    42→import { AutoRechargeConfig, Lock, MeterEvent } from '../store/models';\n    43→import { ensureOverdraftProtectionPrice } from '../libs/overdraft-protection';\n    44→import createQueue from '../libs/queue';\n    45→import { CHARGE_SUPPORTED_CHAIN_TYPES, EVM_CHAIN_TYPES } from '../libs/constants';\n    46→import { getCheckoutSessionSubscriptionIds, getSubscriptionCreateSetup } from '../libs/session';\n    47→import { syncStripeSubscriptionAfterRecovery } from '../integrations/stripe/handlers/subscription';\n    48→import { getLock } from '../libs/lock';\n    49→\n    50→type PaymentJob = {\n    51→  paymentIntentId: string;\n    52→  paymentSettings?: PaymentSettings;\n    53→  retryOnError?: boolean;\n    54→  ignoreMaxRetryCheck?: boolean;\n    55→  immediateRetry?: boolean;\n    56→};\n    57→\n    58→type DepositVaultJob = {\n    59→  currencyId: string;\n    60→};\n    61→\n    62→async function updateQuantitySold(checkoutSession: CheckoutSession) {\n    63→  const updatePromises = checkoutSession.line_items.map((item) => {\n    64→    const priceId = item.upsell_price_id || item.price_id;\n    65→    return Price.increment({ quantity_sold: Number(item.quantity) }, { where: { id: priceId } }).catch((err) => {\n    66→      logger.error('Update quantity_sold failed', {\n    67→        error: err,\n    68→        priceId,\n    69→        checkoutSessionId: checkoutSession.id,\n    70→      });\n    71→    });\n    72→  });\n    73→\n    74→  await Promise.all(updatePromises);\n    75→}\n    76→\n    77→const handleDepositVault = async (paymentCurrencyId: string) => {\n    78→  const { depositAmount, message, vaultAddress, paymentCurrency } = await checkDepositVaultAmount(paymentCurrencyId);\n    79→  if (depositAmount === '0') {\n    80→    logger.info(`Deposit vault skipped: ${message}`, { currencyId: paymentCurrencyId });\n    81→    return;\n    82→  }\n    83→  const payout = await Payout.create({\n    84→    livemode: paymentCurrency!.livemode,\n    85→    automatic: true,\n    86→    description: 'Deposit vault',\n    87→    amount: depositAmount,\n    88→    destination: vaultAddress!,\n    89→    payment_method_id: paymentCurrency!.payment_method_id,\n    90→    currency_id: paymentCurrency!.id,\n    91→    customer_id: '',\n    92→    payment_intent_id: '',\n    93→    status: 'pending',\n    94→    attempt_count: 0,\n    95→    attempted: false,\n    96→    next_attempt: 0,\n    97→    last_attempt_error: null,\n    98→    metadata: {\n    99→      system: true,\n   100→    },\n   101→  });\n   102→  logger.info('Deposit vault payout created', { payoutId: payout.id });\n   103→};\n   104→\n   105→export const depositVaultQueue = createQueue<DepositVaultJob>({\n   106→  name: 'deposit-vault',\n   107→  onJob: async (job) => {\n   108→    await handleDepositVault(job.currencyId);\n   109→  },\n   110→  options: {\n   111→    concurrency: 1,\n   112→    maxRetries: 3,\n   113→    enableScheduledJob: true,\n   114→  },\n   115→});\n   116→\n   117→export async function updateSubscriptionOnPaymentSuccess(\n   118→  paymentIntent: PaymentIntent | null,\n   119→  subscription: Subscription,\n   120→  invoice?: Invoice | null,\n   121→  triggerRenew: boolean = true\n   122→) {\n   123→  // Handle incomplete subscription activation\n   124→  if (subscription.status === 'incomplete' && invoice && invoice.id === subscription.latest_invoice_id) {\n   125→    const started = await subscription.start();\n   126→    if (started) {\n   127→      logger.info(`Subscription ${subscription.id} activated on payment done ${invoice.id}`);\n   128→    }\n   129→    return;\n   130→  }\n   131→\n   132→  // Handle past_due subscription recovery\n   133→  if (subscription.status === 'past_due' && subscription.cancelation_details?.reason === 'payment_failed') {\n   134→    await handlePastDueSubscriptionRecovery(subscription, paymentIntent);\n   135→    return;\n   136→  }\n   137→  if (subscription.status === 'past_due' && subscription.cancelation_details?.reason === 'insufficient_credit') {\n   138→    await handlePastDueSubscriptionRecovery(subscription, paymentIntent);\n   139→    return;\n   140→  }\n   141→\n   142→  // Handle trialing subscription\n   143→  if (subscription.status === 'trialing') {\n   144→    const started = await subscription.start();\n   145→    if (started) {\n   146→      logger.info(`Subscription ${subscription.id} trialing ended on payment done ${invoice?.id || 'credit'}`);\n   147→    }\n   148→    return;\n   149→  }\n   150→\n   151→  // Trigger renewal and upgrade events\n   152→  if (triggerRenew && (!invoice || invoice.billing_reason !== 'subscription_update')) {\n   153→    if (!invoice || invoice.billing_reason === 'subscription_cycle' || paymentIntent?.capture_method === 'manual') {\n   154→      createEvent('Subscription', 'customer.subscription.renewed', subscription).catch(console.error);\n   155→    }\n   156→  }\n   157→  if (invoice?.billing_reason === 'subscription_update') {\n   158→    createEvent('Subscription', 'customer.subscription.upgraded', subscription).catch(console.error);\n   159→  }\n   160→}\n   161→\n   162→export async function handlePastDueSubscriptionRecovery(\n   163→  subscription: Subscription,\n   164→  paymentIntent: PaymentIntent | null\n   165→) {\n   166→  // For credit mode with insufficient_credit reason, check meter events instead of uncollectible invoices\n   167→  if (subscription.cancelation_details?.reason === 'insufficient_credit') {\n   168→    // Check if all meter events for this subscription are completed with zero pending amount\n   169→    const [summary, detail] = await MeterEvent.getPendingAmounts({\n   170→      subscriptionId: subscription.id,\n   171→      livemode: subscription.livemode,\n   172→      currencyId: subscription.currency_id,\n   173→    });\n   174→\n   175→    if (summary[subscription.currency_id] && summary[subscription.currency_id] !== '0') {\n   176→      logger.info('Subscription recovery skipped: pending meter events exist', {\n   177→        subscription: subscription.id,\n   178→        pendingEventsCount: detail[subscription.currency_id]?.length,\n   179→        pendingEventIds: detail[subscription.currency_id],\n   180→      });\n   181→      return;\n   182→    }\n   183→  } else {\n   184→    // For payment_failed reason, check uncollectible invoices\n   185→    const [result] = await Invoice.getUncollectibleAmount({ subscriptionId: subscription.id });\n   186→    if (!isEmpty(result)) {\n   187→      return;\n   188→    }\n   189→  }\n   190→\n   191→  const now = dayjs().unix();\n   192→\n   193→  // Reset billing cycle anchor and cancel_* if we are recovering from payment failed or insufficient credit\n   194→  if (subscription.cancel_at && subscription.cancel_at !== subscription.current_period_end) {\n   195→    if (now <= subscription.current_period_end) {\n   196→      // If payment succeeds before current_period_end, we should activate this subscription\n   197→      await subscription.update({\n   198→        status: 'active',\n   199→        cancel_at: 0,\n   200→        cancel_at_period_end: false,\n   201→        // @ts-ignore\n   202→        cancelation_details: null,\n   203→      });\n   204→      const recoveryReason =\n   205→        subscription.cancelation_details?.reason === 'insufficient_credit' ? 'credit replenished' : 'payment done';\n   206→      logger.info(\n   207→        `Subscription ${subscription.id} recovered on ${recoveryReason} ${paymentIntent?.id || 'credit'}: cancel rest`\n   208→      );\n   209→      if (paymentIntent) {\n   210→        await syncStripeSubscriptionAfterRecovery(subscription, paymentIntent.id);\n   211→      }\n   212→      return;\n   213→    }\n   214→\n   215→    // Reset billing cycle\n   216→    const subscriptionItems = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n   217→    const lineItems = await Price.expand(subscriptionItems.map((x) => x.toJSON()));\n   218→    const setup = getSubscriptionCreateSetup(lineItems, subscription.currency_id, 0);\n   219→    await subscription.update({\n   220→      status: 'active',\n   221→      pending_invoice_item_interval: setup.recurring,\n   222→      current_period_start: setup.period.start,\n   223→      current_period_end: setup.period.end,\n   224→      billing_cycle_anchor: setup.cycle.anchor,\n   225→      cancel_at: 0,\n   226→      cancel_at_period_end: false,\n   227→      // @ts-ignore\n   228→      cancelation_details: null,\n   229→    });\n   230→\n   231→    createEvent('Subscription', 'customer.subscription.recovered', subscription).catch(console.error);\n   232→    const recoveryReason =\n   233→      subscription.cancelation_details?.reason === 'insufficient_credit' ? 'credit replenished' : 'payment done';\n   234→    logger.info(\n   235→      `Subscription ${subscription.id} recovered on ${recoveryReason} ${paymentIntent?.id || 'credit'}: cancel and billing cycle reset`\n   236→    );\n   237→    if (paymentIntent) {\n   238→      await syncStripeSubscriptionAfterRecovery(subscription, paymentIntent.id);\n   239→    }\n   240→  } else if (subscription.cancel_at_period_end) {\n   241→    // Reset cancel_at_period_end if we are recovering from payment failed or insufficient credit\n   242→    // @ts-ignore\n   243→    await subscription.update({ status: 'active', cancel_at_period_end: false, cancelation_details: null });\n   244→    const recoveryReason =\n   245→      subscription.cancelation_details?.reason === 'insufficient_credit' ? 'credit replenished' : 'payment done';\n   246→    logger.info(\n   247→      `Subscription ${subscription.id} recovered on ${recoveryReason} ${paymentIntent?.id || 'credit'}: cancel reset`\n   248→    );\n   249→    if (paymentIntent) {\n   250→      await syncStripeSubscriptionAfterRecovery(subscription, paymentIntent.id);\n   251→    }\n   252→  } else {\n   253→    await subscription.update({ status: 'active' });\n   254→    const recoveryReason =\n   255→      subscription.cancelation_details?.reason === 'insufficient_credit' ? 'credit replenished' : 'payment done';\n   256→    logger.info(`Subscription ${subscription.id} recovered on ${recoveryReason} ${paymentIntent?.id || 'credit'}`);\n   257→  }\n   258→}\n   259→\n   260→async function updateCheckoutSessionOnPaymentSuccess(\n   261→  paymentIntent: PaymentIntent,\n   262→  checkoutSession: CheckoutSession,\n   263→  invoice?: Invoice\n   264→) {\n   265→  if (checkoutSession.status !== 'open') {\n   266→    return;\n   267→  }\n   268→\n   269→  // Update quantity sold for line items\n   270→  updateQuantitySold(checkoutSession).catch((err) => {\n   271→    logger.error('Updating quantity_sold for line items failed', {\n   272→      error: err,\n   273→      checkoutSessionId: checkoutSession.id,\n   274→    });\n   275→  });\n   276→\n   277→  // Handle subscription mode checkout sessions\n   278→  if (['subscription', 'setup'].includes(checkoutSession.mode) && invoice?.subscription_id) {\n   279→    await checkoutSession.increment('success_subscription_count', { by: 1 });\n   280→    await checkoutSession.reload();\n   281→    const subscriptionIds = getCheckoutSessionSubscriptionIds(checkoutSession);\n   282→\n   283→    if (\n   284→      checkoutSession.success_subscription_count &&\n   285→      checkoutSession.success_subscription_count >= subscriptionIds.length\n   286→    ) {\n   287→      await checkoutSession.update({\n   288→        status: 'complete',\n   289→        payment_status: 'paid',\n   290→        payment_details: paymentIntent?.payment_details || {},\n   291→      });\n   292→      logger.info('checkout session become complete on payment done', {\n   293→        id: checkoutSession.id,\n   294→      });\n   295→    }\n   296→  } else {\n   297→    // Handle non-subscription mode checkout sessions\n   298→    await checkoutSession.update({\n   299→      status: 'complete',\n   300→      payment_status: 'paid',\n   301→      payment_details: paymentIntent?.payment_details || {},\n   302→    });\n   303→    logger.info('checkout session become complete on payment done', {\n   304→      id: checkoutSession.id,\n   305→    });\n   306→  }\n   307→\n   308→  logger.info(`CheckoutSession ${checkoutSession.id} updated on payment done ${paymentIntent.id}`);\n   309→}\n   310→\n   311→export const handlePaymentSucceed = async (\n   312→  paymentIntent: PaymentIntent,\n   313→  triggerRenew: boolean = true,\n   314→  slashStake: boolean = false\n   315→) => {\n   316→  // FIXME: @wangshijun we should check stripe payment here before\n   317→\n   318→  if (paymentIntent.beneficiaries?.length && !slashStake) {\n   319→    Promise.all(\n   320→      paymentIntent.beneficiaries.map(async (x) => {\n   321→        let customer = await Customer.findByPkOrDid(x.address);\n   322→        if (!customer) {\n   323→          const { user } = await blocklet.getUser(x.address);\n   324→          if (user) {\n   325→            customer = await Customer.create({\n   326→              livemode: paymentIntent.livemode,\n   327→              did: user.did,\n   328→              name: user.fullName,\n   329→              email: user.email,\n   330→              phone: user.phone,\n   331→              address: Customer.formatAddressFromUser(user),\n   332→              description: user.remark,\n   333→              metadata: {},\n   334→              balance: '0',\n   335→              next_invoice_sequence: 1,\n   336→              delinquent: false,\n   337→              invoice_prefix: Customer.getInvoicePrefix(),\n   338→            });\n   339→            logger.info('Customer created on payout record', {\n   340→              paymentIntent: paymentIntent.id,\n   341→              address: x.address,\n   342→              customer: customer.id,\n   343→            });\n   344→          }\n   345→        }\n   346→\n   347→        const payout = new Payout({\n   348→          livemode: paymentIntent.livemode,\n   349→          automatic: true,\n   350→          description: paymentIntent.description,\n   351→          amount: x.share,\n   352→          destination: x.address,\n   353→          payment_details: paymentIntent.payment_details,\n   354→          payment_intent_id: paymentIntent.id,\n   355→          customer_id: customer?.id || '',\n   356→          currency_id: paymentIntent.currency_id,\n   357→          payment_method_id: paymentIntent.payment_method_id,\n   358→          status: 'paid',\n   359→          attempt_count: 0,\n   360→          attempted: false,\n   361→          next_attempt: 0,\n   362→          last_attempt_error: null,\n   363→          metadata: {},\n   364→        });\n   365→        return payout.save();\n   366→      })\n   367→    )\n   368→      .then(() => logger.info('Payout records created from payment done', { paymentIntent: paymentIntent.id }))\n   369→      .catch((err) =>\n   370→        logger.error('Payout records creation failed from payment done', {\n   371→          paymentIntent: paymentIntent.id,\n   372→          error: err,\n   373→        })\n   374→      );\n   375→  }\n   376→\n   377→  // Trigger vendor commission queue by invoice.paid\n   378→\n   379→  let invoice;\n   380→  if (paymentIntent.invoice_id) {\n   381→    invoice = await Invoice.findByPk(paymentIntent.invoice_id);\n   382→  }\n   383→\n   384→  // Handle checkout session when no invoice exists\n   385→  if (!invoice && !slashStake) {\n   386→    const checkoutSession = await CheckoutSession.findOne({ where: { payment_intent_id: paymentIntent.id } });\n   387→    if (checkoutSession) {\n   388→      await updateCheckoutSessionOnPaymentSuccess(paymentIntent, checkoutSession);\n   389→    }\n   390→    return;\n   391→  }\n   392→\n   393→  // Update invoice status\n   394→  if (invoice && invoice?.status !== 'paid') {\n   395→    await invoice.update({\n   396→      paid: true,\n   397→      status: 'paid',\n   398→      amount_paid: paymentIntent.amount,\n   399→      amount_remaining: '0',\n   400→      attempt_count: invoice.attempt_count + 1,\n   401→      attempted: true,\n   402→      status_transitions: { ...invoice.status_transitions, paid_at: dayjs().unix() },\n   403→    });\n   404→    logger.info(`Invoice ${invoice.id} updated on payment done: ${paymentIntent.id}`);\n   405→  }\n   406→\n   407→  // Update subscription status\n   408→  if (invoice && invoice.subscription_id && !slashStake) {\n   409→    const subscription = await Subscription.findByPk(invoice.subscription_id);\n   410→    if (subscription) {\n   411→      await updateSubscriptionOnPaymentSuccess(paymentIntent, subscription, invoice, triggerRenew);\n   412→    }\n   413→  }\n   414→\n   415→  // Update checkout session\n   416→  if (invoice && invoice.checkout_session_id && !slashStake) {\n   417→    const checkoutSession = await CheckoutSession.findByPk(invoice.checkout_session_id);\n   418→    if (checkoutSession) {\n   419→      await updateCheckoutSessionOnPaymentSuccess(paymentIntent, checkoutSession, invoice);\n   420→    }\n   421→  }\n   422→};\n   423→\n   424→export const doOverdraftProtection = async (\n   425→  paymentIntent: PaymentIntent,\n   426→  subscription: Subscription,\n   427→  customer: Customer,\n   428→  relatedInvoice?: Invoice\n   429→) => {\n   430→  const { enabled } = await isSubscriptionOverdraftProtectionEnabled(subscription);\n   431→  if (!enabled) {\n   432→    logger.warn('overdraft protection is not enabled', {\n   433→      subscription: subscription.id,\n   434→    });\n   435→    return;\n   436→  }\n   437→  const existProtectedInvoice = await Invoice.findOne({\n   438→    where: {\n   439→      subscription_id: subscription.id,\n   440→      billing_reason: 'overdraft_protection',\n   441→      'metadata.payment_intent_id': paymentIntent.id,\n   442→    },\n   443→  });\n   444→  if (existProtectedInvoice) {\n   445→    logger.info('overdraft protection invoice already exists', {\n   446→      invoice: existProtectedInvoice.id,\n   447→    });\n   448→    return;\n   449→  }\n   450→  try {\n   451→    const { invoice, items } = await ensureOverdraftProtectionInvoiceAndItems({\n   452→      customer,\n   453→      subscription,\n   454→      paymentIntent,\n   455→      props: {\n   456→        period_start: subscription.current_period_start,\n   457→        period_end: subscription.current_period_end,\n   458→        metadata: {\n   459→          payment_intent_id: paymentIntent.id,\n   460→          invoice_id: relatedInvoice?.id || '',\n   461→        },\n   462→      },\n   463→    });\n   464→    logger.info('ensure overdraft protection invoice and items done', {\n   465→      invoice: invoice.id,\n   466→      items: items.map((x) => x.id),\n   467→    });\n   468→  } catch (error) {\n   469→    logger.error('ensure overdraft protection invoice and items failed', {\n   470→      error,\n   471→      subscription: subscription.id,\n   472→    });\n   473→    throw error;\n   474→  }\n   475→};\n   476→\n   477→type Updates = {\n   478→  retry: {\n   479→    payment: Partial<PaymentIntent>;\n   480→    invoice: Partial<Invoice>;\n   481→    minRetryMail?: number;\n   482→  };\n   483→  terminate: {\n   484→    payment: Partial<PaymentIntent>;\n   485→    invoice: Partial<Invoice>;\n   486→    minRetryMail?: number;\n   487→  };\n   488→};\n   489→\n   490→export const handlePaymentFailed = async (\n   491→  paymentIntent: PaymentIntent,\n   492→  invoice: Invoice,\n   493→  error: PaymentError,\n   494→  checkSubscriptionStatus = true\n   495→) => {\n   496→  const now = dayjs().unix();\n   497→  const attemptCount = invoice.attempt_count + 1;\n   498→\n   499→  const updates: Updates = {\n   500→    retry: {\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"9d42da52-9f96-434c-a311-32fd07a1fb9f","timestamp":"2026-01-12T15:03:25.768Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/blocklets/core/api/src/queues/payment.ts","content":"import isEmpty from 'lodash/isEmpty';\n\nimport { BN } from '@ocap/util';\nimport pAll from 'p-all';\nimport { ensureStakedForGas } from '../integrations/arcblock/stake';\nimport { transferErc20FromUser } from '../integrations/ethereum/token';\nimport { createEvent } from '../libs/audit';\nimport { blocklet, wallet } from '../libs/auth';\nimport dayjs from '../libs/dayjs';\nimport CustomError from '../libs/error';\nimport { events } from '../libs/event';\nimport logger from '../libs/logger';\nimport { getGasPayerExtra, isDelegationSufficientForPayment, checkDepositVaultAmount } from '../libs/payment';\nimport { validateQuoteForPayment, handleExpiredQuotePayment } from '../libs/quote-validation';\nimport {\n  checkRemainingStake,\n  getDaysUntilCancel,\n  getDaysUntilDue,\n  getDueUnit,\n  getMaxRetryCount,\n  getMinRetryMail,\n  getSubscriptionStakeAddress,\n  isSubscriptionOverdraftProtectionEnabled,\n  shouldCancelSubscription,\n} from '../libs/subscription';\nimport { MAX_RETRY_COUNT, MIN_RETRY_MAIL, getNextRetry } from '../libs/util';\nimport { CheckoutSession } from '../store/models/checkout-session';\nimport { Customer } from '../store/models/customer';\nimport { Invoice } from '../store/models/invoice';\n\nimport { PaymentCurrency } from '../store/models/payment-currency';\nimport { PaymentIntent } from '../store/models/payment-intent';\nimport { PaymentMethod } from '../store/models/payment-method';\nimport { Payout } from '../store/models/payout';\nimport { Price } from '../store/models/price';\n\nimport { Subscription } from '../store/models/subscription';\nimport { SubscriptionItem } from '../store/models/subscription-item';\nimport type { EVMChainType, PaymentError, PaymentSettings } from '../store/models/types';\nimport { notificationQueue } from './notification';\nimport { ensureOverdraftProtectionInvoiceAndItems } from '../libs/invoice';\nimport { AutoRechargeConfig, Lock, MeterEvent } from '../store/models';\nimport { ensureOverdraftProtectionPrice } from '../libs/overdraft-protection';\nimport createQueue from '../libs/queue';\nimport { CHARGE_SUPPORTED_CHAIN_TYPES, EVM_CHAIN_TYPES } from '../libs/constants';\nimport { getCheckoutSessionSubscriptionIds, getSubscriptionCreateSetup } from '../libs/session';\nimport { syncStripeSubscriptionAfterRecovery } from '../integrations/stripe/handlers/subscription';\nimport { getLock } from '../libs/lock';\n\ntype PaymentJob = {\n  paymentIntentId: string;\n  paymentSettings?: PaymentSettings;\n  retryOnError?: boolean;\n  ignoreMaxRetryCheck?: boolean;\n  immediateRetry?: boolean;\n};\n\ntype DepositVaultJob = {\n  currencyId: string;\n};\n\nasync function updateQuantitySold(checkoutSession: CheckoutSession) {\n  const updatePromises = checkoutSession.line_items.map((item) => {\n    const priceId = item.upsell_price_id || item.price_id;\n    return Price.increment({ quantity_sold: Number(item.quantity) }, { where: { id: priceId } }).catch((err) => {\n      logger.error('Update quantity_sold failed', {\n        error: err,\n        priceId,\n        checkoutSessionId: checkoutSession.id,\n      });\n    });\n  });\n\n  await Promise.all(updatePromises);\n}\n\nconst handleDepositVault = async (paymentCurrencyId: string) => {\n  const { depositAmount, message, vaultAddress, paymentCurrency } = await checkDepositVaultAmount(paymentCurrencyId);\n  if (depositAmount === '0') {\n    logger.info(`Deposit vault skipped: ${message}`, { currencyId: paymentCurrencyId });\n    return;\n  }\n  const payout = await Payout.create({\n    livemode: paymentCurrency!.livemode,\n    automatic: true,\n    description: 'Deposit vault',\n    amount: depositAmount,\n    destination: vaultAddress!,\n    payment_method_id: paymentCurrency!.payment_method_id,\n    currency_id: paymentCurrency!.id,\n    customer_id: '',\n    payment_intent_id: '',\n    status: 'pending',\n    attempt_count: 0,\n    attempted: false,\n    next_attempt: 0,\n    last_attempt_error: null,\n    metadata: {\n      system: true,\n    },\n  });\n  logger.info('Deposit vault payout created', { payoutId: payout.id });\n};\n\nexport const depositVaultQueue = createQueue<DepositVaultJob>({\n  name: 'deposit-vault',\n  onJob: async (job) => {\n    await handleDepositVault(job.currencyId);\n  },\n  options: {\n    concurrency: 1,\n    maxRetries: 3,\n    enableScheduledJob: true,\n  },\n});\n\nexport async function updateSubscriptionOnPaymentSuccess(\n  paymentIntent: PaymentIntent | null,\n  subscription: Subscription,\n  invoice?: Invoice | null,\n  triggerRenew: boolean = true\n) {\n  // Handle incomplete subscription activation\n  if (subscription.status === 'incomplete' && invoice && invoice.id === subscription.latest_invoice_id) {\n    const started = await subscription.start();\n    if (started) {\n      logger.info(`Subscription ${subscription.id} activated on payment done ${invoice.id}`);\n    }\n    return;\n  }\n\n  // Handle past_due subscription recovery\n  if (subscription.status === 'past_due' && subscription.cancelation_details?.reason === 'payment_failed') {\n    await handlePastDueSubscriptionRecovery(subscription, paymentIntent);\n    return;\n  }\n  if (subscription.status === 'past_due' && subscription.cancelation_details?.reason === 'insufficient_credit') {\n    await handlePastDueSubscriptionRecovery(subscription, paymentIntent);\n    return;\n  }\n\n  // Handle trialing subscription\n  if (subscription.status === 'trialing') {\n    const started = await subscription.start();\n    if (started) {\n      logger.info(`Subscription ${subscription.id} trialing ended on payment done ${invoice?.id || 'credit'}`);\n    }\n    return;\n  }\n\n  // Trigger renewal and upgrade events\n  if (triggerRenew && (!invoice || invoice.billing_reason !== 'subscription_update')) {\n    if (!invoice || invoice.billing_reason === 'subscription_cycle' || paymentIntent?.capture_method === 'manual') {\n      createEvent('Subscription', 'customer.subscription.renewed', subscription).catch(console.error);\n    }\n  }\n  if (invoice?.billing_reason === 'subscription_update') {\n    createEvent('Subscription', 'customer.subscription.upgraded', subscription).catch(console.error);\n  }\n}\n\nexport async function handlePastDueSubscriptionRecovery(\n  subscription: Subscription,\n  paymentIntent: PaymentIntent | null\n) {\n  // For credit mode with insufficient_credit reason, check meter events instead of uncollectible invoices\n  if (subscription.cancelation_details?.reason === 'insufficient_credit') {\n    // Check if all meter events for this subscription are completed with zero pending amount\n    const [summary, detail] = await MeterEvent.getPendingAmounts({\n      subscriptionId: subscription.id,\n      livemode: subscription.livemode,\n      currencyId: subscription.currency_id,\n    });\n\n    if (summary[subscription.currency_id] && summary[subscription.currency_id] !== '0') {\n      logger.info('Subscription recovery skipped: pending meter events exist', {\n        subscription: subscription.id,\n        pendingEventsCount: detail[subscription.currency_id]?.length,\n        pendingEventIds: detail[subscription.currency_id],\n      });\n      return;\n    }\n  } else {\n    // For payment_failed reason, check uncollectible invoices\n    const [result] = await Invoice.getUncollectibleAmount({ subscriptionId: subscription.id });\n    if (!isEmpty(result)) {\n      return;\n    }\n  }\n\n  const now = dayjs().unix();\n\n  // Reset billing cycle anchor and cancel_* if we are recovering from payment failed or insufficient credit\n  if (subscription.cancel_at && subscription.cancel_at !== subscription.current_period_end) {\n    if (now <= subscription.current_period_end) {\n      // If payment succeeds before current_period_end, we should activate this subscription\n      await subscription.update({\n        status: 'active',\n        cancel_at: 0,\n        cancel_at_period_end: false,\n        // @ts-ignore\n        cancelation_details: null,\n      });\n      const recoveryReason =\n        subscription.cancelation_details?.reason === 'insufficient_credit' ? 'credit replenished' : 'payment done';\n      logger.info(\n        `Subscription ${subscription.id} recovered on ${recoveryReason} ${paymentIntent?.id || 'credit'}: cancel rest`\n      );\n      if (paymentIntent) {\n        await syncStripeSubscriptionAfterRecovery(subscription, paymentIntent.id);\n      }\n      return;\n    }\n\n    // Reset billing cycle\n    const subscriptionItems = await SubscriptionItem.findAll({ where: { subscription_id: subscription.id } });\n    const lineItems = await Price.expand(subscriptionItems.map((x) => x.toJSON()));\n    const setup = getSubscriptionCreateSetup(lineItems, subscription.currency_id, 0);\n    await subscription.update({\n      status: 'active',\n      pending_invoice_item_interval: setup.recurring,\n      current_period_start: setup.period.start,\n      current_period_end: setup.period.end,\n      billing_cycle_anchor: setup.cycle.anchor,\n      cancel_at: 0,\n      cancel_at_period_end: false,\n      // @ts-ignore\n      cancelation_details: null,\n    });\n\n    createEvent('Subscription', 'customer.subscription.recovered', subscription).catch(console.error);\n    const recoveryReason =\n      subscription.cancelation_details?.reason === 'insufficient_credit' ? 'credit replenished' : 'payment done';\n    logger.info(\n      `Subscription ${subscription.id} recovered on ${recoveryReason} ${paymentIntent?.id || 'credit'}: cancel and billing cycle reset`\n    );\n    if (paymentIntent) {\n      await syncStripeSubscriptionAfterRecovery(subscription, paymentIntent.id);\n    }\n  } else if (subscription.cancel_at_period_end) {\n    // Reset cancel_at_period_end if we are recovering from payment failed or insufficient credit\n    // @ts-ignore\n    await subscription.update({ status: 'active', cancel_at_period_end: false, cancelation_details: null });\n    const recoveryReason =\n      subscription.cancelation_details?.reason === 'insufficient_credit' ? 'credit replenished' : 'payment done';\n    logger.info(\n      `Subscription ${subscription.id} recovered on ${recoveryReason} ${paymentIntent?.id || 'credit'}: cancel reset`\n    );\n    if (paymentIntent) {\n      await syncStripeSubscriptionAfterRecovery(subscription, paymentIntent.id);\n    }\n  } else {\n    await subscription.update({ status: 'active' });\n    const recoveryReason =\n      subscription.cancelation_details?.reason === 'insufficient_credit' ? 'credit replenished' : 'payment done';\n    logger.info(`Subscription ${subscription.id} recovered on ${recoveryReason} ${paymentIntent?.id || 'credit'}`);\n  }\n}\n\nasync function updateCheckoutSessionOnPaymentSuccess(\n  paymentIntent: PaymentIntent,\n  checkoutSession: CheckoutSession,\n  invoice?: Invoice\n) {\n  if (checkoutSession.status !== 'open') {\n    return;\n  }\n\n  // Update quantity sold for line items\n  updateQuantitySold(checkoutSession).catch((err) => {\n    logger.error('Updating quantity_sold for line items failed', {\n      error: err,\n      checkoutSessionId: checkoutSession.id,\n    });\n  });\n\n  // Handle subscription mode checkout sessions\n  if (['subscription', 'setup'].includes(checkoutSession.mode) && invoice?.subscription_id) {\n    await checkoutSession.increment('success_subscription_count', { by: 1 });\n    await checkoutSession.reload();\n    const subscriptionIds = getCheckoutSessionSubscriptionIds(checkoutSession);\n\n    if (\n      checkoutSession.success_subscription_count &&\n      checkoutSession.success_subscription_count >= subscriptionIds.length\n    ) {\n      await checkoutSession.update({\n        status: 'complete',\n        payment_status: 'paid',\n        payment_details: paymentIntent?.payment_details || {},\n      });\n      logger.info('checkout session become complete on payment done', {\n        id: checkoutSession.id,\n      });\n    }\n  } else {\n    // Handle non-subscription mode checkout sessions\n    await checkoutSession.update({\n      status: 'complete',\n      payment_status: 'paid',\n      payment_details: paymentIntent?.payment_details || {},\n    });\n    logger.info('checkout session become complete on payment done', {\n      id: checkoutSession.id,\n    });\n  }\n\n  logger.info(`CheckoutSession ${checkoutSession.id} updated on payment done ${paymentIntent.id}`);\n}\n\nexport const handlePaymentSucceed = async (\n  paymentIntent: PaymentIntent,\n  triggerRenew: boolean = true,\n  slashStake: boolean = false\n) => {\n  // FIXME: @wangshijun we should check stripe payment here before\n\n  if (paymentIntent.beneficiaries?.length && !slashStake) {\n    Promise.all(\n      paymentIntent.beneficiaries.map(async (x) => {\n        let customer = await Customer.findByPkOrDid(x.address);\n        if (!customer) {\n          const { user } = await blocklet.getUser(x.address);\n          if (user) {\n            customer = await Customer.create({\n              livemode: paymentIntent.livemode,\n              did: user.did,\n              name: user.fullName,\n              email: user.email,\n              phone: user.phone,\n              address: Customer.formatAddressFromUser(user),\n              description: user.remark,\n              metadata: {},\n              balance: '0',\n              next_invoice_sequence: 1,\n              delinquent: false,\n              invoice_prefix: Customer.getInvoicePrefix(),\n            });\n            logger.info('Customer created on payout record', {\n              paymentIntent: paymentIntent.id,\n              address: x.address,\n              customer: customer.id,\n            });\n          }\n        }\n\n        const payout = new Payout({\n          livemode: paymentIntent.livemode,\n          automatic: true,\n          description: paymentIntent.description,\n          amount: x.share,\n          destination: x.address,\n          payment_details: paymentIntent.payment_details,\n          payment_intent_id: paymentIntent.id,\n          customer_id: customer?.id || '',\n          currency_id: paymentIntent.currency_id,\n          payment_method_id: paymentIntent.payment_method_id,\n          status: 'paid',\n          attempt_count: 0,\n          attempted: false,\n          next_attempt: 0,\n          last_attempt_error: null,\n          metadata: {},\n        });\n        return payout.save();\n      })\n    )\n      .then(() => logger.info('Payout records created from payment done', { paymentIntent: paymentIntent.id }))\n      .catch((err) =>\n        logger.error('Payout records creation failed from payment done', {\n          paymentIntent: paymentIntent.id,\n          error: err,\n        })\n      );\n  }\n\n  // Trigger vendor commission queue by invoice.paid\n\n  let invoice;\n  if (paymentIntent.invoice_id) {\n    invoice = await Invoice.findByPk(paymentIntent.invoice_id);\n  }\n\n  // Handle checkout session when no invoice exists\n  if (!invoice && !slashStake) {\n    const checkoutSession = await CheckoutSession.findOne({ where: { payment_intent_id: paymentIntent.id } });\n    if (checkoutSession) {\n      await updateCheckoutSessionOnPaymentSuccess(paymentIntent, checkoutSession);\n    }\n    return;\n  }\n\n  // Update invoice status\n  if (invoice && invoice?.status !== 'paid') {\n    await invoice.update({\n      paid: true,\n      status: 'paid',\n      amount_paid: paymentIntent.amount,\n      amount_remaining: '0',\n      attempt_count: invoice.attempt_count + 1,\n      attempted: true,\n      status_transitions: { ...invoice.status_transitions, paid_at: dayjs().unix() },\n    });\n    logger.info(`Invoice ${invoice.id} updated on payment done: ${paymentIntent.id}`);\n  }\n\n  // Update subscription status\n  if (invoice && invoice.subscription_id && !slashStake) {\n    const subscription = await Subscription.findByPk(invoice.subscription_id);\n    if (subscription) {\n      await updateSubscriptionOnPaymentSuccess(paymentIntent, subscription, invoice, triggerRenew);\n    }\n  }\n\n  // Update checkout session\n  if (invoice && invoice.checkout_session_id && !slashStake) {\n    const checkoutSession = await CheckoutSession.findByPk(invoice.checkout_session_id);\n    if (checkoutSession) {\n      await updateCheckoutSessionOnPaymentSuccess(paymentIntent, checkoutSession, invoice);\n    }\n  }\n};\n\nexport const doOverdraftProtection = async (\n  paymentIntent: PaymentIntent,\n  subscription: Subscription,\n  customer: Customer,\n  relatedInvoice?: Invoice\n) => {\n  const { enabled } = await isSubscriptionOverdraftProtectionEnabled(subscription);\n  if (!enabled) {\n    logger.warn('overdraft protection is not enabled', {\n      subscription: subscription.id,\n    });\n    return;\n  }\n  const existProtectedInvoice = await Invoice.findOne({\n    where: {\n      subscription_id: subscription.id,\n      billing_reason: 'overdraft_protection',\n      'metadata.payment_intent_id': paymentIntent.id,\n    },\n  });\n  if (existProtectedInvoice) {\n    logger.info('overdraft protection invoice already exists', {\n      invoice: existProtectedInvoice.id,\n    });\n    return;\n  }\n  try {\n    const { invoice, items } = await ensureOverdraftProtectionInvoiceAndItems({\n      customer,\n      subscription,\n      paymentIntent,\n      props: {\n        period_start: subscription.current_period_start,\n        period_end: subscription.current_period_end,\n        metadata: {\n          payment_intent_id: paymentIntent.id,\n          invoice_id: relatedInvoice?.id || '',\n        },\n      },\n    });\n    logger.info('ensure overdraft protection invoice and items done', {\n      invoice: invoice.id,\n      items: items.map((x) => x.id),\n    });\n  } catch (error) {\n    logger.error('ensure overdraft protection invoice and items failed', {\n      error,\n      subscription: subscription.id,\n    });\n    throw error;\n  }\n};\n\ntype Updates = {\n  retry: {\n    payment: Partial<PaymentIntent>;\n    invoice: Partial<Invoice>;\n    minRetryMail?: number;\n  };\n  terminate: {\n    payment: Partial<PaymentIntent>;\n    invoice: Partial<Invoice>;\n    minRetryMail?: number;\n  };\n};\n\nexport const handlePaymentFailed = async (\n  paymentIntent: PaymentIntent,\n  invoice: Invoice,\n  error: PaymentError,\n  checkSubscriptionStatus = true\n) => {\n  const now = dayjs().unix();\n  const attemptCount = invoice.attempt_count + 1;\n\n  const updates: Updates = {\n    retry: {","numLines":500,"startLine":1,"totalLines":1346}}}
{"parentUuid":"9d42da52-9f96-434c-a311-32fd07a1fb9f","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01R18CndJ9crJNMaX9Cctqbc","type":"tool_result","content":"     1→import { useLocaleContext } from '@arcblock/ux/lib/Locale/context';\n     2→import { LockOutlined } from '@mui/icons-material';\n     3→import { Box, Typography } from '@mui/material';\n     4→import type { TLineItemExpanded, TPaymentCurrency } from '@blocklet/payment-types';\n     5→import { useMemo } from 'react';\n     6→import { formatExchangeRate } from '../libs/util';\n     7→\n     8→interface QuoteLockInfo {\n     9→  exchangeRate: string | null;\n    10→  tokenSymbol: string;\n    11→  baseCurrency: string;\n    12→  expiresAt: number | null;\n    13→}\n    14→\n    15→interface QuoteLockBannerProps {\n    16→  items: TLineItemExpanded[];\n    17→  currency: TPaymentCurrency;\n    18→}\n    19→\n    20→function getQuoteLockInfo(items: TLineItemExpanded[], currency: TPaymentCurrency): QuoteLockInfo | null {\n    21→  if (!items?.length || !currency) {\n    22→    return null;\n    23→  }\n    24→\n    25→  const dynamicItems = items.filter((item) => {\n    26→    const price = (item.upsell_price || item.price) as any;\n    27→    return price?.pricing_type === 'dynamic' && (item as any)?.quoted_amount;\n    28→  });\n    29→  if (!dynamicItems.length) {\n    30→    return null;\n    31→  }\n    32→\n    33→  let expiresAt: number | null = null;\n    34→  let exchangeRate: string | null = null;\n    35→\n    36→  dynamicItems.forEach((item) => {\n    37→    if ((item as any)?.expires_at) {\n    38→      expiresAt = expiresAt === null ? (item as any)?.expires_at : Math.min(expiresAt, (item as any)?.expires_at);\n    39→    }\n    40→\n    41→    if (!exchangeRate) {\n    42→      exchangeRate = (item as any)?.exchange_rate || null;\n    43→    }\n    44→  });\n    45→\n    46→  return {\n    47→    exchangeRate,\n    48→    tokenSymbol: currency.symbol,\n    49→    baseCurrency: ((dynamicItems[0]?.upsell_price || dynamicItems[0]?.price) as any)?.base_currency || 'USD',\n    50→    expiresAt,\n    51→  };\n    52→}\n    53→\n    54→export default function QuoteLockBanner({ items, currency }: QuoteLockBannerProps) {\n    55→  const { t } = useLocaleContext();\n    56→  const quoteLockInfo = useMemo(() => getQuoteLockInfo(items, currency), [items, currency]);\n    57→\n    58→  if (!quoteLockInfo || !quoteLockInfo.exchangeRate) {\n    59→    return null;\n    60→  }\n    61→\n    62→  const formattedRateValue = formatExchangeRate(quoteLockInfo.exchangeRate);\n    63→  const formattedRate = formattedRateValue\n    64→    ? quoteLockInfo.baseCurrency === 'USD'\n    65→      ? `$${formattedRateValue}`\n    66→      : `${formattedRateValue} ${quoteLockInfo.baseCurrency}`\n    67→    : '';\n    68→  return (\n    69→    <Box\n    70→      sx={{\n    71→        bgcolor: 'action.hover',\n    72→        border: '1px solid',\n    73→        borderColor: 'divider',\n    74→        borderRadius: 1,\n    75→        px: 2,\n    76→        py: 1.5,\n    77→        mb: 2,\n    78→      }}>\n    79→      <Box\n    80→        sx={{\n    81→          display: 'flex',\n    82→          alignItems: 'center',\n    83→          gap: 1.5,\n    84→          flexWrap: 'wrap',\n    85→        }}>\n    86→        <LockOutlined sx={{ fontSize: '1rem', color: 'success.main' }} />\n    87→        <Typography sx={{ fontSize: '0.875rem', color: 'text.primary', flex: 1 }}>\n    88→          {t('payment.checkout.quote.dynamicPricingInfo', {\n    89→            symbol: quoteLockInfo.tokenSymbol,\n    90→            rate: formattedRate,\n    91→            currency: '',\n    92→          })}\n    93→        </Typography>\n    94→      </Box>\n    95→    </Box>\n    96→  );\n    97→}\n    98→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"uuid":"59e1941e-6372-49b8-85e4-a2fdb07298ec","timestamp":"2026-01-12T15:03:25.769Z","toolUseResult":{"type":"text","file":{"filePath":"~/Arcblock/payment-kit-master/packages/react/src/components/quote-lock-banner.tsx","content":"import { useLocaleContext } from '@arcblock/ux/lib/Locale/context';\nimport { LockOutlined } from '@mui/icons-material';\nimport { Box, Typography } from '@mui/material';\nimport type { TLineItemExpanded, TPaymentCurrency } from '@blocklet/payment-types';\nimport { useMemo } from 'react';\nimport { formatExchangeRate } from '../libs/util';\n\ninterface QuoteLockInfo {\n  exchangeRate: string | null;\n  tokenSymbol: string;\n  baseCurrency: string;\n  expiresAt: number | null;\n}\n\ninterface QuoteLockBannerProps {\n  items: TLineItemExpanded[];\n  currency: TPaymentCurrency;\n}\n\nfunction getQuoteLockInfo(items: TLineItemExpanded[], currency: TPaymentCurrency): QuoteLockInfo | null {\n  if (!items?.length || !currency) {\n    return null;\n  }\n\n  const dynamicItems = items.filter((item) => {\n    const price = (item.upsell_price || item.price) as any;\n    return price?.pricing_type === 'dynamic' && (item as any)?.quoted_amount;\n  });\n  if (!dynamicItems.length) {\n    return null;\n  }\n\n  let expiresAt: number | null = null;\n  let exchangeRate: string | null = null;\n\n  dynamicItems.forEach((item) => {\n    if ((item as any)?.expires_at) {\n      expiresAt = expiresAt === null ? (item as any)?.expires_at : Math.min(expiresAt, (item as any)?.expires_at);\n    }\n\n    if (!exchangeRate) {\n      exchangeRate = (item as any)?.exchange_rate || null;\n    }\n  });\n\n  return {\n    exchangeRate,\n    tokenSymbol: currency.symbol,\n    baseCurrency: ((dynamicItems[0]?.upsell_price || dynamicItems[0]?.price) as any)?.base_currency || 'USD',\n    expiresAt,\n  };\n}\n\nexport default function QuoteLockBanner({ items, currency }: QuoteLockBannerProps) {\n  const { t } = useLocaleContext();\n  const quoteLockInfo = useMemo(() => getQuoteLockInfo(items, currency), [items, currency]);\n\n  if (!quoteLockInfo || !quoteLockInfo.exchangeRate) {\n    return null;\n  }\n\n  const formattedRateValue = formatExchangeRate(quoteLockInfo.exchangeRate);\n  const formattedRate = formattedRateValue\n    ? quoteLockInfo.baseCurrency === 'USD'\n      ? `$${formattedRateValue}`\n      : `${formattedRateValue} ${quoteLockInfo.baseCurrency}`\n    : '';\n  return (\n    <Box\n      sx={{\n        bgcolor: 'action.hover',\n        border: '1px solid',\n        borderColor: 'divider',\n        borderRadius: 1,\n        px: 2,\n        py: 1.5,\n        mb: 2,\n      }}>\n      <Box\n        sx={{\n          display: 'flex',\n          alignItems: 'center',\n          gap: 1.5,\n          flexWrap: 'wrap',\n        }}>\n        <LockOutlined sx={{ fontSize: '1rem', color: 'success.main' }} />\n        <Typography sx={{ fontSize: '0.875rem', color: 'text.primary', flex: 1 }}>\n          {t('payment.checkout.quote.dynamicPricingInfo', {\n            symbol: quoteLockInfo.tokenSymbol,\n            rate: formattedRate,\n            currency: '',\n          })}\n        </Typography>\n      </Box>\n    </Box>\n  );\n}\n","numLines":98,"startLine":1,"totalLines":98}}}
{"parentUuid":"59e1941e-6372-49b8-85e4-a2fdb07298ec","isSidechain":true,"userType":"external","cwd":"~/Arcblock/payment-kit-master/blocklets/core","sessionId":"2f8c41c3-1c48-4a04-aa9f-c0d3e00d8d40","version":"2.0.76","gitBranch":"feat-quote","agentId":"a5eaa85","slug":"serialized-orbiting-blossom","type":"assistant","uuid":"e07a39ca-033e-4cd2-943b-425e7d6ac622","timestamp":"2026-01-12T15:03:28.247Z","message":{"id":"f0a1571c-6c7c-4f1a-b0bd-9a1941231f6f","container":null,"model":"<synthetic>","role":"assistant","stop_reason":"stop_sequence","stop_sequence":"","type":"message","usage":{"input_tokens":0,"output_tokens":0,"cache_creation_input_tokens":0,"cache_read_input_tokens":0,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":null,"cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":0}},"content":[{"type":"text","text":"You've hit your limit · resets 2am (Asia/Shanghai)"}],"context_management":null},"error":"rate_limit","isApiErrorMessage":true}
